
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4                   	.byte 0xe4

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 90 17 00 	lgdtl  0x179018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 90 17 f0       	mov    $0xf0179000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 22 00 00 00       	call   f010005f <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	c7 05 b0 4f 55 f0 01 	movl   $0x1,0xf0554fb0
f0100049:	00 00 00 
f010004c:	90                   	nop
f010004d:	5d                   	pop    %ebp
f010004e:	c3                   	ret    

f010004f <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f010004f:	55                   	push   %ebp
f0100050:	89 e5                	mov    %esp,%ebp
f0100052:	c7 05 04 4f 55 f0 01 	movl   $0x1,0xf0554f04
f0100059:	00 00 00 
f010005c:	90                   	nop
f010005d:	5d                   	pop    %ebp
f010005e:	c3                   	ret    

f010005f <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
bool autograde ;
void FOS_initialize()
{
f010005f:	55                   	push   %ebp
f0100060:	89 e5                	mov    %esp,%ebp
f0100062:	83 ec 28             	sub    $0x28,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100065:	ba a8 79 57 f0       	mov    $0xf05779a8,%edx
f010006a:	b8 b2 17 55 f0       	mov    $0xf05517b2,%eax
f010006f:	29 c2                	sub    %eax,%edx
f0100071:	89 d0                	mov    %edx,%eax
f0100073:	83 ec 04             	sub    $0x4,%esp
f0100076:	50                   	push   %eax
f0100077:	6a 00                	push   $0x0
f0100079:	68 b2 17 55 f0       	push   $0xf05517b2
f010007e:	e8 9e 06 02 00       	call   f0120721 <memset>
f0100083:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f0100086:	e8 8d 0d 00 00       	call   f0100e18 <cons_init>
		//print welcome message
		print_welcome_message();
f010008b:	e8 11 02 00 00       	call   f01002a1 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100090:	83 ec 0c             	sub    $0xc,%esp
f0100093:	68 a0 16 12 f0       	push   $0xf01216a0
f0100098:	e8 cf 0e 00 00       	call   f0100f6c <cprintf>
f010009d:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f01000a0:	83 ec 0c             	sub    $0xc,%esp
f01000a3:	68 e7 16 12 f0       	push   $0xf01216e7
f01000a8:	e8 bf 0e 00 00       	call   f0100f6c <cprintf>
f01000ad:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000b0:	83 ec 0c             	sub    $0xc,%esp
f01000b3:	68 fb 16 12 f0       	push   $0xf01216fb
f01000b8:	e8 af 0e 00 00       	call   f0100f6c <cprintf>
f01000bd:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000c0:	83 ec 0c             	sub    $0xc,%esp
f01000c3:	68 0f 17 12 f0       	push   $0xf012170f
f01000c8:	e8 9f 0e 00 00       	call   f0100f6c <cprintf>
f01000cd:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000d0:	83 ec 0c             	sub    $0xc,%esp
f01000d3:	6a 00                	push   $0x0
f01000d5:	e8 2e 6d 00 00       	call   f0106e08 <cpu_init>
f01000da:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000dd:	83 ec 0c             	sub    $0xc,%esp
f01000e0:	68 1b 17 12 f0       	push   $0xf012171b
f01000e5:	e8 82 0e 00 00       	call   f0100f6c <cprintf>
f01000ea:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000ed:	83 ec 0c             	sub    $0xc,%esp
f01000f0:	68 23 17 12 f0       	push   $0xf0121723
f01000f5:	e8 72 0e 00 00       	call   f0100f6c <cprintf>
f01000fa:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 2 memory management initialization functions
		detect_memory();
f01000fd:	e8 66 76 00 00       	call   f0107768 <detect_memory>
		initialize_kernel_VM();
f0100102:	e8 14 72 00 00       	call   f010731b <initialize_kernel_VM>
		initialize_paging();
f0100107:	e8 e1 79 00 00       	call   f0107aed <initialize_paging>
		initialize_kheap_dynamic_allocator(KERNEL_HEAP_START, PAGE_SIZE, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
#endif
		//	page_check();
		//setPageReplacmentAlgorithmNchanceCLOCK();
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
		setPageReplacmentAlgorithmFIFO();
f010010c:	e8 16 e2 00 00       	call   f010e327 <setPageReplacmentAlgorithmFIFO>
		//setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);

		setUHeapPlacementStrategyFIRSTFIT();
f0100111:	e8 39 ff ff ff       	call   f010004f <setUHeapPlacementStrategyFIRSTFIT>
		setKHeapPlacementStrategyFIRSTFIT();
f0100116:	e8 24 ff ff ff       	call   f010003f <setKHeapPlacementStrategyFIRSTFIT>

		enableBuffering(0);
f010011b:	83 ec 0c             	sub    $0xc,%esp
f010011e:	6a 00                	push   $0x0
f0100120:	e8 ff e2 00 00       	call   f010e424 <enableBuffering>
f0100125:	83 c4 10             	add    $0x10,%esp
		//enableModifiedBuffer(1) ;
		enableModifiedBuffer(0) ;
f0100128:	83 ec 0c             	sub    $0xc,%esp
f010012b:	6a 00                	push   $0x0
f010012d:	e8 da e2 00 00       	call   f010e40c <enableModifiedBuffer>
f0100132:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(1000);
f0100135:	83 ec 0c             	sub    $0xc,%esp
f0100138:	68 e8 03 00 00       	push   $0x3e8
f010013d:	e8 fa e2 00 00       	call   f010e43c <setModifiedBufferLength>
f0100142:	83 c4 10             	add    $0x10,%esp

		ide_init();
f0100145:	e8 2e 0b 02 00       	call   f0120c78 <ide_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) USER ENVs...");
f010014a:	83 ec 0c             	sub    $0xc,%esp
f010014d:	68 31 17 12 f0       	push   $0xf0121731
f0100152:	e8 15 0e 00 00       	call   f0100f6c <cprintf>
f0100157:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 3 user environment initialization functions
		env_init();
f010015a:	e8 c4 93 00 00       	call   f0109523 <env_init>
		ts_init();
f010015f:	e8 31 bc 00 00       	call   f010bd95 <ts_init>
		//2024: removed. called inside cpuinit()
		//idt_init();
	}
	cprintf("[DONE]\n");
f0100164:	83 ec 0c             	sub    $0xc,%esp
f0100167:	68 1b 17 12 f0       	push   $0xf012171b
f010016c:	e8 fb 0d 00 00       	call   f0100f6c <cprintf>
f0100171:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f0100174:	83 ec 0c             	sub    $0xc,%esp
f0100177:	68 44 17 12 f0       	push   $0xf0121744
f010017c:	e8 eb 0d 00 00       	call   f0100f6c <cprintf>
f0100181:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f0100184:	e8 6b 69 00 00       	call   f0106af4 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100189:	83 ec 0c             	sub    $0xc,%esp
f010018c:	68 6d 17 12 f0       	push   $0xf012176d
f0100191:	e8 d6 0d 00 00       	call   f0100f6c <cprintf>
f0100196:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100199:	83 ec 0c             	sub    $0xc,%esp
f010019c:	6a 00                	push   $0x0
f010019e:	e8 43 6b 00 00       	call   f0106ce6 <irq_clear_mask>
f01001a3:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f01001a6:	83 ec 0c             	sub    $0xc,%esp
f01001a9:	68 83 17 12 f0       	push   $0xf0121783
f01001ae:	e8 b9 0d 00 00       	call   f0100f6c <cprintf>
f01001b3:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001b6:	83 ec 0c             	sub    $0xc,%esp
f01001b9:	6a 01                	push   $0x1
f01001bb:	e8 26 6b 00 00       	call   f0106ce6 <irq_clear_mask>
f01001c0:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001c3:	83 ec 0c             	sub    $0xc,%esp
f01001c6:	68 a0 17 12 f0       	push   $0xf01217a0
f01001cb:	e8 9c 0d 00 00       	call   f0100f6c <cprintf>
f01001d0:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001d3:	83 ec 0c             	sub    $0xc,%esp
f01001d6:	6a 04                	push   $0x4
f01001d8:	e8 09 6b 00 00       	call   f0106ce6 <irq_clear_mask>
f01001dd:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001e0:	83 ec 0c             	sub    $0xc,%esp
f01001e3:	68 bf 17 12 f0       	push   $0xf01217bf
f01001e8:	e8 7f 0d 00 00       	call   f0100f6c <cprintf>
f01001ed:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
//		irq_clear_mask(14);
//		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
	}
	cprintf("* 5) SCHEDULER & MULTI-TASKING:\n");
f01001f0:	83 ec 0c             	sub    $0xc,%esp
f01001f3:	68 dc 17 12 f0       	push   $0xf01217dc
f01001f8:	e8 6f 0d 00 00       	call   f0100f6c <cprintf>
f01001fd:	83 c4 10             	add    $0x10,%esp
	{
		// Lab 4 multitasking initialization functions
		kclock_init();
f0100200:	e8 c2 46 00 00       	call   f01048c7 <kclock_init>
		sched_init() ;
f0100205:	e8 45 62 00 00       	call   f010644f <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 6) ESP to SCHED KERN STACK:\n");
f010020a:	83 ec 0c             	sub    $0xc,%esp
f010020d:	68 00 18 12 f0       	push   $0xf0121800
f0100212:	e8 55 0d 00 00       	call   f0100f6c <cprintf>
f0100217:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010021a:	89 e0                	mov    %esp,%eax
f010021c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010021f:	8b 45 e8             	mov    -0x18(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100222:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100225:	b8 00 90 17 f0       	mov    $0xf0179000,%eax
f010022a:	2b 45 f4             	sub    -0xc(%ebp),%eax
f010022d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100230:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100235:	2b 45 f0             	sub    -0x10(%ebp),%eax
f0100238:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010023b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010023e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100241:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100244:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100246:	89 e0                	mov    %esp,%eax
f0100248:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f010024b:	8b 45 e0             	mov    -0x20(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f010024e:	83 ec 04             	sub    $0x4,%esp
f0100251:	50                   	push   %eax
f0100252:	ff 75 f4             	pushl  -0xc(%ebp)
f0100255:	68 20 18 12 f0       	push   $0xf0121820
f010025a:	e8 0d 0d 00 00       	call   f0100f6c <cprintf>
f010025f:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("********************************************************************\n");
f0100262:	83 ec 0c             	sub    $0xc,%esp
f0100265:	68 44 18 12 f0       	push   $0xf0121844
f010026a:	e8 fd 0c 00 00       	call   f0100f6c <cprintf>
f010026f:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	autograde = 0;
f0100272:	c7 05 dc 51 55 f0 00 	movl   $0x0,0xf05551dc
f0100279:	00 00 00 
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f010027c:	83 ec 0c             	sub    $0xc,%esp
f010027f:	68 8c 18 12 f0       	push   $0xf012188c
f0100284:	e8 e3 0c 00 00       	call   f0100f6c <cprintf>
f0100289:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f010028c:	83 ec 0c             	sub    $0xc,%esp
f010028f:	68 b8 18 12 f0       	push   $0xf01218b8
f0100294:	e8 d3 0c 00 00       	call   f0100f6c <cprintf>
f0100299:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f010029c:	e8 02 1b 00 00       	call   f0101da3 <get_into_prompt>

f01002a1 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f01002a1:	55                   	push   %ebp
f01002a2:	89 e5                	mov    %esp,%ebp
f01002a4:	83 ec 08             	sub    $0x8,%esp
	cprintf("\n\n\n");
f01002a7:	83 ec 0c             	sub    $0xc,%esp
f01002aa:	68 dd 18 12 f0       	push   $0xf01218dd
f01002af:	e8 b8 0c 00 00       	call   f0100f6c <cprintf>
f01002b4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002b7:	83 ec 0c             	sub    $0xc,%esp
f01002ba:	68 e4 18 12 f0       	push   $0xf01218e4
f01002bf:	e8 a8 0c 00 00       	call   f0100f6c <cprintf>
f01002c4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002c7:	83 ec 0c             	sub    $0xc,%esp
f01002ca:	68 2c 19 12 f0       	push   $0xf012192c
f01002cf:	e8 98 0c 00 00       	call   f0100f6c <cprintf>
f01002d4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f01002d7:	83 ec 0c             	sub    $0xc,%esp
f01002da:	68 74 19 12 f0       	push   $0xf0121974
f01002df:	e8 88 0c 00 00       	call   f0100f6c <cprintf>
f01002e4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!                                                             !!\n");
f01002e7:	83 ec 0c             	sub    $0xc,%esp
f01002ea:	68 2c 19 12 f0       	push   $0xf012192c
f01002ef:	e8 78 0c 00 00       	call   f0100f6c <cprintf>
f01002f4:	83 c4 10             	add    $0x10,%esp
	cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f01002f7:	83 ec 0c             	sub    $0xc,%esp
f01002fa:	68 e4 18 12 f0       	push   $0xf01218e4
f01002ff:	e8 68 0c 00 00       	call   f0100f6c <cprintf>
f0100304:	83 c4 10             	add    $0x10,%esp
	cprintf("\n\n\n\n");
f0100307:	83 ec 0c             	sub    $0xc,%esp
f010030a:	68 b9 19 12 f0       	push   $0xf01219b9
f010030f:	e8 58 0c 00 00       	call   f0100f6c <cprintf>
f0100314:	83 c4 10             	add    $0x10,%esp
}
f0100317:	90                   	nop
f0100318:	c9                   	leave  
f0100319:	c3                   	ret    

f010031a <_panic>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
 */
void _panic(const char *file, int line, const char *fmt,...)
{
f010031a:	55                   	push   %ebp
f010031b:	89 e5                	mov    %esp,%ebp
f010031d:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f0100320:	e8 4c a1 00 00       	call   f010a471 <get_cpu_proc>
f0100325:	89 45 f4             	mov    %eax,-0xc(%ebp)

	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f0100328:	8b 45 10             	mov    0x10(%ebp),%eax
f010032b:	a3 c0 17 55 f0       	mov    %eax,0xf05517c0

	va_start(ap, fmt);
f0100330:	8d 45 10             	lea    0x10(%ebp),%eax
f0100333:	83 c0 04             	add    $0x4,%eax
f0100336:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("\nkernel [EVAL_FINAL]panic at %s:%d: ", file, line);
f0100339:	83 ec 04             	sub    $0x4,%esp
f010033c:	ff 75 0c             	pushl  0xc(%ebp)
f010033f:	ff 75 08             	pushl  0x8(%ebp)
f0100342:	68 c0 19 12 f0       	push   $0xf01219c0
f0100347:	e8 20 0c 00 00       	call   f0100f6c <cprintf>
f010034c:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f010034f:	8b 45 10             	mov    0x10(%ebp),%eax
f0100352:	83 ec 08             	sub    $0x8,%esp
f0100355:	ff 75 f0             	pushl  -0x10(%ebp)
f0100358:	50                   	push   %eax
f0100359:	e8 e5 0b 00 00       	call   f0100f43 <vcprintf>
f010035e:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100361:	83 ec 0c             	sub    $0xc,%esp
f0100364:	68 e5 19 12 f0       	push   $0xf01219e5
f0100369:	e8 fe 0b 00 00       	call   f0100f6c <cprintf>
f010036e:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f0100371:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100375:	74 10                	je     f0100387 <_panic+0x6d>
f0100377:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010037a:	8b 40 18             	mov    0x18(%eax),%eax
f010037d:	83 f8 02             	cmp    $0x2,%eax
f0100380:	75 05                	jne    f0100387 <_panic+0x6d>
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f0100382:	e8 a8 a0 00 00       	call   f010a42f <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0100387:	89 e0                	mov    %esp,%eax
f0100389:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f010038c:	8b 45 e8             	mov    -0x18(%ebp),%eax
	}
	//else //2024: panic from Kernel and no current running env
	{
		char* esp = (char*)read_esp();
f010038f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		cprintf("esp = %x\n", esp);
f0100392:	83 ec 08             	sub    $0x8,%esp
f0100395:	ff 75 ec             	pushl  -0x14(%ebp)
f0100398:	68 e7 19 12 f0       	push   $0xf01219e7
f010039d:	e8 ca 0b 00 00       	call   f0100f6c <cprintf>
f01003a2:	83 c4 10             	add    $0x10,%esp
		get_into_prompt();
f01003a5:	e8 f9 19 00 00       	call   f0101da3 <get_into_prompt>

f01003aa <_panic_all>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f01003aa:	55                   	push   %ebp
f01003ab:	89 e5                	mov    %esp,%ebp
f01003ad:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01003b0:	8b 45 10             	mov    0x10(%ebp),%eax
f01003b3:	a3 c0 17 55 f0       	mov    %eax,0xf05517c0

	va_start(ap, fmt);
f01003b8:	8d 45 10             	lea    0x10(%ebp),%eax
f01003bb:	83 c0 04             	add    $0x4,%eax
f01003be:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f01003c1:	83 ec 04             	sub    $0x4,%esp
f01003c4:	ff 75 0c             	pushl  0xc(%ebp)
f01003c7:	ff 75 08             	pushl  0x8(%ebp)
f01003ca:	68 f1 19 12 f0       	push   $0xf01219f1
f01003cf:	e8 98 0b 00 00       	call   f0100f6c <cprintf>
f01003d4:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01003d7:	8b 45 10             	mov    0x10(%ebp),%eax
f01003da:	83 ec 08             	sub    $0x8,%esp
f01003dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01003e0:	50                   	push   %eax
f01003e1:	e8 5d 0b 00 00       	call   f0100f43 <vcprintf>
f01003e6:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01003e9:	83 ec 0c             	sub    $0xc,%esp
f01003ec:	68 e5 19 12 f0       	push   $0xf01219e5
f01003f1:	e8 76 0b 00 00       	call   f0100f6c <cprintf>
f01003f6:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
f01003f9:	e8 c3 6a 00 00       	call   f0106ec1 <pushcli>
	struct cpu *c = mycpu();
f01003fe:	e8 fb 69 00 00       	call   f0106dfe <mycpu>
f0100403:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int sched_stat = c->scheduler_status;
f0100406:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0100409:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010040f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	popcli();
f0100412:	e8 fc 6a 00 00       	call   f0106f13 <popcli>
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
f0100417:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f010041b:	74 23                	je     f0100440 <_panic_all+0x96>
	{
		//exit all ready env's
		sched_exit_all_ready_envs();
f010041d:	e8 b3 5d 00 00       	call   f01061d5 <sched_exit_all_ready_envs>
		struct Env* cur_env = get_cpu_proc();
f0100422:	e8 4a a0 00 00       	call   f010a471 <get_cpu_proc>
f0100427:	89 45 e8             	mov    %eax,-0x18(%ebp)
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010042a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010042e:	74 10                	je     f0100440 <_panic_all+0x96>
f0100430:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100433:	8b 40 18             	mov    0x18(%eax),%eax
f0100436:	83 f8 02             	cmp    $0x2,%eax
f0100439:	75 05                	jne    f0100440 <_panic_all+0x96>
		{
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f010043b:	e8 ef 9f 00 00       	call   f010a42f <env_exit>
		}
	}
	//else //2024: panic from Kernel and no current running env
	{
		get_into_prompt();
f0100440:	e8 5e 19 00 00       	call   f0101da3 <get_into_prompt>

f0100445 <_panic_into_prompt>:
/*
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
f0100445:	55                   	push   %ebp
f0100446:	89 e5                	mov    %esp,%ebp
f0100448:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f010044b:	8b 45 10             	mov    0x10(%ebp),%eax
f010044e:	a3 c0 17 55 f0       	mov    %eax,0xf05517c0

	va_start(ap, fmt);
f0100453:	8d 45 10             	lea    0x10(%ebp),%eax
f0100456:	83 c0 04             	add    $0x4,%eax
f0100459:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel panic at %s:%d: ", file, line);
f010045c:	83 ec 04             	sub    $0x4,%esp
f010045f:	ff 75 0c             	pushl  0xc(%ebp)
f0100462:	ff 75 08             	pushl  0x8(%ebp)
f0100465:	68 f1 19 12 f0       	push   $0xf01219f1
f010046a:	e8 fd 0a 00 00       	call   f0100f6c <cprintf>
f010046f:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f0100472:	8b 45 10             	mov    0x10(%ebp),%eax
f0100475:	83 ec 08             	sub    $0x8,%esp
f0100478:	ff 75 f4             	pushl  -0xc(%ebp)
f010047b:	50                   	push   %eax
f010047c:	e8 c2 0a 00 00       	call   f0100f43 <vcprintf>
f0100481:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0100484:	83 ec 0c             	sub    $0xc,%esp
f0100487:	68 e5 19 12 f0       	push   $0xf01219e5
f010048c:	e8 db 0a 00 00       	call   f0100f6c <cprintf>
f0100491:	83 c4 10             	add    $0x10,%esp
	va_end(ap);

//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f0100494:	e8 d8 9f 00 00       	call   f010a471 <get_cpu_proc>
f0100499:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010049c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01004a0:	74 10                	je     f01004b2 <_panic_into_prompt+0x6d>
f01004a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01004a5:	8b 40 18             	mov    0x18(%eax),%eax
f01004a8:	83 f8 02             	cmp    $0x2,%eax
f01004ab:	75 05                	jne    f01004b2 <_panic_into_prompt+0x6d>
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
f01004ad:	e8 7d 9f 00 00       	call   f010a42f <env_exit>
	}

	get_into_prompt();
f01004b2:	e8 ec 18 00 00       	call   f0101da3 <get_into_prompt>

f01004b7 <_warn>:
}


/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
f01004b7:	55                   	push   %ebp
f01004b8:	89 e5                	mov    %esp,%ebp
f01004ba:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f01004bd:	8d 45 10             	lea    0x10(%ebp),%eax
f01004c0:	83 c0 04             	add    $0x4,%eax
f01004c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cprintf("\nkernel warning at %s:%d: ", file, line);
f01004c6:	83 ec 04             	sub    $0x4,%esp
f01004c9:	ff 75 0c             	pushl  0xc(%ebp)
f01004cc:	ff 75 08             	pushl  0x8(%ebp)
f01004cf:	68 0a 1a 12 f0       	push   $0xf0121a0a
f01004d4:	e8 93 0a 00 00       	call   f0100f6c <cprintf>
f01004d9:	83 c4 10             	add    $0x10,%esp
	vcprintf(fmt, ap);
f01004dc:	8b 45 10             	mov    0x10(%ebp),%eax
f01004df:	83 ec 08             	sub    $0x8,%esp
f01004e2:	ff 75 f4             	pushl  -0xc(%ebp)
f01004e5:	50                   	push   %eax
f01004e6:	e8 58 0a 00 00       	call   f0100f43 <vcprintf>
f01004eb:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01004ee:	83 ec 0c             	sub    $0xc,%esp
f01004f1:	68 e5 19 12 f0       	push   $0xf01219e5
f01004f6:	e8 71 0a 00 00       	call   f0100f6c <cprintf>
f01004fb:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f01004fe:	90                   	nop
f01004ff:	c9                   	leave  
f0100500:	c3                   	ret    

f0100501 <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f0100501:	55                   	push   %ebp
f0100502:	89 e5                	mov    %esp,%ebp
f0100504:	83 ec 10             	sub    $0x10,%esp
f0100507:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010050e:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0100511:	89 c2                	mov    %eax,%edx
f0100513:	ec                   	in     (%dx),%al
f0100514:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0100517:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f010051a:	0f b6 c0             	movzbl %al,%eax
f010051d:	83 e0 01             	and    $0x1,%eax
f0100520:	85 c0                	test   %eax,%eax
f0100522:	75 07                	jne    f010052b <serial_proc_data+0x2a>
		return -1;
f0100524:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100529:	eb 16                	jmp    f0100541 <serial_proc_data+0x40>
f010052b:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100532:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100535:	89 c2                	mov    %eax,%edx
f0100537:	ec                   	in     (%dx),%al
f0100538:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f010053b:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f010053e:	0f b6 c0             	movzbl %al,%eax
}
f0100541:	c9                   	leave  
f0100542:	c3                   	ret    

f0100543 <serial_intr>:

void
serial_intr(void)
{
f0100543:	55                   	push   %ebp
f0100544:	89 e5                	mov    %esp,%ebp
f0100546:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f0100549:	a1 e4 17 55 f0       	mov    0xf05517e4,%eax
f010054e:	85 c0                	test   %eax,%eax
f0100550:	74 10                	je     f0100562 <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f0100552:	83 ec 0c             	sub    $0xc,%esp
f0100555:	68 01 05 10 f0       	push   $0xf0100501
f010055a:	e8 9d 07 00 00       	call   f0100cfc <cons_intr>
f010055f:	83 c4 10             	add    $0x10,%esp
}
f0100562:	90                   	nop
f0100563:	c9                   	leave  
f0100564:	c3                   	ret    

f0100565 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0100565:	55                   	push   %ebp
f0100566:	89 e5                	mov    %esp,%ebp
f0100568:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f010056b:	83 ec 0c             	sub    $0xc,%esp
f010056e:	68 28 1a 12 f0       	push   $0xf0121a28
f0100573:	e8 f4 09 00 00       	call   f0100f6c <cprintf>
f0100578:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f010057b:	e8 c3 ff ff ff       	call   f0100543 <serial_intr>
}
f0100580:	90                   	nop
f0100581:	c9                   	leave  
f0100582:	c3                   	ret    

f0100583 <serial_init>:

void
serial_init(void)
{
f0100583:	55                   	push   %ebp
f0100584:	89 e5                	mov    %esp,%ebp
f0100586:	83 ec 48             	sub    $0x48,%esp
f0100589:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f0100590:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100594:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0100597:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010059a:	ee                   	out    %al,(%dx)
f010059b:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f01005a2:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f01005a6:	8a 45 c7             	mov    -0x39(%ebp),%al
f01005a9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01005ac:	ee                   	out    %al,(%dx)
f01005ad:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f01005b4:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f01005b8:	8a 45 c8             	mov    -0x38(%ebp),%al
f01005bb:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01005be:	ee                   	out    %al,(%dx)
f01005bf:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f01005c6:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f01005ca:	8a 45 c9             	mov    -0x37(%ebp),%al
f01005cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01005d0:	ee                   	out    %al,(%dx)
f01005d1:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f01005d8:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f01005dc:	8a 45 ca             	mov    -0x36(%ebp),%al
f01005df:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f01005e2:	ee                   	out    %al,(%dx)
f01005e3:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f01005ea:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f01005ee:	8a 45 cb             	mov    -0x35(%ebp),%al
f01005f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01005f4:	ee                   	out    %al,(%dx)
f01005f5:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f01005fc:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f0100600:	8a 45 cc             	mov    -0x34(%ebp),%al
f0100603:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0100606:	ee                   	out    %al,(%dx)
f0100607:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010060e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0100611:	89 c2                	mov    %eax,%edx
f0100613:	ec                   	in     (%dx),%al
f0100614:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f0100617:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f010061a:	3c ff                	cmp    $0xff,%al
f010061c:	0f 95 c0             	setne  %al
f010061f:	0f b6 c0             	movzbl %al,%eax
f0100622:	a3 e4 17 55 f0       	mov    %eax,0xf05517e4
f0100627:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010062e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100631:	89 c2                	mov    %eax,%edx
f0100633:	ec                   	in     (%dx),%al
f0100634:	88 45 ce             	mov    %al,-0x32(%ebp)
f0100637:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f010063e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0100641:	89 c2                	mov    %eax,%edx
f0100643:	ec                   	in     (%dx),%al
f0100644:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f0100647:	83 ec 08             	sub    $0x8,%esp
f010064a:	68 65 05 10 f0       	push   $0xf0100565
f010064f:	6a 04                	push   $0x4
f0100651:	e8 43 ca 00 00       	call   f010d099 <irq_install_handler>
f0100656:	83 c4 10             	add    $0x10,%esp

}
f0100659:	90                   	nop
f010065a:	c9                   	leave  
f010065b:	c3                   	ret    

f010065c <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f010065c:	55                   	push   %ebp
f010065d:	89 e5                	mov    %esp,%ebp
f010065f:	83 ec 20             	sub    $0x20,%esp
f0100662:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0100669:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010066c:	89 c2                	mov    %eax,%edx
f010066e:	ec                   	in     (%dx),%al
f010066f:	88 45 ec             	mov    %al,-0x14(%ebp)
f0100672:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0100679:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010067c:	89 c2                	mov    %eax,%edx
f010067e:	ec                   	in     (%dx),%al
f010067f:	88 45 ed             	mov    %al,-0x13(%ebp)
f0100682:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0100689:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010068c:	89 c2                	mov    %eax,%edx
f010068e:	ec                   	in     (%dx),%al
f010068f:	88 45 ee             	mov    %al,-0x12(%ebp)
f0100692:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0100699:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010069c:	89 c2                	mov    %eax,%edx
f010069e:	ec                   	in     (%dx),%al
f010069f:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f01006a2:	90                   	nop
f01006a3:	c9                   	leave  
f01006a4:	c3                   	ret    

f01006a5 <lpt_putc>:

static void
lpt_putc(int c)
{
f01006a5:	55                   	push   %ebp
f01006a6:	89 e5                	mov    %esp,%ebp
f01006a8:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01006b2:	eb 08                	jmp    f01006bc <lpt_putc+0x17>
		delay();
f01006b4:	e8 a3 ff ff ff       	call   f010065c <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f01006b9:	ff 45 fc             	incl   -0x4(%ebp)
f01006bc:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f01006c3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01006c6:	89 c2                	mov    %eax,%edx
f01006c8:	ec                   	in     (%dx),%al
f01006c9:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f01006cc:	8a 45 eb             	mov    -0x15(%ebp),%al
f01006cf:	84 c0                	test   %al,%al
f01006d1:	78 09                	js     f01006dc <lpt_putc+0x37>
f01006d3:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f01006da:	7e d8                	jle    f01006b4 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f01006dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01006df:	0f b6 c0             	movzbl %al,%eax
f01006e2:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f01006e9:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01006ec:	8a 45 e8             	mov    -0x18(%ebp),%al
f01006ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01006f2:	ee                   	out    %al,(%dx)
f01006f3:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f01006fa:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f01006fe:	8a 45 e9             	mov    -0x17(%ebp),%al
f0100701:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100704:	ee                   	out    %al,(%dx)
f0100705:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f010070c:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f0100710:	8a 45 ea             	mov    -0x16(%ebp),%al
f0100713:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0100716:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f0100717:	90                   	nop
f0100718:	c9                   	leave  
f0100719:	c3                   	ret    

f010071a <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f010071a:	55                   	push   %ebp
f010071b:	89 e5                	mov    %esp,%ebp
f010071d:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f0100720:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f0100727:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010072a:	66 8b 00             	mov    (%eax),%ax
f010072d:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f0100731:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100734:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f0100739:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010073c:	66 8b 00             	mov    (%eax),%ax
f010073f:	66 3d 5a a5          	cmp    $0xa55a,%ax
f0100743:	74 13                	je     f0100758 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f0100745:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f010074c:	c7 05 e8 17 55 f0 b4 	movl   $0x3b4,0xf05517e8
f0100753:	03 00 00 
f0100756:	eb 14                	jmp    f010076c <cga_init+0x52>
	} else {
		*cp = was;
f0100758:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010075b:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f010075f:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f0100762:	c7 05 e8 17 55 f0 d4 	movl   $0x3d4,0xf05517e8
f0100769:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f010076c:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100771:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100774:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0100778:	8a 45 e0             	mov    -0x20(%ebp),%al
f010077b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010077e:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010077f:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100784:	40                   	inc    %eax
f0100785:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100788:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010078b:	89 c2                	mov    %eax,%edx
f010078d:	ec                   	in     (%dx),%al
f010078e:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f0100791:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100794:	0f b6 c0             	movzbl %al,%eax
f0100797:	c1 e0 08             	shl    $0x8,%eax
f010079a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f010079d:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f01007a2:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01007a5:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01007a9:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01007ac:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01007af:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f01007b0:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f01007b5:	40                   	inc    %eax
f01007b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01007b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01007bc:	89 c2                	mov    %eax,%edx
f01007be:	ec                   	in     (%dx),%al
f01007bf:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f01007c2:	8a 45 e3             	mov    -0x1d(%ebp),%al
f01007c5:	0f b6 c0             	movzbl %al,%eax
f01007c8:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f01007cb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01007ce:	a3 ec 17 55 f0       	mov    %eax,0xf05517ec
	crt_pos = pos;
f01007d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01007d6:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
}
f01007dc:	90                   	nop
f01007dd:	c9                   	leave  
f01007de:	c3                   	ret    

f01007df <cga_putc>:
//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.

void
cga_putc(int c)
{
f01007df:	55                   	push   %ebp
f01007e0:	89 e5                	mov    %esp,%ebp
f01007e2:	53                   	push   %ebx
f01007e3:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
f01007e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007e9:	b0 00                	mov    $0x0,%al
f01007eb:	85 c0                	test   %eax,%eax
f01007ed:	75 07                	jne    f01007f6 <cga_putc+0x17>
		c |= 0x0700;
f01007ef:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)

	switch (c & 0xff) {
f01007f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01007f9:	0f b6 c0             	movzbl %al,%eax
f01007fc:	83 f8 0a             	cmp    $0xa,%eax
f01007ff:	74 77                	je     f0100878 <cga_putc+0x99>
f0100801:	83 f8 0a             	cmp    $0xa,%eax
f0100804:	7f 13                	jg     f0100819 <cga_putc+0x3a>
f0100806:	83 f8 08             	cmp    $0x8,%eax
f0100809:	74 2e                	je     f0100839 <cga_putc+0x5a>
f010080b:	83 f8 09             	cmp    $0x9,%eax
f010080e:	0f 84 a8 00 00 00    	je     f01008bc <cga_putc+0xdd>
f0100814:	e9 22 01 00 00       	jmp    f010093b <cga_putc+0x15c>
f0100819:	3d e4 00 00 00       	cmp    $0xe4,%eax
f010081e:	0f 84 de 00 00 00    	je     f0100902 <cga_putc+0x123>
f0100824:	3d e5 00 00 00       	cmp    $0xe5,%eax
f0100829:	0f 84 f1 00 00 00    	je     f0100920 <cga_putc+0x141>
f010082f:	83 f8 0d             	cmp    $0xd,%eax
f0100832:	74 5d                	je     f0100891 <cga_putc+0xb2>
f0100834:	e9 02 01 00 00       	jmp    f010093b <cga_putc+0x15c>
	case '\b':
		if (crt_pos > 0) {
f0100839:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010083f:	66 85 c0             	test   %ax,%ax
f0100842:	0f 84 4f 01 00 00    	je     f0100997 <cga_putc+0x1b8>
			crt_pos--;
f0100848:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010084e:	48                   	dec    %eax
f010084f:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0100855:	8b 15 ec 17 55 f0    	mov    0xf05517ec,%edx
f010085b:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100861:	0f b7 c0             	movzwl %ax,%eax
f0100864:	01 c0                	add    %eax,%eax
f0100866:	01 c2                	add    %eax,%edx
f0100868:	8b 45 08             	mov    0x8(%ebp),%eax
f010086b:	b0 00                	mov    $0x0,%al
f010086d:	83 c8 20             	or     $0x20,%eax
f0100870:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0100873:	e9 1f 01 00 00       	jmp    f0100997 <cga_putc+0x1b8>
	case '\n':
		crt_pos += CRT_COLS;
f0100878:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010087e:	83 c0 50             	add    $0x50,%eax
f0100881:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		text_length = 0;
f0100887:	c7 05 e0 17 55 f0 00 	movl   $0x0,0xf05517e0
f010088e:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f0100891:	66 8b 0d f0 17 55 f0 	mov    0xf05517f0,%cx
f0100898:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f010089e:	bb 50 00 00 00       	mov    $0x50,%ebx
f01008a3:	ba 00 00 00 00       	mov    $0x0,%edx
f01008a8:	66 f7 f3             	div    %bx
f01008ab:	89 d0                	mov    %edx,%eax
f01008ad:	29 c1                	sub    %eax,%ecx
f01008af:	89 c8                	mov    %ecx,%eax
f01008b1:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		break;
f01008b7:	e9 e5 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case '\t':
		cons_putc(' ');
f01008bc:	83 ec 0c             	sub    $0xc,%esp
f01008bf:	6a 20                	push   $0x20
f01008c1:	e8 30 05 00 00       	call   f0100df6 <cons_putc>
f01008c6:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008c9:	83 ec 0c             	sub    $0xc,%esp
f01008cc:	6a 20                	push   $0x20
f01008ce:	e8 23 05 00 00       	call   f0100df6 <cons_putc>
f01008d3:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008d6:	83 ec 0c             	sub    $0xc,%esp
f01008d9:	6a 20                	push   $0x20
f01008db:	e8 16 05 00 00       	call   f0100df6 <cons_putc>
f01008e0:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008e3:	83 ec 0c             	sub    $0xc,%esp
f01008e6:	6a 20                	push   $0x20
f01008e8:	e8 09 05 00 00       	call   f0100df6 <cons_putc>
f01008ed:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f01008f0:	83 ec 0c             	sub    $0xc,%esp
f01008f3:	6a 20                	push   $0x20
f01008f5:	e8 fc 04 00 00       	call   f0100df6 <cons_putc>
f01008fa:	83 c4 10             	add    $0x10,%esp
		break;
f01008fd:	e9 9f 00 00 00       	jmp    f01009a1 <cga_putc+0x1c2>
	case 228:
		if(crt_pos>0)
f0100902:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100908:	66 85 c0             	test   %ax,%ax
f010090b:	0f 84 89 00 00 00    	je     f010099a <cga_putc+0x1bb>
			crt_pos--;
f0100911:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100917:	48                   	dec    %eax
f0100918:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		break;
f010091e:	eb 7a                	jmp    f010099a <cga_putc+0x1bb>
	case 229:
		if (crt_pos < CRT_SIZE)
f0100920:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100926:	66 3d cf 07          	cmp    $0x7cf,%ax
f010092a:	77 71                	ja     f010099d <cga_putc+0x1be>
			crt_pos++;
f010092c:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100932:	40                   	inc    %eax
f0100933:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
		break;
f0100939:	eb 62                	jmp    f010099d <cga_putc+0x1be>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f010093b:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f0100942:	74 5c                	je     f01009a0 <cga_putc+0x1c1>
f0100944:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f010094b:	74 53                	je     f01009a0 <cga_putc+0x1c1>
			crt_buf[crt_pos++] = c;		/* write the character */
f010094d:	8b 0d ec 17 55 f0    	mov    0xf05517ec,%ecx
f0100953:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100959:	8d 50 01             	lea    0x1(%eax),%edx
f010095c:	66 89 15 f0 17 55 f0 	mov    %dx,0xf05517f0
f0100963:	0f b7 c0             	movzwl %ax,%eax
f0100966:	01 c0                	add    %eax,%eax
f0100968:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010096b:	8b 45 08             	mov    0x8(%ebp),%eax
f010096e:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f0100971:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100977:	0f b7 c0             	movzwl %ax,%eax
f010097a:	8b 15 e0 17 55 f0    	mov    0xf05517e0,%edx
f0100980:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100986:	39 d0                	cmp    %edx,%eax
f0100988:	7e 16                	jle    f01009a0 <cga_putc+0x1c1>
				text_length++;
f010098a:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f010098f:	40                   	inc    %eax
f0100990:	a3 e0 17 55 f0       	mov    %eax,0xf05517e0
		}
		break;
f0100995:	eb 09                	jmp    f01009a0 <cga_putc+0x1c1>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0100997:	90                   	nop
f0100998:	eb 07                	jmp    f01009a1 <cga_putc+0x1c2>
		cons_putc(' ');
		break;
	case 228:
		if(crt_pos>0)
			crt_pos--;
		break;
f010099a:	90                   	nop
f010099b:	eb 04                	jmp    f01009a1 <cga_putc+0x1c2>
	case 229:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010099d:	90                   	nop
f010099e:	eb 01                	jmp    f01009a1 <cga_putc+0x1c2>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f01009a0:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f01009a1:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f01009a7:	66 3d cf 07          	cmp    $0x7cf,%ax
f01009ab:	76 58                	jbe    f0100a05 <cga_putc+0x226>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f01009ad:	a1 ec 17 55 f0       	mov    0xf05517ec,%eax
f01009b2:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f01009b8:	a1 ec 17 55 f0       	mov    0xf05517ec,%eax
f01009bd:	83 ec 04             	sub    $0x4,%esp
f01009c0:	68 00 0f 00 00       	push   $0xf00
f01009c5:	52                   	push   %edx
f01009c6:	50                   	push   %eax
f01009c7:	e8 85 fd 01 00       	call   f0120751 <memcpy>
f01009cc:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009cf:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f01009d6:	eb 15                	jmp    f01009ed <cga_putc+0x20e>
			crt_buf[i] = 0x0700 | ' ';
f01009d8:	8b 15 ec 17 55 f0    	mov    0xf05517ec,%edx
f01009de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01009e1:	01 c0                	add    %eax,%eax
f01009e3:	01 d0                	add    %edx,%eax
f01009e5:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f01009ea:	ff 45 f4             	incl   -0xc(%ebp)
f01009ed:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01009f4:	7e e2                	jle    f01009d8 <cga_putc+0x1f9>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01009f6:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f01009fc:	83 e8 50             	sub    $0x50,%eax
f01009ff:	66 a3 f0 17 55 f0    	mov    %ax,0xf05517f0
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f0100a05:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100a0a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0100a0d:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100a11:	8a 45 e0             	mov    -0x20(%ebp),%al
f0100a14:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0100a17:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f0100a18:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100a1e:	66 c1 e8 08          	shr    $0x8,%ax
f0100a22:	0f b6 c0             	movzbl %al,%eax
f0100a25:	8b 15 e8 17 55 f0    	mov    0xf05517e8,%edx
f0100a2b:	42                   	inc    %edx
f0100a2c:	89 55 ec             	mov    %edx,-0x14(%ebp)
f0100a2f:	88 45 e1             	mov    %al,-0x1f(%ebp)
f0100a32:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0100a35:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0100a38:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f0100a39:	a1 e8 17 55 f0       	mov    0xf05517e8,%eax
f0100a3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100a41:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f0100a45:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0100a48:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0100a4b:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f0100a4c:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100a52:	0f b6 c0             	movzbl %al,%eax
f0100a55:	8b 15 e8 17 55 f0    	mov    0xf05517e8,%edx
f0100a5b:	42                   	inc    %edx
f0100a5c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0100a5f:	88 45 e3             	mov    %al,-0x1d(%ebp)
f0100a62:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0100a65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0100a68:	ee                   	out    %al,(%dx)
}
f0100a69:	90                   	nop
f0100a6a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0100a6d:	c9                   	leave  
f0100a6e:	c3                   	ret    

f0100a6f <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f0100a6f:	55                   	push   %ebp
f0100a70:	89 e5                	mov    %esp,%ebp
f0100a72:	83 ec 28             	sub    $0x28,%esp
f0100a75:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100a7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100a7f:	89 c2                	mov    %eax,%edx
f0100a81:	ec                   	in     (%dx),%al
f0100a82:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0100a85:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0100a88:	0f b6 c0             	movzbl %al,%eax
f0100a8b:	83 e0 01             	and    $0x1,%eax
f0100a8e:	85 c0                	test   %eax,%eax
f0100a90:	75 0a                	jne    f0100a9c <kbd_proc_data+0x2d>
		return -1;
f0100a92:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0100a97:	e9 2a 02 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
f0100a9c:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0100aa3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0100aa6:	89 c2                	mov    %eax,%edx
f0100aa8:	ec                   	in     (%dx),%al
f0100aa9:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0100aac:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f0100aaf:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f0100ab2:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0100ab6:	75 17                	jne    f0100acf <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0100ab8:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100abd:	83 c8 40             	or     $0x40,%eax
f0100ac0:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
		return 0;
f0100ac5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100aca:	e9 f7 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f0100acf:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ad2:	84 c0                	test   %al,%al
f0100ad4:	79 44                	jns    f0100b1a <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0100ad6:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100adb:	83 e0 40             	and    $0x40,%eax
f0100ade:	85 c0                	test   %eax,%eax
f0100ae0:	75 08                	jne    f0100aea <kbd_proc_data+0x7b>
f0100ae2:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100ae5:	83 e0 7f             	and    $0x7f,%eax
f0100ae8:	eb 03                	jmp    f0100aed <kbd_proc_data+0x7e>
f0100aea:	8a 45 f3             	mov    -0xd(%ebp),%al
f0100aed:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f0100af0:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100af4:	8a 80 20 90 17 f0    	mov    -0xfe86fe0(%eax),%al
f0100afa:	83 c8 40             	or     $0x40,%eax
f0100afd:	0f b6 c0             	movzbl %al,%eax
f0100b00:	f7 d0                	not    %eax
f0100b02:	89 c2                	mov    %eax,%edx
f0100b04:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b09:	21 d0                	and    %edx,%eax
f0100b0b:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
		return 0;
f0100b10:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b15:	e9 ac 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f0100b1a:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b1f:	83 e0 40             	and    $0x40,%eax
f0100b22:	85 c0                	test   %eax,%eax
f0100b24:	74 11                	je     f0100b37 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f0100b26:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f0100b2a:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b2f:	83 e0 bf             	and    $0xffffffbf,%eax
f0100b32:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
	}

	shift |= shiftcode[data];
f0100b37:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b3b:	8a 80 20 90 17 f0    	mov    -0xfe86fe0(%eax),%al
f0100b41:	0f b6 d0             	movzbl %al,%edx
f0100b44:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b49:	09 d0                	or     %edx,%eax
f0100b4b:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08
	shift ^= togglecode[data];
f0100b50:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b54:	8a 80 20 91 17 f0    	mov    -0xfe86ee0(%eax),%al
f0100b5a:	0f b6 d0             	movzbl %al,%edx
f0100b5d:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b62:	31 d0                	xor    %edx,%eax
f0100b64:	a3 08 1a 55 f0       	mov    %eax,0xf0551a08

	c = charcode[shift & (CTL | SHIFT)][data];
f0100b69:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100b6e:	83 e0 03             	and    $0x3,%eax
f0100b71:	8b 14 85 20 95 17 f0 	mov    -0xfe86ae0(,%eax,4),%edx
f0100b78:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0100b7c:	01 d0                	add    %edx,%eax
f0100b7e:	8a 00                	mov    (%eax),%al
f0100b80:	0f b6 c0             	movzbl %al,%eax
f0100b83:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0100b86:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100b8d:	0f 85 9c 00 00 00    	jne    f0100c2f <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0100b93:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f0100b98:	85 c0                	test   %eax,%eax
f0100b9a:	0f 8e 85 00 00 00    	jle    f0100c25 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f0100ba0:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100ba6:	0f b7 c0             	movzwl %ax,%eax
f0100ba9:	8b 15 e0 17 55 f0    	mov    0xf05517e0,%edx
f0100baf:	81 c2 80 07 00 00    	add    $0x780,%edx
f0100bb5:	39 d0                	cmp    %edx,%eax
f0100bb7:	75 0a                	jne    f0100bc3 <kbd_proc_data+0x154>
				return 0;
f0100bb9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100bbe:	e9 03 01 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			else {
				text_length--;
f0100bc3:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f0100bc8:	48                   	dec    %eax
f0100bc9:	a3 e0 17 55 f0       	mov    %eax,0xf05517e0
				int crt_pos_Length = crt_pos - 1925;
f0100bce:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100bd4:	0f b7 c0             	movzwl %ax,%eax
f0100bd7:	2d 85 07 00 00       	sub    $0x785,%eax
f0100bdc:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100bdf:	66 a1 f0 17 55 f0    	mov    0xf05517f0,%ax
f0100be5:	0f b7 c0             	movzwl %ax,%eax
f0100be8:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0100beb:	eb 26                	jmp    f0100c13 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f0100bed:	8b 15 ec 17 55 f0    	mov    0xf05517ec,%edx
f0100bf3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0100bf6:	01 c0                	add    %eax,%eax
f0100bf8:	01 c2                	add    %eax,%edx
f0100bfa:	a1 ec 17 55 f0       	mov    0xf05517ec,%eax
f0100bff:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f0100c02:	41                   	inc    %ecx
f0100c03:	01 c9                	add    %ecx,%ecx
f0100c05:	01 c8                	add    %ecx,%eax
f0100c07:	66 8b 00             	mov    (%eax),%ax
f0100c0a:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f0100c0d:	ff 45 e8             	incl   -0x18(%ebp)
f0100c10:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f0100c13:	a1 e0 17 55 f0       	mov    0xf05517e0,%eax
f0100c18:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0100c1b:	7e d0                	jle    f0100bed <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f0100c1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100c20:	e9 a1 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
			}
		}
		return 0;
f0100c25:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c2a:	e9 97 00 00 00       	jmp    f0100cc6 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f0100c2f:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100c34:	83 e0 08             	and    $0x8,%eax
f0100c37:	85 c0                	test   %eax,%eax
f0100c39:	74 22                	je     f0100c5d <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f0100c3b:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f0100c3f:	7e 0c                	jle    f0100c4d <kbd_proc_data+0x1de>
f0100c41:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f0100c45:	7f 06                	jg     f0100c4d <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f0100c47:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f0100c4b:	eb 10                	jmp    f0100c5d <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f0100c4d:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f0100c51:	7e 0a                	jle    f0100c5d <kbd_proc_data+0x1ee>
f0100c53:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0100c57:	7f 04                	jg     f0100c5d <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0100c59:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f0100c5d:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100c62:	83 f8 10             	cmp    $0x10,%eax
f0100c65:	75 13                	jne    f0100c7a <kbd_proc_data+0x20b>
f0100c67:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0100c6b:	7e 0d                	jle    f0100c7a <kbd_proc_data+0x20b>
f0100c6d:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f0100c71:	7f 07                	jg     f0100c7a <kbd_proc_data+0x20b>
		return 0;
f0100c73:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c78:	eb 4c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	if (c == 255)
f0100c7a:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0100c81:	75 07                	jne    f0100c8a <kbd_proc_data+0x21b>
		return 0;
f0100c83:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c88:	eb 3c                	jmp    f0100cc6 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0100c8a:	a1 08 1a 55 f0       	mov    0xf0551a08,%eax
f0100c8f:	f7 d0                	not    %eax
f0100c91:	83 e0 06             	and    $0x6,%eax
f0100c94:	85 c0                	test   %eax,%eax
f0100c96:	75 2b                	jne    f0100cc3 <kbd_proc_data+0x254>
f0100c98:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f0100c9f:	75 22                	jne    f0100cc3 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f0100ca1:	83 ec 0c             	sub    $0xc,%esp
f0100ca4:	68 3b 1a 12 f0       	push   $0xf0121a3b
f0100ca9:	e8 be 02 00 00       	call   f0100f6c <cprintf>
f0100cae:	83 c4 10             	add    $0x10,%esp
f0100cb1:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0100cb8:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0100cbc:	8a 45 d9             	mov    -0x27(%ebp),%al
f0100cbf:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0100cc2:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0100cc3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100cc6:	c9                   	leave  
f0100cc7:	c3                   	ret    

f0100cc8 <kbd_intr>:

void
kbd_intr(void)
{
f0100cc8:	55                   	push   %ebp
f0100cc9:	89 e5                	mov    %esp,%ebp
f0100ccb:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f0100cce:	83 ec 0c             	sub    $0xc,%esp
f0100cd1:	68 6f 0a 10 f0       	push   $0xf0100a6f
f0100cd6:	e8 21 00 00 00       	call   f0100cfc <cons_intr>
f0100cdb:	83 c4 10             	add    $0x10,%esp
}
f0100cde:	90                   	nop
f0100cdf:	c9                   	leave  
f0100ce0:	c3                   	ret    

f0100ce1 <kbd_init>:

void
kbd_init(void)
{
f0100ce1:	55                   	push   %ebp
f0100ce2:	89 e5                	mov    %esp,%ebp
f0100ce4:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0100ce7:	83 ec 08             	sub    $0x8,%esp
f0100cea:	68 83 0e 10 f0       	push   $0xf0100e83
f0100cef:	6a 01                	push   $0x1
f0100cf1:	e8 a3 c3 00 00       	call   f010d099 <irq_install_handler>
f0100cf6:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f0100cf9:	90                   	nop
f0100cfa:	c9                   	leave  
f0100cfb:	c3                   	ret    

f0100cfc <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f0100cfc:	55                   	push   %ebp
f0100cfd:	89 e5                	mov    %esp,%ebp
f0100cff:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f0100d02:	eb 35                	jmp    f0100d39 <cons_intr+0x3d>
		if (c == 0)
f0100d04:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100d08:	75 02                	jne    f0100d0c <cons_intr+0x10>
			continue;
f0100d0a:	eb 2d                	jmp    f0100d39 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f0100d0c:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100d11:	8d 50 01             	lea    0x1(%eax),%edx
f0100d14:	89 15 04 1a 55 f0    	mov    %edx,0xf0551a04
f0100d1a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100d1d:	88 90 00 18 55 f0    	mov    %dl,-0xfaae800(%eax)
		if (cons.wpos == CONSBUFSIZE)
f0100d23:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100d28:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d2d:	75 0a                	jne    f0100d39 <cons_intr+0x3d>
			cons.wpos = 0;
f0100d2f:	c7 05 04 1a 55 f0 00 	movl   $0x0,0xf0551a04
f0100d36:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f0100d39:	8b 45 08             	mov    0x8(%ebp),%eax
f0100d3c:	ff d0                	call   *%eax
f0100d3e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100d41:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f0100d45:	75 bd                	jne    f0100d04 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f0100d47:	90                   	nop
f0100d48:	c9                   	leave  
f0100d49:	c3                   	ret    

f0100d4a <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f0100d4a:	55                   	push   %ebp
f0100d4b:	89 e5                	mov    %esp,%ebp
f0100d4d:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f0100d50:	e8 ee f7 ff ff       	call   f0100543 <serial_intr>
	kbd_intr();
f0100d55:	e8 6e ff ff ff       	call   f0100cc8 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0100d5a:	8b 15 00 1a 55 f0    	mov    0xf0551a00,%edx
f0100d60:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100d65:	39 c2                	cmp    %eax,%edx
f0100d67:	74 35                	je     f0100d9e <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0100d69:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100d6e:	8d 50 01             	lea    0x1(%eax),%edx
f0100d71:	89 15 00 1a 55 f0    	mov    %edx,0xf0551a00
f0100d77:	8a 80 00 18 55 f0    	mov    -0xfaae800(%eax),%al
f0100d7d:	0f b6 c0             	movzbl %al,%eax
f0100d80:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100d83:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100d88:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100d8d:	75 0a                	jne    f0100d99 <cons_getc+0x4f>
			cons.rpos = 0;
f0100d8f:	c7 05 00 1a 55 f0 00 	movl   $0x0,0xf0551a00
f0100d96:	00 00 00 
		return c;
f0100d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100d9c:	eb 05                	jmp    f0100da3 <cons_getc+0x59>
	}
	return 0;
f0100d9e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100da3:	c9                   	leave  
f0100da4:	c3                   	ret    

f0100da5 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0100da5:	55                   	push   %ebp
f0100da6:	89 e5                	mov    %esp,%ebp
f0100da8:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0100dab:	8b 15 00 1a 55 f0    	mov    0xf0551a00,%edx
f0100db1:	a1 04 1a 55 f0       	mov    0xf0551a04,%eax
f0100db6:	39 c2                	cmp    %eax,%edx
f0100db8:	74 35                	je     f0100def <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0100dba:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100dbf:	8d 50 01             	lea    0x1(%eax),%edx
f0100dc2:	89 15 00 1a 55 f0    	mov    %edx,0xf0551a00
f0100dc8:	8a 80 00 18 55 f0    	mov    -0xfaae800(%eax),%al
f0100dce:	0f b6 c0             	movzbl %al,%eax
f0100dd1:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0100dd4:	a1 00 1a 55 f0       	mov    0xf0551a00,%eax
f0100dd9:	3d 00 02 00 00       	cmp    $0x200,%eax
f0100dde:	75 0a                	jne    f0100dea <cons_getc2+0x45>
			cons.rpos = 0;
f0100de0:	c7 05 00 1a 55 f0 00 	movl   $0x0,0xf0551a00
f0100de7:	00 00 00 
		return c;
f0100dea:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0100ded:	eb 05                	jmp    f0100df4 <cons_getc2+0x4f>
	}
	return 0;
f0100def:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0100df4:	c9                   	leave  
f0100df5:	c3                   	ret    

f0100df6 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0100df6:	55                   	push   %ebp
f0100df7:	89 e5                	mov    %esp,%ebp
f0100df9:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0100dfc:	ff 75 08             	pushl  0x8(%ebp)
f0100dff:	e8 a1 f8 ff ff       	call   f01006a5 <lpt_putc>
f0100e04:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0100e07:	83 ec 0c             	sub    $0xc,%esp
f0100e0a:	ff 75 08             	pushl  0x8(%ebp)
f0100e0d:	e8 cd f9 ff ff       	call   f01007df <cga_putc>
f0100e12:	83 c4 10             	add    $0x10,%esp
}
f0100e15:	90                   	nop
f0100e16:	c9                   	leave  
f0100e17:	c3                   	ret    

f0100e18 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0100e18:	55                   	push   %ebp
f0100e19:	89 e5                	mov    %esp,%ebp
f0100e1b:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0100e1e:	e8 f7 f8 ff ff       	call   f010071a <cga_init>
	kbd_init();
f0100e23:	e8 b9 fe ff ff       	call   f0100ce1 <kbd_init>
	serial_init();
f0100e28:	e8 56 f7 ff ff       	call   f0100583 <serial_init>

	if (!serial_exists)
f0100e2d:	a1 e4 17 55 f0       	mov    0xf05517e4,%eax
f0100e32:	85 c0                	test   %eax,%eax
f0100e34:	75 10                	jne    f0100e46 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0100e36:	83 ec 0c             	sub    $0xc,%esp
f0100e39:	68 47 1a 12 f0       	push   $0xf0121a47
f0100e3e:	e8 29 01 00 00       	call   f0100f6c <cprintf>
f0100e43:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0100e46:	90                   	nop
f0100e47:	c9                   	leave  
f0100e48:	c3                   	ret    

f0100e49 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0100e49:	55                   	push   %ebp
f0100e4a:	89 e5                	mov    %esp,%ebp
f0100e4c:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0100e4f:	83 ec 0c             	sub    $0xc,%esp
f0100e52:	ff 75 08             	pushl  0x8(%ebp)
f0100e55:	e8 9c ff ff ff       	call   f0100df6 <cons_putc>
f0100e5a:	83 c4 10             	add    $0x10,%esp
}
f0100e5d:	90                   	nop
f0100e5e:	c9                   	leave  
f0100e5f:	c3                   	ret    

f0100e60 <getchar>:

int
getchar(void)
{
f0100e60:	55                   	push   %ebp
f0100e61:	89 e5                	mov    %esp,%ebp
f0100e63:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0100e66:	e8 df fe ff ff       	call   f0100d4a <cons_getc>
f0100e6b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0100e6e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100e72:	74 f2                	je     f0100e66 <getchar+0x6>
		/* do nothing */;
	return c;
f0100e74:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100e77:	c9                   	leave  
f0100e78:	c3                   	ret    

f0100e79 <iscons>:

int
iscons(int fdnum)
{
f0100e79:	55                   	push   %ebp
f0100e7a:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0100e7c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0100e81:	5d                   	pop    %ebp
f0100e82:	c3                   	ret    

f0100e83 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0100e83:	55                   	push   %ebp
f0100e84:	89 e5                	mov    %esp,%ebp
f0100e86:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0100e89:	e8 3a fe ff ff       	call   f0100cc8 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0100e8e:	90                   	nop
f0100e8f:	c9                   	leave  
f0100e90:	c3                   	ret    

f0100e91 <cons_lock>:

void cons_lock(void)
{
f0100e91:	55                   	push   %ebp
f0100e92:	89 e5                	mov    %esp,%ebp
f0100e94:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100e97:	e8 ed 3a 00 00       	call   f0104989 <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0100e9c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100e9d:	e8 cf 95 00 00       	call   f010a471 <get_cpu_proc>
f0100ea2:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100ea5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ea9:	75 17                	jne    f0100ec2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0100eab:	83 ec 04             	sub    $0x4,%esp
f0100eae:	68 64 1a 12 f0       	push   $0xf0121a64
f0100eb3:	68 2d 02 00 00       	push   $0x22d
f0100eb8:	68 8b 1a 12 f0       	push   $0xf0121a8b
f0100ebd:	e8 58 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0100ec2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100ec5:	8b 00                	mov    (%eax),%eax
f0100ec7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100eca:	8b 12                	mov    (%edx),%edx
f0100ecc:	8b 52 38             	mov    0x38(%edx),%edx
f0100ecf:	80 e6 fd             	and    $0xfd,%dh
f0100ed2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0100ed5:	90                   	nop
f0100ed6:	c9                   	leave  
f0100ed7:	c3                   	ret    

f0100ed8 <cons_unlock>:

void cons_unlock(void)
{
f0100ed8:	55                   	push   %ebp
f0100ed9:	89 e5                	mov    %esp,%ebp
f0100edb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0100ede:	e8 a6 3a 00 00       	call   f0104989 <kclock_stop>
f0100ee3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0100ee4:	e8 88 95 00 00       	call   f010a471 <get_cpu_proc>
f0100ee9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0100eec:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0100ef0:	75 17                	jne    f0100f09 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0100ef2:	83 ec 04             	sub    $0x4,%esp
f0100ef5:	68 a0 1a 12 f0       	push   $0xf0121aa0
f0100efa:	68 46 02 00 00       	push   $0x246
f0100eff:	68 8b 1a 12 f0       	push   $0xf0121a8b
f0100f04:	e8 11 f4 ff ff       	call   f010031a <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0100f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0100f0c:	8b 00                	mov    (%eax),%eax
f0100f0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0100f11:	8b 12                	mov    (%edx),%edx
f0100f13:	8b 52 38             	mov    0x38(%edx),%edx
f0100f16:	80 ce 02             	or     $0x2,%dh
f0100f19:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0100f1c:	90                   	nop
f0100f1d:	c9                   	leave  
f0100f1e:	c3                   	ret    

f0100f1f <putch>:
#include <kern/cpu/cpu.h>


static void
putch(int ch, int *cnt)
{
f0100f1f:	55                   	push   %ebp
f0100f20:	89 e5                	mov    %esp,%ebp
f0100f22:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0100f25:	83 ec 0c             	sub    $0xc,%esp
f0100f28:	ff 75 08             	pushl  0x8(%ebp)
f0100f2b:	e8 19 ff ff ff       	call   f0100e49 <cputchar>
f0100f30:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0100f33:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f36:	8b 00                	mov    (%eax),%eax
f0100f38:	8d 50 01             	lea    0x1(%eax),%edx
f0100f3b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100f3e:	89 10                	mov    %edx,(%eax)
}
f0100f40:	90                   	nop
f0100f41:	c9                   	leave  
f0100f42:	c3                   	ret    

f0100f43 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0100f43:	55                   	push   %ebp
f0100f44:	89 e5                	mov    %esp,%ebp
f0100f46:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0100f49:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0100f50:	ff 75 0c             	pushl  0xc(%ebp)
f0100f53:	ff 75 08             	pushl  0x8(%ebp)
f0100f56:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0100f59:	50                   	push   %eax
f0100f5a:	68 1f 0f 10 f0       	push   $0xf0100f1f
f0100f5f:	e8 0d ef 01 00       	call   f011fe71 <vprintfmt>
f0100f64:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0100f67:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0100f6a:	c9                   	leave  
f0100f6b:	c3                   	ret    

f0100f6c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0100f6c:	55                   	push   %ebp
f0100f6d:	89 e5                	mov    %esp,%ebp
f0100f6f:	83 ec 18             	sub    $0x18,%esp
	//2024 - better to use locks instead (to support multiprocessors)
	int cnt;
	pushcli();	//disable interrupts
f0100f72:	e8 4a 5f 00 00       	call   f0106ec1 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0100f77:	8d 45 0c             	lea    0xc(%ebp),%eax
f0100f7a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0100f7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0100f80:	83 ec 08             	sub    $0x8,%esp
f0100f83:	ff 75 f4             	pushl  -0xc(%ebp)
f0100f86:	50                   	push   %eax
f0100f87:	e8 b7 ff ff ff       	call   f0100f43 <vcprintf>
f0100f8c:	83 c4 10             	add    $0x10,%esp
f0100f8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0100f92:	e8 7c 5f 00 00       	call   f0106f13 <popcli>

	return cnt;
f0100f97:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0100f9a:	c9                   	leave  
f0100f9b:	c3                   	ret    

f0100f9c <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0100f9c:	55                   	push   %ebp
f0100f9d:	89 e5                	mov    %esp,%ebp
f0100f9f:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0100fa2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0100fa9:	eb 10                	jmp    f0100fbb <clearandwritecommand+0x1f>
		cputchar('\b');
f0100fab:	83 ec 0c             	sub    $0xc,%esp
f0100fae:	6a 08                	push   $0x8
f0100fb0:	e8 94 fe ff ff       	call   f0100e49 <cputchar>
f0100fb5:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f0100fb8:	ff 45 f4             	incl   -0xc(%ebp)
f0100fbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0100fbe:	8b 00                	mov    (%eax),%eax
f0100fc0:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0100fc3:	7f e6                	jg     f0100fab <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f0100fc5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0100fc8:	c1 e0 0a             	shl    $0xa,%eax
f0100fcb:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0100fd0:	83 ec 0c             	sub    $0xc,%esp
f0100fd3:	50                   	push   %eax
f0100fd4:	e8 5a f5 01 00       	call   f0120533 <strlen>
f0100fd9:	83 c4 10             	add    $0x10,%esp
f0100fdc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f0100fdf:	83 ec 04             	sub    $0x4,%esp
f0100fe2:	68 00 04 00 00       	push   $0x400
f0100fe7:	68 c0 32 57 f0       	push   $0xf05732c0
f0100fec:	ff 75 10             	pushl  0x10(%ebp)
f0100fef:	e8 5d f7 01 00       	call   f0120751 <memcpy>
f0100ff4:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0100ff7:	8b 45 08             	mov    0x8(%ebp),%eax
f0100ffa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0101000:	eb 52                	jmp    f0101054 <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f0101002:	8b 45 08             	mov    0x8(%ebp),%eax
f0101005:	8b 00                	mov    (%eax),%eax
f0101007:	8b 55 0c             	mov    0xc(%ebp),%edx
f010100a:	c1 e2 0a             	shl    $0xa,%edx
f010100d:	01 d0                	add    %edx,%eax
f010100f:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101014:	8a 00                	mov    (%eax),%al
f0101016:	0f be c0             	movsbl %al,%eax
f0101019:	83 ec 0c             	sub    $0xc,%esp
f010101c:	50                   	push   %eax
f010101d:	e8 27 fe ff ff       	call   f0100e49 <cputchar>
f0101022:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f0101025:	8b 45 08             	mov    0x8(%ebp),%eax
f0101028:	8b 00                	mov    (%eax),%eax
f010102a:	89 c2                	mov    %eax,%edx
f010102c:	8b 45 10             	mov    0x10(%ebp),%eax
f010102f:	01 c2                	add    %eax,%edx
f0101031:	8b 45 08             	mov    0x8(%ebp),%eax
f0101034:	8b 00                	mov    (%eax),%eax
f0101036:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0101039:	c1 e1 0a             	shl    $0xa,%ecx
f010103c:	01 c8                	add    %ecx,%eax
f010103e:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101043:	8a 00                	mov    (%eax),%al
f0101045:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f0101047:	8b 45 08             	mov    0x8(%ebp),%eax
f010104a:	8b 00                	mov    (%eax),%eax
f010104c:	8d 50 01             	lea    0x1(%eax),%edx
f010104f:	8b 45 08             	mov    0x8(%ebp),%eax
f0101052:	89 10                	mov    %edx,(%eax)
f0101054:	8b 45 08             	mov    0x8(%ebp),%eax
f0101057:	8b 00                	mov    (%eax),%eax
f0101059:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010105c:	7c a4                	jl     f0101002 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f010105e:	8b 45 14             	mov    0x14(%ebp),%eax
f0101061:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101064:	89 10                	mov    %edx,(%eax)
}
f0101066:	90                   	nop
f0101067:	c9                   	leave  
f0101068:	c3                   	ret    

f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0101069:	55                   	push   %ebp
f010106a:	89 e5                	mov    %esp,%ebp
f010106c:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f010106f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0101076:	eb 10                	jmp    f0101088 <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f0101078:	83 ec 0c             	sub    $0xc,%esp
f010107b:	6a 08                	push   $0x8
f010107d:	e8 c7 fd ff ff       	call   f0100e49 <cputchar>
f0101082:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f0101085:	ff 45 f4             	incl   -0xc(%ebp)
f0101088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010108b:	3b 45 08             	cmp    0x8(%ebp),%eax
f010108e:	7c e8                	jl     f0101078 <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0101090:	83 ec 0c             	sub    $0xc,%esp
f0101093:	ff 75 0c             	pushl  0xc(%ebp)
f0101096:	e8 98 f4 01 00       	call   f0120533 <strlen>
f010109b:	83 c4 10             	add    $0x10,%esp
f010109e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty, BUFLEN);
f01010a1:	83 ec 04             	sub    $0x4,%esp
f01010a4:	68 00 04 00 00       	push   $0x400
f01010a9:	68 c0 32 57 f0       	push   $0xf05732c0
f01010ae:	ff 75 10             	pushl  0x10(%ebp)
f01010b1:	e8 9b f6 01 00       	call   f0120751 <memcpy>
f01010b6:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f01010b9:	8b 45 14             	mov    0x14(%ebp),%eax
f01010bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01010c2:	eb 46                	jmp    f010110a <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f01010c4:	8b 45 14             	mov    0x14(%ebp),%eax
f01010c7:	8b 00                	mov    (%eax),%eax
f01010c9:	89 c2                	mov    %eax,%edx
f01010cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010ce:	01 d0                	add    %edx,%eax
f01010d0:	8a 00                	mov    (%eax),%al
f01010d2:	0f be c0             	movsbl %al,%eax
f01010d5:	83 ec 0c             	sub    $0xc,%esp
f01010d8:	50                   	push   %eax
f01010d9:	e8 6b fd ff ff       	call   f0100e49 <cputchar>
f01010de:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f01010e1:	8b 45 14             	mov    0x14(%ebp),%eax
f01010e4:	8b 00                	mov    (%eax),%eax
f01010e6:	89 c2                	mov    %eax,%edx
f01010e8:	8b 45 10             	mov    0x10(%ebp),%eax
f01010eb:	01 c2                	add    %eax,%edx
f01010ed:	8b 45 14             	mov    0x14(%ebp),%eax
f01010f0:	8b 00                	mov    (%eax),%eax
f01010f2:	89 c1                	mov    %eax,%ecx
f01010f4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01010f7:	01 c8                	add    %ecx,%eax
f01010f9:	8a 00                	mov    (%eax),%al
f01010fb:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01010fd:	8b 45 14             	mov    0x14(%ebp),%eax
f0101100:	8b 00                	mov    (%eax),%eax
f0101102:	8d 50 01             	lea    0x1(%eax),%edx
f0101105:	8b 45 14             	mov    0x14(%ebp),%eax
f0101108:	89 10                	mov    %edx,(%eax)
f010110a:	8b 45 14             	mov    0x14(%ebp),%eax
f010110d:	8b 00                	mov    (%eax),%eax
f010110f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0101112:	7c b0                	jl     f01010c4 <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f0101114:	8b 45 18             	mov    0x18(%ebp),%eax
f0101117:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010111a:	89 10                	mov    %edx,(%eax)
}
f010111c:	90                   	nop
f010111d:	c9                   	leave  
f010111e:	c3                   	ret    

f010111f <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f010111f:	55                   	push   %ebp
f0101120:	89 e5                	mov    %esp,%ebp
f0101122:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f0101125:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010112c:	eb 21                	jmp    f010114f <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f010112e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101131:	c1 e0 0a             	shl    $0xa,%eax
f0101134:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f0101139:	83 ec 04             	sub    $0x4,%esp
f010113c:	68 00 04 00 00       	push   $0x400
f0101141:	6a 00                	push   $0x0
f0101143:	50                   	push   %eax
f0101144:	e8 d8 f5 01 00       	call   f0120721 <memset>
f0101149:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f010114c:	ff 45 f4             	incl   -0xc(%ebp)
f010114f:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f0101153:	7e d9                	jle    f010112e <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f0101155:	90                   	nop
f0101156:	c9                   	leave  
f0101157:	c3                   	ret    

f0101158 <command_prompt_readline>:

void command_prompt_readline(const char *prompt, char* buf) {
f0101158:	55                   	push   %ebp
f0101159:	89 e5                	mov    %esp,%ebp
f010115b:	57                   	push   %edi
f010115c:	53                   	push   %ebx
f010115d:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f0101163:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0101167:	74 13                	je     f010117c <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0101169:	83 ec 08             	sub    $0x8,%esp
f010116c:	ff 75 08             	pushl  0x8(%ebp)
f010116f:	68 cc 1a 12 f0       	push   $0xf0121acc
f0101174:	e8 f3 fd ff ff       	call   f0100f6c <cprintf>
f0101179:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f010117c:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101181:	40                   	inc    %eax
f0101182:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f0101185:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f010118c:	00 00 00 
f010118f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101195:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010119b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f01011a4:	83 ec 0c             	sub    $0xc,%esp
f01011a7:	6a 00                	push   $0x0
f01011a9:	e8 cb fc ff ff       	call   f0100e79 <iscons>
f01011ae:	83 c4 10             	add    $0x10,%esp
f01011b1:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f01011b4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f01011bb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f01011c2:	e8 99 fc ff ff       	call   f0100e60 <getchar>
f01011c7:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f01011ca:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f01011d0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f01011d6:	39 c2                	cmp    %eax,%edx
f01011d8:	7e 0c                	jle    f01011e6 <command_prompt_readline+0x8e>
			lastIndex = i;
f01011da:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01011e0:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f01011e6:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f01011ea:	79 22                	jns    f010120e <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f01011ec:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f01011f0:	0f 84 94 0a 00 00    	je     f0101c8a <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f01011f6:	83 ec 08             	sub    $0x8,%esp
f01011f9:	ff 75 94             	pushl  -0x6c(%ebp)
f01011fc:	68 cf 1a 12 f0       	push   $0xf0121acf
f0101201:	e8 66 fd ff ff       	call   f0100f6c <cprintf>
f0101206:	83 c4 10             	add    $0x10,%esp
			return;
f0101209:	e9 7c 0a 00 00       	jmp    f0101c8a <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f010120e:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f0101215:	75 2a                	jne    f0101241 <command_prompt_readline+0xe9>
			if (commandidx)
f0101217:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010121b:	74 03                	je     f0101220 <command_prompt_readline+0xc8>
				commandidx--;
f010121d:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101220:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0101226:	50                   	push   %eax
f0101227:	ff 75 0c             	pushl  0xc(%ebp)
f010122a:	ff 75 f4             	pushl  -0xc(%ebp)
f010122d:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101233:	50                   	push   %eax
f0101234:	e8 63 fd ff ff       	call   f0100f9c <clearandwritecommand>
f0101239:	83 c4 10             	add    $0x10,%esp
f010123c:	e9 32 0a 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f0101241:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f0101248:	75 3b                	jne    f0101285 <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f010124a:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f010124f:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0101252:	7d 03                	jge    f0101257 <command_prompt_readline+0xff>
				commandidx++;
f0101254:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f0101257:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f010125c:	85 c0                	test   %eax,%eax
f010125e:	0f 88 0f 0a 00 00    	js     f0101c73 <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f0101264:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f010126a:	50                   	push   %eax
f010126b:	ff 75 0c             	pushl  0xc(%ebp)
f010126e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101271:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0101277:	50                   	push   %eax
f0101278:	e8 1f fd ff ff       	call   f0100f9c <clearandwritecommand>
f010127d:	83 c4 10             	add    $0x10,%esp
f0101280:	e9 ee 09 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f0101285:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0101289:	0f 85 6d 07 00 00    	jne    f01019fc <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f010128f:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f0101293:	0f 84 fc 06 00 00    	je     f0101995 <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0101299:	83 ec 08             	sub    $0x8,%esp
f010129c:	6a 64                	push   $0x64
f010129e:	68 a0 52 55 f0       	push   $0xf05552a0
f01012a3:	e8 77 fe ff ff       	call   f010111f <clear_prefix_list>
f01012a8:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f01012ab:	83 ec 0c             	sub    $0xc,%esp
f01012ae:	ff 75 0c             	pushl  0xc(%ebp)
f01012b1:	e8 7d f2 01 00       	call   f0120533 <strlen>
f01012b6:	83 c4 10             	add    $0x10,%esp
f01012b9:	85 c0                	test   %eax,%eax
f01012bb:	0f 84 bd 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
f01012c1:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f01012c8:	0f 84 b0 09 00 00    	je     f0101c7e <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f01012ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01012d5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01012d8:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f01012de:	83 ec 08             	sub    $0x8,%esp
f01012e1:	ff 75 0c             	pushl  0xc(%ebp)
f01012e4:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01012ea:	50                   	push   %eax
f01012eb:	e8 92 f2 01 00       	call   f0120582 <strcpy>
f01012f0:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f01012f3:	83 ec 0c             	sub    $0xc,%esp
f01012f6:	ff 75 0c             	pushl  0xc(%ebp)
f01012f9:	e8 35 f2 01 00       	call   f0120533 <strlen>
f01012fe:	83 c4 10             	add    $0x10,%esp
f0101301:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f0101304:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101307:	8d 50 ff             	lea    -0x1(%eax),%edx
f010130a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010130d:	01 d0                	add    %edx,%eax
f010130f:	8a 00                	mov    (%eax),%al
f0101311:	3c 20                	cmp    $0x20,%al
f0101313:	0f 84 6b 09 00 00    	je     f0101c84 <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f0101319:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f010131f:	50                   	push   %eax
f0101320:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f0101326:	50                   	push   %eax
f0101327:	68 df 1a 12 f0       	push   $0xf0121adf
f010132c:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101332:	50                   	push   %eax
f0101333:	e8 10 f8 01 00       	call   f0120b48 <strsplit>
f0101338:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f010133b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f0101342:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101348:	83 f8 01             	cmp    $0x1,%eax
f010134b:	0f 8e 28 01 00 00    	jle    f0101479 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f0101351:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101357:	83 ec 08             	sub    $0x8,%esp
f010135a:	68 e4 1a 12 f0       	push   $0xf0121ae4
f010135f:	50                   	push   %eax
f0101360:	e8 da f2 01 00       	call   f012063f <strcmp>
f0101365:	83 c4 10             	add    $0x10,%esp
f0101368:	85 c0                	test   %eax,%eax
f010136a:	74 3c                	je     f01013a8 <command_prompt_readline+0x250>
f010136c:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0101372:	83 ec 08             	sub    $0x8,%esp
f0101375:	68 e8 1a 12 f0       	push   $0xf0121ae8
f010137a:	50                   	push   %eax
f010137b:	e8 bf f2 01 00       	call   f012063f <strcmp>
f0101380:	83 c4 10             	add    $0x10,%esp
f0101383:	85 c0                	test   %eax,%eax
f0101385:	74 21                	je     f01013a8 <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f0101387:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f010138d:	83 ec 08             	sub    $0x8,%esp
f0101390:	68 ed 1a 12 f0       	push   $0xf0121aed
f0101395:	50                   	push   %eax
f0101396:	e8 a4 f2 01 00       	call   f012063f <strcmp>
f010139b:	83 c4 10             	add    $0x10,%esp
f010139e:	85 c0                	test   %eax,%eax
f01013a0:	74 06                	je     f01013a8 <command_prompt_readline+0x250>
						continue;
f01013a2:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f01013a3:	e9 d6 08 00 00       	jmp    f0101c7e <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f01013a8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01013ae:	83 ec 08             	sub    $0x8,%esp
f01013b1:	68 ed 1a 12 f0       	push   $0xf0121aed
f01013b6:	50                   	push   %eax
f01013b7:	e8 83 f2 01 00       	call   f012063f <strcmp>
f01013bc:	83 c4 10             	add    $0x10,%esp
f01013bf:	85 c0                	test   %eax,%eax
f01013c1:	75 09                	jne    f01013cc <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f01013c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f01013ca:	eb 07                	jmp    f01013d3 <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f01013cc:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f01013d3:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01013da:	00 00 00 
f01013dd:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01013e3:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01013e8:	b8 00 00 00 00       	mov    $0x0,%eax
f01013ed:	89 d7                	mov    %edx,%edi
f01013ef:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f01013f1:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01013f7:	48                   	dec    %eax
f01013f8:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01013ff:	83 ec 0c             	sub    $0xc,%esp
f0101402:	50                   	push   %eax
f0101403:	e8 2b f1 01 00       	call   f0120533 <strlen>
f0101408:	83 c4 10             	add    $0x10,%esp
f010140b:	8b 55 90             	mov    -0x70(%ebp),%edx
f010140e:	29 c2                	sub    %eax,%edx
f0101410:	89 d0                	mov    %edx,%eax
f0101412:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f0101415:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010141c:	eb 1d                	jmp    f010143b <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f010141e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101421:	8d 50 01             	lea    0x1(%eax),%edx
f0101424:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0101427:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f010142a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010142d:	01 ca                	add    %ecx,%edx
f010142f:	8a 12                	mov    (%edx),%dl
f0101431:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f0101438:	ff 45 d8             	incl   -0x28(%ebp)
f010143b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010143e:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0101441:	7c db                	jl     f010141e <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f0101443:	83 ec 08             	sub    $0x8,%esp
f0101446:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010144c:	50                   	push   %eax
f010144d:	ff 75 0c             	pushl  0xc(%ebp)
f0101450:	e8 2d f1 01 00       	call   f0120582 <strcpy>
f0101455:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f0101458:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010145e:	48                   	dec    %eax
f010145f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f0101466:	83 ec 08             	sub    $0x8,%esp
f0101469:	50                   	push   %eax
f010146a:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101470:	50                   	push   %eax
f0101471:	e8 0c f1 01 00       	call   f0120582 <strcpy>
f0101476:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0101479:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0101480:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0101486:	83 f8 01             	cmp    $0x1,%eax
f0101489:	0f 85 30 01 00 00    	jne    f01015bf <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010148f:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0101496:	e9 0f 01 00 00       	jmp    f01015aa <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f010149b:	83 ec 0c             	sub    $0xc,%esp
f010149e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014a4:	50                   	push   %eax
f01014a5:	e8 89 f0 01 00       	call   f0120533 <strlen>
f01014aa:	83 c4 10             	add    $0x10,%esp
f01014ad:	89 c1                	mov    %eax,%ecx
f01014af:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01014b2:	89 d0                	mov    %edx,%eax
f01014b4:	01 c0                	add    %eax,%eax
f01014b6:	01 d0                	add    %edx,%eax
f01014b8:	c1 e0 03             	shl    $0x3,%eax
f01014bb:	05 40 95 17 f0       	add    $0xf0179540,%eax
f01014c0:	8b 00                	mov    (%eax),%eax
f01014c2:	83 ec 04             	sub    $0x4,%esp
f01014c5:	51                   	push   %ecx
f01014c6:	50                   	push   %eax
f01014c7:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01014cd:	50                   	push   %eax
f01014ce:	e8 a4 f1 01 00       	call   f0120677 <strncmp>
f01014d3:	83 c4 10             	add    $0x10,%esp
f01014d6:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f01014d9:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f01014dd:	0f 85 c4 00 00 00    	jne    f01015a7 <command_prompt_readline+0x44f>
							it_str = -1;
f01014e3:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f01014ea:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01014f1:	00 00 00 
f01014f4:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01014fa:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01014ff:	b8 00 00 00 00       	mov    $0x0,%eax
f0101504:	89 d7                	mov    %edx,%edi
f0101506:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f0101508:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010150f:	eb 2d                	jmp    f010153e <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f0101511:	ff 45 dc             	incl   -0x24(%ebp)
f0101514:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101517:	89 d0                	mov    %edx,%eax
f0101519:	01 c0                	add    %eax,%eax
f010151b:	01 d0                	add    %edx,%eax
f010151d:	c1 e0 03             	shl    $0x3,%eax
f0101520:	05 40 95 17 f0       	add    $0xf0179540,%eax
f0101525:	8b 10                	mov    (%eax),%edx
f0101527:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010152a:	01 d0                	add    %edx,%eax
f010152c:	8a 00                	mov    (%eax),%al
f010152e:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101534:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0101537:	01 ca                	add    %ecx,%edx
f0101539:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f010153b:	ff 45 cc             	incl   -0x34(%ebp)
f010153e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0101541:	89 d0                	mov    %edx,%eax
f0101543:	01 c0                	add    %eax,%eax
f0101545:	01 d0                	add    %edx,%eax
f0101547:	c1 e0 03             	shl    $0x3,%eax
f010154a:	05 40 95 17 f0       	add    $0xf0179540,%eax
f010154f:	8b 00                	mov    (%eax),%eax
f0101551:	83 ec 0c             	sub    $0xc,%esp
f0101554:	50                   	push   %eax
f0101555:	e8 d9 ef 01 00       	call   f0120533 <strlen>
f010155a:	83 c4 10             	add    $0x10,%esp
f010155d:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0101560:	7f af                	jg     f0101511 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0101562:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101565:	c1 e0 0a             	shl    $0xa,%eax
f0101568:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f010156d:	83 ec 04             	sub    $0x4,%esp
f0101570:	68 00 04 00 00       	push   $0x400
f0101575:	6a 00                	push   $0x0
f0101577:	50                   	push   %eax
f0101578:	e8 a4 f1 01 00       	call   f0120721 <memset>
f010157d:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101580:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101583:	40                   	inc    %eax
f0101584:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0101587:	c1 e2 0a             	shl    $0xa,%edx
f010158a:	81 c2 a0 52 55 f0    	add    $0xf05552a0,%edx
f0101590:	83 ec 04             	sub    $0x4,%esp
f0101593:	50                   	push   %eax
f0101594:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010159a:	50                   	push   %eax
f010159b:	52                   	push   %edx
f010159c:	e8 0f f0 01 00       	call   f01205b0 <strncpy>
f01015a1:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f01015a4:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f01015a7:	ff 45 d0             	incl   -0x30(%ebp)
f01015aa:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01015ad:	a1 48 99 17 f0       	mov    0xf0179948,%eax
f01015b2:	39 c2                	cmp    %eax,%edx
f01015b4:	0f 82 e1 fe ff ff    	jb     f010149b <command_prompt_readline+0x343>
f01015ba:	e9 fe 02 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f01015bf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01015c3:	0f 84 7b 01 00 00    	je     f0101744 <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01015c9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f01015d0:	e9 5c 01 00 00       	jmp    f0101731 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f01015d5:	83 ec 0c             	sub    $0xc,%esp
f01015d8:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01015de:	50                   	push   %eax
f01015df:	e8 4f ef 01 00       	call   f0120533 <strlen>
f01015e4:	83 c4 10             	add    $0x10,%esp
f01015e7:	89 c1                	mov    %eax,%ecx
f01015e9:	8b 1d a4 9c 17 f0    	mov    0xf0179ca4,%ebx
f01015ef:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01015f2:	89 d0                	mov    %edx,%eax
f01015f4:	01 c0                	add    %eax,%eax
f01015f6:	01 d0                	add    %edx,%eax
f01015f8:	c1 e0 02             	shl    $0x2,%eax
f01015fb:	01 d8                	add    %ebx,%eax
f01015fd:	8b 00                	mov    (%eax),%eax
f01015ff:	83 ec 04             	sub    $0x4,%esp
f0101602:	51                   	push   %ecx
f0101603:	50                   	push   %eax
f0101604:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010160a:	50                   	push   %eax
f010160b:	e8 67 f0 01 00       	call   f0120677 <strncmp>
f0101610:	83 c4 10             	add    $0x10,%esp
f0101613:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f0101616:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f010161a:	0f 85 0e 01 00 00    	jne    f010172e <command_prompt_readline+0x5d6>
								it_str = -1;
f0101620:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0101627:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f010162e:	00 00 00 
f0101631:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0101637:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010163c:	b8 00 00 00 00       	mov    $0x0,%eax
f0101641:	89 d7                	mov    %edx,%edi
f0101643:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0101645:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010164b:	83 f8 01             	cmp    $0x1,%eax
f010164e:	7e 39                	jle    f0101689 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101650:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0101657:	eb 1d                	jmp    f0101676 <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0101659:	ff 45 dc             	incl   -0x24(%ebp)
f010165c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010165f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101662:	01 d0                	add    %edx,%eax
f0101664:	8a 00                	mov    (%eax),%al
f0101666:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010166c:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010166f:	01 ca                	add    %ecx,%edx
f0101671:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0101673:	ff 45 c4             	incl   -0x3c(%ebp)
f0101676:	83 ec 0c             	sub    $0xc,%esp
f0101679:	ff 75 0c             	pushl  0xc(%ebp)
f010167c:	e8 b2 ee 01 00       	call   f0120533 <strlen>
f0101681:	83 c4 10             	add    $0x10,%esp
f0101684:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0101687:	7f d0                	jg     f0101659 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0101689:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0101690:	eb 30                	jmp    f01016c2 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0101692:	ff 45 dc             	incl   -0x24(%ebp)
f0101695:	8b 0d a4 9c 17 f0    	mov    0xf0179ca4,%ecx
f010169b:	8b 55 c8             	mov    -0x38(%ebp),%edx
f010169e:	89 d0                	mov    %edx,%eax
f01016a0:	01 c0                	add    %eax,%eax
f01016a2:	01 d0                	add    %edx,%eax
f01016a4:	c1 e0 02             	shl    $0x2,%eax
f01016a7:	01 c8                	add    %ecx,%eax
f01016a9:	8b 10                	mov    (%eax),%edx
f01016ab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01016ae:	01 d0                	add    %edx,%eax
f01016b0:	8a 00                	mov    (%eax),%al
f01016b2:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01016b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01016bb:	01 ca                	add    %ecx,%edx
f01016bd:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f01016bf:	ff 45 c0             	incl   -0x40(%ebp)
f01016c2:	8b 0d a4 9c 17 f0    	mov    0xf0179ca4,%ecx
f01016c8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01016cb:	89 d0                	mov    %edx,%eax
f01016cd:	01 c0                	add    %eax,%eax
f01016cf:	01 d0                	add    %edx,%eax
f01016d1:	c1 e0 02             	shl    $0x2,%eax
f01016d4:	01 c8                	add    %ecx,%eax
f01016d6:	8b 00                	mov    (%eax),%eax
f01016d8:	83 ec 0c             	sub    $0xc,%esp
f01016db:	50                   	push   %eax
f01016dc:	e8 52 ee 01 00       	call   f0120533 <strlen>
f01016e1:	83 c4 10             	add    $0x10,%esp
f01016e4:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f01016e7:	7f a9                	jg     f0101692 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f01016e9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01016ec:	c1 e0 0a             	shl    $0xa,%eax
f01016ef:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f01016f4:	83 ec 04             	sub    $0x4,%esp
f01016f7:	68 00 04 00 00       	push   $0x400
f01016fc:	6a 00                	push   $0x0
f01016fe:	50                   	push   %eax
f01016ff:	e8 1d f0 01 00       	call   f0120721 <memset>
f0101704:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101707:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010170a:	40                   	inc    %eax
f010170b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010170e:	c1 e2 0a             	shl    $0xa,%edx
f0101711:	81 c2 a0 52 55 f0    	add    $0xf05552a0,%edx
f0101717:	83 ec 04             	sub    $0x4,%esp
f010171a:	50                   	push   %eax
f010171b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0101721:	50                   	push   %eax
f0101722:	52                   	push   %edx
f0101723:	e8 88 ee 01 00       	call   f01205b0 <strncpy>
f0101728:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f010172b:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f010172e:	ff 45 c8             	incl   -0x38(%ebp)
f0101731:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f0101736:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f0101739:	0f 8c 96 fe ff ff    	jl     f01015d5 <command_prompt_readline+0x47d>
f010173f:	e9 79 01 00 00       	jmp    f01018bd <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f0101744:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0101748:	0f 84 6f 01 00 00    	je     f01018bd <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f010174e:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0101755:	e9 53 01 00 00       	jmp    f01018ad <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f010175a:	83 ec 0c             	sub    $0xc,%esp
f010175d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0101763:	50                   	push   %eax
f0101764:	e8 ca ed 01 00       	call   f0120533 <strlen>
f0101769:	83 c4 10             	add    $0x10,%esp
f010176c:	89 c1                	mov    %eax,%ecx
f010176e:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101771:	89 d0                	mov    %edx,%eax
f0101773:	01 c0                	add    %eax,%eax
f0101775:	01 d0                	add    %edx,%eax
f0101777:	c1 e0 02             	shl    $0x2,%eax
f010177a:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f010177f:	8b 00                	mov    (%eax),%eax
f0101781:	83 ec 04             	sub    $0x4,%esp
f0101784:	51                   	push   %ecx
f0101785:	50                   	push   %eax
f0101786:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010178c:	50                   	push   %eax
f010178d:	e8 e5 ee 01 00       	call   f0120677 <strncmp>
f0101792:	83 c4 10             	add    $0x10,%esp
f0101795:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f0101798:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f010179c:	0f 85 08 01 00 00    	jne    f01018aa <command_prompt_readline+0x752>
								it_str = -1;
f01017a2:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01017a9:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01017b0:	00 00 00 
f01017b3:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01017b9:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01017be:	b8 00 00 00 00       	mov    $0x0,%eax
f01017c3:	89 d7                	mov    %edx,%edi
f01017c5:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01017c7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01017cd:	83 f8 01             	cmp    $0x1,%eax
f01017d0:	7e 39                	jle    f010180b <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017d2:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01017d9:	eb 1d                	jmp    f01017f8 <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f01017db:	ff 45 dc             	incl   -0x24(%ebp)
f01017de:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01017e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01017e4:	01 d0                	add    %edx,%eax
f01017e6:	8a 00                	mov    (%eax),%al
f01017e8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01017ee:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01017f1:	01 ca                	add    %ecx,%edx
f01017f3:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01017f5:	ff 45 b8             	incl   -0x48(%ebp)
f01017f8:	83 ec 0c             	sub    $0xc,%esp
f01017fb:	ff 75 0c             	pushl  0xc(%ebp)
f01017fe:	e8 30 ed 01 00       	call   f0120533 <strlen>
f0101803:	83 c4 10             	add    $0x10,%esp
f0101806:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0101809:	7f d0                	jg     f01017db <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010180b:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0101812:	eb 2d                	jmp    f0101841 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0101814:	ff 45 dc             	incl   -0x24(%ebp)
f0101817:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010181a:	89 d0                	mov    %edx,%eax
f010181c:	01 c0                	add    %eax,%eax
f010181e:	01 d0                	add    %edx,%eax
f0101820:	c1 e0 02             	shl    $0x2,%eax
f0101823:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f0101828:	8b 10                	mov    (%eax),%edx
f010182a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010182d:	01 d0                	add    %edx,%eax
f010182f:	8a 00                	mov    (%eax),%al
f0101831:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0101837:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010183a:	01 ca                	add    %ecx,%edx
f010183c:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f010183e:	ff 45 b4             	incl   -0x4c(%ebp)
f0101841:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0101844:	89 d0                	mov    %edx,%eax
f0101846:	01 c0                	add    %eax,%eax
f0101848:	01 d0                	add    %edx,%eax
f010184a:	c1 e0 02             	shl    $0x2,%eax
f010184d:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f0101852:	8b 00                	mov    (%eax),%eax
f0101854:	83 ec 0c             	sub    $0xc,%esp
f0101857:	50                   	push   %eax
f0101858:	e8 d6 ec 01 00       	call   f0120533 <strlen>
f010185d:	83 c4 10             	add    $0x10,%esp
f0101860:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0101863:	7f af                	jg     f0101814 <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0101865:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101868:	c1 e0 0a             	shl    $0xa,%eax
f010186b:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f0101870:	83 ec 04             	sub    $0x4,%esp
f0101873:	68 00 04 00 00       	push   $0x400
f0101878:	6a 00                	push   $0x0
f010187a:	50                   	push   %eax
f010187b:	e8 a1 ee 01 00       	call   f0120721 <memset>
f0101880:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0101883:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0101886:	40                   	inc    %eax
f0101887:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010188a:	c1 e2 0a             	shl    $0xa,%edx
f010188d:	81 c2 a0 52 55 f0    	add    $0xf05552a0,%edx
f0101893:	83 ec 04             	sub    $0x4,%esp
f0101896:	50                   	push   %eax
f0101897:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f010189d:	50                   	push   %eax
f010189e:	52                   	push   %edx
f010189f:	e8 0c ed 01 00       	call   f01205b0 <strncpy>
f01018a4:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01018a7:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01018aa:	ff 45 bc             	incl   -0x44(%ebp)
f01018ad:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01018b0:	a1 74 9d 17 f0       	mov    0xf0179d74,%eax
f01018b5:	39 c2                	cmp    %eax,%edx
f01018b7:	0f 82 9d fe ff ff    	jb     f010175a <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f01018bd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01018c0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f01018c3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01018c7:	0f 84 a6 03 00 00    	je     f0101c73 <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f01018cd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01018d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018da:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f01018e1:	eb 1f                	jmp    f0101902 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f01018e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01018e6:	8d 50 01             	lea    0x1(%eax),%edx
f01018e9:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01018ec:	89 c2                	mov    %eax,%edx
f01018ee:	8b 45 0c             	mov    0xc(%ebp),%eax
f01018f1:	01 c2                	add    %eax,%edx
f01018f3:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01018f6:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f01018fb:	8a 00                	mov    (%eax),%al
f01018fd:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f01018ff:	ff 45 b0             	incl   -0x50(%ebp)
f0101902:	83 ec 0c             	sub    $0xc,%esp
f0101905:	68 a0 52 55 f0       	push   $0xf05552a0
f010190a:	e8 24 ec 01 00       	call   f0120533 <strlen>
f010190f:	83 c4 10             	add    $0x10,%esp
f0101912:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0101915:	7f cc                	jg     f01018e3 <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0101917:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f010191e:	eb 10                	jmp    f0101930 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0101920:	83 ec 0c             	sub    $0xc,%esp
f0101923:	6a 08                	push   $0x8
f0101925:	e8 1f f5 ff ff       	call   f0100e49 <cputchar>
f010192a:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f010192d:	ff 45 ac             	incl   -0x54(%ebp)
f0101930:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0101933:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0101936:	7c e8                	jl     f0101920 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0101938:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f010193f:	eb 1c                	jmp    f010195d <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0101941:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0101944:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101947:	01 d0                	add    %edx,%eax
f0101949:	8a 00                	mov    (%eax),%al
f010194b:	0f be c0             	movsbl %al,%eax
f010194e:	83 ec 0c             	sub    $0xc,%esp
f0101951:	50                   	push   %eax
f0101952:	e8 f2 f4 ff ff       	call   f0100e49 <cputchar>
f0101957:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f010195a:	ff 45 a8             	incl   -0x58(%ebp)
f010195d:	83 ec 0c             	sub    $0xc,%esp
f0101960:	ff 75 0c             	pushl  0xc(%ebp)
f0101963:	e8 cb eb 01 00       	call   f0120533 <strlen>
f0101968:	83 c4 10             	add    $0x10,%esp
f010196b:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f010196e:	7f d1                	jg     f0101941 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0101970:	83 ec 0c             	sub    $0xc,%esp
f0101973:	ff 75 0c             	pushl  0xc(%ebp)
f0101976:	e8 b8 eb 01 00       	call   f0120533 <strlen>
f010197b:	83 c4 10             	add    $0x10,%esp
f010197e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101984:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010198a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101990:	e9 de 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0101995:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0101999:	0f 8e d4 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
f010199f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019a2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f01019a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019ab:	40                   	inc    %eax
f01019ac:	99                   	cltd   
f01019ad:	f7 7d ec             	idivl  -0x14(%ebp)
f01019b0:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f01019b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01019b6:	c1 e0 0a             	shl    $0xa,%eax
f01019b9:	8d 98 a0 52 55 f0    	lea    -0xfaaad60(%eax),%ebx
f01019bf:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f01019c5:	c1 e0 0a             	shl    $0xa,%eax
f01019c8:	05 a0 52 55 f0       	add    $0xf05552a0,%eax
f01019cd:	83 ec 0c             	sub    $0xc,%esp
f01019d0:	50                   	push   %eax
f01019d1:	e8 5d eb 01 00       	call   f0120533 <strlen>
f01019d6:	83 c4 10             	add    $0x10,%esp
f01019d9:	83 ec 0c             	sub    $0xc,%esp
f01019dc:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f01019e2:	52                   	push   %edx
f01019e3:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f01019e9:	52                   	push   %edx
f01019ea:	ff 75 0c             	pushl  0xc(%ebp)
f01019ed:	53                   	push   %ebx
f01019ee:	50                   	push   %eax
f01019ef:	e8 75 f6 ff ff       	call   f0101069 <RoundAutoCompleteCommandWithTheSamePrefix>
f01019f4:	83 c4 20             	add    $0x20,%esp
f01019f7:	e9 77 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f01019fc:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101a03:	75 2e                	jne    f0101a33 <command_prompt_readline+0x8db>
			if (i > 0) {
f0101a05:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a0b:	85 c0                	test   %eax,%eax
f0101a0d:	0f 8e 60 02 00 00    	jle    f0101c73 <command_prompt_readline+0xb1b>
				i--;
f0101a13:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a19:	48                   	dec    %eax
f0101a1a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a20:	83 ec 0c             	sub    $0xc,%esp
f0101a23:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a26:	e8 1e f4 ff ff       	call   f0100e49 <cputchar>
f0101a2b:	83 c4 10             	add    $0x10,%esp
f0101a2e:	e9 40 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0101a33:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101a3a:	75 34                	jne    f0101a70 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0101a3c:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0101a42:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101a48:	39 c2                	cmp    %eax,%edx
f0101a4a:	0f 8d 23 02 00 00    	jge    f0101c73 <command_prompt_readline+0xb1b>
				i++;
f0101a50:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a56:	40                   	inc    %eax
f0101a57:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0101a5d:	83 ec 0c             	sub    $0xc,%esp
f0101a60:	ff 75 94             	pushl  -0x6c(%ebp)
f0101a63:	e8 e1 f3 ff ff       	call   f0100e49 <cputchar>
f0101a68:	83 c4 10             	add    $0x10,%esp
f0101a6b:	e9 03 02 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0101a70:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0101a77:	75 4c                	jne    f0101ac5 <command_prompt_readline+0x96d>
f0101a79:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a7f:	85 c0                	test   %eax,%eax
f0101a81:	7e 42                	jle    f0101ac5 <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0101a83:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101a89:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0101a8c:	eb 1a                	jmp    f0101aa8 <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0101a8e:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0101a91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a94:	01 c2                	add    %eax,%edx
f0101a96:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0101a99:	8d 48 01             	lea    0x1(%eax),%ecx
f0101a9c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101a9f:	01 c8                	add    %ecx,%eax
f0101aa1:	8a 00                	mov    (%eax),%al
f0101aa3:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0101aa5:	ff 45 a4             	incl   -0x5c(%ebp)
f0101aa8:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101aae:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0101ab1:	7e db                	jle    f0101a8e <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0101ab3:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101ab9:	48                   	dec    %eax
f0101aba:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101ac0:	e9 ae 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0101ac5:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0101ac9:	7e 60                	jle    f0101b2b <command_prompt_readline+0x9d3>
f0101acb:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101ad1:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0101ad6:	7f 53                	jg     f0101b2b <command_prompt_readline+0x9d3>
f0101ad8:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0101adf:	74 4a                	je     f0101b2b <command_prompt_readline+0x9d3>
f0101ae1:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0101ae8:	74 41                	je     f0101b2b <command_prompt_readline+0x9d3>
			if (echoing)
f0101aea:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101aee:	74 0e                	je     f0101afe <command_prompt_readline+0x9a6>
				cputchar(c);
f0101af0:	83 ec 0c             	sub    $0xc,%esp
f0101af3:	ff 75 94             	pushl  -0x6c(%ebp)
f0101af6:	e8 4e f3 ff ff       	call   f0100e49 <cputchar>
f0101afb:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0101afe:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b04:	8d 50 01             	lea    0x1(%eax),%edx
f0101b07:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0101b0d:	89 c2                	mov    %eax,%edx
f0101b0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b12:	01 d0                	add    %edx,%eax
f0101b14:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0101b17:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0101b19:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101b1f:	40                   	inc    %eax
f0101b20:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0101b26:	e9 48 01 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0101b2b:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0101b2f:	75 60                	jne    f0101b91 <command_prompt_readline+0xa39>
f0101b31:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b37:	85 c0                	test   %eax,%eax
f0101b39:	7e 56                	jle    f0101b91 <command_prompt_readline+0xa39>

			if (echoing)
f0101b3b:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101b3f:	74 0e                	je     f0101b4f <command_prompt_readline+0x9f7>
				cputchar(c);
f0101b41:	83 ec 0c             	sub    $0xc,%esp
f0101b44:	ff 75 94             	pushl  -0x6c(%ebp)
f0101b47:	e8 fd f2 ff ff       	call   f0100e49 <cputchar>
f0101b4c:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0101b4f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b55:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0101b58:	eb 1a                	jmp    f0101b74 <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0101b5a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0101b5d:	8d 50 ff             	lea    -0x1(%eax),%edx
f0101b60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b63:	01 c2                	add    %eax,%edx
f0101b65:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0101b68:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101b6b:	01 c8                	add    %ecx,%eax
f0101b6d:	8a 00                	mov    (%eax),%al
f0101b6f:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0101b71:	ff 45 a0             	incl   -0x60(%ebp)
f0101b74:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b7a:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0101b7d:	7e db                	jle    f0101b5a <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0101b7f:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0101b85:	48                   	dec    %eax
f0101b86:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0101b8c:	e9 e2 00 00 00       	jmp    f0101c73 <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0101b91:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0101b95:	74 0a                	je     f0101ba1 <command_prompt_readline+0xa49>
f0101b97:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0101b9b:	0f 85 d2 00 00 00    	jne    f0101c73 <command_prompt_readline+0xb1b>

			if (echoing)
f0101ba1:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0101ba5:	74 0e                	je     f0101bb5 <command_prompt_readline+0xa5d>
				cputchar(c);
f0101ba7:	83 ec 0c             	sub    $0xc,%esp
f0101baa:	ff 75 94             	pushl  -0x6c(%ebp)
f0101bad:	e8 97 f2 ff ff       	call   f0100e49 <cputchar>
f0101bb2:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0101bb5:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0101bbb:	89 c2                	mov    %eax,%edx
f0101bbd:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101bc0:	01 d0                	add    %edx,%eax
f0101bc2:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0101bc5:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101bca:	83 f8 13             	cmp    $0x13,%eax
f0101bcd:	75 56                	jne    f0101c25 <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101bcf:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0101bd6:	eb 2d                	jmp    f0101c05 <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0101bd8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101bdb:	40                   	inc    %eax
f0101bdc:	c1 e0 0a             	shl    $0xa,%eax
f0101bdf:	8d 90 a0 e2 56 f0    	lea    -0xfa91d60(%eax),%edx
f0101be5:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0101be8:	c1 e0 0a             	shl    $0xa,%eax
f0101beb:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101bf0:	83 ec 04             	sub    $0x4,%esp
f0101bf3:	68 00 04 00 00       	push   $0x400
f0101bf8:	52                   	push   %edx
f0101bf9:	50                   	push   %eax
f0101bfa:	e8 52 eb 01 00       	call   f0120751 <memcpy>
f0101bff:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0101c02:	ff 45 9c             	incl   -0x64(%ebp)
f0101c05:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0101c09:	7e cd                	jle    f0101bd8 <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0101c0b:	83 ec 04             	sub    $0x4,%esp
f0101c0e:	68 00 04 00 00       	push   $0x400
f0101c13:	ff 75 0c             	pushl  0xc(%ebp)
f0101c16:	68 a0 2e 57 f0       	push   $0xf0572ea0
f0101c1b:	e8 31 eb 01 00       	call   f0120751 <memcpy>
f0101c20:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c23:	eb 68                	jmp    f0101c8d <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0101c25:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101c2a:	c1 e0 0a             	shl    $0xa,%eax
f0101c2d:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101c32:	83 ec 08             	sub    $0x8,%esp
f0101c35:	ff 75 0c             	pushl  0xc(%ebp)
f0101c38:	50                   	push   %eax
f0101c39:	e8 01 ea 01 00       	call   f012063f <strcmp>
f0101c3e:	83 c4 10             	add    $0x10,%esp
f0101c41:	85 c0                	test   %eax,%eax
f0101c43:	74 48                	je     f0101c8d <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0101c45:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101c4a:	40                   	inc    %eax
f0101c4b:	a3 30 95 17 f0       	mov    %eax,0xf0179530
f0101c50:	a1 30 95 17 f0       	mov    0xf0179530,%eax
f0101c55:	c1 e0 0a             	shl    $0xa,%eax
f0101c58:	05 a0 e2 56 f0       	add    $0xf056e2a0,%eax
f0101c5d:	83 ec 04             	sub    $0x4,%esp
f0101c60:	68 00 04 00 00       	push   $0x400
f0101c65:	ff 75 0c             	pushl  0xc(%ebp)
f0101c68:	50                   	push   %eax
f0101c69:	e8 e3 ea 01 00       	call   f0120751 <memcpy>
f0101c6e:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0101c71:	eb 1a                	jmp    f0101c8d <command_prompt_readline+0xb35>

		}
		last_c = c;
f0101c73:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0101c76:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101c79:	e9 44 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0101c7e:	90                   	nop
f0101c7f:	e9 3e f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0101c84:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0101c85:	e9 38 f5 ff ff       	jmp    f01011c2 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0101c8a:	90                   	nop
f0101c8b:	eb 01                	jmp    f0101c8e <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0101c8d:	90                   	nop

		}
		last_c = c;
	}
}
f0101c8e:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0101c91:	5b                   	pop    %ebx
f0101c92:	5f                   	pop    %edi
f0101c93:	5d                   	pop    %ebp
f0101c94:	c3                   	ret    

f0101c95 <run_command_prompt>:
// ******************************************************************
// ******************************************************************

extern bool autograde ;
void run_command_prompt()
{
f0101c95:	55                   	push   %ebp
f0101c96:	89 e5                	mov    %esp,%ebp
f0101c98:	57                   	push   %edi
f0101c99:	56                   	push   %esi
f0101c9a:	53                   	push   %ebx
f0101c9b:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (autograde)
f0101ca1:	a1 dc 51 55 f0       	mov    0xf05551dc,%eax
f0101ca6:	85 c0                	test   %eax,%eax
f0101ca8:	0f 84 85 00 00 00    	je     f0101d33 <run_command_prompt+0x9e>
	{
		char cmd1_2[BUFLEN] = "tst bsd_nice 0";
f0101cae:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cb4:	bb f7 1a 12 f0       	mov    $0xf0121af7,%ebx
f0101cb9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101cbe:	89 c7                	mov    %eax,%edi
f0101cc0:	89 de                	mov    %ebx,%esi
f0101cc2:	89 d1                	mov    %edx,%ecx
f0101cc4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cc6:	8d 95 f7 ef ff ff    	lea    -0x1009(%ebp),%edx
f0101ccc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cd1:	b0 00                	mov    $0x0,%al
f0101cd3:	89 d7                	mov    %edx,%edi
f0101cd5:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd2_2[BUFLEN] = "tst bsd_nice 1";
f0101cd7:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101cdd:	bb f7 1e 12 f0       	mov    $0xf0121ef7,%ebx
f0101ce2:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101ce7:	89 c7                	mov    %eax,%edi
f0101ce9:	89 de                	mov    %ebx,%esi
f0101ceb:	89 d1                	mov    %edx,%ecx
f0101ced:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101cef:	8d 95 f7 f3 ff ff    	lea    -0xc09(%ebp),%edx
f0101cf5:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101cfa:	b0 00                	mov    $0x0,%al
f0101cfc:	89 d7                	mov    %edx,%edi
f0101cfe:	f3 aa                	rep stos %al,%es:(%edi)
		char cmd3_2[BUFLEN] = "tst bsd_nice 2";
f0101d00:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d06:	bb f7 22 12 f0       	mov    $0xf01222f7,%ebx
f0101d0b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0101d10:	89 c7                	mov    %eax,%edi
f0101d12:	89 de                	mov    %ebx,%esi
f0101d14:	89 d1                	mov    %edx,%ecx
f0101d16:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d18:	8d 95 f7 f7 ff ff    	lea    -0x809(%ebp),%edx
f0101d1e:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0101d23:	b0 00                	mov    $0x0,%al
f0101d25:	89 d7                	mov    %edx,%edi
f0101d27:	f3 aa                	rep stos %al,%es:(%edi)
		//execute_command(cmd3_2);
		autograde = 0;
f0101d29:	c7 05 dc 51 55 f0 00 	movl   $0x0,0xf05551dc
f0101d30:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d33:	c7 05 6c 51 55 f0 00 	movl   $0x0,0xf055516c
f0101d3a:	00 00 00 
f0101d3d:	c7 05 70 51 55 f0 00 	movl   $0x0,0xf0555170
f0101d44:	00 00 00 
f0101d47:	c7 05 78 51 55 f0 00 	movl   $0x0,0xf0555178
f0101d4e:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d51:	83 ec 04             	sub    $0x4,%esp
f0101d54:	68 00 04 00 00       	push   $0x400
f0101d59:	6a 00                	push   $0x0
f0101d5b:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d61:	50                   	push   %eax
f0101d62:	e8 ba e9 01 00       	call   f0120721 <memset>
f0101d67:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101d6a:	83 ec 08             	sub    $0x8,%esp
f0101d6d:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d73:	50                   	push   %eax
f0101d74:	68 f1 1a 12 f0       	push   $0xf0121af1
f0101d79:	e8 da f3 ff ff       	call   f0101158 <command_prompt_readline>
f0101d7e:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101d81:	83 ec 0c             	sub    $0xc,%esp
f0101d84:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101d8a:	50                   	push   %eax
f0101d8b:	e8 4c 01 00 00       	call   f0101edc <execute_command>
f0101d90:	83 c4 10             	add    $0x10,%esp
f0101d93:	85 c0                	test   %eax,%eax
f0101d95:	78 02                	js     f0101d99 <run_command_prompt+0x104>
				break;
	}
f0101d97:	eb b8                	jmp    f0101d51 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101d99:	90                   	nop
	}
}
f0101d9a:	90                   	nop
f0101d9b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101d9e:	5b                   	pop    %ebx
f0101d9f:	5e                   	pop    %esi
f0101da0:	5f                   	pop    %edi
f0101da1:	5d                   	pop    %ebp
f0101da2:	c3                   	ret    

f0101da3 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101da3:	55                   	push   %ebp
f0101da4:	89 e5                	mov    %esp,%ebp
f0101da6:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101da9:	9c                   	pushf  
f0101daa:	58                   	pop    %eax
f0101dab:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101dae:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101db1:	25 00 02 00 00       	and    $0x200,%eax
f0101db6:	85 c0                	test   %eax,%eax
f0101db8:	74 01                	je     f0101dbb <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101dba:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dbb:	e8 4a 89 00 00       	call   f010a70a <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101dc0:	e8 39 50 00 00       	call   f0106dfe <mycpu>
f0101dc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101dc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dcb:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101dd2:	00 00 00 
		c->intena = 0;
f0101dd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dd8:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101ddf:	00 00 00 
		c->scheduler = NULL;
f0101de2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101de5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101dec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101def:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101df6:	00 00 00 
		c->proc = NULL;
f0101df9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101dfc:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e03:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e06:	89 e0                	mov    %esp,%eax
f0101e08:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e0b:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e0e:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e11:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e14:	8b 40 08             	mov    0x8(%eax),%eax
f0101e17:	05 00 80 00 00       	add    $0x8000,%eax
f0101e1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e22:	8b 40 08             	mov    0x8(%eax),%eax
f0101e25:	05 00 10 00 00       	add    $0x1000,%eax
f0101e2a:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e2d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e30:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e33:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e36:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e38:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e3b:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e3e:	73 44                	jae    f0101e84 <get_into_prompt+0xe1>
f0101e40:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e43:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e46:	72 3c                	jb     f0101e84 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e48:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e4b:	a3 80 52 55 f0       	mov    %eax,0xf0555280
			m = cpuStackTop - cur_esp;
f0101e50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e53:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e56:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
			while (--m >= 0)
f0101e5b:	eb 11                	jmp    f0101e6e <get_into_prompt+0xcb>
				*p++ = 0;
f0101e5d:	a1 80 52 55 f0       	mov    0xf0555280,%eax
f0101e62:	8d 50 01             	lea    0x1(%eax),%edx
f0101e65:	89 15 80 52 55 f0    	mov    %edx,0xf0555280
f0101e6b:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101e6e:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101e73:	48                   	dec    %eax
f0101e74:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
f0101e79:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101e7e:	85 c0                	test   %eax,%eax
f0101e80:	79 db                	jns    f0101e5d <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e82:	eb 3a                	jmp    f0101ebe <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101e84:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101e87:	a3 80 52 55 f0       	mov    %eax,0xf0555280
			m = cpuStackTop - cpuStackBottom;
f0101e8c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e8f:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101e92:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
			while (--m >= 0)
f0101e97:	eb 11                	jmp    f0101eaa <get_into_prompt+0x107>
				*p++ = 0;
f0101e99:	a1 80 52 55 f0       	mov    0xf0555280,%eax
f0101e9e:	8d 50 01             	lea    0x1(%eax),%edx
f0101ea1:	89 15 80 52 55 f0    	mov    %edx,0xf0555280
f0101ea7:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101eaa:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101eaf:	48                   	dec    %eax
f0101eb0:	a3 a0 32 57 f0       	mov    %eax,0xf05732a0
f0101eb5:	a1 a0 32 57 f0       	mov    0xf05732a0,%eax
f0101eba:	85 c0                	test   %eax,%eax
f0101ebc:	79 db                	jns    f0101e99 <get_into_prompt+0xf6>
f0101ebe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101ec5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101ec8:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101eca:	83 ec 0c             	sub    $0xc,%esp
f0101ecd:	6a 00                	push   $0x0
f0101ecf:	e8 c1 fd ff ff       	call   f0101c95 <run_command_prompt>
f0101ed4:	83 c4 10             	add    $0x10,%esp
	}
f0101ed7:	e9 cd fe ff ff       	jmp    f0101da9 <get_into_prompt+0x6>

f0101edc <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101edc:	55                   	push   %ebp
f0101edd:	89 e5                	mov    %esp,%ebp
f0101edf:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101ee2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101ee5:	50                   	push   %eax
f0101ee6:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101ee9:	50                   	push   %eax
f0101eea:	68 df 1a 12 f0       	push   $0xf0121adf
f0101eef:	ff 75 08             	pushl  0x8(%ebp)
f0101ef2:	e8 51 ec 01 00       	call   f0120b48 <strsplit>
f0101ef7:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101efa:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101efd:	85 c0                	test   %eax,%eax
f0101eff:	75 0a                	jne    f0101f0b <execute_command+0x2f>
		return 0;
f0101f01:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f06:	e9 a4 02 00 00       	jmp    f01021af <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f0b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f0e:	83 ec 08             	sub    $0x8,%esp
f0101f11:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f14:	52                   	push   %edx
f0101f15:	50                   	push   %eax
f0101f16:	e8 96 02 00 00       	call   f01021b1 <process_command>
f0101f1b:	83 c4 10             	add    $0x10,%esp
f0101f1e:	89 45 e0             	mov    %eax,-0x20(%ebp)

	//cprintf("cmd %s, num of args %d, return %d\n", arguments[0], number_of_arguments, ret);

	if (ret == CMD_INVALID)
f0101f21:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f25:	75 19                	jne    f0101f40 <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f27:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f2a:	83 ec 08             	sub    $0x8,%esp
f0101f2d:	50                   	push   %eax
f0101f2e:	68 f7 26 12 f0       	push   $0xf01226f7
f0101f33:	e8 34 f0 ff ff       	call   f0100f6c <cprintf>
f0101f38:	83 c4 10             	add    $0x10,%esp
f0101f3b:	e9 6a 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f40:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f44:	75 4f                	jne    f0101f95 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f46:	a1 78 51 55 f0       	mov    0xf0555178,%eax
f0101f4b:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f4e:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f52:	74 17                	je     f0101f6b <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f54:	83 ec 04             	sub    $0x4,%esp
f0101f57:	68 10 27 12 f0       	push   $0xf0122710
f0101f5c:	68 8b 01 00 00       	push   $0x18b
f0101f61:	68 61 27 12 f0       	push   $0xf0122761
f0101f66:	e8 af e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101f6b:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f0101f70:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101f73:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f76:	8b 50 04             	mov    0x4(%eax),%edx
f0101f79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101f7c:	8b 00                	mov    (%eax),%eax
f0101f7e:	83 ec 04             	sub    $0x4,%esp
f0101f81:	52                   	push   %edx
f0101f82:	50                   	push   %eax
f0101f83:	68 7c 27 12 f0       	push   $0xf012277c
f0101f88:	e8 df ef ff ff       	call   f0100f6c <cprintf>
f0101f8d:	83 c4 10             	add    $0x10,%esp
f0101f90:	e9 15 02 00 00       	jmp    f01021aa <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101f95:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101f99:	0f 85 e6 01 00 00    	jne    f0102185 <execute_command+0x2a9>
	{
		int i = 1;
f0101f9f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fa6:	a1 78 51 55 f0       	mov    0xf0555178,%eax
f0101fab:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fae:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101fb2:	75 17                	jne    f0101fcb <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101fb4:	83 ec 04             	sub    $0x4,%esp
f0101fb7:	68 ac 27 12 f0       	push   $0xf01227ac
f0101fbc:	68 96 01 00 00       	push   $0x196
f0101fc1:	68 61 27 12 f0       	push   $0xf0122761
f0101fc6:	e8 4f e3 ff ff       	call   f010031a <_panic>
		}
		struct Command * cmd = NULL;
f0101fcb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0101fd2:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f0101fd7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0101fda:	eb 28                	jmp    f0102004 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f0101fdc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101fdf:	8b 10                	mov    (%eax),%edx
f0101fe1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101fe4:	8d 48 01             	lea    0x1(%eax),%ecx
f0101fe7:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0101fea:	83 ec 04             	sub    $0x4,%esp
f0101fed:	52                   	push   %edx
f0101fee:	50                   	push   %eax
f0101fef:	68 d6 27 12 f0       	push   $0xf01227d6
f0101ff4:	e8 73 ef ff ff       	call   f0100f6c <cprintf>
f0101ff9:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f0101ffc:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102001:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102004:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102008:	74 08                	je     f0102012 <execute_command+0x136>
f010200a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010200d:	8b 40 10             	mov    0x10(%eax),%eax
f0102010:	eb 05                	jmp    f0102017 <execute_command+0x13b>
f0102012:	b8 00 00 00 00       	mov    $0x0,%eax
f0102017:	a3 74 51 55 f0       	mov    %eax,0xf0555174
f010201c:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102021:	85 c0                	test   %eax,%eax
f0102023:	75 b7                	jne    f0101fdc <execute_command+0x100>
f0102025:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102029:	75 b1                	jne    f0101fdc <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010202b:	83 ec 08             	sub    $0x8,%esp
f010202e:	ff 75 dc             	pushl  -0x24(%ebp)
f0102031:	68 e0 27 12 f0       	push   $0xf01227e0
f0102036:	e8 31 ef ff ff       	call   f0100f6c <cprintf>
f010203b:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010203e:	e8 1d ee ff ff       	call   f0100e60 <getchar>
f0102043:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102046:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f010204a:	83 ec 0c             	sub    $0xc,%esp
f010204d:	50                   	push   %eax
f010204e:	e8 f6 ed ff ff       	call   f0100e49 <cputchar>
f0102053:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102056:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010205d:	eb 40                	jmp    f010209f <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010205f:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0102062:	89 d0                	mov    %edx,%eax
f0102064:	c1 e0 02             	shl    $0x2,%eax
f0102067:	01 d0                	add    %edx,%eax
f0102069:	01 c0                	add    %eax,%eax
f010206b:	89 c2                	mov    %eax,%edx
f010206d:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102071:	83 e8 30             	sub    $0x30,%eax
f0102074:	01 d0                	add    %edx,%eax
f0102076:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f0102079:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010207d:	7e 2c                	jle    f01020ab <execute_command+0x1cf>
f010207f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102082:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102085:	7f 24                	jg     f01020ab <execute_command+0x1cf>
				break;

			Chose = getchar();
f0102087:	e8 d4 ed ff ff       	call   f0100e60 <getchar>
f010208c:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f010208f:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102093:	83 ec 0c             	sub    $0xc,%esp
f0102096:	50                   	push   %eax
f0102097:	e8 ad ed ff ff       	call   f0100e49 <cputchar>
f010209c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f010209f:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020a3:	7e 06                	jle    f01020ab <execute_command+0x1cf>
f01020a5:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020a9:	7e b4                	jle    f010205f <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ab:	83 ec 0c             	sub    $0xc,%esp
f01020ae:	6a 0a                	push   $0xa
f01020b0:	e8 94 ed ff ff       	call   f0100e49 <cputchar>
f01020b5:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020bc:	0f 8e e8 00 00 00    	jle    f01021aa <execute_command+0x2ce>
f01020c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020c5:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020c8:	0f 8f dc 00 00 00    	jg     f01021aa <execute_command+0x2ce>
		{
			int c = 1;
f01020ce:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f01020d5:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f01020da:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01020dd:	eb 75                	jmp    f0102154 <execute_command+0x278>
			{
				if (c++ == selection)
f01020df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01020e2:	8d 50 01             	lea    0x1(%eax),%edx
f01020e5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f01020e8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01020eb:	75 5f                	jne    f010214c <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f01020ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020f0:	8b 40 0c             	mov    0xc(%eax),%eax
f01020f3:	85 c0                	test   %eax,%eax
f01020f5:	75 31                	jne    f0102128 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f01020f7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01020fa:	8b 00                	mov    (%eax),%eax
f01020fc:	83 ec 08             	sub    $0x8,%esp
f01020ff:	50                   	push   %eax
f0102100:	68 43 28 12 f0       	push   $0xf0122843
f0102105:	e8 62 ee ff ff       	call   f0100f6c <cprintf>
f010210a:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010210d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102110:	8b 40 08             	mov    0x8(%eax),%eax
f0102113:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102116:	83 ec 08             	sub    $0x8,%esp
f0102119:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010211c:	51                   	push   %ecx
f010211d:	52                   	push   %edx
f010211e:	ff d0                	call   *%eax
f0102120:	83 c4 10             	add    $0x10,%esp
f0102123:	e9 87 00 00 00       	jmp    f01021af <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102128:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212b:	8b 50 04             	mov    0x4(%eax),%edx
f010212e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102131:	8b 00                	mov    (%eax),%eax
f0102133:	83 ec 04             	sub    $0x4,%esp
f0102136:	52                   	push   %edx
f0102137:	50                   	push   %eax
f0102138:	68 4c 28 12 f0       	push   $0xf012284c
f010213d:	e8 2a ee ff ff       	call   f0100f6c <cprintf>
f0102142:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102145:	b8 00 00 00 00       	mov    $0x0,%eax
f010214a:	eb 63                	jmp    f01021af <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010214c:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102151:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102154:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102158:	74 08                	je     f0102162 <execute_command+0x286>
f010215a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010215d:	8b 40 10             	mov    0x10(%eax),%eax
f0102160:	eb 05                	jmp    f0102167 <execute_command+0x28b>
f0102162:	b8 00 00 00 00       	mov    $0x0,%eax
f0102167:	a3 74 51 55 f0       	mov    %eax,0xf0555174
f010216c:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0102171:	85 c0                	test   %eax,%eax
f0102173:	0f 85 66 ff ff ff    	jne    f01020df <execute_command+0x203>
f0102179:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010217d:	0f 85 5c ff ff ff    	jne    f01020df <execute_command+0x203>
f0102183:	eb 25                	jmp    f01021aa <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f0102185:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102188:	89 d0                	mov    %edx,%eax
f010218a:	01 c0                	add    %eax,%eax
f010218c:	01 d0                	add    %edx,%eax
f010218e:	c1 e0 03             	shl    $0x3,%eax
f0102191:	05 48 95 17 f0       	add    $0xf0179548,%eax
f0102196:	8b 00                	mov    (%eax),%eax
f0102198:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010219b:	83 ec 08             	sub    $0x8,%esp
f010219e:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021a1:	51                   	push   %ecx
f01021a2:	52                   	push   %edx
f01021a3:	ff d0                	call   *%eax
f01021a5:	83 c4 10             	add    $0x10,%esp
f01021a8:	eb 05                	jmp    f01021af <execute_command+0x2d3>
	}
	return 0;
f01021aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021af:	c9                   	leave  
f01021b0:	c3                   	ret    

f01021b1 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01021b1:	55                   	push   %ebp
f01021b2:	89 e5                	mov    %esp,%ebp
f01021b4:	83 ec 18             	sub    $0x18,%esp
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01021b7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01021be:	eb 31                	jmp    f01021f1 <process_command+0x40>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01021c0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01021c3:	89 d0                	mov    %edx,%eax
f01021c5:	01 c0                	add    %eax,%eax
f01021c7:	01 d0                	add    %edx,%eax
f01021c9:	c1 e0 03             	shl    $0x3,%eax
f01021cc:	05 40 95 17 f0       	add    $0xf0179540,%eax
f01021d1:	8b 10                	mov    (%eax),%edx
f01021d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01021d6:	8b 00                	mov    (%eax),%eax
f01021d8:	83 ec 08             	sub    $0x8,%esp
f01021db:	52                   	push   %edx
f01021dc:	50                   	push   %eax
f01021dd:	e8 5d e4 01 00       	call   f012063f <strcmp>
f01021e2:	83 c4 10             	add    $0x10,%esp
f01021e5:	85 c0                	test   %eax,%eax
f01021e7:	75 05                	jne    f01021ee <process_command+0x3d>
		{
			return i;
f01021e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01021ec:	eb 14                	jmp    f0102202 <process_command+0x51>

int process_command(int number_of_arguments, char** arguments)
{
	//TODO: [PROJECT'24.MS1 - #01] [1] PLAY WITH CODE! - process_command

	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01021ee:	ff 45 f4             	incl   -0xc(%ebp)
f01021f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01021f4:	a1 48 99 17 f0       	mov    0xf0179948,%eax
f01021f9:	39 c2                	cmp    %eax,%edx
f01021fb:	72 c3                	jb     f01021c0 <process_command+0xf>
		if (strcmp(arguments[0], commands[i].name) == 0)
		{
			return i;
		}
	}
	return CMD_INVALID;
f01021fd:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102202:	c9                   	leave  
f0102203:	c3                   	ret    

f0102204 <setKHeapPlacementStrategyCONTALLOC>:
#define KHP_PLACE_FIRSTFIT 	0x1
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
f0102204:	55                   	push   %ebp
f0102205:	89 e5                	mov    %esp,%ebp
f0102207:	c7 05 b0 4f 55 f0 00 	movl   $0x0,0xf0554fb0
f010220e:	00 00 00 
f0102211:	90                   	nop
f0102212:	5d                   	pop    %ebp
f0102213:	c3                   	ret    

f0102214 <setKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f0102214:	55                   	push   %ebp
f0102215:	89 e5                	mov    %esp,%ebp
f0102217:	c7 05 b0 4f 55 f0 01 	movl   $0x1,0xf0554fb0
f010221e:	00 00 00 
f0102221:	90                   	nop
f0102222:	5d                   	pop    %ebp
f0102223:	c3                   	ret    

f0102224 <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f0102224:	55                   	push   %ebp
f0102225:	89 e5                	mov    %esp,%ebp
f0102227:	c7 05 b0 4f 55 f0 02 	movl   $0x2,0xf0554fb0
f010222e:	00 00 00 
f0102231:	90                   	nop
f0102232:	5d                   	pop    %ebp
f0102233:	c3                   	ret    

f0102234 <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f0102234:	55                   	push   %ebp
f0102235:	89 e5                	mov    %esp,%ebp
f0102237:	c7 05 b0 4f 55 f0 03 	movl   $0x3,0xf0554fb0
f010223e:	00 00 00 
f0102241:	90                   	nop
f0102242:	5d                   	pop    %ebp
f0102243:	c3                   	ret    

f0102244 <setKHeapPlacementStrategyWORSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}
f0102244:	55                   	push   %ebp
f0102245:	89 e5                	mov    %esp,%ebp
f0102247:	c7 05 b0 4f 55 f0 04 	movl   $0x4,0xf0554fb0
f010224e:	00 00 00 
f0102251:	90                   	nop
f0102252:	5d                   	pop    %ebp
f0102253:	c3                   	ret    

f0102254 <isKHeapPlacementStrategyCONTALLOC>:

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
f0102254:	55                   	push   %ebp
f0102255:	89 e5                	mov    %esp,%ebp
f0102257:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010225c:	85 c0                	test   %eax,%eax
f010225e:	75 04                	jne    f0102264 <isKHeapPlacementStrategyCONTALLOC+0x10>
f0102260:	b0 01                	mov    $0x1,%al
f0102262:	eb 02                	jmp    f0102266 <isKHeapPlacementStrategyCONTALLOC+0x12>
f0102264:	b0 00                	mov    $0x0,%al
f0102266:	5d                   	pop    %ebp
f0102267:	c3                   	ret    

f0102268 <isKHeapPlacementStrategyFIRSTFIT>:
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f0102268:	55                   	push   %ebp
f0102269:	89 e5                	mov    %esp,%ebp
f010226b:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f0102270:	83 f8 01             	cmp    $0x1,%eax
f0102273:	75 04                	jne    f0102279 <isKHeapPlacementStrategyFIRSTFIT+0x11>
f0102275:	b0 01                	mov    $0x1,%al
f0102277:	eb 02                	jmp    f010227b <isKHeapPlacementStrategyFIRSTFIT+0x13>
f0102279:	b0 00                	mov    $0x0,%al
f010227b:	5d                   	pop    %ebp
f010227c:	c3                   	ret    

f010227d <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010227d:	55                   	push   %ebp
f010227e:	89 e5                	mov    %esp,%ebp
f0102280:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f0102285:	83 f8 02             	cmp    $0x2,%eax
f0102288:	75 04                	jne    f010228e <isKHeapPlacementStrategyBESTFIT+0x11>
f010228a:	b0 01                	mov    $0x1,%al
f010228c:	eb 02                	jmp    f0102290 <isKHeapPlacementStrategyBESTFIT+0x13>
f010228e:	b0 00                	mov    $0x0,%al
f0102290:	5d                   	pop    %ebp
f0102291:	c3                   	ret    

f0102292 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f0102292:	55                   	push   %ebp
f0102293:	89 e5                	mov    %esp,%ebp
f0102295:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010229a:	83 f8 03             	cmp    $0x3,%eax
f010229d:	75 04                	jne    f01022a3 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010229f:	b0 01                	mov    $0x1,%al
f01022a1:	eb 02                	jmp    f01022a5 <isKHeapPlacementStrategyNEXTFIT+0x13>
f01022a3:	b0 00                	mov    $0x0,%al
f01022a5:	5d                   	pop    %ebp
f01022a6:	c3                   	ret    

f01022a7 <isKHeapPlacementStrategyWORSTFIT>:
static inline uint8 isKHeapPlacementStrategyWORSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_WORSTFIT) return 1; return 0;}
f01022a7:	55                   	push   %ebp
f01022a8:	89 e5                	mov    %esp,%ebp
f01022aa:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f01022af:	83 f8 04             	cmp    $0x4,%eax
f01022b2:	75 04                	jne    f01022b8 <isKHeapPlacementStrategyWORSTFIT+0x11>
f01022b4:	b0 01                	mov    $0x1,%al
f01022b6:	eb 02                	jmp    f01022ba <isKHeapPlacementStrategyWORSTFIT+0x13>
f01022b8:	b0 00                	mov    $0x0,%al
f01022ba:	5d                   	pop    %ebp
f01022bb:	c3                   	ret    

f01022bc <setUHeapPlacementStrategyFIRSTFIT>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;

static inline void setUHeapPlacementStrategyFIRSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_FIRSTFIT;}
f01022bc:	55                   	push   %ebp
f01022bd:	89 e5                	mov    %esp,%ebp
f01022bf:	c7 05 04 4f 55 f0 01 	movl   $0x1,0xf0554f04
f01022c6:	00 00 00 
f01022c9:	90                   	nop
f01022ca:	5d                   	pop    %ebp
f01022cb:	c3                   	ret    

f01022cc <setUHeapPlacementStrategyBESTFIT>:
static inline void setUHeapPlacementStrategyBESTFIT(){_UHeapPlacementStrategy = UHP_PLACE_BESTFIT;}
f01022cc:	55                   	push   %ebp
f01022cd:	89 e5                	mov    %esp,%ebp
f01022cf:	c7 05 04 4f 55 f0 02 	movl   $0x2,0xf0554f04
f01022d6:	00 00 00 
f01022d9:	90                   	nop
f01022da:	5d                   	pop    %ebp
f01022db:	c3                   	ret    

f01022dc <setUHeapPlacementStrategyNEXTFIT>:
static inline void setUHeapPlacementStrategyNEXTFIT(){_UHeapPlacementStrategy = UHP_PLACE_NEXTFIT;}
f01022dc:	55                   	push   %ebp
f01022dd:	89 e5                	mov    %esp,%ebp
f01022df:	c7 05 04 4f 55 f0 03 	movl   $0x3,0xf0554f04
f01022e6:	00 00 00 
f01022e9:	90                   	nop
f01022ea:	5d                   	pop    %ebp
f01022eb:	c3                   	ret    

f01022ec <setUHeapPlacementStrategyWORSTFIT>:
static inline void setUHeapPlacementStrategyWORSTFIT(){_UHeapPlacementStrategy = UHP_PLACE_WORSTFIT;}
f01022ec:	55                   	push   %ebp
f01022ed:	89 e5                	mov    %esp,%ebp
f01022ef:	c7 05 04 4f 55 f0 04 	movl   $0x4,0xf0554f04
f01022f6:	00 00 00 
f01022f9:	90                   	nop
f01022fa:	5d                   	pop    %ebp
f01022fb:	c3                   	ret    

f01022fc <isUHeapPlacementStrategyFIRSTFIT>:

static inline uint8 isUHeapPlacementStrategyFIRSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_FIRSTFIT) return 1; return 0;}
f01022fc:	55                   	push   %ebp
f01022fd:	89 e5                	mov    %esp,%ebp
f01022ff:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f0102304:	83 f8 01             	cmp    $0x1,%eax
f0102307:	75 04                	jne    f010230d <isUHeapPlacementStrategyFIRSTFIT+0x11>
f0102309:	b0 01                	mov    $0x1,%al
f010230b:	eb 02                	jmp    f010230f <isUHeapPlacementStrategyFIRSTFIT+0x13>
f010230d:	b0 00                	mov    $0x0,%al
f010230f:	5d                   	pop    %ebp
f0102310:	c3                   	ret    

f0102311 <isUHeapPlacementStrategyBESTFIT>:
static inline uint8 isUHeapPlacementStrategyBESTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_BESTFIT) return 1; return 0;}
f0102311:	55                   	push   %ebp
f0102312:	89 e5                	mov    %esp,%ebp
f0102314:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f0102319:	83 f8 02             	cmp    $0x2,%eax
f010231c:	75 04                	jne    f0102322 <isUHeapPlacementStrategyBESTFIT+0x11>
f010231e:	b0 01                	mov    $0x1,%al
f0102320:	eb 02                	jmp    f0102324 <isUHeapPlacementStrategyBESTFIT+0x13>
f0102322:	b0 00                	mov    $0x0,%al
f0102324:	5d                   	pop    %ebp
f0102325:	c3                   	ret    

f0102326 <isUHeapPlacementStrategyNEXTFIT>:
static inline uint8 isUHeapPlacementStrategyNEXTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_NEXTFIT) return 1; return 0;}
f0102326:	55                   	push   %ebp
f0102327:	89 e5                	mov    %esp,%ebp
f0102329:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f010232e:	83 f8 03             	cmp    $0x3,%eax
f0102331:	75 04                	jne    f0102337 <isUHeapPlacementStrategyNEXTFIT+0x11>
f0102333:	b0 01                	mov    $0x1,%al
f0102335:	eb 02                	jmp    f0102339 <isUHeapPlacementStrategyNEXTFIT+0x13>
f0102337:	b0 00                	mov    $0x0,%al
f0102339:	5d                   	pop    %ebp
f010233a:	c3                   	ret    

f010233b <isUHeapPlacementStrategyWORSTFIT>:
static inline uint8 isUHeapPlacementStrategyWORSTFIT(){if(_UHeapPlacementStrategy == UHP_PLACE_WORSTFIT) return 1; return 0;}
f010233b:	55                   	push   %ebp
f010233c:	89 e5                	mov    %esp,%ebp
f010233e:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
f0102343:	83 f8 04             	cmp    $0x4,%eax
f0102346:	75 04                	jne    f010234c <isUHeapPlacementStrategyWORSTFIT+0x11>
f0102348:	b0 01                	mov    $0x1,%al
f010234a:	eb 02                	jmp    f010234e <isUHeapPlacementStrategyWORSTFIT+0x13>
f010234c:	b0 00                	mov    $0x0,%al
f010234e:	5d                   	pop    %ebp
f010234f:	c3                   	ret    

f0102350 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102350:	55                   	push   %ebp
f0102351:	89 e5                	mov    %esp,%ebp
f0102353:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102356:	8b 45 08             	mov    0x8(%ebp),%eax
f0102359:	c1 e8 0c             	shr    $0xc,%eax
f010235c:	89 c2                	mov    %eax,%edx
f010235e:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0102363:	39 c2                	cmp    %eax,%edx
f0102365:	72 14                	jb     f010237b <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0102367:	83 ec 04             	sub    $0x4,%esp
f010236a:	68 54 28 12 f0       	push   $0xf0122854
f010236f:	6a 55                	push   $0x55
f0102371:	68 7c 28 12 f0       	push   $0xf012287c
f0102376:	e8 9f df ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f010237b:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0102381:	8b 45 08             	mov    0x8(%ebp),%eax
f0102384:	c1 e8 0c             	shr    $0xc,%eax
f0102387:	89 c1                	mov    %eax,%ecx
f0102389:	89 c8                	mov    %ecx,%eax
f010238b:	01 c0                	add    %eax,%eax
f010238d:	01 c8                	add    %ecx,%eax
f010238f:	c1 e0 03             	shl    $0x3,%eax
f0102392:	01 d0                	add    %edx,%eax
}
f0102394:	c9                   	leave  
f0102395:	c3                   	ret    

f0102396 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102396:	55                   	push   %ebp
f0102397:	89 e5                	mov    %esp,%ebp
f0102399:	53                   	push   %ebx
f010239a:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f010239d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01023a4:	eb 3b                	jmp    f01023e1 <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f01023a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01023a9:	89 d0                	mov    %edx,%eax
f01023ab:	01 c0                	add    %eax,%eax
f01023ad:	01 d0                	add    %edx,%eax
f01023af:	c1 e0 03             	shl    $0x3,%eax
f01023b2:	05 44 95 17 f0       	add    $0xf0179544,%eax
f01023b7:	8b 10                	mov    (%eax),%edx
f01023b9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01023bc:	89 c8                	mov    %ecx,%eax
f01023be:	01 c0                	add    %eax,%eax
f01023c0:	01 c8                	add    %ecx,%eax
f01023c2:	c1 e0 03             	shl    $0x3,%eax
f01023c5:	05 40 95 17 f0       	add    $0xf0179540,%eax
f01023ca:	8b 00                	mov    (%eax),%eax
f01023cc:	83 ec 04             	sub    $0x4,%esp
f01023cf:	52                   	push   %edx
f01023d0:	50                   	push   %eax
f01023d1:	68 ff 30 12 f0       	push   $0xf01230ff
f01023d6:	e8 91 eb ff ff       	call   f0100f6c <cprintf>
f01023db:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01023de:	ff 45 f4             	incl   -0xc(%ebp)
f01023e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01023e4:	a1 48 99 17 f0       	mov    0xf0179948,%eax
f01023e9:	39 c2                	cmp    %eax,%edx
f01023eb:	72 b9                	jb     f01023a6 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f01023ed:	83 ec 0c             	sub    $0xc,%esp
f01023f0:	68 08 31 12 f0       	push   $0xf0123108
f01023f5:	e8 72 eb ff ff       	call   f0100f6c <cprintf>
f01023fa:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f01023fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102404:	eb 42                	jmp    f0102448 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0102406:	8b 0d a4 9c 17 f0    	mov    0xf0179ca4,%ecx
f010240c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010240f:	89 d0                	mov    %edx,%eax
f0102411:	01 c0                	add    %eax,%eax
f0102413:	01 d0                	add    %edx,%eax
f0102415:	c1 e0 02             	shl    $0x2,%eax
f0102418:	01 c8                	add    %ecx,%eax
f010241a:	8b 50 04             	mov    0x4(%eax),%edx
f010241d:	8b 1d a4 9c 17 f0    	mov    0xf0179ca4,%ebx
f0102423:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102426:	89 c8                	mov    %ecx,%eax
f0102428:	01 c0                	add    %eax,%eax
f010242a:	01 c8                	add    %ecx,%eax
f010242c:	c1 e0 02             	shl    $0x2,%eax
f010242f:	01 d8                	add    %ebx,%eax
f0102431:	8b 00                	mov    (%eax),%eax
f0102433:	83 ec 04             	sub    $0x4,%esp
f0102436:	52                   	push   %edx
f0102437:	50                   	push   %eax
f0102438:	68 1d 31 12 f0       	push   $0xf012311d
f010243d:	e8 2a eb ff ff       	call   f0100f6c <cprintf>
f0102442:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0102445:	ff 45 f4             	incl   -0xc(%ebp)
f0102448:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010244d:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f0102450:	7c b4                	jl     f0102406 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f0102452:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102457:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010245a:	c9                   	leave  
f010245b:	c3                   	ret    

f010245c <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f010245c:	55                   	push   %ebp
f010245d:	89 e5                	mov    %esp,%ebp
f010245f:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f0102462:	83 ec 0c             	sub    $0xc,%esp
f0102465:	68 39 31 12 f0       	push   $0xf0123139
f010246a:	e8 fd ea ff ff       	call   f0100f6c <cprintf>
f010246f:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f0102472:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0102477:	83 ec 04             	sub    $0x4,%esp
f010247a:	50                   	push   %eax
f010247b:	68 0c 00 10 f0       	push   $0xf010000c
f0102480:	68 54 31 12 f0       	push   $0xf0123154
f0102485:	e8 e2 ea ff ff       	call   f0100f6c <cprintf>
f010248a:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f010248d:	b8 85 16 12 00       	mov    $0x121685,%eax
f0102492:	83 ec 04             	sub    $0x4,%esp
f0102495:	50                   	push   %eax
f0102496:	68 85 16 12 f0       	push   $0xf0121685
f010249b:	68 90 31 12 f0       	push   $0xf0123190
f01024a0:	e8 c7 ea ff ff       	call   f0100f6c <cprintf>
f01024a5:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f01024a8:	b8 b2 17 55 00       	mov    $0x5517b2,%eax
f01024ad:	83 ec 04             	sub    $0x4,%esp
f01024b0:	50                   	push   %eax
f01024b1:	68 b2 17 55 f0       	push   $0xf05517b2
f01024b6:	68 cc 31 12 f0       	push   $0xf01231cc
f01024bb:	e8 ac ea ff ff       	call   f0100f6c <cprintf>
f01024c0:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01024c3:	b8 a8 79 57 00       	mov    $0x5779a8,%eax
f01024c8:	83 ec 04             	sub    $0x4,%esp
f01024cb:	50                   	push   %eax
f01024cc:	68 a8 79 57 f0       	push   $0xf05779a8
f01024d1:	68 14 32 12 f0       	push   $0xf0123214
f01024d6:	e8 91 ea ff ff       	call   f0100f6c <cprintf>
f01024db:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01024de:	b8 a8 79 57 f0       	mov    $0xf05779a8,%eax
f01024e3:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f01024e9:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f01024ee:	29 c2                	sub    %eax,%edx
f01024f0:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f01024f2:	85 c0                	test   %eax,%eax
f01024f4:	79 05                	jns    f01024fb <command_kernel_info+0x9f>
f01024f6:	05 ff 03 00 00       	add    $0x3ff,%eax
f01024fb:	c1 f8 0a             	sar    $0xa,%eax
f01024fe:	83 ec 08             	sub    $0x8,%esp
f0102501:	50                   	push   %eax
f0102502:	68 50 32 12 f0       	push   $0xf0123250
f0102507:	e8 60 ea ff ff       	call   f0100f6c <cprintf>
f010250c:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010250f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102514:	c9                   	leave  
f0102515:	c3                   	ret    

f0102516 <command_writeusermem>:

//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0102516:	55                   	push   %ebp
f0102517:	89 e5                	mov    %esp,%ebp
f0102519:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f010251c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102520:	75 37                	jne    f0102559 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0102522:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102525:	83 c0 04             	add    $0x4,%eax
f0102528:	8b 00                	mov    (%eax),%eax
f010252a:	83 ec 04             	sub    $0x4,%esp
f010252d:	6a 10                	push   $0x10
f010252f:	6a 00                	push   $0x0
f0102531:	50                   	push   %eax
f0102532:	e8 5c e3 01 00       	call   f0120893 <strtol>
f0102537:	83 c4 10             	add    $0x10,%esp
f010253a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010253d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102540:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0102543:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102546:	83 c0 08             	add    $0x8,%eax
f0102549:	8b 00                	mov    (%eax),%eax
f010254b:	8a 00                	mov    (%eax),%al
f010254d:	88 c2                	mov    %al,%dl
f010254f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102552:	88 10                	mov    %dl,(%eax)
f0102554:	e9 b9 00 00 00       	jmp    f0102612 <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0102559:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010255d:	0f 85 9f 00 00 00    	jne    f0102602 <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0102563:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102566:	83 c0 04             	add    $0x4,%eax
f0102569:	8b 00                	mov    (%eax),%eax
f010256b:	83 ec 04             	sub    $0x4,%esp
f010256e:	6a 0a                	push   $0xa
f0102570:	6a 00                	push   $0x0
f0102572:	50                   	push   %eax
f0102573:	e8 1b e3 01 00       	call   f0120893 <strtol>
f0102578:	83 c4 10             	add    $0x10,%esp
f010257b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f010257e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0102585:	83 ec 04             	sub    $0x4,%esp
f0102588:	6a 00                	push   $0x0
f010258a:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010258d:	50                   	push   %eax
f010258e:	ff 75 f4             	pushl  -0xc(%ebp)
f0102591:	e8 2b 7f 00 00       	call   f010a4c1 <envid2env>
f0102596:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0102599:	8b 45 0c             	mov    0xc(%ebp),%eax
f010259c:	83 c0 08             	add    $0x8,%eax
f010259f:	8b 00                	mov    (%eax),%eax
f01025a1:	83 ec 04             	sub    $0x4,%esp
f01025a4:	6a 10                	push   $0x10
f01025a6:	6a 00                	push   $0x0
f01025a8:	50                   	push   %eax
f01025a9:	e8 e5 e2 01 00       	call   f0120893 <strtol>
f01025ae:	83 c4 10             	add    $0x10,%esp
f01025b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01025b4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01025b7:	85 c0                	test   %eax,%eax
f01025b9:	75 07                	jne    f01025c2 <command_writeusermem+0xac>
f01025bb:	b8 00 00 00 00       	mov    $0x0,%eax
f01025c0:	eb 55                	jmp    f0102617 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01025c2:	0f 20 d8             	mov    %cr3,%eax
f01025c5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01025c8:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01025cb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01025ce:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01025d1:	8b 40 68             	mov    0x68(%eax),%eax
f01025d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01025d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01025da:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01025dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01025e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01025e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01025e6:	83 c0 0c             	add    $0xc,%eax
f01025e9:	8b 00                	mov    (%eax),%eax
f01025eb:	8a 00                	mov    (%eax),%al
f01025ed:	88 c2                	mov    %al,%dl
f01025ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01025f2:	88 10                	mov    %dl,(%eax)
f01025f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01025f7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01025fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01025fd:	0f 22 d8             	mov    %eax,%cr3
f0102600:	eb 10                	jmp    f0102612 <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f0102602:	83 ec 0c             	sub    $0xc,%esp
f0102605:	68 7c 32 12 f0       	push   $0xf012327c
f010260a:	e8 5d e9 ff ff       	call   f0100f6c <cprintf>
f010260f:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102612:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102617:	c9                   	leave  
f0102618:	c3                   	ret    

f0102619 <command_writemem_k>:

int command_writemem_k(int number_of_arguments, char **arguments)
{
f0102619:	55                   	push   %ebp
f010261a:	89 e5                	mov    %esp,%ebp
f010261c:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f010261f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102622:	83 c0 04             	add    $0x4,%eax
f0102625:	8b 00                	mov    (%eax),%eax
f0102627:	83 ec 04             	sub    $0x4,%esp
f010262a:	6a 10                	push   $0x10
f010262c:	6a 00                	push   $0x0
f010262e:	50                   	push   %eax
f010262f:	e8 5f e2 01 00       	call   f0120893 <strtol>
f0102634:	83 c4 10             	add    $0x10,%esp
f0102637:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010263c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int c, i=0;
f010263f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int stringLen = strlen(arguments[2]);
f0102646:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102649:	83 c0 08             	add    $0x8,%eax
f010264c:	8b 00                	mov    (%eax),%eax
f010264e:	83 ec 0c             	sub    $0xc,%esp
f0102651:	50                   	push   %eax
f0102652:	e8 dc de 01 00       	call   f0120533 <strlen>
f0102657:	83 c4 10             	add    $0x10,%esp
f010265a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(i=0;i < stringLen; i++)
f010265d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0102664:	eb 1c                	jmp    f0102682 <command_writemem_k+0x69>
	{
		*address = arguments[2][i];
f0102666:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102669:	83 c0 08             	add    $0x8,%eax
f010266c:	8b 10                	mov    (%eax),%edx
f010266e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102671:	01 d0                	add    %edx,%eax
f0102673:	8a 00                	mov    (%eax),%al
f0102675:	88 c2                	mov    %al,%dl
f0102677:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010267a:	88 10                	mov    %dl,(%eax)
		address++;
f010267c:	ff 45 f4             	incl   -0xc(%ebp)
{
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int c, i=0;
	int stringLen = strlen(arguments[2]);

	for(i=0;i < stringLen; i++)
f010267f:	ff 45 f0             	incl   -0x10(%ebp)
f0102682:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102685:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0102688:	7c dc                	jl     f0102666 <command_writemem_k+0x4d>
	{
		*address = arguments[2][i];
		address++;
	}

	return 0;
f010268a:	b8 00 00 00 00       	mov    $0x0,%eax


}
f010268f:	c9                   	leave  
f0102690:	c3                   	ret    

f0102691 <command_readusermem>:

int command_readusermem(int number_of_arguments, char **arguments)
{
f0102691:	55                   	push   %ebp
f0102692:	89 e5                	mov    %esp,%ebp
f0102694:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f0102697:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010269b:	75 42                	jne    f01026df <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010269d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01026a0:	83 c0 04             	add    $0x4,%eax
f01026a3:	8b 00                	mov    (%eax),%eax
f01026a5:	83 ec 04             	sub    $0x4,%esp
f01026a8:	6a 10                	push   $0x10
f01026aa:	6a 00                	push   $0x0
f01026ac:	50                   	push   %eax
f01026ad:	e8 e1 e1 01 00       	call   f0120893 <strtol>
f01026b2:	83 c4 10             	add    $0x10,%esp
f01026b5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f01026b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01026bb:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f01026be:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01026c1:	8a 00                	mov    (%eax),%al
f01026c3:	0f b6 c0             	movzbl %al,%eax
f01026c6:	83 ec 04             	sub    $0x4,%esp
f01026c9:	50                   	push   %eax
f01026ca:	ff 75 d8             	pushl  -0x28(%ebp)
f01026cd:	68 a6 32 12 f0       	push   $0xf01232a6
f01026d2:	e8 95 e8 ff ff       	call   f0100f6c <cprintf>
f01026d7:	83 c4 10             	add    $0x10,%esp
f01026da:	e9 c4 00 00 00       	jmp    f01027a3 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f01026df:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01026e3:	0f 85 aa 00 00 00    	jne    f0102793 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f01026e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01026ec:	83 c0 04             	add    $0x4,%eax
f01026ef:	8b 00                	mov    (%eax),%eax
f01026f1:	83 ec 04             	sub    $0x4,%esp
f01026f4:	6a 0a                	push   $0xa
f01026f6:	6a 00                	push   $0x0
f01026f8:	50                   	push   %eax
f01026f9:	e8 95 e1 01 00       	call   f0120893 <strtol>
f01026fe:	83 c4 10             	add    $0x10,%esp
f0102701:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0102704:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f010270b:	83 ec 04             	sub    $0x4,%esp
f010270e:	6a 00                	push   $0x0
f0102710:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102713:	50                   	push   %eax
f0102714:	ff 75 f4             	pushl  -0xc(%ebp)
f0102717:	e8 a5 7d 00 00       	call   f010a4c1 <envid2env>
f010271c:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f010271f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102722:	83 c0 08             	add    $0x8,%eax
f0102725:	8b 00                	mov    (%eax),%eax
f0102727:	83 ec 04             	sub    $0x4,%esp
f010272a:	6a 10                	push   $0x10
f010272c:	6a 00                	push   $0x0
f010272e:	50                   	push   %eax
f010272f:	e8 5f e1 01 00       	call   f0120893 <strtol>
f0102734:	83 c4 10             	add    $0x10,%esp
f0102737:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f010273a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010273d:	85 c0                	test   %eax,%eax
f010273f:	75 07                	jne    f0102748 <command_readusermem+0xb7>
f0102741:	b8 00 00 00 00       	mov    $0x0,%eax
f0102746:	eb 60                	jmp    f01027a8 <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0102748:	0f 20 d8             	mov    %cr3,%eax
f010274b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f010274e:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f0102751:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f0102754:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102757:	8b 40 68             	mov    0x68(%eax),%eax
f010275a:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010275d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0102760:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f0102763:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102766:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f0102769:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010276c:	8a 00                	mov    (%eax),%al
f010276e:	0f b6 c0             	movzbl %al,%eax
f0102771:	83 ec 04             	sub    $0x4,%esp
f0102774:	50                   	push   %eax
f0102775:	ff 75 f0             	pushl  -0x10(%ebp)
f0102778:	68 a6 32 12 f0       	push   $0xf01232a6
f010277d:	e8 ea e7 ff ff       	call   f0100f6c <cprintf>
f0102782:	83 c4 10             	add    $0x10,%esp
f0102785:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0102788:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010278b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010278e:	0f 22 d8             	mov    %eax,%cr3
f0102791:	eb 10                	jmp    f01027a3 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0102793:	83 ec 0c             	sub    $0xc,%esp
f0102796:	68 c0 32 12 f0       	push   $0xf01232c0
f010279b:	e8 cc e7 ff ff       	call   f0100f6c <cprintf>
f01027a0:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01027a3:	b8 00 00 00 00       	mov    $0x0,%eax

}
f01027a8:	c9                   	leave  
f01027a9:	c3                   	ret    

f01027aa <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01027aa:	55                   	push   %ebp
f01027ab:	89 e5                	mov    %esp,%ebp
f01027ad:	83 ec 18             	sub    $0x18,%esp
	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f01027b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01027b3:	83 c0 04             	add    $0x4,%eax
f01027b6:	8b 00                	mov    (%eax),%eax
f01027b8:	83 ec 04             	sub    $0x4,%esp
f01027bb:	6a 10                	push   $0x10
f01027bd:	6a 00                	push   $0x0
f01027bf:	50                   	push   %eax
f01027c0:	e8 ce e0 01 00       	call   f0120893 <strtol>
f01027c5:	83 c4 10             	add    $0x10,%esp
f01027c8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01027cd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int i=0;
f01027d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cprintf("%c",*address);
f01027d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01027da:	8a 00                	mov    (%eax),%al
f01027dc:	0f b6 c0             	movzbl %al,%eax
f01027df:	83 ec 08             	sub    $0x8,%esp
f01027e2:	50                   	push   %eax
f01027e3:	68 ea 32 12 f0       	push   $0xf01232ea
f01027e8:	e8 7f e7 ff ff       	call   f0100f6c <cprintf>
f01027ed:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01027f0:	83 ec 0c             	sub    $0xc,%esp
f01027f3:	68 ed 32 12 f0       	push   $0xf01232ed
f01027f8:	e8 6f e7 ff ff       	call   f0100f6c <cprintf>
f01027fd:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102800:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102805:	c9                   	leave  
f0102806:	c3                   	ret    

f0102807 <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f0102807:	55                   	push   %ebp
f0102808:	89 e5                	mov    %esp,%ebp
f010280a:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f010280d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102810:	83 c0 04             	add    $0x4,%eax
f0102813:	8b 00                	mov    (%eax),%eax
f0102815:	83 ec 04             	sub    $0x4,%esp
f0102818:	6a 0a                	push   $0xa
f010281a:	6a 00                	push   $0x0
f010281c:	50                   	push   %eax
f010281d:	e8 71 e0 01 00       	call   f0120893 <strtol>
f0102822:	83 c4 10             	add    $0x10,%esp
f0102825:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0102828:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f010282f:	83 ec 04             	sub    $0x4,%esp
f0102832:	6a 00                	push   $0x0
f0102834:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0102837:	50                   	push   %eax
f0102838:	ff 75 ec             	pushl  -0x14(%ebp)
f010283b:	e8 81 7c 00 00       	call   f010a4c1 <envid2env>
f0102840:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f0102843:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102846:	83 c0 08             	add    $0x8,%eax
f0102849:	8b 00                	mov    (%eax),%eax
f010284b:	83 ec 04             	sub    $0x4,%esp
f010284e:	6a 10                	push   $0x10
f0102850:	6a 00                	push   $0x0
f0102852:	50                   	push   %eax
f0102853:	e8 3b e0 01 00       	call   f0120893 <strtol>
f0102858:	83 c4 10             	add    $0x10,%esp
f010285b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f010285e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102861:	83 c0 0c             	add    $0xc,%eax
f0102864:	8b 00                	mov    (%eax),%eax
f0102866:	83 ec 04             	sub    $0x4,%esp
f0102869:	6a 0a                	push   $0xa
f010286b:	6a 00                	push   $0x0
f010286d:	50                   	push   %eax
f010286e:	e8 20 e0 01 00       	call   f0120893 <strtol>
f0102873:	83 c4 10             	add    $0x10,%esp
f0102876:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f0102879:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010287c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f010287f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0102882:	85 c0                	test   %eax,%eax
f0102884:	75 07                	jne    f010288d <command_readuserblock+0x86>
f0102886:	b8 00 00 00 00       	mov    $0x0,%eax
f010288b:	eb 65                	jmp    f01028f2 <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010288d:	0f 20 d8             	mov    %cr3,%eax
f0102890:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0102893:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f0102896:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f0102899:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010289c:	8b 40 68             	mov    0x68(%eax),%eax
f010289f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01028a2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01028a5:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01028a8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01028af:	eb 28                	jmp    f01028d9 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01028b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01028b4:	8a 00                	mov    (%eax),%al
f01028b6:	0f b6 d0             	movzbl %al,%edx
f01028b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01028bc:	8a 00                	mov    (%eax),%al
f01028be:	0f b6 c0             	movzbl %al,%eax
f01028c1:	52                   	push   %edx
f01028c2:	50                   	push   %eax
f01028c3:	ff 75 f4             	pushl  -0xc(%ebp)
f01028c6:	68 ef 32 12 f0       	push   $0xf01232ef
f01028cb:	e8 9c e6 ff ff       	call   f0100f6c <cprintf>
f01028d0:	83 c4 10             	add    $0x10,%esp
		ptr++;
f01028d3:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f01028d6:	ff 45 f0             	incl   -0x10(%ebp)
f01028d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01028dc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01028df:	7c d0                	jl     f01028b1 <command_readuserblock+0xaa>
f01028e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01028e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01028e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01028ea:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f01028ed:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01028f2:	c9                   	leave  
f01028f3:	c3                   	ret    

f01028f4 <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f01028f4:	55                   	push   %ebp
f01028f5:	89 e5                	mov    %esp,%ebp
f01028f7:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f01028fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01028fd:	83 c0 04             	add    $0x4,%eax
f0102900:	8b 00                	mov    (%eax),%eax
f0102902:	83 ec 04             	sub    $0x4,%esp
f0102905:	6a 0a                	push   $0xa
f0102907:	6a 00                	push   $0x0
f0102909:	50                   	push   %eax
f010290a:	e8 84 df 01 00       	call   f0120893 <strtol>
f010290f:	83 c4 10             	add    $0x10,%esp
f0102912:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f0102915:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f010291c:	83 ec 04             	sub    $0x4,%esp
f010291f:	6a 00                	push   $0x0
f0102921:	8d 45 d8             	lea    -0x28(%ebp),%eax
f0102924:	50                   	push   %eax
f0102925:	ff 75 f4             	pushl  -0xc(%ebp)
f0102928:	e8 94 7b 00 00       	call   f010a4c1 <envid2env>
f010292d:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102930:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102933:	85 c0                	test   %eax,%eax
f0102935:	75 0a                	jne    f0102941 <command_remove_table+0x4d>
f0102937:	b8 00 00 00 00       	mov    $0x0,%eax
f010293c:	e9 a1 00 00 00       	jmp    f01029e2 <command_remove_table+0xee>

	uint32 address = strtol(arguments[2], NULL, 16);
f0102941:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102944:	83 c0 08             	add    $0x8,%eax
f0102947:	8b 00                	mov    (%eax),%eax
f0102949:	83 ec 04             	sub    $0x4,%esp
f010294c:	6a 10                	push   $0x10
f010294e:	6a 00                	push   $0x0
f0102950:	50                   	push   %eax
f0102951:	e8 3d df 01 00       	call   f0120893 <strtol>
f0102956:	83 c4 10             	add    $0x10,%esp
f0102959:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f010295c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010295f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f0102962:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0102965:	8b 40 64             	mov    0x64(%eax),%eax
f0102968:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010296b:	c1 ea 16             	shr    $0x16,%edx
f010296e:	c1 e2 02             	shl    $0x2,%edx
f0102971:	01 d0                	add    %edx,%eax
f0102973:	8b 00                	mov    (%eax),%eax
f0102975:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010297a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree((void*)kheap_virtual_address(table_pa));
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f010297d:	83 ec 0c             	sub    $0xc,%esp
f0102980:	ff 75 e8             	pushl  -0x18(%ebp)
f0102983:	e8 c8 f9 ff ff       	call   f0102350 <to_frame_info>
f0102988:	83 c4 10             	add    $0x10,%esp
f010298b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f010298e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102991:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f0102997:	83 ec 0c             	sub    $0xc,%esp
f010299a:	ff 75 e4             	pushl  -0x1c(%ebp)
f010299d:	e8 83 56 00 00       	call   f0108025 <free_frame>
f01029a2:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01029a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01029a8:	c1 e8 16             	shr    $0x16,%eax
f01029ab:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f01029ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029b1:	8b 40 64             	mov    0x64(%eax),%eax
f01029b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01029b7:	c1 e2 02             	shl    $0x2,%edx
f01029ba:	01 c2                	add    %eax,%edx
f01029bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01029bf:	8b 40 64             	mov    0x64(%eax),%eax
f01029c2:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f01029c5:	c1 e1 02             	shl    $0x2,%ecx
f01029c8:	01 c8                	add    %ecx,%eax
f01029ca:	8b 00                	mov    (%eax),%eax
f01029cc:	83 e0 fe             	and    $0xfffffffe,%eax
f01029cf:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01029d1:	0f 20 d8             	mov    %cr3,%eax
f01029d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01029d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029da:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f01029dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01029e2:	c9                   	leave  
f01029e3:	c3                   	ret    

f01029e4 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f01029e4:	55                   	push   %ebp
f01029e5:	89 e5                	mov    %esp,%ebp
f01029e7:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f01029ea:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01029ee:	7e 06                	jle    f01029f6 <command_allocuserpage+0x12>
f01029f0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01029f4:	7e 1a                	jle    f0102a10 <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f01029f6:	83 ec 0c             	sub    $0xc,%esp
f01029f9:	68 00 33 12 f0       	push   $0xf0123300
f01029fe:	e8 69 e5 ff ff       	call   f0100f6c <cprintf>
f0102a03:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102a06:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a0b:	e9 46 01 00 00       	jmp    f0102b56 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0102a10:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a13:	83 c0 04             	add    $0x4,%eax
f0102a16:	8b 00                	mov    (%eax),%eax
f0102a18:	83 ec 04             	sub    $0x4,%esp
f0102a1b:	6a 0a                	push   $0xa
f0102a1d:	6a 00                	push   $0x0
f0102a1f:	50                   	push   %eax
f0102a20:	e8 6e de 01 00       	call   f0120893 <strtol>
f0102a25:	83 c4 10             	add    $0x10,%esp
f0102a28:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0102a2b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0102a32:	83 ec 04             	sub    $0x4,%esp
f0102a35:	6a 00                	push   $0x0
f0102a37:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0102a3a:	50                   	push   %eax
f0102a3b:	ff 75 f0             	pushl  -0x10(%ebp)
f0102a3e:	e8 7e 7a 00 00       	call   f010a4c1 <envid2env>
f0102a43:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0102a46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102a49:	85 c0                	test   %eax,%eax
f0102a4b:	75 0a                	jne    f0102a57 <command_allocuserpage+0x73>
f0102a4d:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a52:	e9 ff 00 00 00       	jmp    f0102b56 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0102a57:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a5a:	83 c0 08             	add    $0x8,%eax
f0102a5d:	8b 00                	mov    (%eax),%eax
f0102a5f:	83 ec 04             	sub    $0x4,%esp
f0102a62:	6a 10                	push   $0x10
f0102a64:	6a 00                	push   $0x0
f0102a66:	50                   	push   %eax
f0102a67:	e8 27 de 01 00       	call   f0120893 <strtol>
f0102a6c:	83 c4 10             	add    $0x10,%esp
f0102a6f:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0102a72:	83 ec 0c             	sub    $0xc,%esp
f0102a75:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0102a78:	50                   	push   %eax
f0102a79:	e8 53 54 00 00       	call   f0107ed1 <allocate_frame>
f0102a7e:	83 c4 10             	add    $0x10,%esp
f0102a81:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0102a84:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0102a88:	75 1a                	jne    f0102aa4 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0102a8a:	83 ec 0c             	sub    $0xc,%esp
f0102a8d:	68 2a 33 12 f0       	push   $0xf012332a
f0102a92:	e8 d5 e4 ff ff       	call   f0100f6c <cprintf>
f0102a97:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102a9a:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a9f:	e9 b2 00 00 00       	jmp    f0102b56 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0102aa4:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0102aa8:	75 1d                	jne    f0102ac7 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0102aaa:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102aad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102ab0:	8b 40 64             	mov    0x64(%eax),%eax
f0102ab3:	6a 06                	push   $0x6
f0102ab5:	ff 75 ec             	pushl  -0x14(%ebp)
f0102ab8:	52                   	push   %edx
f0102ab9:	50                   	push   %eax
f0102aba:	e8 28 58 00 00       	call   f01082e7 <map_frame>
f0102abf:	83 c4 10             	add    $0x10,%esp
f0102ac2:	e9 8a 00 00 00       	jmp    f0102b51 <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0102ac7:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0102acb:	0f 85 80 00 00 00    	jne    f0102b51 <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0102ad1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ad4:	83 c0 0c             	add    $0xc,%eax
f0102ad7:	8b 00                	mov    (%eax),%eax
f0102ad9:	8a 00                	mov    (%eax),%al
f0102adb:	3c 72                	cmp    $0x72,%al
f0102add:	74 0e                	je     f0102aed <command_allocuserpage+0x109>
f0102adf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102ae2:	83 c0 0c             	add    $0xc,%eax
f0102ae5:	8b 00                	mov    (%eax),%eax
f0102ae7:	8a 00                	mov    (%eax),%al
f0102ae9:	3c 52                	cmp    $0x52,%al
f0102aeb:	75 09                	jne    f0102af6 <command_allocuserpage+0x112>
			rw = 0 ;
f0102aed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102af4:	eb 3c                	jmp    f0102b32 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0102af6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102af9:	83 c0 0c             	add    $0xc,%eax
f0102afc:	8b 00                	mov    (%eax),%eax
f0102afe:	8a 00                	mov    (%eax),%al
f0102b00:	3c 77                	cmp    $0x77,%al
f0102b02:	74 0e                	je     f0102b12 <command_allocuserpage+0x12e>
f0102b04:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b07:	83 c0 0c             	add    $0xc,%eax
f0102b0a:	8b 00                	mov    (%eax),%eax
f0102b0c:	8a 00                	mov    (%eax),%al
f0102b0e:	3c 57                	cmp    $0x57,%al
f0102b10:	75 09                	jne    f0102b1b <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0102b12:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102b19:	eb 17                	jmp    f0102b32 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0102b1b:	83 ec 0c             	sub    $0xc,%esp
f0102b1e:	68 44 33 12 f0       	push   $0xf0123344
f0102b23:	e8 44 e4 ff ff       	call   f0100f6c <cprintf>
f0102b28:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0102b2b:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0102b32:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102b35:	83 c8 04             	or     $0x4,%eax
f0102b38:	89 c1                	mov    %eax,%ecx
f0102b3a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0102b3d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102b40:	8b 40 64             	mov    0x64(%eax),%eax
f0102b43:	51                   	push   %ecx
f0102b44:	ff 75 ec             	pushl  -0x14(%ebp)
f0102b47:	52                   	push   %edx
f0102b48:	50                   	push   %eax
f0102b49:	e8 99 57 00 00       	call   f01082e7 <map_frame>
f0102b4e:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0102b51:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102b56:	c9                   	leave  
f0102b57:	c3                   	ret    

f0102b58 <command_meminfo>:

int command_meminfo(int number_of_arguments, char **arguments)
{
f0102b58:	55                   	push   %ebp
f0102b59:	89 e5                	mov    %esp,%ebp
f0102b5b:	56                   	push   %esi
f0102b5c:	53                   	push   %ebx
f0102b5d:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0102b60:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0102b63:	83 ec 0c             	sub    $0xc,%esp
f0102b66:	50                   	push   %eax
f0102b67:	e8 33 5a 00 00       	call   f010859f <calculate_available_frames>
f0102b6c:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102b6f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102b72:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0102b75:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0102b78:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0102b7b:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0102b7e:	01 de                	add    %ebx,%esi
f0102b80:	8b 5d f4             	mov    -0xc(%ebp),%ebx
}

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0102b83:	01 f3                	add    %esi,%ebx
f0102b85:	83 ec 0c             	sub    $0xc,%esp
f0102b88:	51                   	push   %ecx
f0102b89:	52                   	push   %edx
f0102b8a:	50                   	push   %eax
f0102b8b:	53                   	push   %ebx
f0102b8c:	68 88 33 12 f0       	push   $0xf0123388
f0102b91:	e8 d6 e3 ff ff       	call   f0100f6c <cprintf>
f0102b96:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0102b99:	a1 d0 50 55 f0       	mov    0xf05550d0,%eax
f0102b9e:	83 ec 08             	sub    $0x8,%esp
f0102ba1:	50                   	push   %eax
f0102ba2:	68 e0 33 12 f0       	push   $0xf01233e0
f0102ba7:	e8 c0 e3 ff ff       	call   f0100f6c <cprintf>
f0102bac:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102baf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102bb4:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102bb7:	5b                   	pop    %ebx
f0102bb8:	5e                   	pop    %esi
f0102bb9:	5d                   	pop    %ebp
f0102bba:	c3                   	ret    

f0102bbb <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0102bbb:	55                   	push   %ebp
f0102bbc:	89 e5                	mov    %esp,%ebp
f0102bbe:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0102bc1:	c7 45 ec 88 13 00 00 	movl   $0x1388,-0x14(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0102bc8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0102bcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0102bd6:	c7 45 e8 9c ff ff ff 	movl   $0xffffff9c,-0x18(%ebp)
//			assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
//		}
	}
#else
	{
		switch (number_of_arguments)
f0102bdd:	8b 45 08             	mov    0x8(%ebp),%eax
f0102be0:	83 f8 02             	cmp    $0x2,%eax
f0102be3:	74 3c                	je     f0102c21 <CreateEnv+0x66>
f0102be5:	83 f8 03             	cmp    $0x3,%eax
f0102be8:	75 1d                	jne    f0102c07 <CreateEnv+0x4c>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
f0102bea:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bed:	83 c0 08             	add    $0x8,%eax
f0102bf0:	8b 00                	mov    (%eax),%eax
f0102bf2:	83 ec 04             	sub    $0x4,%esp
f0102bf5:	6a 0a                	push   $0xa
f0102bf7:	6a 00                	push   $0x0
f0102bf9:	50                   	push   %eax
f0102bfa:	e8 94 dc 01 00       	call   f0120893 <strtol>
f0102bff:	83 c4 10             	add    $0x10,%esp
f0102c02:	89 45 f0             	mov    %eax,-0x10(%ebp)
			break;
f0102c05:	eb 1b                	jmp    f0102c22 <CreateEnv+0x67>
		case 2:
			break;
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0102c07:	83 ec 0c             	sub    $0xc,%esp
f0102c0a:	68 1c 34 12 f0       	push   $0xf012341c
f0102c0f:	e8 58 e3 ff ff       	call   f0100f6c <cprintf>
f0102c14:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0102c17:	b8 00 00 00 00       	mov    $0x0,%eax
f0102c1c:	e9 a7 00 00 00       	jmp    f0102cc8 <CreateEnv+0x10d>
		{
		case 3:
			percent_WS_pages_to_remove = strtol(arguments[2], NULL, 10);
			break;
		case 2:
			break;
f0102c21:	90                   	nop
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
			return NULL;

			break;
		}
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0102c22:	83 ec 0c             	sub    $0xc,%esp
f0102c25:	6a 02                	push   $0x2
f0102c27:	e8 43 b7 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f0102c2c:	83 c4 10             	add    $0x10,%esp
f0102c2f:	85 c0                	test   %eax,%eax
f0102c31:	74 07                	je     f0102c3a <CreateEnv+0x7f>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
f0102c33:	c7 45 f4 f4 01 00 00 	movl   $0x1f4,-0xc(%ebp)
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0102c3a:	83 7d f0 64          	cmpl   $0x64,-0x10(%ebp)
f0102c3e:	76 19                	jbe    f0102c59 <CreateEnv+0x9e>
f0102c40:	68 8c 34 12 f0       	push   $0xf012348c
f0102c45:	68 d1 34 12 f0       	push   $0xf01234d1
f0102c4a:	68 c0 01 00 00       	push   $0x1c0
f0102c4f:	68 e6 34 12 f0       	push   $0xf01234e6
f0102c54:	e8 c1 d6 ff ff       	call   f010031a <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0102c59:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102c5c:	83 c0 04             	add    $0x4,%eax
f0102c5f:	8b 00                	mov    (%eax),%eax
f0102c61:	ff 75 f0             	pushl  -0x10(%ebp)
f0102c64:	ff 75 f4             	pushl  -0xc(%ebp)
f0102c67:	ff 75 ec             	pushl  -0x14(%ebp)
f0102c6a:	50                   	push   %eax
f0102c6b:	e8 01 6b 00 00       	call   f0109771 <env_create>
f0102c70:	83 c4 10             	add    $0x10,%esp
f0102c73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (BSDSchedNiceVal != -100)
f0102c76:	83 7d e8 9c          	cmpl   $0xffffff9c,-0x18(%ebp)
f0102c7a:	74 49                	je     f0102cc5 <CreateEnv+0x10a>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0102c7c:	83 ec 08             	sub    $0x8,%esp
f0102c7f:	ff 75 e8             	pushl  -0x18(%ebp)
f0102c82:	68 fa 34 12 f0       	push   $0xf01234fa
f0102c87:	e8 e0 e2 ff ff       	call   f0100f6c <cprintf>
f0102c8c:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0102c8f:	83 7d e8 ec          	cmpl   $0xffffffec,-0x18(%ebp)
f0102c93:	7c 06                	jl     f0102c9b <CreateEnv+0xe0>
f0102c95:	83 7d e8 14          	cmpl   $0x14,-0x18(%ebp)
f0102c99:	7e 19                	jle    f0102cb4 <CreateEnv+0xf9>
f0102c9b:	68 0c 35 12 f0       	push   $0xf012350c
f0102ca0:	68 d1 34 12 f0       	push   $0xf01234d1
f0102ca5:	68 c5 01 00 00       	push   $0x1c5
f0102caa:	68 e6 34 12 f0       	push   $0xf01234e6
f0102caf:	e8 66 d6 ff ff       	call   f010031a <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0102cb4:	83 ec 08             	sub    $0x8,%esp
f0102cb7:	ff 75 e8             	pushl  -0x18(%ebp)
f0102cba:	ff 75 e4             	pushl  -0x1c(%ebp)
f0102cbd:	e8 e6 36 00 00       	call   f01063a8 <env_set_nice>
f0102cc2:	83 c4 10             	add    $0x10,%esp
	}
	return env;
f0102cc5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0102cc8:	c9                   	leave  
f0102cc9:	c3                   	ret    

f0102cca <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0102cca:	55                   	push   %ebp
f0102ccb:	89 e5                	mov    %esp,%ebp
f0102ccd:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0102cd0:	83 ec 08             	sub    $0x8,%esp
f0102cd3:	ff 75 0c             	pushl  0xc(%ebp)
f0102cd6:	ff 75 08             	pushl  0x8(%ebp)
f0102cd9:	e8 dd fe ff ff       	call   f0102bbb <CreateEnv>
f0102cde:	83 c4 10             	add    $0x10,%esp
f0102ce1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0102ce4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102ce8:	75 07                	jne    f0102cf1 <command_run_program+0x27>
f0102cea:	b8 00 00 00 00       	mov    $0x0,%eax
f0102cef:	eb 46                	jmp    f0102d37 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0102cf1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102cf4:	8b 40 10             	mov    0x10(%eax),%eax
f0102cf7:	83 ec 08             	sub    $0x8,%esp
f0102cfa:	50                   	push   %eax
f0102cfb:	68 3c 35 12 f0       	push   $0xf012353c
f0102d00:	e8 67 e2 ff ff       	call   f0100f6c <cprintf>
f0102d05:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0102d08:	83 ec 0c             	sub    $0xc,%esp
f0102d0b:	ff 75 f4             	pushl  -0xc(%ebp)
f0102d0e:	e8 93 26 00 00       	call   f01053a6 <sched_new_env>
f0102d13:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0102d16:	c7 05 d0 50 55 f0 00 	movl   $0x0,0xf05550d0
f0102d1d:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0102d20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d23:	8b 40 10             	mov    0x10(%eax),%eax
f0102d26:	83 ec 0c             	sub    $0xc,%esp
f0102d29:	50                   	push   %eax
f0102d2a:	e8 cd 26 00 00       	call   f01053fc <sched_run_env>
f0102d2f:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102d32:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102d37:	c9                   	leave  
f0102d38:	c3                   	ret    

f0102d39 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0102d39:	55                   	push   %ebp
f0102d3a:	89 e5                	mov    %esp,%ebp
f0102d3c:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0102d3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d42:	83 c0 04             	add    $0x4,%eax
f0102d45:	8b 00                	mov    (%eax),%eax
f0102d47:	83 ec 04             	sub    $0x4,%esp
f0102d4a:	6a 0a                	push   $0xa
f0102d4c:	6a 00                	push   $0x0
f0102d4e:	50                   	push   %eax
f0102d4f:	e8 3f db 01 00       	call   f0120893 <strtol>
f0102d54:	83 c4 10             	add    $0x10,%esp
f0102d57:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0102d5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102d5d:	83 ec 0c             	sub    $0xc,%esp
f0102d60:	50                   	push   %eax
f0102d61:	e8 fe 29 00 00       	call   f0105764 <sched_kill_env>
f0102d66:	83 c4 10             	add    $0x10,%esp

	return 0;
f0102d69:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102d6e:	c9                   	leave  
f0102d6f:	c3                   	ret    

f0102d70 <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0102d70:	55                   	push   %ebp
f0102d71:	89 e5                	mov    %esp,%ebp
f0102d73:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0102d76:	83 ec 08             	sub    $0x8,%esp
f0102d79:	ff 75 0c             	pushl  0xc(%ebp)
f0102d7c:	ff 75 08             	pushl  0x8(%ebp)
f0102d7f:	e8 37 fe ff ff       	call   f0102bbb <CreateEnv>
f0102d84:	83 c4 10             	add    $0x10,%esp
f0102d87:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0102d8a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0102d8e:	75 07                	jne    f0102d97 <commnad_load_env+0x27>
		return 0 ;
f0102d90:	b8 00 00 00 00       	mov    $0x0,%eax
f0102d95:	eb 2a                	jmp    f0102dc1 <commnad_load_env+0x51>

	sched_new_env(env) ;
f0102d97:	83 ec 0c             	sub    $0xc,%esp
f0102d9a:	ff 75 f4             	pushl  -0xc(%ebp)
f0102d9d:	e8 04 26 00 00       	call   f01053a6 <sched_new_env>
f0102da2:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0102da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102da8:	8b 40 10             	mov    0x10(%eax),%eax
f0102dab:	83 ec 08             	sub    $0x8,%esp
f0102dae:	50                   	push   %eax
f0102daf:	68 3c 35 12 f0       	push   $0xf012353c
f0102db4:	e8 b3 e1 ff ff       	call   f0100f6c <cprintf>
f0102db9:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102dbc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102dc1:	c9                   	leave  
f0102dc2:	c3                   	ret    

f0102dc3 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0102dc3:	55                   	push   %ebp
f0102dc4:	89 e5                	mov    %esp,%ebp
f0102dc6:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0102dc9:	c7 05 d0 50 55 f0 00 	movl   $0x0,0xf05550d0
f0102dd0:	00 00 00 
	sched_run_all();
f0102dd3:	e8 7b 2f 00 00       	call   f0105d53 <sched_run_all>

	return 0 ;
f0102dd8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ddd:	c9                   	leave  
f0102dde:	c3                   	ret    

f0102ddf <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f0102ddf:	55                   	push   %ebp
f0102de0:	89 e5                	mov    %esp,%ebp
f0102de2:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0102de5:	e8 38 2d 00 00       	call   f0105b22 <sched_print_all>

	return 0 ;
f0102dea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102def:	c9                   	leave  
f0102df0:	c3                   	ret    

f0102df1 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0102df1:	55                   	push   %ebp
f0102df2:	89 e5                	mov    %esp,%ebp
f0102df4:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f0102df7:	e8 ec 2f 00 00       	call   f0105de8 <sched_kill_all>

	return 0 ;
f0102dfc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102e01:	c9                   	leave  
f0102e02:	c3                   	ret    

f0102e03 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0102e03:	55                   	push   %ebp
f0102e04:	89 e5                	mov    %esp,%ebp
f0102e06:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0102e09:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0102e0d:	7f 1a                	jg     f0102e29 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0102e0f:	83 ec 0c             	sub    $0xc,%esp
f0102e12:	68 54 35 12 f0       	push   $0xf0123554
f0102e17:	e8 50 e1 ff ff       	call   f0100f6c <cprintf>
f0102e1c:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102e1f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102e24:	e9 83 00 00 00       	jmp    f0102eac <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0102e29:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e2c:	83 c0 04             	add    $0x4,%eax
f0102e2f:	8b 00                	mov    (%eax),%eax
f0102e31:	83 ec 04             	sub    $0x4,%esp
f0102e34:	6a 0a                	push   $0xa
f0102e36:	6a 00                	push   $0x0
f0102e38:	50                   	push   %eax
f0102e39:	e8 55 da 01 00       	call   f0120893 <strtol>
f0102e3e:	83 c4 10             	add    $0x10,%esp
f0102e41:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0102e44:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0102e48:	75 20                	jne    f0102e6a <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0102e4a:	83 ec 0c             	sub    $0xc,%esp
f0102e4d:	ff 75 f4             	pushl  -0xc(%ebp)
f0102e50:	e8 8f b4 00 00       	call   f010e2e4 <setPageReplacmentAlgorithmLRU>
f0102e55:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0102e58:	83 ec 0c             	sub    $0xc,%esp
f0102e5b:	68 b4 35 12 f0       	push   $0xf01235b4
f0102e60:	e8 07 e1 ff ff       	call   f0100f6c <cprintf>
f0102e65:	83 c4 10             	add    $0x10,%esp
f0102e68:	eb 3d                	jmp    f0102ea7 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0102e6a:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f0102e6e:	75 20                	jne    f0102e90 <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0102e70:	83 ec 0c             	sub    $0xc,%esp
f0102e73:	ff 75 f4             	pushl  -0xc(%ebp)
f0102e76:	e8 69 b4 00 00       	call   f010e2e4 <setPageReplacmentAlgorithmLRU>
f0102e7b:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f0102e7e:	83 ec 0c             	sub    $0xc,%esp
f0102e81:	68 f8 35 12 f0       	push   $0xf01235f8
f0102e86:	e8 e1 e0 ff ff       	call   f0100f6c <cprintf>
f0102e8b:	83 c4 10             	add    $0x10,%esp
f0102e8e:	eb 17                	jmp    f0102ea7 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f0102e90:	83 ec 0c             	sub    $0xc,%esp
f0102e93:	68 38 36 12 f0       	push   $0xf0123638
f0102e98:	e8 cf e0 ff ff       	call   f0100f6c <cprintf>
f0102e9d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0102ea0:	b8 00 00 00 00       	mov    $0x0,%eax
f0102ea5:	eb 05                	jmp    f0102eac <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f0102ea7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102eac:	c9                   	leave  
f0102ead:	c3                   	ret    

f0102eae <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f0102eae:	55                   	push   %ebp
f0102eaf:	89 e5                	mov    %esp,%ebp
f0102eb1:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f0102eb4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102eb7:	83 c0 04             	add    $0x4,%eax
f0102eba:	8b 00                	mov    (%eax),%eax
f0102ebc:	83 ec 04             	sub    $0x4,%esp
f0102ebf:	6a 0a                	push   $0xa
f0102ec1:	6a 00                	push   $0x0
f0102ec3:	50                   	push   %eax
f0102ec4:	e8 ca d9 01 00       	call   f0120893 <strtol>
f0102ec9:	83 c4 10             	add    $0x10,%esp
f0102ecc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f0102ecf:	83 ec 0c             	sub    $0xc,%esp
f0102ed2:	ff 75 f4             	pushl  -0xc(%ebp)
f0102ed5:	e8 7d b4 00 00       	call   f010e357 <setPageReplacmentAlgorithmNchanceCLOCK>
f0102eda:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f0102edd:	83 ec 0c             	sub    $0xc,%esp
f0102ee0:	68 8c 36 12 f0       	push   $0xf012368c
f0102ee5:	e8 82 e0 ff ff       	call   f0100f6c <cprintf>
f0102eea:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102eed:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102ef2:	c9                   	leave  
f0102ef3:	c3                   	ret    

f0102ef4 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f0102ef4:	55                   	push   %ebp
f0102ef5:	89 e5                	mov    %esp,%ebp
f0102ef7:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0102efa:	e8 18 b4 00 00       	call   f010e317 <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f0102eff:	83 ec 0c             	sub    $0xc,%esp
f0102f02:	68 c0 36 12 f0       	push   $0xf01236c0
f0102f07:	e8 60 e0 ff ff       	call   f0100f6c <cprintf>
f0102f0c:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f0f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f14:	c9                   	leave  
f0102f15:	c3                   	ret    

f0102f16 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f0102f16:	55                   	push   %ebp
f0102f17:	89 e5                	mov    %esp,%ebp
f0102f19:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f0102f1c:	e8 06 b4 00 00       	call   f010e327 <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f0102f21:	83 ec 0c             	sub    $0xc,%esp
f0102f24:	68 ec 36 12 f0       	push   $0xf01236ec
f0102f29:	e8 3e e0 ff ff       	call   f0100f6c <cprintf>
f0102f2e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f31:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f36:	c9                   	leave  
f0102f37:	c3                   	ret    

f0102f38 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f0102f38:	55                   	push   %ebp
f0102f39:	89 e5                	mov    %esp,%ebp
f0102f3b:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f0102f3e:	e8 f4 b3 00 00       	call   f010e337 <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f0102f43:	83 ec 0c             	sub    $0xc,%esp
f0102f46:	68 14 37 12 f0       	push   $0xf0123714
f0102f4b:	e8 1c e0 ff ff       	call   f0100f6c <cprintf>
f0102f50:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102f53:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102f58:	c9                   	leave  
f0102f59:	c3                   	ret    

f0102f5a <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f0102f5a:	55                   	push   %ebp
f0102f5b:	89 e5                	mov    %esp,%ebp
f0102f5d:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f0102f60:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102f63:	83 c0 04             	add    $0x4,%eax
f0102f66:	8b 00                	mov    (%eax),%eax
f0102f68:	83 ec 04             	sub    $0x4,%esp
f0102f6b:	6a 0a                	push   $0xa
f0102f6d:	6a 00                	push   $0x0
f0102f6f:	50                   	push   %eax
f0102f70:	e8 1e d9 01 00       	call   f0120893 <strtol>
f0102f75:	83 c4 10             	add    $0x10,%esp
f0102f78:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f0102f7b:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0102f7f:	83 ec 0c             	sub    $0xc,%esp
f0102f82:	50                   	push   %eax
f0102f83:	e8 4e 37 00 00       	call   f01066d6 <sched_init_RR>
f0102f88:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f0102f8b:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f0102f90:	0f b6 c0             	movzbl %al,%eax
f0102f93:	83 ec 08             	sub    $0x8,%esp
f0102f96:	50                   	push   %eax
f0102f97:	68 48 37 12 f0       	push   $0xf0123748
f0102f9c:	e8 cb df ff ff       	call   f0100f6c <cprintf>
f0102fa1:	83 c4 10             	add    $0x10,%esp
	return 0;
f0102fa4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0102fa9:	c9                   	leave  
f0102faa:	c3                   	ret    

f0102fab <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f0102fab:	55                   	push   %ebp
f0102fac:	89 e5                	mov    %esp,%ebp
f0102fae:	53                   	push   %ebx
f0102faf:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0102fb2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fb5:	83 c0 04             	add    $0x4,%eax
f0102fb8:	8b 00                	mov    (%eax),%eax
f0102fba:	83 ec 04             	sub    $0x4,%esp
f0102fbd:	6a 0a                	push   $0xa
f0102fbf:	6a 00                	push   $0x0
f0102fc1:	50                   	push   %eax
f0102fc2:	e8 cc d8 01 00       	call   f0120893 <strtol>
f0102fc7:	83 c4 10             	add    $0x10,%esp
f0102fca:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0102fcd:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0102fd4:	eb 2e                	jmp    f0103004 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0102fd6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102fd9:	8d 58 fe             	lea    -0x2(%eax),%ebx
f0102fdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102fdf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0102fe6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102fe9:	01 d0                	add    %edx,%eax
f0102feb:	8b 00                	mov    (%eax),%eax
f0102fed:	83 ec 04             	sub    $0x4,%esp
f0102ff0:	6a 0a                	push   $0xa
f0102ff2:	6a 00                	push   $0x0
f0102ff4:	50                   	push   %eax
f0102ff5:	e8 99 d8 01 00       	call   f0120893 <strtol>
f0102ffa:	83 c4 10             	add    $0x10,%esp
f0102ffd:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0103001:	ff 45 f4             	incl   -0xc(%ebp)
f0103004:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103007:	3b 45 08             	cmp    0x8(%ebp),%eax
f010300a:	7c ca                	jl     f0102fd6 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f010300c:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0103010:	83 ec 08             	sub    $0x8,%esp
f0103013:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f0103016:	52                   	push   %edx
f0103017:	50                   	push   %eax
f0103018:	e8 32 37 00 00       	call   f010674f <sched_init_MLFQ>
f010301d:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f0103020:	83 ec 0c             	sub    $0xc,%esp
f0103023:	68 80 37 12 f0       	push   $0xf0123780
f0103028:	e8 3f df ff ff       	call   f0100f6c <cprintf>
f010302d:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f0103030:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103037:	eb 21                	jmp    f010305a <command_sch_MLFQ+0xaf>
	{
		cprintf("%d   ", quantums[i]) ;
f0103039:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010303c:	05 e4 4d 55 f0       	add    $0xf0554de4,%eax
f0103041:	8a 00                	mov    (%eax),%al
f0103043:	0f b6 c0             	movzbl %al,%eax
f0103046:	83 ec 08             	sub    $0x8,%esp
f0103049:	50                   	push   %eax
f010304a:	68 ad 37 12 f0       	push   $0xf01237ad
f010304f:	e8 18 df ff ff       	call   f0100f6c <cprintf>
f0103054:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f0103057:	ff 45 f0             	incl   -0x10(%ebp)
f010305a:	a0 60 51 55 f0       	mov    0xf0555160,%al
f010305f:	0f b6 c0             	movzbl %al,%eax
f0103062:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103065:	7f d2                	jg     f0103039 <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f0103067:	83 ec 0c             	sub    $0xc,%esp
f010306a:	68 ed 32 12 f0       	push   $0xf01232ed
f010306f:	e8 f8 de ff ff       	call   f0100f6c <cprintf>
f0103074:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103077:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010307c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010307f:	c9                   	leave  
f0103080:	c3                   	ret    

f0103081 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0103081:	55                   	push   %ebp
f0103082:	89 e5                	mov    %esp,%ebp
f0103084:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0103087:	8b 45 0c             	mov    0xc(%ebp),%eax
f010308a:	83 c0 04             	add    $0x4,%eax
f010308d:	8b 00                	mov    (%eax),%eax
f010308f:	83 ec 04             	sub    $0x4,%esp
f0103092:	6a 0a                	push   $0xa
f0103094:	6a 00                	push   $0x0
f0103096:	50                   	push   %eax
f0103097:	e8 f7 d7 01 00       	call   f0120893 <strtol>
f010309c:	83 c4 10             	add    $0x10,%esp
f010309f:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01030a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01030a5:	83 c0 08             	add    $0x8,%eax
f01030a8:	8b 00                	mov    (%eax),%eax
f01030aa:	83 ec 04             	sub    $0x4,%esp
f01030ad:	6a 0a                	push   $0xa
f01030af:	6a 00                	push   $0x0
f01030b1:	50                   	push   %eax
f01030b2:	e8 dc d7 01 00       	call   f0120893 <strtol>
f01030b7:	83 c4 10             	add    $0x10,%esp
f01030ba:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f01030bd:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01030c1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01030c5:	83 ec 08             	sub    $0x8,%esp
f01030c8:	52                   	push   %edx
f01030c9:	50                   	push   %eax
f01030ca:	e8 a8 36 00 00       	call   f0106777 <sched_init_BSD>
f01030cf:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f01030d2:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f01030d6:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f01030da:	83 ec 04             	sub    $0x4,%esp
f01030dd:	52                   	push   %edx
f01030de:	50                   	push   %eax
f01030df:	68 b4 37 12 f0       	push   $0xf01237b4
f01030e4:	e8 83 de ff ff       	call   f0100f6c <cprintf>
f01030e9:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01030ec:	83 ec 0c             	sub    $0xc,%esp
f01030ef:	68 ed 32 12 f0       	push   $0xf01232ed
f01030f4:	e8 73 de ff ff       	call   f0100f6c <cprintf>
f01030f9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01030fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103101:	c9                   	leave  
f0103102:	c3                   	ret    

f0103103 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f0103103:	55                   	push   %ebp
f0103104:	89 e5                	mov    %esp,%ebp
f0103106:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f0103109:	e8 0b 33 00 00       	call   f0106419 <isSchedMethodMLFQ>
f010310e:	85 c0                	test   %eax,%eax
f0103110:	74 59                	je     f010316b <command_print_sch_method+0x68>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f0103112:	83 ec 0c             	sub    $0xc,%esp
f0103115:	68 f0 37 12 f0       	push   $0xf01237f0
f010311a:	e8 4d de ff ff       	call   f0100f6c <cprintf>
f010311f:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103122:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103129:	eb 21                	jmp    f010314c <command_print_sch_method+0x49>
		{
			cprintf("%d   ", quantums[i]) ;
f010312b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010312e:	05 e4 4d 55 f0       	add    $0xf0554de4,%eax
f0103133:	8a 00                	mov    (%eax),%al
f0103135:	0f b6 c0             	movzbl %al,%eax
f0103138:	83 ec 08             	sub    $0x8,%esp
f010313b:	50                   	push   %eax
f010313c:	68 ad 37 12 f0       	push   $0xf01237ad
f0103141:	e8 26 de ff ff       	call   f0100f6c <cprintf>
f0103146:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0103149:	ff 45 f4             	incl   -0xc(%ebp)
f010314c:	a0 60 51 55 f0       	mov    0xf0555160,%al
f0103151:	0f b6 c0             	movzbl %al,%eax
f0103154:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103157:	7f d2                	jg     f010312b <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f0103159:	83 ec 0c             	sub    $0xc,%esp
f010315c:	68 ed 32 12 f0       	push   $0xf01232ed
f0103161:	e8 06 de ff ff       	call   f0100f6c <cprintf>
f0103166:	83 c4 10             	add    $0x10,%esp
f0103169:	eb 61                	jmp    f01031cc <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodRR())
f010316b:	e8 8f 32 00 00       	call   f01063ff <isSchedMethodRR>
f0103170:	85 c0                	test   %eax,%eax
f0103172:	74 1b                	je     f010318f <command_print_sch_method+0x8c>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f0103174:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f0103179:	0f b6 c0             	movzbl %al,%eax
f010317c:	83 ec 08             	sub    $0x8,%esp
f010317f:	50                   	push   %eax
f0103180:	68 24 38 12 f0       	push   $0xf0123824
f0103185:	e8 e2 dd ff ff       	call   f0100f6c <cprintf>
f010318a:	83 c4 10             	add    $0x10,%esp
f010318d:	eb 3d                	jmp    f01031cc <command_print_sch_method+0xc9>
	}
	else if (isSchedMethodBSD())
f010318f:	e8 a0 32 00 00       	call   f0106434 <isSchedMethodBSD>
f0103194:	85 c0                	test   %eax,%eax
f0103196:	74 24                	je     f01031bc <command_print_sch_method+0xb9>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0103198:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f010319d:	0f b6 d0             	movzbl %al,%edx
f01031a0:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01031a5:	0f b6 c0             	movzbl %al,%eax
f01031a8:	83 ec 04             	sub    $0x4,%esp
f01031ab:	52                   	push   %edx
f01031ac:	50                   	push   %eax
f01031ad:	68 b4 37 12 f0       	push   $0xf01237b4
f01031b2:	e8 b5 dd ff ff       	call   f0100f6c <cprintf>
f01031b7:	83 c4 10             	add    $0x10,%esp
f01031ba:	eb 10                	jmp    f01031cc <command_print_sch_method+0xc9>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01031bc:	83 ec 0c             	sub    $0xc,%esp
f01031bf:	68 60 38 12 f0       	push   $0xf0123860
f01031c4:	e8 a3 dd ff ff       	call   f0100f6c <cprintf>
f01031c9:	83 c4 10             	add    $0x10,%esp

	return 0;
f01031cc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031d1:	c9                   	leave  
f01031d2:	c3                   	ret    

f01031d3 <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01031d3:	55                   	push   %ebp
f01031d4:	89 e5                	mov    %esp,%ebp
f01031d6:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01031d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031dc:	83 c0 04             	add    $0x4,%eax
f01031df:	8b 00                	mov    (%eax),%eax
f01031e1:	83 ec 04             	sub    $0x4,%esp
f01031e4:	6a 0a                	push   $0xa
f01031e6:	6a 00                	push   $0x0
f01031e8:	50                   	push   %eax
f01031e9:	e8 a5 d6 01 00       	call   f0120893 <strtol>
f01031ee:	83 c4 10             	add    $0x10,%esp
f01031f1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f01031f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031f7:	0f b6 c0             	movzbl %al,%eax
f01031fa:	83 ec 0c             	sub    $0xc,%esp
f01031fd:	50                   	push   %eax
f01031fe:	e8 8d c4 01 00       	call   f011f690 <chksch>
f0103203:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f0103206:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010320a:	75 12                	jne    f010321e <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f010320c:	83 ec 0c             	sub    $0xc,%esp
f010320f:	68 88 38 12 f0       	push   $0xf0123888
f0103214:	e8 53 dd ff ff       	call   f0100f6c <cprintf>
f0103219:	83 c4 10             	add    $0x10,%esp
f010321c:	eb 16                	jmp    f0103234 <command_sch_test+0x61>
	else if (status == 1)
f010321e:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0103222:	75 10                	jne    f0103234 <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f0103224:	83 ec 0c             	sub    $0xc,%esp
f0103227:	68 b0 38 12 f0       	push   $0xf01238b0
f010322c:	e8 3b dd ff ff       	call   f0100f6c <cprintf>
f0103231:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103234:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103239:	c9                   	leave  
f010323a:	c3                   	ret    

f010323b <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f010323b:	55                   	push   %ebp
f010323c:	89 e5                	mov    %esp,%ebp
f010323e:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f0103241:	e8 3f b1 00 00       	call   f010e385 <isPageReplacmentAlgorithmCLOCK>
f0103246:	85 c0                	test   %eax,%eax
f0103248:	74 15                	je     f010325f <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f010324a:	83 ec 0c             	sub    $0xc,%esp
f010324d:	68 d4 38 12 f0       	push   $0xf01238d4
f0103252:	e8 15 dd ff ff       	call   f0100f6c <cprintf>
f0103257:	83 c4 10             	add    $0x10,%esp
f010325a:	e9 8c 00 00 00       	jmp    f01032eb <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010325f:	83 ec 0c             	sub    $0xc,%esp
f0103262:	6a 01                	push   $0x1
f0103264:	e8 06 b1 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f0103269:	83 c4 10             	add    $0x10,%esp
f010326c:	85 c0                	test   %eax,%eax
f010326e:	74 12                	je     f0103282 <command_print_page_rep+0x47>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0103270:	83 ec 0c             	sub    $0xc,%esp
f0103273:	68 fc 38 12 f0       	push   $0xf01238fc
f0103278:	e8 ef dc ff ff       	call   f0100f6c <cprintf>
f010327d:	83 c4 10             	add    $0x10,%esp
f0103280:	eb 69                	jmp    f01032eb <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103282:	83 ec 0c             	sub    $0xc,%esp
f0103285:	6a 02                	push   $0x2
f0103287:	e8 e3 b0 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f010328c:	83 c4 10             	add    $0x10,%esp
f010328f:	85 c0                	test   %eax,%eax
f0103291:	74 12                	je     f01032a5 <command_print_page_rep+0x6a>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f0103293:	83 ec 0c             	sub    $0xc,%esp
f0103296:	68 3c 39 12 f0       	push   $0xf012393c
f010329b:	e8 cc dc ff ff       	call   f0100f6c <cprintf>
f01032a0:	83 c4 10             	add    $0x10,%esp
f01032a3:	eb 46                	jmp    f01032eb <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmFIFO())
f01032a5:	e8 f6 b0 00 00       	call   f010e3a0 <isPageReplacmentAlgorithmFIFO>
f01032aa:	85 c0                	test   %eax,%eax
f01032ac:	74 12                	je     f01032c0 <command_print_page_rep+0x85>
		cprintf("Page replacement algorithm is FIFO\n");
f01032ae:	83 ec 0c             	sub    $0xc,%esp
f01032b1:	68 78 39 12 f0       	push   $0xf0123978
f01032b6:	e8 b1 dc ff ff       	call   f0100f6c <cprintf>
f01032bb:	83 c4 10             	add    $0x10,%esp
f01032be:	eb 2b                	jmp    f01032eb <command_print_page_rep+0xb0>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01032c0:	e8 f6 b0 00 00       	call   f010e3bb <isPageReplacmentAlgorithmModifiedCLOCK>
f01032c5:	85 c0                	test   %eax,%eax
f01032c7:	74 12                	je     f01032db <command_print_page_rep+0xa0>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01032c9:	83 ec 0c             	sub    $0xc,%esp
f01032cc:	68 9c 39 12 f0       	push   $0xf012399c
f01032d1:	e8 96 dc ff ff       	call   f0100f6c <cprintf>
f01032d6:	83 c4 10             	add    $0x10,%esp
f01032d9:	eb 10                	jmp    f01032eb <command_print_page_rep+0xb0>
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f01032db:	83 ec 0c             	sub    $0xc,%esp
f01032de:	68 cc 39 12 f0       	push   $0xf01239cc
f01032e3:	e8 84 dc ff ff       	call   f0100f6c <cprintf>
f01032e8:	83 c4 10             	add    $0x10,%esp

	return 0;
f01032eb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032f0:	c9                   	leave  
f01032f1:	c3                   	ret    

f01032f2 <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01032f2:	55                   	push   %ebp
f01032f3:	89 e5                	mov    %esp,%ebp
f01032f5:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyFIRSTFIT();
f01032f8:	e8 bf ef ff ff       	call   f01022bc <setUHeapPlacementStrategyFIRSTFIT>
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f01032fd:	83 ec 0c             	sub    $0xc,%esp
f0103300:	68 f8 39 12 f0       	push   $0xf01239f8
f0103305:	e8 62 dc ff ff       	call   f0100f6c <cprintf>
f010330a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010330d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103312:	c9                   	leave  
f0103313:	c3                   	ret    

f0103314 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103314:	55                   	push   %ebp
f0103315:	89 e5                	mov    %esp,%ebp
f0103317:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyBESTFIT();
f010331a:	e8 ad ef ff ff       	call   f01022cc <setUHeapPlacementStrategyBESTFIT>
	cprintf("User Heap placement strategy is now BEST FIT\n");
f010331f:	83 ec 0c             	sub    $0xc,%esp
f0103322:	68 28 3a 12 f0       	push   $0xf0123a28
f0103327:	e8 40 dc ff ff       	call   f0100f6c <cprintf>
f010332c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010332f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103334:	c9                   	leave  
f0103335:	c3                   	ret    

f0103336 <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103336:	55                   	push   %ebp
f0103337:	89 e5                	mov    %esp,%ebp
f0103339:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyNEXTFIT();
f010333c:	e8 9b ef ff ff       	call   f01022dc <setUHeapPlacementStrategyNEXTFIT>
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f0103341:	83 ec 0c             	sub    $0xc,%esp
f0103344:	68 58 3a 12 f0       	push   $0xf0123a58
f0103349:	e8 1e dc ff ff       	call   f0100f6c <cprintf>
f010334e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103351:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103356:	c9                   	leave  
f0103357:	c3                   	ret    

f0103358 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0103358:	55                   	push   %ebp
f0103359:	89 e5                	mov    %esp,%ebp
f010335b:	83 ec 08             	sub    $0x8,%esp
	setUHeapPlacementStrategyWORSTFIT();
f010335e:	e8 89 ef ff ff       	call   f01022ec <setUHeapPlacementStrategyWORSTFIT>
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0103363:	83 ec 0c             	sub    $0xc,%esp
f0103366:	68 88 3a 12 f0       	push   $0xf0123a88
f010336b:	e8 fc db ff ff       	call   f0100f6c <cprintf>
f0103370:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103373:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103378:	c9                   	leave  
f0103379:	c3                   	ret    

f010337a <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f010337a:	55                   	push   %ebp
f010337b:	89 e5                	mov    %esp,%ebp
f010337d:	83 ec 08             	sub    $0x8,%esp
	if (isUHeapPlacementStrategyFIRSTFIT())
f0103380:	e8 77 ef ff ff       	call   f01022fc <isUHeapPlacementStrategyFIRSTFIT>
f0103385:	84 c0                	test   %al,%al
f0103387:	74 12                	je     f010339b <command_print_uheap_plac+0x21>
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0103389:	83 ec 0c             	sub    $0xc,%esp
f010338c:	68 b8 3a 12 f0       	push   $0xf0123ab8
f0103391:	e8 d6 db ff ff       	call   f0100f6c <cprintf>
f0103396:	83 c4 10             	add    $0x10,%esp
f0103399:	eb 61                	jmp    f01033fc <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyBESTFIT())
f010339b:	e8 71 ef ff ff       	call   f0102311 <isUHeapPlacementStrategyBESTFIT>
f01033a0:	84 c0                	test   %al,%al
f01033a2:	74 12                	je     f01033b6 <command_print_uheap_plac+0x3c>
		cprintf("User Heap placement strategy is BEST FIT\n");
f01033a4:	83 ec 0c             	sub    $0xc,%esp
f01033a7:	68 e4 3a 12 f0       	push   $0xf0123ae4
f01033ac:	e8 bb db ff ff       	call   f0100f6c <cprintf>
f01033b1:	83 c4 10             	add    $0x10,%esp
f01033b4:	eb 46                	jmp    f01033fc <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyNEXTFIT())
f01033b6:	e8 6b ef ff ff       	call   f0102326 <isUHeapPlacementStrategyNEXTFIT>
f01033bb:	84 c0                	test   %al,%al
f01033bd:	74 12                	je     f01033d1 <command_print_uheap_plac+0x57>
		cprintf("User Heap placement strategy is NEXT FIT\n");
f01033bf:	83 ec 0c             	sub    $0xc,%esp
f01033c2:	68 10 3b 12 f0       	push   $0xf0123b10
f01033c7:	e8 a0 db ff ff       	call   f0100f6c <cprintf>
f01033cc:	83 c4 10             	add    $0x10,%esp
f01033cf:	eb 2b                	jmp    f01033fc <command_print_uheap_plac+0x82>
	else if (isUHeapPlacementStrategyWORSTFIT())
f01033d1:	e8 65 ef ff ff       	call   f010233b <isUHeapPlacementStrategyWORSTFIT>
f01033d6:	84 c0                	test   %al,%al
f01033d8:	74 12                	je     f01033ec <command_print_uheap_plac+0x72>
		cprintf("User Heap placement strategy is WORST FIT\n");
f01033da:	83 ec 0c             	sub    $0xc,%esp
f01033dd:	68 3c 3b 12 f0       	push   $0xf0123b3c
f01033e2:	e8 85 db ff ff       	call   f0100f6c <cprintf>
f01033e7:	83 c4 10             	add    $0x10,%esp
f01033ea:	eb 10                	jmp    f01033fc <command_print_uheap_plac+0x82>
	else
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01033ec:	83 ec 0c             	sub    $0xc,%esp
f01033ef:	68 68 3b 12 f0       	push   $0xf0123b68
f01033f4:	e8 73 db ff ff       	call   f0100f6c <cprintf>
f01033f9:	83 c4 10             	add    $0x10,%esp

	return 0;
f01033fc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103401:	c9                   	leave  
f0103402:	c3                   	ret    

f0103403 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f0103403:	55                   	push   %ebp
f0103404:	89 e5                	mov    %esp,%ebp
f0103406:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyCONTALLOC();
f0103409:	e8 f6 ed ff ff       	call   f0102204 <setKHeapPlacementStrategyCONTALLOC>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010340e:	83 ec 0c             	sub    $0xc,%esp
f0103411:	68 94 3b 12 f0       	push   $0xf0123b94
f0103416:	e8 51 db ff ff       	call   f0100f6c <cprintf>
f010341b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010341e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103423:	c9                   	leave  
f0103424:	c3                   	ret    

f0103425 <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f0103425:	55                   	push   %ebp
f0103426:	89 e5                	mov    %esp,%ebp
f0103428:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyFIRSTFIT();
f010342b:	e8 e4 ed ff ff       	call   f0102214 <setKHeapPlacementStrategyFIRSTFIT>
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f0103430:	83 ec 0c             	sub    $0xc,%esp
f0103433:	68 94 3b 12 f0       	push   $0xf0123b94
f0103438:	e8 2f db ff ff       	call   f0100f6c <cprintf>
f010343d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103440:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103445:	c9                   	leave  
f0103446:	c3                   	ret    

f0103447 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0103447:	55                   	push   %ebp
f0103448:	89 e5                	mov    %esp,%ebp
f010344a:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyBESTFIT();
f010344d:	e8 d2 ed ff ff       	call   f0102224 <setKHeapPlacementStrategyBESTFIT>
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0103452:	83 ec 0c             	sub    $0xc,%esp
f0103455:	68 c8 3b 12 f0       	push   $0xf0123bc8
f010345a:	e8 0d db ff ff       	call   f0100f6c <cprintf>
f010345f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103462:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103467:	c9                   	leave  
f0103468:	c3                   	ret    

f0103469 <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f0103469:	55                   	push   %ebp
f010346a:	89 e5                	mov    %esp,%ebp
f010346c:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyNEXTFIT();
f010346f:	e8 c0 ed ff ff       	call   f0102234 <setKHeapPlacementStrategyNEXTFIT>
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f0103474:	83 ec 0c             	sub    $0xc,%esp
f0103477:	68 f8 3b 12 f0       	push   $0xf0123bf8
f010347c:	e8 eb da ff ff       	call   f0100f6c <cprintf>
f0103481:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103484:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103489:	c9                   	leave  
f010348a:	c3                   	ret    

f010348b <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f010348b:	55                   	push   %ebp
f010348c:	89 e5                	mov    %esp,%ebp
f010348e:	83 ec 08             	sub    $0x8,%esp
	setKHeapPlacementStrategyWORSTFIT();
f0103491:	e8 ae ed ff ff       	call   f0102244 <setKHeapPlacementStrategyWORSTFIT>
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0103496:	83 ec 0c             	sub    $0xc,%esp
f0103499:	68 28 3c 12 f0       	push   $0xf0123c28
f010349e:	e8 c9 da ff ff       	call   f0100f6c <cprintf>
f01034a3:	83 c4 10             	add    $0x10,%esp
	return 0;
f01034a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034ab:	c9                   	leave  
f01034ac:	c3                   	ret    

f01034ad <command_print_kheap_plac>:

int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01034ad:	55                   	push   %ebp
f01034ae:	89 e5                	mov    %esp,%ebp
f01034b0:	83 ec 08             	sub    $0x8,%esp
	if (isKHeapPlacementStrategyCONTALLOC())
f01034b3:	e8 9c ed ff ff       	call   f0102254 <isKHeapPlacementStrategyCONTALLOC>
f01034b8:	84 c0                	test   %al,%al
f01034ba:	74 12                	je     f01034ce <command_print_kheap_plac+0x21>
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01034bc:	83 ec 0c             	sub    $0xc,%esp
f01034bf:	68 5c 3c 12 f0       	push   $0xf0123c5c
f01034c4:	e8 a3 da ff ff       	call   f0100f6c <cprintf>
f01034c9:	83 c4 10             	add    $0x10,%esp
f01034cc:	eb 7c                	jmp    f010354a <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyFIRSTFIT())
f01034ce:	e8 95 ed ff ff       	call   f0102268 <isKHeapPlacementStrategyFIRSTFIT>
f01034d3:	84 c0                	test   %al,%al
f01034d5:	74 12                	je     f01034e9 <command_print_kheap_plac+0x3c>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01034d7:	83 ec 0c             	sub    $0xc,%esp
f01034da:	68 98 3c 12 f0       	push   $0xf0123c98
f01034df:	e8 88 da ff ff       	call   f0100f6c <cprintf>
f01034e4:	83 c4 10             	add    $0x10,%esp
f01034e7:	eb 61                	jmp    f010354a <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyBESTFIT())
f01034e9:	e8 8f ed ff ff       	call   f010227d <isKHeapPlacementStrategyBESTFIT>
f01034ee:	84 c0                	test   %al,%al
f01034f0:	74 12                	je     f0103504 <command_print_kheap_plac+0x57>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f01034f2:	83 ec 0c             	sub    $0xc,%esp
f01034f5:	68 c8 3c 12 f0       	push   $0xf0123cc8
f01034fa:	e8 6d da ff ff       	call   f0100f6c <cprintf>
f01034ff:	83 c4 10             	add    $0x10,%esp
f0103502:	eb 46                	jmp    f010354a <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyNEXTFIT())
f0103504:	e8 89 ed ff ff       	call   f0102292 <isKHeapPlacementStrategyNEXTFIT>
f0103509:	84 c0                	test   %al,%al
f010350b:	74 12                	je     f010351f <command_print_kheap_plac+0x72>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010350d:	83 ec 0c             	sub    $0xc,%esp
f0103510:	68 f4 3c 12 f0       	push   $0xf0123cf4
f0103515:	e8 52 da ff ff       	call   f0100f6c <cprintf>
f010351a:	83 c4 10             	add    $0x10,%esp
f010351d:	eb 2b                	jmp    f010354a <command_print_kheap_plac+0x9d>
	else if (isKHeapPlacementStrategyWORSTFIT())
f010351f:	e8 83 ed ff ff       	call   f01022a7 <isKHeapPlacementStrategyWORSTFIT>
f0103524:	84 c0                	test   %al,%al
f0103526:	74 12                	je     f010353a <command_print_kheap_plac+0x8d>
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0103528:	83 ec 0c             	sub    $0xc,%esp
f010352b:	68 20 3d 12 f0       	push   $0xf0123d20
f0103530:	e8 37 da ff ff       	call   f0100f6c <cprintf>
f0103535:	83 c4 10             	add    $0x10,%esp
f0103538:	eb 10                	jmp    f010354a <command_print_kheap_plac+0x9d>
	else
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f010353a:	83 ec 0c             	sub    $0xc,%esp
f010353d:	68 50 3d 12 f0       	push   $0xf0123d50
f0103542:	e8 25 da ff ff       	call   f0100f6c <cprintf>
f0103547:	83 c4 10             	add    $0x10,%esp

	return 0;
f010354a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010354f:	c9                   	leave  
f0103550:	c3                   	ret    

f0103551 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103551:	55                   	push   %ebp
f0103552:	89 e5                	mov    %esp,%ebp
f0103554:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0103557:	e8 d6 ae 00 00       	call   f010e432 <isBufferingEnabled>
f010355c:	84 c0                	test   %al,%al
f010355e:	75 12                	jne    f0103572 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0103560:	83 ec 0c             	sub    $0xc,%esp
f0103563:	68 80 3d 12 f0       	push   $0xf0123d80
f0103568:	e8 ff d9 ff ff       	call   f0100f6c <cprintf>
f010356d:	83 c4 10             	add    $0x10,%esp
f0103570:	eb 1d                	jmp    f010358f <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0103572:	83 ec 0c             	sub    $0xc,%esp
f0103575:	6a 00                	push   $0x0
f0103577:	e8 90 ae 00 00       	call   f010e40c <enableModifiedBuffer>
f010357c:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f010357f:	83 ec 0c             	sub    $0xc,%esp
f0103582:	68 bc 3d 12 f0       	push   $0xf0123dbc
f0103587:	e8 e0 d9 ff ff       	call   f0100f6c <cprintf>
f010358c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010358f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103594:	c9                   	leave  
f0103595:	c3                   	ret    

f0103596 <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0103596:	55                   	push   %ebp
f0103597:	89 e5                	mov    %esp,%ebp
f0103599:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f010359c:	e8 91 ae 00 00       	call   f010e432 <isBufferingEnabled>
f01035a1:	84 c0                	test   %al,%al
f01035a3:	75 12                	jne    f01035b7 <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f01035a5:	83 ec 0c             	sub    $0xc,%esp
f01035a8:	68 80 3d 12 f0       	push   $0xf0123d80
f01035ad:	e8 ba d9 ff ff       	call   f0100f6c <cprintf>
f01035b2:	83 c4 10             	add    $0x10,%esp
f01035b5:	eb 1d                	jmp    f01035d4 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f01035b7:	83 ec 0c             	sub    $0xc,%esp
f01035ba:	6a 01                	push   $0x1
f01035bc:	e8 4b ae 00 00       	call   f010e40c <enableModifiedBuffer>
f01035c1:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f01035c4:	83 ec 0c             	sub    $0xc,%esp
f01035c7:	68 e0 3d 12 f0       	push   $0xf0123de0
f01035cc:	e8 9b d9 ff ff       	call   f0100f6c <cprintf>
f01035d1:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01035d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035d9:	c9                   	leave  
f01035da:	c3                   	ret    

f01035db <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f01035db:	55                   	push   %ebp
f01035dc:	89 e5                	mov    %esp,%ebp
f01035de:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f01035e1:	83 ec 0c             	sub    $0xc,%esp
f01035e4:	6a 00                	push   $0x0
f01035e6:	e8 39 ae 00 00       	call   f010e424 <enableBuffering>
f01035eb:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f01035ee:	83 ec 0c             	sub    $0xc,%esp
f01035f1:	6a 00                	push   $0x0
f01035f3:	e8 14 ae 00 00       	call   f010e40c <enableModifiedBuffer>
f01035f8:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f01035fb:	83 ec 0c             	sub    $0xc,%esp
f01035fe:	68 00 3e 12 f0       	push   $0xf0123e00
f0103603:	e8 64 d9 ff ff       	call   f0100f6c <cprintf>
f0103608:	83 c4 10             	add    $0x10,%esp
	return 0;
f010360b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103610:	c9                   	leave  
f0103611:	c3                   	ret    

f0103612 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0103612:	55                   	push   %ebp
f0103613:	89 e5                	mov    %esp,%ebp
f0103615:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0103618:	83 ec 0c             	sub    $0xc,%esp
f010361b:	6a 01                	push   $0x1
f010361d:	e8 02 ae 00 00       	call   f010e424 <enableBuffering>
f0103622:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0103625:	83 ec 0c             	sub    $0xc,%esp
f0103628:	6a 01                	push   $0x1
f010362a:	e8 dd ad 00 00       	call   f010e40c <enableModifiedBuffer>
f010362f:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0103632:	e8 13 ae 00 00       	call   f010e44a <getModifiedBufferLength>
f0103637:	85 c0                	test   %eax,%eax
f0103639:	75 59                	jne    f0103694 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f010363b:	83 ec 0c             	sub    $0xc,%esp
f010363e:	68 1c 3e 12 f0       	push   $0xf0123e1c
f0103643:	e8 24 d9 ff ff       	call   f0100f6c <cprintf>
f0103648:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f010364b:	83 ec 08             	sub    $0x8,%esp
f010364e:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103651:	50                   	push   %eax
f0103652:	68 4c 3e 12 f0       	push   $0xf0123e4c
f0103657:	e8 cf cc 01 00       	call   f012032b <readline>
f010365c:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f010365f:	83 ec 04             	sub    $0x4,%esp
f0103662:	6a 0a                	push   $0xa
f0103664:	6a 00                	push   $0x0
f0103666:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0103669:	50                   	push   %eax
f010366a:	e8 24 d2 01 00       	call   f0120893 <strtol>
f010366f:	83 c4 10             	add    $0x10,%esp
f0103672:	83 ec 0c             	sub    $0xc,%esp
f0103675:	50                   	push   %eax
f0103676:	e8 c1 ad 00 00       	call   f010e43c <setModifiedBufferLength>
f010367b:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f010367e:	e8 c7 ad 00 00       	call   f010e44a <getModifiedBufferLength>
f0103683:	83 ec 08             	sub    $0x8,%esp
f0103686:	50                   	push   %eax
f0103687:	68 78 3e 12 f0       	push   $0xf0123e78
f010368c:	e8 db d8 ff ff       	call   f0100f6c <cprintf>
f0103691:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0103694:	83 ec 0c             	sub    $0xc,%esp
f0103697:	68 9d 3e 12 f0       	push   $0xf0123e9d
f010369c:	e8 cb d8 ff ff       	call   f0100f6c <cprintf>
f01036a1:	83 c4 10             	add    $0x10,%esp
	return 0;
f01036a4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01036a9:	c9                   	leave  
f01036aa:	c3                   	ret    

f01036ab <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f01036ab:	55                   	push   %ebp
f01036ac:	89 e5                	mov    %esp,%ebp
f01036ae:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f01036b1:	e8 7c ad 00 00       	call   f010e432 <isBufferingEnabled>
f01036b6:	84 c0                	test   %al,%al
f01036b8:	75 12                	jne    f01036cc <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f01036ba:	83 ec 0c             	sub    $0xc,%esp
f01036bd:	68 b8 3e 12 f0       	push   $0xf0123eb8
f01036c2:	e8 a5 d8 ff ff       	call   f0100f6c <cprintf>
f01036c7:	83 c4 10             	add    $0x10,%esp
f01036ca:	eb 19                	jmp    f01036e5 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f01036cc:	e8 49 ad 00 00       	call   f010e41a <isModifiedBufferEnabled>
f01036d1:	84 c0                	test   %al,%al
f01036d3:	75 10                	jne    f01036e5 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f01036d5:	83 ec 0c             	sub    $0xc,%esp
f01036d8:	68 08 3f 12 f0       	push   $0xf0123f08
f01036dd:	e8 8a d8 ff ff       	call   f0100f6c <cprintf>
f01036e2:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f01036e5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036e8:	83 c0 04             	add    $0x4,%eax
f01036eb:	8b 00                	mov    (%eax),%eax
f01036ed:	83 ec 04             	sub    $0x4,%esp
f01036f0:	6a 0a                	push   $0xa
f01036f2:	6a 00                	push   $0x0
f01036f4:	50                   	push   %eax
f01036f5:	e8 99 d1 01 00       	call   f0120893 <strtol>
f01036fa:	83 c4 10             	add    $0x10,%esp
f01036fd:	83 ec 0c             	sub    $0xc,%esp
f0103700:	50                   	push   %eax
f0103701:	e8 36 ad 00 00       	call   f010e43c <setModifiedBufferLength>
f0103706:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0103709:	e8 3c ad 00 00       	call   f010e44a <getModifiedBufferLength>
f010370e:	83 ec 08             	sub    $0x8,%esp
f0103711:	50                   	push   %eax
f0103712:	68 78 3e 12 f0       	push   $0xf0123e78
f0103717:	e8 50 d8 ff ff       	call   f0100f6c <cprintf>
f010371c:	83 c4 10             	add    $0x10,%esp
	return 0;
f010371f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103724:	c9                   	leave  
f0103725:	c3                   	ret    

f0103726 <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0103726:	55                   	push   %ebp
f0103727:	89 e5                	mov    %esp,%ebp
f0103729:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f010372c:	e8 01 ad 00 00       	call   f010e432 <isBufferingEnabled>
f0103731:	84 c0                	test   %al,%al
f0103733:	75 12                	jne    f0103747 <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0103735:	83 ec 0c             	sub    $0xc,%esp
f0103738:	68 b8 3e 12 f0       	push   $0xf0123eb8
f010373d:	e8 2a d8 ff ff       	call   f0100f6c <cprintf>
f0103742:	83 c4 10             	add    $0x10,%esp
f0103745:	eb 19                	jmp    f0103760 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0103747:	e8 ce ac 00 00       	call   f010e41a <isModifiedBufferEnabled>
f010374c:	84 c0                	test   %al,%al
f010374e:	75 10                	jne    f0103760 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0103750:	83 ec 0c             	sub    $0xc,%esp
f0103753:	68 08 3f 12 f0       	push   $0xf0123f08
f0103758:	e8 0f d8 ff ff       	call   f0100f6c <cprintf>
f010375d:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0103760:	e8 e5 ac 00 00       	call   f010e44a <getModifiedBufferLength>
f0103765:	83 ec 08             	sub    $0x8,%esp
f0103768:	50                   	push   %eax
f0103769:	68 4e 3f 12 f0       	push   $0xf0123f4e
f010376e:	e8 f9 d7 ff ff       	call   f0100f6c <cprintf>
f0103773:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103776:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010377b:	c9                   	leave  
f010377c:	c3                   	ret    

f010377d <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f010377d:	55                   	push   %ebp
f010377e:	89 e5                	mov    %esp,%ebp
f0103780:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0103783:	83 ec 08             	sub    $0x8,%esp
f0103786:	ff 75 0c             	pushl  0xc(%ebp)
f0103789:	ff 75 08             	pushl  0x8(%ebp)
f010378c:	e8 79 b4 00 00       	call   f010ec0a <tst_handler>
f0103791:	83 c4 10             	add    $0x10,%esp
}
f0103794:	c9                   	leave  
f0103795:	c3                   	ret    

f0103796 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0103796:	55                   	push   %ebp
f0103797:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0103799:	8b 45 08             	mov    0x8(%ebp),%eax
f010379c:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f01037a2:	29 d0                	sub    %edx,%eax
f01037a4:	c1 f8 03             	sar    $0x3,%eax
f01037a7:	89 c2                	mov    %eax,%edx
f01037a9:	89 d0                	mov    %edx,%eax
f01037ab:	c1 e0 02             	shl    $0x2,%eax
f01037ae:	01 d0                	add    %edx,%eax
f01037b0:	c1 e0 02             	shl    $0x2,%eax
f01037b3:	01 d0                	add    %edx,%eax
f01037b5:	c1 e0 02             	shl    $0x2,%eax
f01037b8:	01 d0                	add    %edx,%eax
f01037ba:	89 c1                	mov    %eax,%ecx
f01037bc:	c1 e1 08             	shl    $0x8,%ecx
f01037bf:	01 c8                	add    %ecx,%eax
f01037c1:	89 c1                	mov    %eax,%ecx
f01037c3:	c1 e1 10             	shl    $0x10,%ecx
f01037c6:	01 c8                	add    %ecx,%eax
f01037c8:	01 c0                	add    %eax,%eax
f01037ca:	01 d0                	add    %edx,%eax
}
f01037cc:	5d                   	pop    %ebp
f01037cd:	c3                   	ret    

f01037ce <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f01037ce:	55                   	push   %ebp
f01037cf:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f01037d1:	ff 75 08             	pushl  0x8(%ebp)
f01037d4:	e8 bd ff ff ff       	call   f0103796 <to_frame_number>
f01037d9:	83 c4 04             	add    $0x4,%esp
f01037dc:	c1 e0 0c             	shl    $0xc,%eax
}
f01037df:	c9                   	leave  
f01037e0:	c3                   	ret    

f01037e1 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f01037e1:	55                   	push   %ebp
f01037e2:	89 e5                	mov    %esp,%ebp
f01037e4:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f01037e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01037ea:	c1 e8 0c             	shr    $0xc,%eax
f01037ed:	89 c2                	mov    %eax,%edx
f01037ef:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01037f4:	39 c2                	cmp    %eax,%edx
f01037f6:	72 14                	jb     f010380c <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f01037f8:	83 ec 04             	sub    $0x4,%esp
f01037fb:	68 6c 3f 12 f0       	push   $0xf0123f6c
f0103800:	6a 55                	push   $0x55
f0103802:	68 94 3f 12 f0       	push   $0xf0123f94
f0103807:	e8 0e cb ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f010380c:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0103812:	8b 45 08             	mov    0x8(%ebp),%eax
f0103815:	c1 e8 0c             	shr    $0xc,%eax
f0103818:	89 c1                	mov    %eax,%ecx
f010381a:	89 c8                	mov    %ecx,%eax
f010381c:	01 c0                	add    %eax,%eax
f010381e:	01 c8                	add    %ecx,%eax
f0103820:	c1 e0 03             	shl    $0x3,%eax
f0103823:	01 d0                	add    %edx,%eax
}
f0103825:	c9                   	leave  
f0103826:	c3                   	ret    

f0103827 <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0103827:	55                   	push   %ebp
f0103828:	89 e5                	mov    %esp,%ebp
f010382a:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f010382d:	8b 45 08             	mov    0x8(%ebp),%eax
f0103830:	05 00 14 00 00       	add    $0x1400,%eax
f0103835:	c1 e0 03             	shl    $0x3,%eax
f0103838:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f010383b:	83 ec 04             	sub    $0x4,%esp
f010383e:	6a 08                	push   $0x8
f0103840:	ff 75 0c             	pushl  0xc(%ebp)
f0103843:	ff 75 f4             	pushl  -0xc(%ebp)
f0103846:	e8 d0 d4 01 00       	call   f0120d1b <ide_read>
f010384b:	83 c4 10             	add    $0x10,%esp
f010384e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0103851:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0103854:	c9                   	leave  
f0103855:	c3                   	ret    

f0103856 <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0103856:	55                   	push   %ebp
f0103857:	89 e5                	mov    %esp,%ebp
f0103859:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f010385c:	8b 45 08             	mov    0x8(%ebp),%eax
f010385f:	05 00 14 00 00       	add    $0x1400,%eax
f0103864:	c1 e0 03             	shl    $0x3,%eax
f0103867:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f010386a:	83 ec 04             	sub    $0x4,%esp
f010386d:	6a 08                	push   $0x8
f010386f:	ff 75 0c             	pushl  0xc(%ebp)
f0103872:	ff 75 f4             	pushl  -0xc(%ebp)
f0103875:	e8 e1 d5 01 00       	call   f0120e5b <ide_write>
f010387a:	83 c4 10             	add    $0x10,%esp
f010387d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0103880:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103884:	74 14                	je     f010389a <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0103886:	83 ec 04             	sub    $0x4,%esp
f0103889:	68 b6 3f 12 f0       	push   $0xf0123fb6
f010388e:	6a 2f                	push   $0x2f
f0103890:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103895:	e8 80 ca ff ff       	call   f010031a <_panic>
	return success;
f010389a:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010389d:	c9                   	leave  
f010389e:	c3                   	ret    

f010389f <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f010389f:	55                   	push   %ebp
f01038a0:	89 e5                	mov    %esp,%ebp
f01038a2:	53                   	push   %ebx
f01038a3:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f01038a6:	c7 05 e0 50 55 f0 00 	movl   $0x0,0xf05550e0
f01038ad:	00 00 00 
f01038b0:	c7 05 e4 50 55 f0 00 	movl   $0x0,0xf05550e4
f01038b7:	00 00 00 
f01038ba:	c7 05 ec 50 55 f0 00 	movl   $0x0,0xf05550ec
f01038c1:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f01038c4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f01038cb:	e9 e8 00 00 00       	jmp    f01039b8 <initialize_disk_page_file+0x119>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f01038d0:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f01038d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01038d9:	89 d0                	mov    %edx,%eax
f01038db:	01 c0                	add    %eax,%eax
f01038dd:	01 d0                	add    %edx,%eax
f01038df:	c1 e0 03             	shl    $0x3,%eax
f01038e2:	01 c8                	add    %ecx,%eax
f01038e4:	83 ec 0c             	sub    $0xc,%esp
f01038e7:	50                   	push   %eax
f01038e8:	e8 c9 45 00 00       	call   f0107eb6 <initialize_frame_info>
f01038ed:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f01038f0:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f01038f6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01038f9:	89 d0                	mov    %edx,%eax
f01038fb:	01 c0                	add    %eax,%eax
f01038fd:	01 d0                	add    %edx,%eax
f01038ff:	c1 e0 03             	shl    $0x3,%eax
f0103902:	01 c8                	add    %ecx,%eax
f0103904:	85 c0                	test   %eax,%eax
f0103906:	75 14                	jne    f010391c <initialize_disk_page_file+0x7d>
f0103908:	83 ec 04             	sub    $0x4,%esp
f010390b:	68 ec 3f 12 f0       	push   $0xf0123fec
f0103910:	6a 56                	push   $0x56
f0103912:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103917:	e8 fe c9 ff ff       	call   f010031a <_panic>
f010391c:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103922:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103925:	89 d0                	mov    %edx,%eax
f0103927:	01 c0                	add    %eax,%eax
f0103929:	01 d0                	add    %edx,%eax
f010392b:	c1 e0 03             	shl    $0x3,%eax
f010392e:	01 c8                	add    %ecx,%eax
f0103930:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103936:	89 10                	mov    %edx,(%eax)
f0103938:	8b 00                	mov    (%eax),%eax
f010393a:	85 c0                	test   %eax,%eax
f010393c:	74 1f                	je     f010395d <initialize_disk_page_file+0xbe>
f010393e:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103944:	8b 1d c0 22 55 f0    	mov    0xf05522c0,%ebx
f010394a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010394d:	89 c8                	mov    %ecx,%eax
f010394f:	01 c0                	add    %eax,%eax
f0103951:	01 c8                	add    %ecx,%eax
f0103953:	c1 e0 03             	shl    $0x3,%eax
f0103956:	01 d8                	add    %ebx,%eax
f0103958:	89 42 04             	mov    %eax,0x4(%edx)
f010395b:	eb 19                	jmp    f0103976 <initialize_disk_page_file+0xd7>
f010395d:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103963:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103966:	89 d0                	mov    %edx,%eax
f0103968:	01 c0                	add    %eax,%eax
f010396a:	01 d0                	add    %edx,%eax
f010396c:	c1 e0 03             	shl    $0x3,%eax
f010396f:	01 c8                	add    %ecx,%eax
f0103971:	a3 e4 50 55 f0       	mov    %eax,0xf05550e4
f0103976:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f010397c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010397f:	89 d0                	mov    %edx,%eax
f0103981:	01 c0                	add    %eax,%eax
f0103983:	01 d0                	add    %edx,%eax
f0103985:	c1 e0 03             	shl    $0x3,%eax
f0103988:	01 c8                	add    %ecx,%eax
f010398a:	a3 e0 50 55 f0       	mov    %eax,0xf05550e0
f010398f:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103995:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103998:	89 d0                	mov    %edx,%eax
f010399a:	01 c0                	add    %eax,%eax
f010399c:	01 d0                	add    %edx,%eax
f010399e:	c1 e0 03             	shl    $0x3,%eax
f01039a1:	01 c8                	add    %ecx,%eax
f01039a3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01039aa:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f01039af:	40                   	inc    %eax
f01039b0:	a3 ec 50 55 f0       	mov    %eax,0xf05550ec
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f01039b5:	ff 45 f4             	incl   -0xc(%ebp)
f01039b8:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f01039bf:	0f 8e 0b ff ff ff    	jle    f01038d0 <initialize_disk_page_file+0x31>
		initialize_frame_info(&(disk_frames_info[i]));

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}
}
f01039c5:	90                   	nop
f01039c6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01039c9:	c9                   	leave  
f01039ca:	c3                   	ret    

f01039cb <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f01039cb:	55                   	push   %ebp
f01039cc:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f01039ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01039d1:	8b 15 c0 22 55 f0    	mov    0xf05522c0,%edx
f01039d7:	29 d0                	sub    %edx,%eax
f01039d9:	c1 f8 03             	sar    $0x3,%eax
f01039dc:	89 c2                	mov    %eax,%edx
f01039de:	89 d0                	mov    %edx,%eax
f01039e0:	c1 e0 02             	shl    $0x2,%eax
f01039e3:	01 d0                	add    %edx,%eax
f01039e5:	c1 e0 02             	shl    $0x2,%eax
f01039e8:	01 d0                	add    %edx,%eax
f01039ea:	c1 e0 02             	shl    $0x2,%eax
f01039ed:	01 d0                	add    %edx,%eax
f01039ef:	89 c1                	mov    %eax,%ecx
f01039f1:	c1 e1 08             	shl    $0x8,%ecx
f01039f4:	01 c8                	add    %ecx,%eax
f01039f6:	89 c1                	mov    %eax,%ecx
f01039f8:	c1 e1 10             	shl    $0x10,%ecx
f01039fb:	01 c8                	add    %ecx,%eax
f01039fd:	01 c0                	add    %eax,%eax
f01039ff:	01 d0                	add    %edx,%eax
}
f0103a01:	5d                   	pop    %ebp
f0103a02:	c3                   	ret    

f0103a03 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0103a03:	55                   	push   %ebp
f0103a04:	89 e5                	mov    %esp,%ebp
f0103a06:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0103a09:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103a10:	83 ec 0c             	sub    $0xc,%esp
f0103a13:	68 f0 50 55 f0       	push   $0xf05550f0
f0103a18:	e8 63 ad 00 00       	call   f010e780 <acquire_spinlock>
f0103a1d:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0103a20:	a1 e0 50 55 f0       	mov    0xf05550e0,%eax
f0103a25:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0103a28:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103a2c:	75 0c                	jne    f0103a3a <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0103a2e:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0103a35:	e9 a2 00 00 00       	jmp    f0103adc <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0103a3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0103a3e:	75 14                	jne    f0103a54 <allocate_disk_frame+0x51>
f0103a40:	83 ec 04             	sub    $0x4,%esp
f0103a43:	68 0f 40 12 f0       	push   $0xf012400f
f0103a48:	6a 7b                	push   $0x7b
f0103a4a:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103a4f:	e8 c6 c8 ff ff       	call   f010031a <_panic>
f0103a54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a57:	8b 00                	mov    (%eax),%eax
f0103a59:	85 c0                	test   %eax,%eax
f0103a5b:	74 10                	je     f0103a6d <allocate_disk_frame+0x6a>
f0103a5d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a60:	8b 00                	mov    (%eax),%eax
f0103a62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103a65:	8b 52 04             	mov    0x4(%edx),%edx
f0103a68:	89 50 04             	mov    %edx,0x4(%eax)
f0103a6b:	eb 0b                	jmp    f0103a78 <allocate_disk_frame+0x75>
f0103a6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a70:	8b 40 04             	mov    0x4(%eax),%eax
f0103a73:	a3 e4 50 55 f0       	mov    %eax,0xf05550e4
f0103a78:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a7b:	8b 40 04             	mov    0x4(%eax),%eax
f0103a7e:	85 c0                	test   %eax,%eax
f0103a80:	74 0f                	je     f0103a91 <allocate_disk_frame+0x8e>
f0103a82:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a85:	8b 40 04             	mov    0x4(%eax),%eax
f0103a88:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103a8b:	8b 12                	mov    (%edx),%edx
f0103a8d:	89 10                	mov    %edx,(%eax)
f0103a8f:	eb 0a                	jmp    f0103a9b <allocate_disk_frame+0x98>
f0103a91:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a94:	8b 00                	mov    (%eax),%eax
f0103a96:	a3 e0 50 55 f0       	mov    %eax,0xf05550e0
f0103a9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103a9e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0103aa4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103aa7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103aae:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f0103ab3:	48                   	dec    %eax
f0103ab4:	a3 ec 50 55 f0       	mov    %eax,0xf05550ec
			initialize_frame_info(ptr_frame_info);
f0103ab9:	83 ec 0c             	sub    $0xc,%esp
f0103abc:	ff 75 f0             	pushl  -0x10(%ebp)
f0103abf:	e8 f2 43 00 00       	call   f0107eb6 <initialize_frame_info>
f0103ac4:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0103ac7:	83 ec 0c             	sub    $0xc,%esp
f0103aca:	ff 75 f0             	pushl  -0x10(%ebp)
f0103acd:	e8 f9 fe ff ff       	call   f01039cb <to_disk_frame_number>
f0103ad2:	83 c4 10             	add    $0x10,%esp
f0103ad5:	89 c2                	mov    %eax,%edx
f0103ad7:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ada:	89 10                	mov    %edx,(%eax)
		}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103adc:	83 ec 0c             	sub    $0xc,%esp
f0103adf:	68 f0 50 55 f0       	push   $0xf05550f0
f0103ae4:	e8 1e ad 00 00       	call   f010e807 <release_spinlock>
f0103ae9:	83 c4 10             	add    $0x10,%esp

	return ret;
f0103aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103aef:	c9                   	leave  
f0103af0:	c3                   	ret    

f0103af1 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0103af1:	55                   	push   %ebp
f0103af2:	89 e5                	mov    %esp,%ebp
f0103af4:	53                   	push   %ebx
f0103af5:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0103af8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0103afc:	0f 84 ea 00 00 00    	je     f0103bec <free_disk_frame+0xfb>
	acquire_spinlock(&DiskFrameLists.dfllock);
f0103b02:	83 ec 0c             	sub    $0xc,%esp
f0103b05:	68 f0 50 55 f0       	push   $0xf05550f0
f0103b0a:	e8 71 ac 00 00       	call   f010e780 <acquire_spinlock>
f0103b0f:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0103b12:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103b18:	8b 55 08             	mov    0x8(%ebp),%edx
f0103b1b:	89 d0                	mov    %edx,%eax
f0103b1d:	01 c0                	add    %eax,%eax
f0103b1f:	01 d0                	add    %edx,%eax
f0103b21:	c1 e0 03             	shl    $0x3,%eax
f0103b24:	01 c8                	add    %ecx,%eax
f0103b26:	85 c0                	test   %eax,%eax
f0103b28:	75 17                	jne    f0103b41 <free_disk_frame+0x50>
f0103b2a:	83 ec 04             	sub    $0x4,%esp
f0103b2d:	68 ec 3f 12 f0       	push   $0xf0123fec
f0103b32:	68 8e 00 00 00       	push   $0x8e
f0103b37:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103b3c:	e8 d9 c7 ff ff       	call   f010031a <_panic>
f0103b41:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103b47:	8b 55 08             	mov    0x8(%ebp),%edx
f0103b4a:	89 d0                	mov    %edx,%eax
f0103b4c:	01 c0                	add    %eax,%eax
f0103b4e:	01 d0                	add    %edx,%eax
f0103b50:	c1 e0 03             	shl    $0x3,%eax
f0103b53:	01 c8                	add    %ecx,%eax
f0103b55:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103b5b:	89 10                	mov    %edx,(%eax)
f0103b5d:	8b 00                	mov    (%eax),%eax
f0103b5f:	85 c0                	test   %eax,%eax
f0103b61:	74 1f                	je     f0103b82 <free_disk_frame+0x91>
f0103b63:	8b 15 e0 50 55 f0    	mov    0xf05550e0,%edx
f0103b69:	8b 1d c0 22 55 f0    	mov    0xf05522c0,%ebx
f0103b6f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0103b72:	89 c8                	mov    %ecx,%eax
f0103b74:	01 c0                	add    %eax,%eax
f0103b76:	01 c8                	add    %ecx,%eax
f0103b78:	c1 e0 03             	shl    $0x3,%eax
f0103b7b:	01 d8                	add    %ebx,%eax
f0103b7d:	89 42 04             	mov    %eax,0x4(%edx)
f0103b80:	eb 19                	jmp    f0103b9b <free_disk_frame+0xaa>
f0103b82:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103b88:	8b 55 08             	mov    0x8(%ebp),%edx
f0103b8b:	89 d0                	mov    %edx,%eax
f0103b8d:	01 c0                	add    %eax,%eax
f0103b8f:	01 d0                	add    %edx,%eax
f0103b91:	c1 e0 03             	shl    $0x3,%eax
f0103b94:	01 c8                	add    %ecx,%eax
f0103b96:	a3 e4 50 55 f0       	mov    %eax,0xf05550e4
f0103b9b:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103ba1:	8b 55 08             	mov    0x8(%ebp),%edx
f0103ba4:	89 d0                	mov    %edx,%eax
f0103ba6:	01 c0                	add    %eax,%eax
f0103ba8:	01 d0                	add    %edx,%eax
f0103baa:	c1 e0 03             	shl    $0x3,%eax
f0103bad:	01 c8                	add    %ecx,%eax
f0103baf:	a3 e0 50 55 f0       	mov    %eax,0xf05550e0
f0103bb4:	8b 0d c0 22 55 f0    	mov    0xf05522c0,%ecx
f0103bba:	8b 55 08             	mov    0x8(%ebp),%edx
f0103bbd:	89 d0                	mov    %edx,%eax
f0103bbf:	01 c0                	add    %eax,%eax
f0103bc1:	01 d0                	add    %edx,%eax
f0103bc3:	c1 e0 03             	shl    $0x3,%eax
f0103bc6:	01 c8                	add    %ecx,%eax
f0103bc8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0103bcf:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f0103bd4:	40                   	inc    %eax
f0103bd5:	a3 ec 50 55 f0       	mov    %eax,0xf05550ec
	}
	release_spinlock(&DiskFrameLists.dfllock);
f0103bda:	83 ec 0c             	sub    $0xc,%esp
f0103bdd:	68 f0 50 55 f0       	push   $0xf05550f0
f0103be2:	e8 20 ac 00 00       	call   f010e807 <release_spinlock>
f0103be7:	83 c4 10             	add    $0x10,%esp
f0103bea:	eb 01                	jmp    f0103bed <free_disk_frame+0xfc>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f0103bec:	90                   	nop
	acquire_spinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_spinlock(&DiskFrameLists.dfllock);
}
f0103bed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103bf0:	c9                   	leave  
f0103bf1:	c3                   	ret    

f0103bf2 <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f0103bf2:	55                   	push   %ebp
f0103bf3:	89 e5                	mov    %esp,%ebp
f0103bf5:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f0103bf8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103bfb:	c1 e8 16             	shr    $0x16,%eax
f0103bfe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103c05:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c08:	01 d0                	add    %edx,%eax
f0103c0a:	8b 00                	mov    (%eax),%eax
f0103c0c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f0103c0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103c12:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0103c17:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103c1a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103c1d:	c1 e8 0c             	shr    $0xc,%eax
f0103c20:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103c23:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0103c28:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0103c2b:	72 17                	jb     f0103c44 <get_disk_page_table+0x52>
f0103c2d:	ff 75 f0             	pushl  -0x10(%ebp)
f0103c30:	68 30 40 12 f0       	push   $0xf0124030
f0103c35:	68 9d 00 00 00       	push   $0x9d
f0103c3a:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103c3f:	e8 d6 c6 ff ff       	call   f010031a <_panic>
f0103c44:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103c47:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103c4c:	89 c2                	mov    %eax,%edx
f0103c4e:	8b 45 14             	mov    0x14(%ebp),%eax
f0103c51:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0103c53:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103c57:	0f 85 b7 00 00 00    	jne    f0103d14 <get_disk_page_table+0x122>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f0103c5d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0103c61:	0f 84 9d 00 00 00    	je     f0103d04 <get_disk_page_table+0x112>
						,PERM_PRESENT);
			}
#else
			{
				struct FrameInfo* ptr_frame_info;
				allocate_frame(&ptr_frame_info) ;
f0103c67:	83 ec 0c             	sub    $0xc,%esp
f0103c6a:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0103c6d:	50                   	push   %eax
f0103c6e:	e8 5e 42 00 00       	call   f0107ed1 <allocate_frame>
f0103c73:	83 c4 10             	add    $0x10,%esp

				//LOG_STATMENT(cprintf("created table"));
				uint32 phys_page_table = to_physical_address(ptr_frame_info);
f0103c76:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103c79:	83 ec 0c             	sub    $0xc,%esp
f0103c7c:	50                   	push   %eax
f0103c7d:	e8 4c fb ff ff       	call   f01037ce <to_physical_address>
f0103c82:	83 c4 10             	add    $0x10,%esp
f0103c85:	89 45 e8             	mov    %eax,-0x18(%ebp)
				*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f0103c88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103c8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0103c8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103c91:	c1 e8 0c             	shr    $0xc,%eax
f0103c94:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0103c97:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0103c9c:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f0103c9f:	72 17                	jb     f0103cb8 <get_disk_page_table+0xc6>
f0103ca1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103ca4:	68 30 40 12 f0       	push   $0xf0124030
f0103ca9:	68 b9 00 00 00       	push   $0xb9
f0103cae:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103cb3:	e8 62 c6 ff ff       	call   f010031a <_panic>
f0103cb8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103cbb:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103cc0:	89 c2                	mov    %eax,%edx
f0103cc2:	8b 45 14             	mov    0x14(%ebp),%eax
f0103cc5:	89 10                	mov    %edx,(%eax)
				ptr_frame_info->references = 1;
f0103cc7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103cca:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
f0103cd0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cd3:	c1 e8 16             	shr    $0x16,%eax
f0103cd6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0103cdd:	8b 45 08             	mov    0x8(%ebp),%eax
f0103ce0:	01 d0                	add    %edx,%eax
f0103ce2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0103ce5:	83 ca 01             	or     $0x1,%edx
f0103ce8:	89 10                	mov    %edx,(%eax)
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0103cea:	8b 45 14             	mov    0x14(%ebp),%eax
f0103ced:	8b 00                	mov    (%eax),%eax
f0103cef:	83 ec 04             	sub    $0x4,%esp
f0103cf2:	68 00 10 00 00       	push   $0x1000
f0103cf7:	6a 00                	push   $0x0
f0103cf9:	50                   	push   %eax
f0103cfa:	e8 22 ca 01 00       	call   f0120721 <memset>
f0103cff:	83 c4 10             	add    $0x10,%esp
f0103d02:	eb 10                	jmp    f0103d14 <get_disk_page_table+0x122>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f0103d04:	8b 45 14             	mov    0x14(%ebp),%eax
f0103d07:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f0103d0d:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d12:	eb 05                	jmp    f0103d19 <get_disk_page_table+0x127>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f0103d14:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103d19:	c9                   	leave  
f0103d1a:	c3                   	ret    

f0103d1b <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f0103d1b:	55                   	push   %ebp
f0103d1c:	89 e5                	mov    %esp,%ebp
f0103d1e:	83 ec 28             	sub    $0x28,%esp
f0103d21:	8b 45 10             	mov    0x10(%ebp),%eax
f0103d24:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f0103d27:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f0103d2b:	74 72                	je     f0103d9f <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f0103d2d:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0103d34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103d37:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0103d3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0103d3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d42:	ba 00 00 00 00       	mov    $0x0,%edx
f0103d47:	f7 75 f4             	divl   -0xc(%ebp)
f0103d4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103d4d:	29 d0                	sub    %edx,%eax
f0103d4f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0103d52:	73 2f                	jae    f0103d83 <pf_add_empty_env_page+0x68>
f0103d54:	8b 45 08             	mov    0x8(%ebp),%eax
f0103d57:	8b 50 6c             	mov    0x6c(%eax),%edx
f0103d5a:	b8 00 00 00 00       	mov    $0x0,%eax
f0103d5f:	29 d0                	sub    %edx,%eax
f0103d61:	c1 e0 0c             	shl    $0xc,%eax
f0103d64:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0103d69:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0103d6c:	76 15                	jbe    f0103d83 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f0103d6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0103d71:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f0103d77:	8d 50 01             	lea    0x1(%eax),%edx
f0103d7a:	8b 45 08             	mov    0x8(%ebp),%eax
f0103d7d:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0103d83:	a1 b4 4f 55 f0       	mov    0xf0554fb4,%eax
f0103d88:	83 ec 04             	sub    $0x4,%esp
f0103d8b:	50                   	push   %eax
f0103d8c:	ff 75 0c             	pushl  0xc(%ebp)
f0103d8f:	ff 75 08             	pushl  0x8(%ebp)
f0103d92:	e8 b2 00 00 00       	call   f0103e49 <pf_add_env_page>
f0103d97:	83 c4 10             	add    $0x10,%esp
f0103d9a:	e9 a8 00 00 00       	jmp    f0103e47 <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0103d9f:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0103da6:	76 19                	jbe    f0103dc1 <pf_add_empty_env_page+0xa6>
f0103da8:	68 60 40 12 f0       	push   $0xf0124060
f0103dad:	68 86 40 12 f0       	push   $0xf0124086
f0103db2:	68 dc 00 00 00       	push   $0xdc
f0103db7:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103dbc:	e8 59 c5 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0103dc1:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dc4:	83 c0 74             	add    $0x74,%eax
f0103dc7:	83 ec 08             	sub    $0x8,%esp
f0103dca:	50                   	push   %eax
f0103dcb:	ff 75 08             	pushl  0x8(%ebp)
f0103dce:	e8 ce 05 00 00       	call   f01043a1 <get_disk_page_directory>
f0103dd3:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0103dd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0103dd9:	8b 40 74             	mov    0x74(%eax),%eax
f0103ddc:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0103ddf:	52                   	push   %edx
f0103de0:	6a 01                	push   $0x1
f0103de2:	ff 75 0c             	pushl  0xc(%ebp)
f0103de5:	50                   	push   %eax
f0103de6:	e8 07 fe ff ff       	call   f0103bf2 <get_disk_page_table>
f0103deb:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0103dee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103df1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103df4:	c1 ea 0c             	shr    $0xc,%edx
f0103df7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103dfd:	c1 e2 02             	shl    $0x2,%edx
f0103e00:	01 d0                	add    %edx,%eax
f0103e02:	8b 00                	mov    (%eax),%eax
f0103e04:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f0103e07:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103e0a:	85 c0                	test   %eax,%eax
f0103e0c:	75 34                	jne    f0103e42 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0103e0e:	83 ec 0c             	sub    $0xc,%esp
f0103e11:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0103e14:	50                   	push   %eax
f0103e15:	e8 e9 fb ff ff       	call   f0103a03 <allocate_disk_frame>
f0103e1a:	83 c4 10             	add    $0x10,%esp
f0103e1d:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0103e20:	75 07                	jne    f0103e29 <pf_add_empty_env_page+0x10e>
f0103e22:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0103e27:	eb 1e                	jmp    f0103e47 <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0103e29:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103e2c:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103e2f:	c1 ea 0c             	shr    $0xc,%edx
f0103e32:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103e38:	c1 e2 02             	shl    $0x2,%edx
f0103e3b:	01 c2                	add    %eax,%edx
f0103e3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0103e40:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f0103e42:	b8 00 00 00 00       	mov    $0x0,%eax

}
f0103e47:	c9                   	leave  
f0103e48:	c3                   	ret    

f0103e49 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f0103e49:	55                   	push   %ebp
f0103e4a:	89 e5                	mov    %esp,%ebp
f0103e4c:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f0103e4f:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0103e56:	76 19                	jbe    f0103e71 <pf_add_env_page+0x28>
f0103e58:	68 60 40 12 f0       	push   $0xf0124060
f0103e5d:	68 86 40 12 f0       	push   $0xf0124086
f0103e62:	68 f1 00 00 00       	push   $0xf1
f0103e67:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103e6c:	e8 a9 c4 ff ff       	call   f010031a <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0103e71:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e74:	83 c0 74             	add    $0x74,%eax
f0103e77:	83 ec 08             	sub    $0x8,%esp
f0103e7a:	50                   	push   %eax
f0103e7b:	ff 75 08             	pushl  0x8(%ebp)
f0103e7e:	e8 1e 05 00 00       	call   f01043a1 <get_disk_page_directory>
f0103e83:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0103e86:	8b 45 08             	mov    0x8(%ebp),%eax
f0103e89:	8b 40 74             	mov    0x74(%eax),%eax
f0103e8c:	8d 55 f0             	lea    -0x10(%ebp),%edx
f0103e8f:	52                   	push   %edx
f0103e90:	6a 01                	push   $0x1
f0103e92:	ff 75 0c             	pushl  0xc(%ebp)
f0103e95:	50                   	push   %eax
f0103e96:	e8 57 fd ff ff       	call   f0103bf2 <get_disk_page_table>
f0103e9b:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0103e9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103ea1:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103ea4:	c1 ea 0c             	shr    $0xc,%edx
f0103ea7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103ead:	c1 e2 02             	shl    $0x2,%edx
f0103eb0:	01 d0                	add    %edx,%eax
f0103eb2:	8b 00                	mov    (%eax),%eax
f0103eb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0103eb7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103eba:	85 c0                	test   %eax,%eax
f0103ebc:	75 34                	jne    f0103ef2 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0103ebe:	83 ec 0c             	sub    $0xc,%esp
f0103ec1:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0103ec4:	50                   	push   %eax
f0103ec5:	e8 39 fb ff ff       	call   f0103a03 <allocate_disk_frame>
f0103eca:	83 c4 10             	add    $0x10,%esp
f0103ecd:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0103ed0:	75 07                	jne    f0103ed9 <pf_add_env_page+0x90>
f0103ed2:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0103ed7:	eb 31                	jmp    f0103f0a <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0103ed9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103edc:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103edf:	c1 ea 0c             	shr    $0xc,%edx
f0103ee2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103ee8:	c1 e2 02             	shl    $0x2,%edx
f0103eeb:	01 c2                	add    %eax,%edx
f0103eed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103ef0:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f0103ef2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103ef5:	83 ec 08             	sub    $0x8,%esp
f0103ef8:	ff 75 10             	pushl  0x10(%ebp)
f0103efb:	50                   	push   %eax
f0103efc:	e8 55 f9 ff ff       	call   f0103856 <write_disk_page>
f0103f01:	83 c4 10             	add    $0x10,%esp
f0103f04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f0103f07:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0103f0a:	c9                   	leave  
f0103f0b:	c3                   	ret    

f0103f0c <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f0103f0c:	55                   	push   %ebp
f0103f0d:	89 e5                	mov    %esp,%ebp
f0103f0f:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f0103f12:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0103f19:	76 19                	jbe    f0103f34 <pf_update_env_page+0x28>
f0103f1b:	68 60 40 12 f0       	push   $0xf0124060
f0103f20:	68 86 40 12 f0       	push   $0xf0124086
f0103f25:	68 13 01 00 00       	push   $0x113
f0103f2a:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0103f2f:	e8 e6 c3 ff ff       	call   f010031a <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f0103f34:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f37:	83 c0 74             	add    $0x74,%eax
f0103f3a:	83 ec 08             	sub    $0x8,%esp
f0103f3d:	50                   	push   %eax
f0103f3e:	ff 75 08             	pushl  0x8(%ebp)
f0103f41:	e8 5b 04 00 00       	call   f01043a1 <get_disk_page_directory>
f0103f46:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0103f49:	8b 45 08             	mov    0x8(%ebp),%eax
f0103f4c:	8b 40 74             	mov    0x74(%eax),%eax
f0103f4f:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0103f52:	52                   	push   %edx
f0103f53:	6a 00                	push   $0x0
f0103f55:	ff 75 0c             	pushl  0xc(%ebp)
f0103f58:	50                   	push   %eax
f0103f59:	e8 94 fc ff ff       	call   f0103bf2 <get_disk_page_table>
f0103f5e:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f0103f61:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103f64:	85 c0                	test   %eax,%eax
f0103f66:	74 29                	je     f0103f91 <pf_update_env_page+0x85>
f0103f68:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103f6b:	85 c0                	test   %eax,%eax
f0103f6d:	0f 84 c5 00 00 00    	je     f0104038 <pf_update_env_page+0x12c>
f0103f73:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103f76:	8b 55 0c             	mov    0xc(%ebp),%edx
f0103f79:	c1 ea 0c             	shr    $0xc,%edx
f0103f7c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0103f82:	c1 e2 02             	shl    $0x2,%edx
f0103f85:	01 d0                	add    %edx,%eax
f0103f87:	8b 00                	mov    (%eax),%eax
f0103f89:	85 c0                	test   %eax,%eax
f0103f8b:	0f 85 a7 00 00 00    	jne    f0104038 <pf_update_env_page+0x12c>
	{

		uint32 VA = (uint32)virtual_address ;
f0103f91:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f94:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if ((VA >= USER_HEAP_START && VA < USER_HEAP_MAX) || (VA >= USTACKBOTTOM && VA < USTACKTOP))
f0103f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103f9a:	85 c0                	test   %eax,%eax
f0103f9c:	79 09                	jns    f0103fa7 <pf_update_env_page+0x9b>
f0103f9e:	81 7d f4 ff ff ff 9f 	cmpl   $0x9fffffff,-0xc(%ebp)
f0103fa5:	76 30                	jbe    f0103fd7 <pf_update_env_page+0xcb>
f0103fa7:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0103fae:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103fb1:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f0103fb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103fb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103fbc:	ba 00 00 00 00       	mov    $0x0,%edx
f0103fc1:	f7 75 f0             	divl   -0x10(%ebp)
f0103fc4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0103fc7:	29 d0                	sub    %edx,%eax
f0103fc9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0103fcc:	77 53                	ja     f0104021 <pf_update_env_page+0x115>
f0103fce:	81 7d f4 ff df bf ee 	cmpl   $0xeebfdfff,-0xc(%ebp)
f0103fd5:	77 4a                	ja     f0104021 <pf_update_env_page+0x115>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, VA, 0);
f0103fd7:	83 ec 04             	sub    $0x4,%esp
f0103fda:	6a 00                	push   $0x0
f0103fdc:	ff 75 f4             	pushl  -0xc(%ebp)
f0103fdf:	ff 75 08             	pushl  0x8(%ebp)
f0103fe2:	e8 34 fd ff ff       	call   f0103d1b <pf_add_empty_env_page>
f0103fe7:	83 c4 10             	add    $0x10,%esp
f0103fea:	89 45 e8             	mov    %eax,-0x18(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f0103fed:	83 7d e8 f8          	cmpl   $0xfffffff8,-0x18(%ebp)
f0103ff1:	75 17                	jne    f010400a <pf_update_env_page+0xfe>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f0103ff3:	83 ec 04             	sub    $0x4,%esp
f0103ff6:	68 9c 40 12 f0       	push   $0xf012409c
f0103ffb:	68 43 01 00 00       	push   $0x143
f0104000:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0104005:	e8 10 c3 ff ff       	call   f010031a <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f010400a:	8b 45 08             	mov    0x8(%ebp),%eax
f010400d:	8b 80 64 da 01 00    	mov    0x1da64(%eax),%eax
f0104013:	8d 50 01             	lea    0x1(%eax),%edx
f0104016:	8b 45 08             	mov    0x8(%ebp),%eax
f0104019:	89 90 64 da 01 00    	mov    %edx,0x1da64(%eax)
f010401f:	eb 17                	jmp    f0104038 <pf_update_env_page+0x12c>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f0104021:	83 ec 04             	sub    $0x4,%esp
f0104024:	68 e8 40 12 f0       	push   $0xf01240e8
f0104029:	68 4c 01 00 00       	push   $0x14c
f010402e:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0104033:	e8 e2 c2 ff ff       	call   f010031a <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0104038:	8b 45 08             	mov    0x8(%ebp),%eax
f010403b:	8b 40 74             	mov    0x74(%eax),%eax
f010403e:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0104041:	52                   	push   %edx
f0104042:	6a 00                	push   $0x0
f0104044:	ff 75 0c             	pushl  0xc(%ebp)
f0104047:	50                   	push   %eax
f0104048:	e8 a5 fb ff ff       	call   f0103bf2 <get_disk_page_table>
f010404d:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0104050:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0104053:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104056:	c1 ea 0c             	shr    $0xc,%edx
f0104059:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010405f:	c1 e2 02             	shl    $0x2,%edx
f0104062:	01 d0                	add    %edx,%eax
f0104064:	8b 00                	mov    (%eax),%eax
f0104066:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//cprintf("[%s] updating page\n",ptr_env->prog_name);
	}
#else
	{
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
f0104069:	83 ec 0c             	sub    $0xc,%esp
f010406c:	ff 75 10             	pushl  0x10(%ebp)
f010406f:	e8 5a f7 ff ff       	call   f01037ce <to_physical_address>
f0104074:	83 c4 10             	add    $0x10,%esp
f0104077:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010407a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010407d:	c1 e8 0c             	shr    $0xc,%eax
f0104080:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0104083:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0104088:	39 45 dc             	cmp    %eax,-0x24(%ebp)
f010408b:	72 17                	jb     f01040a4 <pf_update_env_page+0x198>
f010408d:	ff 75 e0             	pushl  -0x20(%ebp)
f0104090:	68 30 40 12 f0       	push   $0xf0124030
f0104095:	68 68 01 00 00       	push   $0x168
f010409a:	68 cd 3f 12 f0       	push   $0xf0123fcd
f010409f:	e8 76 c2 ff ff       	call   f010031a <_panic>
f01040a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01040a7:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01040ac:	83 ec 08             	sub    $0x8,%esp
f01040af:	50                   	push   %eax
f01040b0:	ff 75 e4             	pushl  -0x1c(%ebp)
f01040b3:	e8 9e f7 ff ff       	call   f0103856 <write_disk_page>
f01040b8:	83 c4 10             	add    $0x10,%esp
f01040bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f01040be:	8b 45 08             	mov    0x8(%ebp),%eax
f01040c1:	8b 80 60 da 01 00    	mov    0x1da60(%eax),%eax
f01040c7:	8d 50 01             	lea    0x1(%eax),%edx
f01040ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01040cd:	89 90 60 da 01 00    	mov    %edx,0x1da60(%eax)
	//======================

	return ret;
f01040d3:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f01040d6:	c9                   	leave  
f01040d7:	c3                   	ret    

f01040d8 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f01040d8:	55                   	push   %ebp
f01040d9:	89 e5                	mov    %esp,%ebp
f01040db:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f01040de:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040e1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01040e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01040e7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01040ec:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01040ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01040f2:	8b 40 74             	mov    0x74(%eax),%eax
f01040f5:	85 c0                	test   %eax,%eax
f01040f7:	75 0a                	jne    f0104103 <pf_read_env_page+0x2b>
f01040f9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01040fe:	e9 90 00 00 00       	jmp    f0104193 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f0104103:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104106:	8b 45 08             	mov    0x8(%ebp),%eax
f0104109:	8b 40 74             	mov    0x74(%eax),%eax
f010410c:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f010410f:	51                   	push   %ecx
f0104110:	6a 00                	push   $0x0
f0104112:	52                   	push   %edx
f0104113:	50                   	push   %eax
f0104114:	e8 d9 fa ff ff       	call   f0103bf2 <get_disk_page_table>
f0104119:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f010411c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010411f:	85 c0                	test   %eax,%eax
f0104121:	75 07                	jne    f010412a <pf_read_env_page+0x52>
f0104123:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f0104128:	eb 69                	jmp    f0104193 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010412a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010412d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104130:	c1 ea 0c             	shr    $0xc,%edx
f0104133:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0104139:	c1 e2 02             	shl    $0x2,%edx
f010413c:	01 d0                	add    %edx,%eax
f010413e:	8b 00                	mov    (%eax),%eax
f0104140:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0104143:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104147:	75 07                	jne    f0104150 <pf_read_env_page+0x78>
f0104149:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010414e:	eb 43                	jmp    f0104193 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f0104150:	83 ec 08             	sub    $0x8,%esp
f0104153:	ff 75 0c             	pushl  0xc(%ebp)
f0104156:	ff 75 f0             	pushl  -0x10(%ebp)
f0104159:	e8 c9 f6 ff ff       	call   f0103827 <read_disk_page>
f010415e:	83 c4 10             	add    $0x10,%esp
f0104161:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0104164:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104167:	8b 45 08             	mov    0x8(%ebp),%eax
f010416a:	8b 40 64             	mov    0x64(%eax),%eax
f010416d:	6a 40                	push   $0x40
f010416f:	6a 00                	push   $0x0
f0104171:	52                   	push   %edx
f0104172:	50                   	push   %eax
f0104173:	e8 b1 46 00 00       	call   f0108829 <pt_set_page_permissions>
f0104178:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010417b:	8b 45 08             	mov    0x8(%ebp),%eax
f010417e:	8b 80 5c da 01 00    	mov    0x1da5c(%eax),%eax
f0104184:	8d 50 01             	lea    0x1(%eax),%edx
f0104187:	8b 45 08             	mov    0x8(%ebp),%eax
f010418a:	89 90 5c da 01 00    	mov    %edx,0x1da5c(%eax)
	//======================

	return disk_read_error;
f0104190:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104193:	c9                   	leave  
f0104194:	c3                   	ret    

f0104195 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0104195:	55                   	push   %ebp
f0104196:	89 e5                	mov    %esp,%ebp
f0104198:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010419b:	8b 45 08             	mov    0x8(%ebp),%eax
f010419e:	8b 40 74             	mov    0x74(%eax),%eax
f01041a1:	85 c0                	test   %eax,%eax
f01041a3:	74 62                	je     f0104207 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01041a5:	8b 45 08             	mov    0x8(%ebp),%eax
f01041a8:	8b 40 74             	mov    0x74(%eax),%eax
f01041ab:	8d 55 f0             	lea    -0x10(%ebp),%edx
f01041ae:	52                   	push   %edx
f01041af:	6a 00                	push   $0x0
f01041b1:	ff 75 0c             	pushl  0xc(%ebp)
f01041b4:	50                   	push   %eax
f01041b5:	e8 38 fa ff ff       	call   f0103bf2 <get_disk_page_table>
f01041ba:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f01041bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041c0:	85 c0                	test   %eax,%eax
f01041c2:	74 46                	je     f010420a <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01041c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041c7:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041ca:	c1 ea 0c             	shr    $0xc,%edx
f01041cd:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041d3:	c1 e2 02             	shl    $0x2,%edx
f01041d6:	01 d0                	add    %edx,%eax
f01041d8:	8b 00                	mov    (%eax),%eax
f01041da:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f01041dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01041e0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01041e3:	c1 ea 0c             	shr    $0xc,%edx
f01041e6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01041ec:	c1 e2 02             	shl    $0x2,%edx
f01041ef:	01 d0                	add    %edx,%eax
f01041f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01041f7:	83 ec 0c             	sub    $0xc,%esp
f01041fa:	ff 75 f4             	pushl  -0xc(%ebp)
f01041fd:	e8 ef f8 ff ff       	call   f0103af1 <free_disk_frame>
f0104202:	83 c4 10             	add    $0x10,%esp
f0104205:	eb 04                	jmp    f010420b <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f0104207:	90                   	nop
f0104208:	eb 01                	jmp    f010420b <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f010420a:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f010420b:	c9                   	leave  
f010420c:	c3                   	ret    

f010420d <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f010420d:	55                   	push   %ebp
f010420e:	89 e5                	mov    %esp,%ebp
f0104210:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0104213:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010421a:	e9 ee 00 00 00       	jmp    f010430d <pf_free_env+0x100>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f010421f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104222:	8b 40 74             	mov    0x74(%eax),%eax
f0104225:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104228:	c1 e2 02             	shl    $0x2,%edx
f010422b:	01 d0                	add    %edx,%eax
f010422d:	8b 00                	mov    (%eax),%eax
f010422f:	83 e0 01             	and    $0x1,%eax
f0104232:	85 c0                	test   %eax,%eax
f0104234:	0f 84 cf 00 00 00    	je     f0104309 <pf_free_env+0xfc>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f010423a:	8b 45 08             	mov    0x8(%ebp),%eax
f010423d:	8b 40 74             	mov    0x74(%eax),%eax
f0104240:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104243:	c1 e2 02             	shl    $0x2,%edx
f0104246:	01 d0                	add    %edx,%eax
f0104248:	8b 00                	mov    (%eax),%eax
f010424a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010424f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f0104252:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104255:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0104258:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010425b:	c1 e8 0c             	shr    $0xc,%eax
f010425e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0104261:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0104266:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0104269:	72 17                	jb     f0104282 <pf_free_env+0x75>
f010426b:	ff 75 e8             	pushl  -0x18(%ebp)
f010426e:	68 30 40 12 f0       	push   $0xf0124030
f0104273:	68 c8 01 00 00       	push   $0x1c8
f0104278:	68 cd 3f 12 f0       	push   $0xf0123fcd
f010427d:	e8 98 c0 ff ff       	call   f010031a <_panic>
f0104282:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104285:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010428a:	89 45 e0             	mov    %eax,-0x20(%ebp)
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f010428d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0104294:	eb 3a                	jmp    f01042d0 <pf_free_env+0xc3>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f0104296:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104299:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01042a3:	01 d0                	add    %edx,%eax
f01042a5:	8b 00                	mov    (%eax),%eax
f01042a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
			pt[pteno] = 0;
f01042aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042ad:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01042b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01042b7:	01 d0                	add    %edx,%eax
f01042b9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f01042bf:	83 ec 0c             	sub    $0xc,%esp
f01042c2:	ff 75 dc             	pushl  -0x24(%ebp)
f01042c5:	e8 27 f8 ff ff       	call   f0103af1 <free_disk_frame>
f01042ca:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f01042cd:	ff 45 f0             	incl   -0x10(%ebp)
f01042d0:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f01042d7:	76 bd                	jbe    f0104296 <pf_free_env+0x89>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f01042d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01042dc:	8b 40 74             	mov    0x74(%eax),%eax
f01042df:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01042e2:	c1 e2 02             	shl    $0x2,%edx
f01042e5:	01 d0                	add    %edx,%eax
f01042e7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		{
			kfree(pt);
		}
#else
		{
			decrement_references(to_frame_info(pa));
f01042ed:	83 ec 0c             	sub    $0xc,%esp
f01042f0:	ff 75 ec             	pushl  -0x14(%ebp)
f01042f3:	e8 e9 f4 ff ff       	call   f01037e1 <to_frame_info>
f01042f8:	83 c4 10             	add    $0x10,%esp
f01042fb:	83 ec 0c             	sub    $0xc,%esp
f01042fe:	50                   	push   %eax
f01042ff:	e8 da 3d 00 00       	call   f01080de <decrement_references>
f0104304:	83 c4 10             	add    $0x10,%esp
f0104307:	eb 01                	jmp    f010430a <pf_free_env+0xfd>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0104309:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010430a:	ff 45 f4             	incl   -0xc(%ebp)
f010430d:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104314:	0f 86 05 ff ff ff    	jbe    f010421f <pf_free_env+0x12>
	{
		kfree(ptr_env->disk_env_pgdir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
f010431a:	8b 45 08             	mov    0x8(%ebp),%eax
f010431d:	8b 40 78             	mov    0x78(%eax),%eax
f0104320:	83 ec 0c             	sub    $0xc,%esp
f0104323:	50                   	push   %eax
f0104324:	e8 b8 f4 ff ff       	call   f01037e1 <to_frame_info>
f0104329:	83 c4 10             	add    $0x10,%esp
f010432c:	83 ec 0c             	sub    $0xc,%esp
f010432f:	50                   	push   %eax
f0104330:	e8 a9 3d 00 00       	call   f01080de <decrement_references>
f0104335:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f0104338:	8b 45 08             	mov    0x8(%ebp),%eax
f010433b:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f0104342:	8b 45 08             	mov    0x8(%ebp),%eax
f0104345:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f010434c:	8b 45 08             	mov    0x8(%ebp),%eax
f010434f:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104352:	85 c0                	test   %eax,%eax
f0104354:	74 48                	je     f010439e <pf_free_env+0x191>
		return;
	__pf_remove_env_all_tables(ptr_env);
f0104356:	83 ec 0c             	sub    $0xc,%esp
f0104359:	ff 75 08             	pushl  0x8(%ebp)
f010435c:	e8 dd 03 00 00       	call   f010473e <__pf_remove_env_all_tables>
f0104361:	83 c4 10             	add    $0x10,%esp
	{
		kfree(ptr_env->disk_env_tabledir);
	}
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
f0104364:	8b 45 08             	mov    0x8(%ebp),%eax
f0104367:	8b 80 80 00 00 00    	mov    0x80(%eax),%eax
f010436d:	83 ec 0c             	sub    $0xc,%esp
f0104370:	50                   	push   %eax
f0104371:	e8 6b f4 ff ff       	call   f01037e1 <to_frame_info>
f0104376:	83 c4 10             	add    $0x10,%esp
f0104379:	83 ec 0c             	sub    $0xc,%esp
f010437c:	50                   	push   %eax
f010437d:	e8 5c 3d 00 00       	call   f01080de <decrement_references>
f0104382:	83 c4 10             	add    $0x10,%esp
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f0104385:	8b 45 08             	mov    0x8(%ebp),%eax
f0104388:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f010438f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104392:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0104399:	00 00 00 
f010439c:	eb 01                	jmp    f010439f <pf_free_env+0x192>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010439e:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010439f:	c9                   	leave  
f01043a0:	c3                   	ret    

f01043a1 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f01043a1:	55                   	push   %ebp
f01043a2:	89 e5                	mov    %esp,%ebp
f01043a4:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f01043a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01043aa:	8b 50 74             	mov    0x74(%eax),%edx
f01043ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043b0:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f01043b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043b5:	8b 00                	mov    (%eax),%eax
f01043b7:	85 c0                	test   %eax,%eax
f01043b9:	0f 85 aa 00 00 00    	jne    f0104469 <get_disk_page_directory+0xc8>
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f01043bf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f01043c6:	83 ec 0c             	sub    $0xc,%esp
f01043c9:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01043cc:	50                   	push   %eax
f01043cd:	e8 ff 3a 00 00       	call   f0107ed1 <allocate_frame>
f01043d2:	83 c4 10             	add    $0x10,%esp
f01043d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01043d8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01043dc:	79 08                	jns    f01043e6 <get_disk_page_directory+0x45>
				return r;
f01043de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01043e1:	e9 88 00 00 00       	jmp    f010446e <get_disk_page_directory+0xcd>
			p->references = 1;
f01043e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01043e9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f01043ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01043f2:	83 ec 0c             	sub    $0xc,%esp
f01043f5:	50                   	push   %eax
f01043f6:	e8 d3 f3 ff ff       	call   f01037ce <to_physical_address>
f01043fb:	83 c4 10             	add    $0x10,%esp
f01043fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0104401:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104404:	c1 e8 0c             	shr    $0xc,%eax
f0104407:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010440a:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010440f:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0104412:	72 17                	jb     f010442b <get_disk_page_directory+0x8a>
f0104414:	ff 75 f0             	pushl  -0x10(%ebp)
f0104417:	68 30 40 12 f0       	push   $0xf0124030
f010441c:	68 20 02 00 00       	push   $0x220
f0104421:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0104426:	e8 ef be ff ff       	call   f010031a <_panic>
f010442b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010442e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104433:	89 c2                	mov    %eax,%edx
f0104435:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104438:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
f010443a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010443d:	83 ec 0c             	sub    $0xc,%esp
f0104440:	50                   	push   %eax
f0104441:	e8 88 f3 ff ff       	call   f01037ce <to_physical_address>
f0104446:	83 c4 10             	add    $0x10,%esp
f0104449:	89 c2                	mov    %eax,%edx
f010444b:	8b 45 08             	mov    0x8(%ebp),%eax
f010444e:	89 50 78             	mov    %edx,0x78(%eax)
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f0104451:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104454:	8b 00                	mov    (%eax),%eax
f0104456:	83 ec 04             	sub    $0x4,%esp
f0104459:	68 00 10 00 00       	push   $0x1000
f010445e:	6a 00                	push   $0x0
f0104460:	50                   	push   %eax
f0104461:	e8 bb c2 01 00       	call   f0120721 <memset>
f0104466:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0104469:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010446e:	c9                   	leave  
f010446f:	c3                   	ret    

f0104470 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0104470:	55                   	push   %ebp
f0104471:	89 e5                	mov    %esp,%ebp
f0104473:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f0104476:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010447d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104484:	e9 a6 00 00 00       	jmp    f010452f <pf_calculate_allocated_pages+0xbf>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f0104489:	8b 45 08             	mov    0x8(%ebp),%eax
f010448c:	8b 40 74             	mov    0x74(%eax),%eax
f010448f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104492:	c1 e2 02             	shl    $0x2,%edx
f0104495:	01 d0                	add    %edx,%eax
f0104497:	8b 00                	mov    (%eax),%eax
f0104499:	83 e0 01             	and    $0x1,%eax
f010449c:	85 c0                	test   %eax,%eax
f010449e:	0f 84 87 00 00 00    	je     f010452b <pf_calculate_allocated_pages+0xbb>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01044a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01044a7:	8b 40 74             	mov    0x74(%eax),%eax
f01044aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01044ad:	c1 e2 02             	shl    $0x2,%edx
f01044b0:	01 d0                	add    %edx,%eax
f01044b2:	8b 00                	mov    (%eax),%eax
f01044b4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01044b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
		{
			pt = (uint32*) kheap_virtual_address(pa);
		}
#else
		{
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
f01044bc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01044bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01044c2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01044c5:	c1 e8 0c             	shr    $0xc,%eax
f01044c8:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01044cb:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01044d0:	39 45 e0             	cmp    %eax,-0x20(%ebp)
f01044d3:	72 17                	jb     f01044ec <pf_calculate_allocated_pages+0x7c>
f01044d5:	ff 75 e4             	pushl  -0x1c(%ebp)
f01044d8:	68 30 40 12 f0       	push   $0xf0124030
f01044dd:	68 40 02 00 00       	push   $0x240
f01044e2:	68 cd 3f 12 f0       	push   $0xf0123fcd
f01044e7:	e8 2e be ff ff       	call   f010031a <_panic>
f01044ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01044ef:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01044f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01044f7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01044fe:	eb 20                	jmp    f0104520 <pf_calculate_allocated_pages+0xb0>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f0104500:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104503:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010450a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010450d:	01 d0                	add    %edx,%eax
f010450f:	8b 00                	mov    (%eax),%eax
f0104511:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if(dfn != 0)
f0104514:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0104518:	74 03                	je     f010451d <pf_calculate_allocated_pages+0xad>
				counter ++;
f010451a:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f010451d:	ff 45 ec             	incl   -0x14(%ebp)
f0104520:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f0104527:	76 d7                	jbe    f0104500 <pf_calculate_allocated_pages+0x90>
f0104529:	eb 01                	jmp    f010452c <pf_calculate_allocated_pages+0xbc>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f010452b:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f010452c:	ff 45 f4             	incl   -0xc(%ebp)
f010452f:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104536:	0f 86 4d ff ff ff    	jbe    f0104489 <pf_calculate_allocated_pages+0x19>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f010453c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010453f:	c9                   	leave  
f0104540:	c3                   	ret    

f0104541 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0104541:	55                   	push   %ebp
f0104542:	89 e5                	mov    %esp,%ebp
f0104544:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_spinlock(&DiskFrameLists.dfllock);
f0104547:	83 ec 0c             	sub    $0xc,%esp
f010454a:	68 f0 50 55 f0       	push   $0xf05550f0
f010454f:	e8 2c a2 00 00       	call   f010e780 <acquire_spinlock>
f0104554:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f0104557:	a1 ec 50 55 f0       	mov    0xf05550ec,%eax
f010455c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_spinlock(&DiskFrameLists.dfllock);
f010455f:	83 ec 0c             	sub    $0xc,%esp
f0104562:	68 f0 50 55 f0       	push   $0xf05550f0
f0104567:	e8 9b a2 00 00       	call   f010e807 <release_spinlock>
f010456c:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f010456f:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f0104572:	c9                   	leave  
f0104573:	c3                   	ret    

f0104574 <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f0104574:	55                   	push   %ebp
f0104575:	89 e5                	mov    %esp,%ebp
f0104577:	83 ec 18             	sub    $0x18,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f010457a:	8b 45 08             	mov    0x8(%ebp),%eax
f010457d:	8b 50 7c             	mov    0x7c(%eax),%edx
f0104580:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104583:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f0104585:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104588:	8b 00                	mov    (%eax),%eax
f010458a:	85 c0                	test   %eax,%eax
f010458c:	0f 85 ad 00 00 00    	jne    f010463f <get_disk_table_directory+0xcb>
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
		}
#else
		{
			int r;
			struct FrameInfo *p = NULL;
f0104592:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

			if ((r = allocate_frame(&p)) < 0)
f0104599:	83 ec 0c             	sub    $0xc,%esp
f010459c:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010459f:	50                   	push   %eax
f01045a0:	e8 2c 39 00 00       	call   f0107ed1 <allocate_frame>
f01045a5:	83 c4 10             	add    $0x10,%esp
f01045a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01045ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01045af:	79 08                	jns    f01045b9 <get_disk_table_directory+0x45>
				return r;
f01045b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01045b4:	e9 8b 00 00 00       	jmp    f0104644 <get_disk_table_directory+0xd0>
			p->references = 1;
f01045b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01045bc:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

			//[4] initialize the new environment by the virtual address of the page directory
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f01045c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01045c5:	83 ec 0c             	sub    $0xc,%esp
f01045c8:	50                   	push   %eax
f01045c9:	e8 00 f2 ff ff       	call   f01037ce <to_physical_address>
f01045ce:	83 c4 10             	add    $0x10,%esp
f01045d1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01045d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01045d7:	c1 e8 0c             	shr    $0xc,%eax
f01045da:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01045dd:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01045e2:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01045e5:	72 17                	jb     f01045fe <get_disk_table_directory+0x8a>
f01045e7:	ff 75 f0             	pushl  -0x10(%ebp)
f01045ea:	68 30 40 12 f0       	push   $0xf0124030
f01045ef:	68 83 02 00 00       	push   $0x283
f01045f4:	68 cd 3f 12 f0       	push   $0xf0123fcd
f01045f9:	e8 1c bd ff ff       	call   f010031a <_panic>
f01045fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104601:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0104606:	89 c2                	mov    %eax,%edx
f0104608:	8b 45 0c             	mov    0xc(%ebp),%eax
f010460b:	89 10                	mov    %edx,(%eax)
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
f010460d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104610:	83 ec 0c             	sub    $0xc,%esp
f0104613:	50                   	push   %eax
f0104614:	e8 b5 f1 ff ff       	call   f01037ce <to_physical_address>
f0104619:	83 c4 10             	add    $0x10,%esp
f010461c:	89 c2                	mov    %eax,%edx
f010461e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104621:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f0104627:	8b 45 0c             	mov    0xc(%ebp),%eax
f010462a:	8b 00                	mov    (%eax),%eax
f010462c:	83 ec 04             	sub    $0x4,%esp
f010462f:	68 00 10 00 00       	push   $0x1000
f0104634:	6a 00                	push   $0x0
f0104636:	50                   	push   %eax
f0104637:	e8 e5 c0 01 00       	call   f0120721 <memset>
f010463c:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f010463f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104644:	c9                   	leave  
f0104645:	c3                   	ret    

f0104646 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0104646:	55                   	push   %ebp
f0104647:	89 e5                	mov    %esp,%ebp
f0104649:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f010464c:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0104653:	76 19                	jbe    f010466e <__pf_write_env_table+0x28>
f0104655:	68 60 40 12 f0       	push   $0xf0124060
f010465a:	68 86 40 12 f0       	push   $0xf0124086
f010465f:	68 91 02 00 00       	push   $0x291
f0104664:	68 cd 3f 12 f0       	push   $0xf0123fcd
f0104669:	e8 ac bc ff ff       	call   f010031a <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f010466e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104671:	83 c0 7c             	add    $0x7c,%eax
f0104674:	83 ec 08             	sub    $0x8,%esp
f0104677:	50                   	push   %eax
f0104678:	ff 75 08             	pushl  0x8(%ebp)
f010467b:	e8 f4 fe ff ff       	call   f0104574 <get_disk_table_directory>
f0104680:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104683:	8b 45 08             	mov    0x8(%ebp),%eax
f0104686:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104689:	8b 55 0c             	mov    0xc(%ebp),%edx
f010468c:	c1 ea 16             	shr    $0x16,%edx
f010468f:	c1 e2 02             	shl    $0x2,%edx
f0104692:	01 d0                	add    %edx,%eax
f0104694:	8b 00                	mov    (%eax),%eax
f0104696:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0104699:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010469c:	85 c0                	test   %eax,%eax
f010469e:	75 31                	jne    f01046d1 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01046a0:	83 ec 0c             	sub    $0xc,%esp
f01046a3:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01046a6:	50                   	push   %eax
f01046a7:	e8 57 f3 ff ff       	call   f0103a03 <allocate_disk_frame>
f01046ac:	83 c4 10             	add    $0x10,%esp
f01046af:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01046b2:	75 07                	jne    f01046bb <__pf_write_env_table+0x75>
f01046b4:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01046b9:	eb 2e                	jmp    f01046e9 <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f01046bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01046be:	8b 40 7c             	mov    0x7c(%eax),%eax
f01046c1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01046c4:	c1 ea 16             	shr    $0x16,%edx
f01046c7:	c1 e2 02             	shl    $0x2,%edx
f01046ca:	01 c2                	add    %eax,%edx
f01046cc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01046cf:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f01046d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01046d4:	83 ec 08             	sub    $0x8,%esp
f01046d7:	ff 75 10             	pushl  0x10(%ebp)
f01046da:	50                   	push   %eax
f01046db:	e8 76 f1 ff ff       	call   f0103856 <write_disk_page>
f01046e0:	83 c4 10             	add    $0x10,%esp
f01046e3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f01046e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01046e9:	c9                   	leave  
f01046ea:	c3                   	ret    

f01046eb <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01046eb:	55                   	push   %ebp
f01046ec:	89 e5                	mov    %esp,%ebp
f01046ee:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f01046f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01046f4:	8b 40 7c             	mov    0x7c(%eax),%eax
f01046f7:	85 c0                	test   %eax,%eax
f01046f9:	75 07                	jne    f0104702 <__pf_read_env_table+0x17>
f01046fb:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104700:	eb 3a                	jmp    f010473c <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0104702:	8b 45 08             	mov    0x8(%ebp),%eax
f0104705:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104708:	8b 55 0c             	mov    0xc(%ebp),%edx
f010470b:	c1 ea 16             	shr    $0x16,%edx
f010470e:	c1 e2 02             	shl    $0x2,%edx
f0104711:	01 d0                	add    %edx,%eax
f0104713:	8b 00                	mov    (%eax),%eax
f0104715:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0104718:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010471c:	75 07                	jne    f0104725 <__pf_read_env_table+0x3a>
f010471e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0104723:	eb 17                	jmp    f010473c <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0104725:	83 ec 08             	sub    $0x8,%esp
f0104728:	ff 75 10             	pushl  0x10(%ebp)
f010472b:	ff 75 f4             	pushl  -0xc(%ebp)
f010472e:	e8 f4 f0 ff ff       	call   f0103827 <read_disk_page>
f0104733:	83 c4 10             	add    $0x10,%esp
f0104736:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0104739:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010473c:	c9                   	leave  
f010473d:	c3                   	ret    

f010473e <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f010473e:	55                   	push   %ebp
f010473f:	89 e5                	mov    %esp,%ebp
f0104741:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0104744:	8b 45 08             	mov    0x8(%ebp),%eax
f0104747:	8b 40 7c             	mov    0x7c(%eax),%eax
f010474a:	85 c0                	test   %eax,%eax
f010474c:	74 4c                	je     f010479a <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010474e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104755:	eb 38                	jmp    f010478f <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0104757:	8b 45 08             	mov    0x8(%ebp),%eax
f010475a:	8b 40 7c             	mov    0x7c(%eax),%eax
f010475d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104760:	c1 e2 02             	shl    $0x2,%edx
f0104763:	01 d0                	add    %edx,%eax
f0104765:	8b 00                	mov    (%eax),%eax
f0104767:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f010476a:	8b 45 08             	mov    0x8(%ebp),%eax
f010476d:	8b 40 7c             	mov    0x7c(%eax),%eax
f0104770:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104773:	c1 e2 02             	shl    $0x2,%edx
f0104776:	01 d0                	add    %edx,%eax
f0104778:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f010477e:	83 ec 0c             	sub    $0xc,%esp
f0104781:	ff 75 f0             	pushl  -0x10(%ebp)
f0104784:	e8 68 f3 ff ff       	call   f0103af1 <free_disk_frame>
f0104789:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f010478c:	ff 45 f4             	incl   -0xc(%ebp)
f010478f:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0104796:	76 bf                	jbe    f0104757 <__pf_remove_env_all_tables+0x19>
f0104798:	eb 01                	jmp    f010479b <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f010479a:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f010479b:	c9                   	leave  
f010479c:	c3                   	ret    

f010479d <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f010479d:	55                   	push   %ebp
f010479e:	89 e5                	mov    %esp,%ebp
f01047a0:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f01047a3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01047a7:	75 10                	jne    f01047b9 <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f01047a9:	83 ec 0c             	sub    $0xc,%esp
f01047ac:	68 64 41 12 f0       	push   $0xf0124164
f01047b1:	e8 b6 c7 ff ff       	call   f0100f6c <cprintf>
f01047b6:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f01047b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01047bc:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047bf:	85 c0                	test   %eax,%eax
f01047c1:	74 3d                	je     f0104800 <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f01047c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01047c6:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047c9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047cc:	c1 ea 16             	shr    $0x16,%edx
f01047cf:	c1 e2 02             	shl    $0x2,%edx
f01047d2:	01 d0                	add    %edx,%eax
f01047d4:	8b 00                	mov    (%eax),%eax
f01047d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f01047d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01047dc:	8b 40 7c             	mov    0x7c(%eax),%eax
f01047df:	8b 55 0c             	mov    0xc(%ebp),%edx
f01047e2:	c1 ea 16             	shr    $0x16,%edx
f01047e5:	c1 e2 02             	shl    $0x2,%edx
f01047e8:	01 d0                	add    %edx,%eax
f01047ea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01047f0:	83 ec 0c             	sub    $0xc,%esp
f01047f3:	ff 75 f4             	pushl  -0xc(%ebp)
f01047f6:	e8 f6 f2 ff ff       	call   f0103af1 <free_disk_frame>
f01047fb:	83 c4 10             	add    $0x10,%esp
f01047fe:	eb 01                	jmp    f0104801 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0104800:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0104801:	c9                   	leave  
f0104802:	c3                   	ret    

f0104803 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0104803:	55                   	push   %ebp
f0104804:	89 e5                	mov    %esp,%ebp
f0104806:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0104809:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0104810:	eb 1f                	jmp    f0104831 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0104812:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104815:	83 ec 04             	sub    $0x4,%esp
f0104818:	6a 08                	push   $0x8
f010481a:	ff 75 08             	pushl  0x8(%ebp)
f010481d:	50                   	push   %eax
f010481e:	e8 38 c6 01 00       	call   f0120e5b <ide_write>
f0104823:	83 c4 10             	add    $0x10,%esp
f0104826:	85 c0                	test   %eax,%eax
f0104828:	75 12                	jne    f010483c <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f010482a:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0104831:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0104838:	7e d8                	jle    f0104812 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f010483a:	eb 01                	jmp    f010483d <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f010483c:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f010483d:	90                   	nop
f010483e:	c9                   	leave  
f010483f:	c3                   	ret    

f0104840 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0104840:	55                   	push   %ebp
  pushl %eax
f0104841:	50                   	push   %eax
  pushl %ebx
f0104842:	53                   	push   %ebx
  pushl %ecx
f0104843:	51                   	push   %ecx
  pushl %edx
f0104844:	52                   	push   %edx
  pushl %esi
f0104845:	56                   	push   %esi
  pushl %edi
f0104846:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0104847:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f010484b:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f010484f:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0104851:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0104853:	5f                   	pop    %edi
  popl %esi
f0104854:	5e                   	pop    %esi
  popl %edx
f0104855:	5a                   	pop    %edx
  popl %ecx
f0104856:	59                   	pop    %ecx
  popl %ebx
f0104857:	5b                   	pop    %ebx
  popl %eax
f0104858:	58                   	pop    %eax
  popl %ebp
f0104859:	5d                   	pop    %ebp
  ret
f010485a:	c3                   	ret    

f010485b <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f010485b:	55                   	push   %ebp
f010485c:	89 e5                	mov    %esp,%ebp
f010485e:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104861:	8b 45 08             	mov    0x8(%ebp),%eax
f0104864:	0f b6 c0             	movzbl %al,%eax
f0104867:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f010486e:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104871:	8a 45 f6             	mov    -0xa(%ebp),%al
f0104874:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0104877:	ee                   	out    %al,(%dx)
f0104878:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010487f:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104882:	89 c2                	mov    %eax,%edx
f0104884:	ec                   	in     (%dx),%al
f0104885:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0104888:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f010488b:	0f b6 c0             	movzbl %al,%eax
}
f010488e:	c9                   	leave  
f010488f:	c3                   	ret    

f0104890 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0104890:	55                   	push   %ebp
f0104891:	89 e5                	mov    %esp,%ebp
f0104893:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0104896:	8b 45 08             	mov    0x8(%ebp),%eax
f0104899:	0f b6 c0             	movzbl %al,%eax
f010489c:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f01048a3:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01048a6:	8a 45 f6             	mov    -0xa(%ebp),%al
f01048a9:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01048ac:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f01048ad:	8b 45 0c             	mov    0xc(%ebp),%eax
f01048b0:	0f b6 c0             	movzbl %al,%eax
f01048b3:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f01048ba:	88 45 f7             	mov    %al,-0x9(%ebp)
f01048bd:	8a 45 f7             	mov    -0x9(%ebp),%al
f01048c0:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01048c3:	ee                   	out    %al,(%dx)
}
f01048c4:	90                   	nop
f01048c5:	c9                   	leave  
f01048c6:	c3                   	ret    

f01048c7 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f01048c7:	55                   	push   %ebp
f01048c8:	89 e5                	mov    %esp,%ebp
f01048ca:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f01048cd:	c7 05 c8 50 55 f0 00 	movl   $0x0,0xf05550c8
f01048d4:	00 00 00 
f01048d7:	c7 05 cc 50 55 f0 00 	movl   $0x0,0xf05550cc
f01048de:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f01048e1:	83 ec 08             	sub    $0x8,%esp
f01048e4:	68 b5 68 10 f0       	push   $0xf01068b5
f01048e9:	6a 00                	push   $0x0
f01048eb:	e8 a9 87 00 00       	call   f010d099 <irq_install_handler>
f01048f0:	83 c4 10             	add    $0x10,%esp
}
f01048f3:	90                   	nop
f01048f4:	c9                   	leave  
f01048f5:	c3                   	ret    

f01048f6 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f01048f6:	55                   	push   %ebp
f01048f7:	89 e5                	mov    %esp,%ebp
f01048f9:	53                   	push   %ebx
f01048fa:	83 ec 24             	sub    $0x24,%esp
f01048fd:	8b 45 08             	mov    0x8(%ebp),%eax
f0104900:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104903:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f010490a:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f010490e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104911:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104914:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104915:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104919:	77 48                	ja     f0104963 <kclock_start+0x6d>
f010491b:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104922:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0104926:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104929:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010492c:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f010492d:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104931:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104936:	99                   	cltd   
f0104937:	f7 fb                	idiv   %ebx
f0104939:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f010493f:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104943:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104948:	99                   	cltd   
f0104949:	f7 fb                	idiv   %ebx
f010494b:	89 c3                	mov    %eax,%ebx
f010494d:	89 c8                	mov    %ecx,%eax
f010494f:	99                   	cltd   
f0104950:	f7 fb                	idiv   %ebx
f0104952:	0f b7 c0             	movzwl %ax,%eax
f0104955:	83 ec 0c             	sub    $0xc,%esp
f0104958:	50                   	push   %eax
f0104959:	e8 b3 01 00 00       	call   f0104b11 <kclock_write_cnt0_LSB_first>
f010495e:	83 c4 10             	add    $0x10,%esp
f0104961:	eb 13                	jmp    f0104976 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104963:	6a 35                	push   $0x35
f0104965:	68 88 41 12 f0       	push   $0xf0124188
f010496a:	6a 41                	push   $0x41
f010496c:	68 e4 41 12 f0       	push   $0xf01241e4
f0104971:	e8 a4 b9 ff ff       	call   f010031a <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104976:	83 ec 0c             	sub    $0xc,%esp
f0104979:	6a 00                	push   $0x0
f010497b:	e8 66 23 00 00       	call   f0106ce6 <irq_clear_mask>
f0104980:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0104983:	90                   	nop
f0104984:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104987:	c9                   	leave  
f0104988:	c3                   	ret    

f0104989 <kclock_stop>:

void
kclock_stop(void)
{
f0104989:	55                   	push   %ebp
f010498a:	89 e5                	mov    %esp,%ebp
f010498c:	83 ec 18             	sub    $0x18,%esp
f010498f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104996:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f010499a:	8a 45 f3             	mov    -0xd(%ebp),%al
f010499d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01049a0:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f01049a1:	83 ec 0c             	sub    $0xc,%esp
f01049a4:	6a 00                	push   $0x0
f01049a6:	e8 c6 22 00 00       	call   f0106c71 <irq_set_mask>
f01049ab:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f01049ae:	90                   	nop
f01049af:	c9                   	leave  
f01049b0:	c3                   	ret    

f01049b1 <kclock_resume>:

void
kclock_resume(void)
{
f01049b1:	55                   	push   %ebp
f01049b2:	89 e5                	mov    %esp,%ebp
f01049b4:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f01049b7:	e8 f5 01 00 00       	call   f0104bb1 <kclock_read_cnt0_latch>
f01049bc:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f01049c0:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f01049c5:	77 06                	ja     f01049cd <kclock_resume+0x1c>
	{
		cnt0 = 20;
f01049c7:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f01049cd:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f01049d1:	83 e0 01             	and    $0x1,%eax
f01049d4:	66 85 c0             	test   %ax,%ax
f01049d7:	74 09                	je     f01049e2 <kclock_resume+0x31>
		cnt0++;
f01049d9:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f01049dd:	40                   	inc    %eax
f01049de:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f01049e2:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f01049e9:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f01049ed:	8a 45 ef             	mov    -0x11(%ebp),%al
f01049f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01049f3:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f01049f4:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f01049f8:	83 ec 0c             	sub    $0xc,%esp
f01049fb:	50                   	push   %eax
f01049fc:	e8 10 01 00 00       	call   f0104b11 <kclock_write_cnt0_LSB_first>
f0104a01:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104a04:	83 ec 0c             	sub    $0xc,%esp
f0104a07:	6a 00                	push   $0x0
f0104a09:	e8 d8 22 00 00       	call   f0106ce6 <irq_clear_mask>
f0104a0e:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0104a11:	90                   	nop
f0104a12:	c9                   	leave  
f0104a13:	c3                   	ret    

f0104a14 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0104a14:	55                   	push   %ebp
f0104a15:	89 e5                	mov    %esp,%ebp
f0104a17:	83 ec 28             	sub    $0x28,%esp
f0104a1a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a1d:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0104a20:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104a27:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0104a2b:	8a 45 f3             	mov    -0xd(%ebp),%al
f0104a2e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104a31:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0104a32:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0104a36:	83 ec 0c             	sub    $0xc,%esp
f0104a39:	50                   	push   %eax
f0104a3a:	e8 d2 00 00 00       	call   f0104b11 <kclock_write_cnt0_LSB_first>
f0104a3f:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0104a42:	83 ec 0c             	sub    $0xc,%esp
f0104a45:	6a 00                	push   $0x0
f0104a47:	e8 9a 22 00 00       	call   f0106ce6 <irq_clear_mask>
f0104a4c:	83 c4 10             	add    $0x10,%esp
}
f0104a4f:	90                   	nop
f0104a50:	c9                   	leave  
f0104a51:	c3                   	ret    

f0104a52 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0104a52:	55                   	push   %ebp
f0104a53:	89 e5                	mov    %esp,%ebp
f0104a55:	56                   	push   %esi
f0104a56:	53                   	push   %ebx
f0104a57:	83 ec 20             	sub    $0x20,%esp
f0104a5a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104a5d:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0104a60:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0104a64:	0f 87 8a 00 00 00    	ja     f0104af4 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0104a6a:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104a6e:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104a73:	99                   	cltd   
f0104a74:	f7 fe                	idiv   %esi
f0104a76:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104a7c:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0104a80:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104a85:	99                   	cltd   
f0104a86:	f7 fb                	idiv   %ebx
f0104a88:	89 c6                	mov    %eax,%esi
f0104a8a:	89 c8                	mov    %ecx,%eax
f0104a8c:	99                   	cltd   
f0104a8d:	f7 fe                	idiv   %esi
f0104a8f:	89 c3                	mov    %eax,%ebx
f0104a91:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0104a95:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0104a9a:	99                   	cltd   
f0104a9b:	f7 f9                	idiv   %ecx
f0104a9d:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0104aa3:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0104aa7:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0104aac:	99                   	cltd   
f0104aad:	f7 fe                	idiv   %esi
f0104aaf:	89 c6                	mov    %eax,%esi
f0104ab1:	89 c8                	mov    %ecx,%eax
f0104ab3:	99                   	cltd   
f0104ab4:	f7 fe                	idiv   %esi
f0104ab6:	25 01 00 00 80       	and    $0x80000001,%eax
f0104abb:	85 c0                	test   %eax,%eax
f0104abd:	79 05                	jns    f0104ac4 <kclock_set_quantum+0x72>
f0104abf:	48                   	dec    %eax
f0104ac0:	83 c8 fe             	or     $0xfffffffe,%eax
f0104ac3:	40                   	inc    %eax
f0104ac4:	01 d8                	add    %ebx,%eax
f0104ac6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0104ac9:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0104ad0:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0104ad4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104ad7:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104ada:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0104adb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104ade:	0f b7 c0             	movzwl %ax,%eax
f0104ae1:	83 ec 0c             	sub    $0xc,%esp
f0104ae4:	50                   	push   %eax
f0104ae5:	e8 27 00 00 00       	call   f0104b11 <kclock_write_cnt0_LSB_first>
f0104aea:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0104aed:	e8 97 fe ff ff       	call   f0104989 <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0104af2:	eb 16                	jmp    f0104b0a <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0104af4:	6a 35                	push   $0x35
f0104af6:	68 88 41 12 f0       	push   $0xf0124188
f0104afb:	68 ea 00 00 00       	push   $0xea
f0104b00:	68 e4 41 12 f0       	push   $0xf01241e4
f0104b05:	e8 10 b8 ff ff       	call   f010031a <_panic>
	}
}
f0104b0a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0104b0d:	5b                   	pop    %ebx
f0104b0e:	5e                   	pop    %esi
f0104b0f:	5d                   	pop    %ebp
f0104b10:	c3                   	ret    

f0104b11 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0104b11:	55                   	push   %ebp
f0104b12:	89 e5                	mov    %esp,%ebp
f0104b14:	83 ec 28             	sub    $0x28,%esp
f0104b17:	8b 45 08             	mov    0x8(%ebp),%eax
f0104b1a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0104b1e:	e8 9e 23 00 00       	call   f0106ec1 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0104b23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104b26:	0f b6 c0             	movzbl %al,%eax
f0104b29:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0104b30:	88 45 ee             	mov    %al,-0x12(%ebp)
f0104b33:	8a 45 ee             	mov    -0x12(%ebp),%al
f0104b36:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104b39:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0104b3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104b3d:	66 c1 e8 08          	shr    $0x8,%ax
f0104b41:	0f b6 c0             	movzbl %al,%eax
f0104b44:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0104b4b:	88 45 ef             	mov    %al,-0x11(%ebp)
f0104b4e:	8a 45 ef             	mov    -0x11(%ebp),%al
f0104b51:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104b54:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0104b55:	e8 b9 23 00 00       	call   f0106f13 <popcli>

}
f0104b5a:	90                   	nop
f0104b5b:	c9                   	leave  
f0104b5c:	c3                   	ret    

f0104b5d <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0104b5d:	55                   	push   %ebp
f0104b5e:	89 e5                	mov    %esp,%ebp
f0104b60:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0104b63:	e8 59 23 00 00       	call   f0106ec1 <pushcli>
f0104b68:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104b72:	89 c2                	mov    %eax,%edx
f0104b74:	ec                   	in     (%dx),%al
f0104b75:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0104b78:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104b7b:	88 45 f7             	mov    %al,-0x9(%ebp)
f0104b7e:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104b85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0104b88:	89 c2                	mov    %eax,%edx
f0104b8a:	ec                   	in     (%dx),%al
f0104b8b:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0104b8e:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104b91:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104b94:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0104b98:	c1 e0 08             	shl    $0x8,%eax
f0104b9b:	89 c2                	mov    %eax,%edx
f0104b9d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104ba1:	09 d0                	or     %edx,%eax
f0104ba3:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0104ba7:	e8 67 23 00 00       	call   f0106f13 <popcli>
	return cnt0 ;
f0104bac:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0104baf:	c9                   	leave  
f0104bb0:	c3                   	ret    

f0104bb1 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0104bb1:	55                   	push   %ebp
f0104bb2:	89 e5                	mov    %esp,%ebp
f0104bb4:	83 ec 30             	sub    $0x30,%esp
f0104bb7:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bbe:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0104bc1:	89 c2                	mov    %eax,%edx
f0104bc3:	ec                   	in     (%dx),%al
f0104bc4:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0104bc7:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0104bca:	88 45 ff             	mov    %al,-0x1(%ebp)
f0104bcd:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0104bd4:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104bd8:	8a 45 dc             	mov    -0x24(%ebp),%al
f0104bdb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104bde:	ee                   	out    %al,(%dx)
f0104bdf:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104be6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0104be9:	89 c2                	mov    %eax,%edx
f0104beb:	ec                   	in     (%dx),%al
f0104bec:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0104bef:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0104bf2:	88 45 f3             	mov    %al,-0xd(%ebp)
f0104bf5:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0104bfc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0104bff:	89 c2                	mov    %eax,%edx
f0104c01:	ec                   	in     (%dx),%al
f0104c02:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0104c05:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0104c08:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0104c0b:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0104c0f:	c1 e0 08             	shl    $0x8,%eax
f0104c12:	89 c2                	mov    %eax,%edx
f0104c14:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0104c18:	09 d0                	or     %edx,%eax
f0104c1a:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0104c1e:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0104c22:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0104c29:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0104c2c:	8a 45 df             	mov    -0x21(%ebp),%al
f0104c2f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0104c32:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0104c33:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0104c36:	c9                   	leave  
f0104c37:	c3                   	ret    

f0104c38 <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0104c38:	55                   	push   %ebp
f0104c39:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104c3b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104c3f:	74 1d                	je     f0104c5e <init_queue+0x26>
	{
		LIST_INIT(queue);
f0104c41:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c44:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104c4a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c4d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104c54:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c57:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0104c5e:	90                   	nop
f0104c5f:	5d                   	pop    %ebp
f0104c60:	c3                   	ret    

f0104c61 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0104c61:	55                   	push   %ebp
f0104c62:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0104c64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104c68:	74 08                	je     f0104c72 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0104c6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0104c6d:	8b 40 0c             	mov    0xc(%eax),%eax
f0104c70:	eb 05                	jmp    f0104c77 <queue_size+0x16>
	}
	else
	{
		return 0;
f0104c72:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0104c77:	5d                   	pop    %ebp
f0104c78:	c3                   	ret    

f0104c79 <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f0104c79:	55                   	push   %ebp
f0104c7a:	89 e5                	mov    %esp,%ebp
f0104c7c:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104c7f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104c83:	75 16                	jne    f0104c9b <enqueue+0x22>
f0104c85:	68 f8 41 12 f0       	push   $0xf01241f8
f0104c8a:	68 06 42 12 f0       	push   $0xf0124206
f0104c8f:	6a 34                	push   $0x34
f0104c91:	68 1b 42 12 f0       	push   $0xf012421b
f0104c96:	e8 7f b6 ff ff       	call   f010031a <_panic>
	if(env != NULL)
f0104c9b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104c9f:	74 66                	je     f0104d07 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0104ca1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104ca5:	75 14                	jne    f0104cbb <enqueue+0x42>
f0104ca7:	83 ec 04             	sub    $0x4,%esp
f0104caa:	68 34 42 12 f0       	push   $0xf0124234
f0104caf:	6a 37                	push   $0x37
f0104cb1:	68 1b 42 12 f0       	push   $0xf012421b
f0104cb6:	e8 5f b6 ff ff       	call   f010031a <_panic>
f0104cbb:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cbe:	8b 10                	mov    (%eax),%edx
f0104cc0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104cc3:	89 50 08             	mov    %edx,0x8(%eax)
f0104cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104cc9:	8b 40 08             	mov    0x8(%eax),%eax
f0104ccc:	85 c0                	test   %eax,%eax
f0104cce:	74 0d                	je     f0104cdd <enqueue+0x64>
f0104cd0:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cd3:	8b 00                	mov    (%eax),%eax
f0104cd5:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104cd8:	89 50 0c             	mov    %edx,0xc(%eax)
f0104cdb:	eb 09                	jmp    f0104ce6 <enqueue+0x6d>
f0104cdd:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ce0:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104ce3:	89 50 04             	mov    %edx,0x4(%eax)
f0104ce6:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ce9:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104cec:	89 10                	mov    %edx,(%eax)
f0104cee:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104cf1:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104cf8:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cfb:	8b 40 0c             	mov    0xc(%eax),%eax
f0104cfe:	8d 50 01             	lea    0x1(%eax),%edx
f0104d01:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d04:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104d07:	90                   	nop
f0104d08:	c9                   	leave  
f0104d09:	c3                   	ret    

f0104d0a <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f0104d0a:	55                   	push   %ebp
f0104d0b:	89 e5                	mov    %esp,%ebp
f0104d0d:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f0104d10:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104d14:	75 0a                	jne    f0104d20 <dequeue+0x16>
f0104d16:	b8 00 00 00 00       	mov    $0x0,%eax
f0104d1b:	e9 a0 00 00 00       	jmp    f0104dc0 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f0104d20:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d23:	8b 40 04             	mov    0x4(%eax),%eax
f0104d26:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f0104d29:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104d2d:	0f 84 8a 00 00 00    	je     f0104dbd <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f0104d33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104d37:	75 14                	jne    f0104d4d <dequeue+0x43>
f0104d39:	83 ec 04             	sub    $0x4,%esp
f0104d3c:	68 57 42 12 f0       	push   $0xf0124257
f0104d41:	6a 44                	push   $0x44
f0104d43:	68 1b 42 12 f0       	push   $0xf012421b
f0104d48:	e8 cd b5 ff ff       	call   f010031a <_panic>
f0104d4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d50:	8b 40 08             	mov    0x8(%eax),%eax
f0104d53:	85 c0                	test   %eax,%eax
f0104d55:	74 11                	je     f0104d68 <dequeue+0x5e>
f0104d57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d5a:	8b 40 08             	mov    0x8(%eax),%eax
f0104d5d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d60:	8b 52 0c             	mov    0xc(%edx),%edx
f0104d63:	89 50 0c             	mov    %edx,0xc(%eax)
f0104d66:	eb 0c                	jmp    f0104d74 <dequeue+0x6a>
f0104d68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d6b:	8b 50 0c             	mov    0xc(%eax),%edx
f0104d6e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d71:	89 50 04             	mov    %edx,0x4(%eax)
f0104d74:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d77:	8b 40 0c             	mov    0xc(%eax),%eax
f0104d7a:	85 c0                	test   %eax,%eax
f0104d7c:	74 11                	je     f0104d8f <dequeue+0x85>
f0104d7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d81:	8b 40 0c             	mov    0xc(%eax),%eax
f0104d84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d87:	8b 52 08             	mov    0x8(%edx),%edx
f0104d8a:	89 50 08             	mov    %edx,0x8(%eax)
f0104d8d:	eb 0b                	jmp    f0104d9a <dequeue+0x90>
f0104d8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d92:	8b 50 08             	mov    0x8(%eax),%edx
f0104d95:	8b 45 08             	mov    0x8(%ebp),%eax
f0104d98:	89 10                	mov    %edx,(%eax)
f0104d9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104d9d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0104da4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104da7:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104dae:	8b 45 08             	mov    0x8(%ebp),%eax
f0104db1:	8b 40 0c             	mov    0xc(%eax),%eax
f0104db4:	8d 50 ff             	lea    -0x1(%eax),%edx
f0104db7:	8b 45 08             	mov    0x8(%ebp),%eax
f0104dba:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f0104dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104dc0:	c9                   	leave  
f0104dc1:	c3                   	ret    

f0104dc2 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0104dc2:	55                   	push   %ebp
f0104dc3:	89 e5                	mov    %esp,%ebp
f0104dc5:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0104dc8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104dcc:	75 16                	jne    f0104de4 <remove_from_queue+0x22>
f0104dce:	68 f8 41 12 f0       	push   $0xf01241f8
f0104dd3:	68 06 42 12 f0       	push   $0xf0124206
f0104dd8:	6a 4e                	push   $0x4e
f0104dda:	68 1b 42 12 f0       	push   $0xf012421b
f0104ddf:	e8 36 b5 ff ff       	call   f010031a <_panic>

	if (e != NULL)
f0104de4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104de8:	0f 84 8a 00 00 00    	je     f0104e78 <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0104dee:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0104df2:	75 14                	jne    f0104e08 <remove_from_queue+0x46>
f0104df4:	83 ec 04             	sub    $0x4,%esp
f0104df7:	68 57 42 12 f0       	push   $0xf0124257
f0104dfc:	6a 52                	push   $0x52
f0104dfe:	68 1b 42 12 f0       	push   $0xf012421b
f0104e03:	e8 12 b5 ff ff       	call   f010031a <_panic>
f0104e08:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e0b:	8b 40 08             	mov    0x8(%eax),%eax
f0104e0e:	85 c0                	test   %eax,%eax
f0104e10:	74 11                	je     f0104e23 <remove_from_queue+0x61>
f0104e12:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e15:	8b 40 08             	mov    0x8(%eax),%eax
f0104e18:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104e1b:	8b 52 0c             	mov    0xc(%edx),%edx
f0104e1e:	89 50 0c             	mov    %edx,0xc(%eax)
f0104e21:	eb 0c                	jmp    f0104e2f <remove_from_queue+0x6d>
f0104e23:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e26:	8b 50 0c             	mov    0xc(%eax),%edx
f0104e29:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e2c:	89 50 04             	mov    %edx,0x4(%eax)
f0104e2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e32:	8b 40 0c             	mov    0xc(%eax),%eax
f0104e35:	85 c0                	test   %eax,%eax
f0104e37:	74 11                	je     f0104e4a <remove_from_queue+0x88>
f0104e39:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e3c:	8b 40 0c             	mov    0xc(%eax),%eax
f0104e3f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0104e42:	8b 52 08             	mov    0x8(%edx),%edx
f0104e45:	89 50 08             	mov    %edx,0x8(%eax)
f0104e48:	eb 0b                	jmp    f0104e55 <remove_from_queue+0x93>
f0104e4a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e4d:	8b 50 08             	mov    0x8(%eax),%edx
f0104e50:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e53:	89 10                	mov    %edx,(%eax)
f0104e55:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e58:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0104e5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104e62:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0104e69:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e6c:	8b 40 0c             	mov    0xc(%eax),%eax
f0104e6f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0104e72:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e75:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0104e78:	90                   	nop
f0104e79:	c9                   	leave  
f0104e7a:	c3                   	ret    

f0104e7b <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f0104e7b:	55                   	push   %ebp
f0104e7c:	89 e5                	mov    %esp,%ebp
f0104e7e:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0104e81:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104e85:	75 07                	jne    f0104e8e <find_env_in_queue+0x13>
f0104e87:	b8 00 00 00 00       	mov    $0x0,%eax
f0104e8c:	eb 58                	jmp    f0104ee6 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0104e8e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0104e95:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e98:	8b 00                	mov    (%eax),%eax
f0104e9a:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0104e9d:	eb 19                	jmp    f0104eb8 <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0104e9f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0104ea2:	8b 40 10             	mov    0x10(%eax),%eax
f0104ea5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0104ea8:	75 05                	jne    f0104eaf <find_env_in_queue+0x34>
		{
			return ptr_env;
f0104eaa:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0104ead:	eb 37                	jmp    f0104ee6 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0104eaf:	8b 45 08             	mov    0x8(%ebp),%eax
f0104eb2:	8b 40 08             	mov    0x8(%eax),%eax
f0104eb5:	89 45 fc             	mov    %eax,-0x4(%ebp)
f0104eb8:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0104ebc:	74 08                	je     f0104ec6 <find_env_in_queue+0x4b>
f0104ebe:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0104ec1:	8b 40 08             	mov    0x8(%eax),%eax
f0104ec4:	eb 05                	jmp    f0104ecb <find_env_in_queue+0x50>
f0104ec6:	b8 00 00 00 00       	mov    $0x0,%eax
f0104ecb:	8b 55 08             	mov    0x8(%ebp),%edx
f0104ece:	89 42 08             	mov    %eax,0x8(%edx)
f0104ed1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104ed4:	8b 40 08             	mov    0x8(%eax),%eax
f0104ed7:	85 c0                	test   %eax,%eax
f0104ed9:	75 c4                	jne    f0104e9f <find_env_in_queue+0x24>
f0104edb:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0104edf:	75 be                	jne    f0104e9f <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0104ee1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104ee6:	c9                   	leave  
f0104ee7:	c3                   	ret    

f0104ee8 <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f0104ee8:	55                   	push   %ebp
f0104ee9:	89 e5                	mov    %esp,%ebp
			kfree(quantums);
	}
	release_spinlock(&ProcessQueues.qlock);

#endif
}
f0104eeb:	90                   	nop
f0104eec:	5d                   	pop    %ebp
f0104eed:	c3                   	ret    

f0104eee <sched_insert_ready0>:

//=================================================
// [2] Insert the given Env in the 1st Ready Queue:
//=================================================
void sched_insert_ready0(struct Env* env)
{
f0104eee:	55                   	push   %ebp
f0104eef:	89 e5                	mov    %esp,%ebp
f0104ef1:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0104ef4:	83 ec 0c             	sub    $0xc,%esp
f0104ef7:	68 60 24 55 f0       	push   $0xf0552460
f0104efc:	e8 98 9a 00 00       	call   f010e999 <holding_spinlock>
f0104f01:	83 c4 10             	add    $0x10,%esp
f0104f04:	85 c0                	test   %eax,%eax
f0104f06:	75 17                	jne    f0104f1f <sched_insert_ready0+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0104f08:	83 ec 04             	sub    $0x4,%esp
f0104f0b:	68 78 42 12 f0       	push   $0xf0124278
f0104f10:	68 85 00 00 00       	push   $0x85
f0104f15:	68 1b 42 12 f0       	push   $0xf012421b
f0104f1a:	e8 fb b3 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0104f1f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f23:	75 19                	jne    f0104f3e <sched_insert_ready0+0x50>
f0104f25:	68 b9 42 12 f0       	push   $0xf01242b9
f0104f2a:	68 06 42 12 f0       	push   $0xf0124206
f0104f2f:	68 88 00 00 00       	push   $0x88
f0104f34:	68 1b 42 12 f0       	push   $0xf012421b
f0104f39:	e8 dc b3 ff ff       	call   f010031a <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0104f3e:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f41:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[0]), env);
f0104f48:	83 ec 08             	sub    $0x8,%esp
f0104f4b:	ff 75 08             	pushl  0x8(%ebp)
f0104f4e:	68 f0 24 55 f0       	push   $0xf05524f0
f0104f53:	e8 21 fd ff ff       	call   f0104c79 <enqueue>
f0104f58:	83 c4 10             	add    $0x10,%esp
	}
}
f0104f5b:	90                   	nop
f0104f5c:	c9                   	leave  
f0104f5d:	c3                   	ret    

f0104f5e <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0104f5e:	55                   	push   %ebp
f0104f5f:	89 e5                	mov    %esp,%ebp
f0104f61:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0104f64:	83 ec 0c             	sub    $0xc,%esp
f0104f67:	68 60 24 55 f0       	push   $0xf0552460
f0104f6c:	e8 28 9a 00 00       	call   f010e999 <holding_spinlock>
f0104f71:	83 c4 10             	add    $0x10,%esp
f0104f74:	85 c0                	test   %eax,%eax
f0104f76:	75 17                	jne    f0104f8f <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0104f78:	83 ec 04             	sub    $0x4,%esp
f0104f7b:	68 78 42 12 f0       	push   $0xf0124278
f0104f80:	68 97 00 00 00       	push   $0x97
f0104f85:	68 1b 42 12 f0       	push   $0xf012421b
f0104f8a:	e8 8b b3 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0104f8f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104f93:	74 0b                	je     f0104fa0 <sched_remove_ready+0x42>
f0104f95:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f98:	8b 40 18             	mov    0x18(%eax),%eax
f0104f9b:	83 f8 01             	cmp    $0x1,%eax
f0104f9e:	74 19                	je     f0104fb9 <sched_remove_ready+0x5b>
f0104fa0:	68 c8 42 12 f0       	push   $0xf01242c8
f0104fa5:	68 06 42 12 f0       	push   $0xf0124206
f0104faa:	68 9a 00 00 00       	push   $0x9a
f0104faf:	68 1b 42 12 f0       	push   $0xf012421b
f0104fb4:	e8 61 b3 ff ff       	call   f010031a <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0104fb9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104fc0:	e9 f7 00 00 00       	jmp    f01050bc <sched_remove_ready+0x15e>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f0104fc5:	8b 45 08             	mov    0x8(%ebp),%eax
f0104fc8:	8b 40 10             	mov    0x10(%eax),%eax
f0104fcb:	89 c2                	mov    %eax,%edx
f0104fcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104fd0:	83 c0 09             	add    $0x9,%eax
f0104fd3:	c1 e0 04             	shl    $0x4,%eax
f0104fd6:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0104fdb:	83 ec 08             	sub    $0x8,%esp
f0104fde:	52                   	push   %edx
f0104fdf:	50                   	push   %eax
f0104fe0:	e8 96 fe ff ff       	call   f0104e7b <find_env_in_queue>
f0104fe5:	83 c4 10             	add    $0x10,%esp
f0104fe8:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f0104feb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104fef:	0f 84 c4 00 00 00    	je     f01050b9 <sched_remove_ready+0x15b>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f0104ff5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104ff9:	75 17                	jne    f0105012 <sched_remove_ready+0xb4>
f0104ffb:	83 ec 04             	sub    $0x4,%esp
f0104ffe:	68 57 42 12 f0       	push   $0xf0124257
f0105003:	68 a1 00 00 00       	push   $0xa1
f0105008:	68 1b 42 12 f0       	push   $0xf012421b
f010500d:	e8 08 b3 ff ff       	call   f010031a <_panic>
f0105012:	8b 45 08             	mov    0x8(%ebp),%eax
f0105015:	8b 40 08             	mov    0x8(%eax),%eax
f0105018:	85 c0                	test   %eax,%eax
f010501a:	74 11                	je     f010502d <sched_remove_ready+0xcf>
f010501c:	8b 45 08             	mov    0x8(%ebp),%eax
f010501f:	8b 40 08             	mov    0x8(%eax),%eax
f0105022:	8b 55 08             	mov    0x8(%ebp),%edx
f0105025:	8b 52 0c             	mov    0xc(%edx),%edx
f0105028:	89 50 0c             	mov    %edx,0xc(%eax)
f010502b:	eb 17                	jmp    f0105044 <sched_remove_ready+0xe6>
f010502d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105030:	8b 40 0c             	mov    0xc(%eax),%eax
f0105033:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105036:	83 c2 09             	add    $0x9,%edx
f0105039:	c1 e2 04             	shl    $0x4,%edx
f010503c:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f0105042:	89 02                	mov    %eax,(%edx)
f0105044:	8b 45 08             	mov    0x8(%ebp),%eax
f0105047:	8b 40 0c             	mov    0xc(%eax),%eax
f010504a:	85 c0                	test   %eax,%eax
f010504c:	74 11                	je     f010505f <sched_remove_ready+0x101>
f010504e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105051:	8b 40 0c             	mov    0xc(%eax),%eax
f0105054:	8b 55 08             	mov    0x8(%ebp),%edx
f0105057:	8b 52 08             	mov    0x8(%edx),%edx
f010505a:	89 50 08             	mov    %edx,0x8(%eax)
f010505d:	eb 17                	jmp    f0105076 <sched_remove_ready+0x118>
f010505f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105062:	8b 40 08             	mov    0x8(%eax),%eax
f0105065:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105068:	83 c2 09             	add    $0x9,%edx
f010506b:	c1 e2 04             	shl    $0x4,%edx
f010506e:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f0105074:	89 02                	mov    %eax,(%edx)
f0105076:	8b 45 08             	mov    0x8(%ebp),%eax
f0105079:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105080:	8b 45 08             	mov    0x8(%ebp),%eax
f0105083:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010508a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010508d:	83 c0 09             	add    $0x9,%eax
f0105090:	c1 e0 04             	shl    $0x4,%eax
f0105093:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105098:	8b 00                	mov    (%eax),%eax
f010509a:	8d 50 ff             	lea    -0x1(%eax),%edx
f010509d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050a0:	83 c0 09             	add    $0x9,%eax
f01050a3:	c1 e0 04             	shl    $0x4,%eax
f01050a6:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f01050ab:	89 10                	mov    %edx,(%eax)
				env->env_status = ENV_UNKNOWN;
f01050ad:	8b 45 08             	mov    0x8(%ebp),%eax
f01050b0:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
				return ;
f01050b7:	eb 14                	jmp    f01050cd <sched_remove_ready+0x16f>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01050b9:	ff 45 f4             	incl   -0xc(%ebp)
f01050bc:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01050c1:	0f b6 c0             	movzbl %al,%eax
f01050c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01050c7:	0f 8f f8 fe ff ff    	jg     f0104fc5 <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01050cd:	c9                   	leave  
f01050ce:	c3                   	ret    

f01050cf <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01050cf:	55                   	push   %ebp
f01050d0:	89 e5                	mov    %esp,%ebp
f01050d2:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01050d5:	83 ec 0c             	sub    $0xc,%esp
f01050d8:	68 60 24 55 f0       	push   $0xf0552460
f01050dd:	e8 b7 98 00 00       	call   f010e999 <holding_spinlock>
f01050e2:	83 c4 10             	add    $0x10,%esp
f01050e5:	85 c0                	test   %eax,%eax
f01050e7:	75 17                	jne    f0105100 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01050e9:	83 ec 04             	sub    $0x4,%esp
f01050ec:	68 78 42 12 f0       	push   $0xf0124278
f01050f1:	68 b0 00 00 00       	push   $0xb0
f01050f6:	68 1b 42 12 f0       	push   $0xf012421b
f01050fb:	e8 1a b2 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105100:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105104:	75 19                	jne    f010511f <sched_insert_new+0x50>
f0105106:	68 b9 42 12 f0       	push   $0xf01242b9
f010510b:	68 06 42 12 f0       	push   $0xf0124206
f0105110:	68 b3 00 00 00       	push   $0xb3
f0105115:	68 1b 42 12 f0       	push   $0xf012421b
f010511a:	e8 fb b1 ff ff       	call   f010031a <_panic>
	{
		env->env_status = ENV_NEW ;
f010511f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105122:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f0105129:	83 ec 08             	sub    $0x8,%esp
f010512c:	ff 75 08             	pushl  0x8(%ebp)
f010512f:	68 d0 24 55 f0       	push   $0xf05524d0
f0105134:	e8 40 fb ff ff       	call   f0104c79 <enqueue>
f0105139:	83 c4 10             	add    $0x10,%esp
	}
}
f010513c:	90                   	nop
f010513d:	c9                   	leave  
f010513e:	c3                   	ret    

f010513f <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f010513f:	55                   	push   %ebp
f0105140:	89 e5                	mov    %esp,%ebp
f0105142:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105145:	83 ec 0c             	sub    $0xc,%esp
f0105148:	68 60 24 55 f0       	push   $0xf0552460
f010514d:	e8 47 98 00 00       	call   f010e999 <holding_spinlock>
f0105152:	83 c4 10             	add    $0x10,%esp
f0105155:	85 c0                	test   %eax,%eax
f0105157:	75 17                	jne    f0105170 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105159:	83 ec 04             	sub    $0x4,%esp
f010515c:	68 78 42 12 f0       	push   $0xf0124278
f0105161:	68 c1 00 00 00       	push   $0xc1
f0105166:	68 1b 42 12 f0       	push   $0xf012421b
f010516b:	e8 aa b1 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0105170:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105174:	74 0b                	je     f0105181 <sched_remove_new+0x42>
f0105176:	8b 45 08             	mov    0x8(%ebp),%eax
f0105179:	8b 40 18             	mov    0x18(%eax),%eax
f010517c:	83 f8 04             	cmp    $0x4,%eax
f010517f:	74 19                	je     f010519a <sched_remove_new+0x5b>
f0105181:	68 f4 42 12 f0       	push   $0xf01242f4
f0105186:	68 06 42 12 f0       	push   $0xf0124206
f010518b:	68 c4 00 00 00       	push   $0xc4
f0105190:	68 1b 42 12 f0       	push   $0xf012421b
f0105195:	e8 80 b1 ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010519a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010519e:	75 17                	jne    f01051b7 <sched_remove_new+0x78>
f01051a0:	83 ec 04             	sub    $0x4,%esp
f01051a3:	68 57 42 12 f0       	push   $0xf0124257
f01051a8:	68 c6 00 00 00       	push   $0xc6
f01051ad:	68 1b 42 12 f0       	push   $0xf012421b
f01051b2:	e8 63 b1 ff ff       	call   f010031a <_panic>
f01051b7:	8b 45 08             	mov    0x8(%ebp),%eax
f01051ba:	8b 40 08             	mov    0x8(%eax),%eax
f01051bd:	85 c0                	test   %eax,%eax
f01051bf:	74 11                	je     f01051d2 <sched_remove_new+0x93>
f01051c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01051c4:	8b 40 08             	mov    0x8(%eax),%eax
f01051c7:	8b 55 08             	mov    0x8(%ebp),%edx
f01051ca:	8b 52 0c             	mov    0xc(%edx),%edx
f01051cd:	89 50 0c             	mov    %edx,0xc(%eax)
f01051d0:	eb 0b                	jmp    f01051dd <sched_remove_new+0x9e>
f01051d2:	8b 45 08             	mov    0x8(%ebp),%eax
f01051d5:	8b 40 0c             	mov    0xc(%eax),%eax
f01051d8:	a3 d4 24 55 f0       	mov    %eax,0xf05524d4
f01051dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01051e0:	8b 40 0c             	mov    0xc(%eax),%eax
f01051e3:	85 c0                	test   %eax,%eax
f01051e5:	74 11                	je     f01051f8 <sched_remove_new+0xb9>
f01051e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01051ea:	8b 40 0c             	mov    0xc(%eax),%eax
f01051ed:	8b 55 08             	mov    0x8(%ebp),%edx
f01051f0:	8b 52 08             	mov    0x8(%edx),%edx
f01051f3:	89 50 08             	mov    %edx,0x8(%eax)
f01051f6:	eb 0b                	jmp    f0105203 <sched_remove_new+0xc4>
f01051f8:	8b 45 08             	mov    0x8(%ebp),%eax
f01051fb:	8b 40 08             	mov    0x8(%eax),%eax
f01051fe:	a3 d0 24 55 f0       	mov    %eax,0xf05524d0
f0105203:	8b 45 08             	mov    0x8(%ebp),%eax
f0105206:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010520d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105210:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105217:	a1 dc 24 55 f0       	mov    0xf05524dc,%eax
f010521c:	48                   	dec    %eax
f010521d:	a3 dc 24 55 f0       	mov    %eax,0xf05524dc
		env->env_status = ENV_UNKNOWN;
f0105222:	8b 45 08             	mov    0x8(%ebp),%eax
f0105225:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f010522c:	90                   	nop
f010522d:	c9                   	leave  
f010522e:	c3                   	ret    

f010522f <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f010522f:	55                   	push   %ebp
f0105230:	89 e5                	mov    %esp,%ebp
f0105232:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0105235:	83 ec 0c             	sub    $0xc,%esp
f0105238:	68 60 24 55 f0       	push   $0xf0552460
f010523d:	e8 57 97 00 00       	call   f010e999 <holding_spinlock>
f0105242:	83 c4 10             	add    $0x10,%esp
f0105245:	85 c0                	test   %eax,%eax
f0105247:	75 17                	jne    f0105260 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f0105249:	83 ec 04             	sub    $0x4,%esp
f010524c:	68 78 42 12 f0       	push   $0xf0124278
f0105251:	68 d2 00 00 00       	push   $0xd2
f0105256:	68 1b 42 12 f0       	push   $0xf012421b
f010525b:	e8 ba b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0105260:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105264:	75 19                	jne    f010527f <sched_insert_exit+0x50>
f0105266:	68 b9 42 12 f0       	push   $0xf01242b9
f010526b:	68 06 42 12 f0       	push   $0xf0124206
f0105270:	68 d5 00 00 00       	push   $0xd5
f0105275:	68 1b 42 12 f0       	push   $0xf012421b
f010527a:	e8 9b b0 ff ff       	call   f010031a <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f010527f:	e8 ae 91 00 00       	call   f010e432 <isBufferingEnabled>
f0105284:	84 c0                	test   %al,%al
f0105286:	74 0e                	je     f0105296 <sched_insert_exit+0x67>
f0105288:	83 ec 0c             	sub    $0xc,%esp
f010528b:	ff 75 08             	pushl  0x8(%ebp)
f010528e:	e8 ef 67 00 00       	call   f010ba82 <cleanup_buffers>
f0105293:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0105296:	8b 45 08             	mov    0x8(%ebp),%eax
f0105299:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f01052a0:	83 ec 08             	sub    $0x8,%esp
f01052a3:	ff 75 08             	pushl  0x8(%ebp)
f01052a6:	68 e0 24 55 f0       	push   $0xf05524e0
f01052ab:	e8 c9 f9 ff ff       	call   f0104c79 <enqueue>
f01052b0:	83 c4 10             	add    $0x10,%esp
	}
}
f01052b3:	90                   	nop
f01052b4:	c9                   	leave  
f01052b5:	c3                   	ret    

f01052b6 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f01052b6:	55                   	push   %ebp
f01052b7:	89 e5                	mov    %esp,%ebp
f01052b9:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01052bc:	83 ec 0c             	sub    $0xc,%esp
f01052bf:	68 60 24 55 f0       	push   $0xf0552460
f01052c4:	e8 d0 96 00 00       	call   f010e999 <holding_spinlock>
f01052c9:	83 c4 10             	add    $0x10,%esp
f01052cc:	85 c0                	test   %eax,%eax
f01052ce:	75 17                	jne    f01052e7 <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01052d0:	83 ec 04             	sub    $0x4,%esp
f01052d3:	68 78 42 12 f0       	push   $0xf0124278
f01052d8:	68 e3 00 00 00       	push   $0xe3
f01052dd:	68 1b 42 12 f0       	push   $0xf012421b
f01052e2:	e8 33 b0 ff ff       	call   f010031a <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01052e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01052eb:	74 0b                	je     f01052f8 <sched_remove_exit+0x42>
f01052ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01052f0:	8b 40 18             	mov    0x18(%eax),%eax
f01052f3:	83 f8 05             	cmp    $0x5,%eax
f01052f6:	74 19                	je     f0105311 <sched_remove_exit+0x5b>
f01052f8:	68 20 43 12 f0       	push   $0xf0124320
f01052fd:	68 06 42 12 f0       	push   $0xf0124206
f0105302:	68 e6 00 00 00       	push   $0xe6
f0105307:	68 1b 42 12 f0       	push   $0xf012421b
f010530c:	e8 09 b0 ff ff       	call   f010031a <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f0105311:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105315:	75 17                	jne    f010532e <sched_remove_exit+0x78>
f0105317:	83 ec 04             	sub    $0x4,%esp
f010531a:	68 57 42 12 f0       	push   $0xf0124257
f010531f:	68 e8 00 00 00       	push   $0xe8
f0105324:	68 1b 42 12 f0       	push   $0xf012421b
f0105329:	e8 ec af ff ff       	call   f010031a <_panic>
f010532e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105331:	8b 40 08             	mov    0x8(%eax),%eax
f0105334:	85 c0                	test   %eax,%eax
f0105336:	74 11                	je     f0105349 <sched_remove_exit+0x93>
f0105338:	8b 45 08             	mov    0x8(%ebp),%eax
f010533b:	8b 40 08             	mov    0x8(%eax),%eax
f010533e:	8b 55 08             	mov    0x8(%ebp),%edx
f0105341:	8b 52 0c             	mov    0xc(%edx),%edx
f0105344:	89 50 0c             	mov    %edx,0xc(%eax)
f0105347:	eb 0b                	jmp    f0105354 <sched_remove_exit+0x9e>
f0105349:	8b 45 08             	mov    0x8(%ebp),%eax
f010534c:	8b 40 0c             	mov    0xc(%eax),%eax
f010534f:	a3 e4 24 55 f0       	mov    %eax,0xf05524e4
f0105354:	8b 45 08             	mov    0x8(%ebp),%eax
f0105357:	8b 40 0c             	mov    0xc(%eax),%eax
f010535a:	85 c0                	test   %eax,%eax
f010535c:	74 11                	je     f010536f <sched_remove_exit+0xb9>
f010535e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105361:	8b 40 0c             	mov    0xc(%eax),%eax
f0105364:	8b 55 08             	mov    0x8(%ebp),%edx
f0105367:	8b 52 08             	mov    0x8(%edx),%edx
f010536a:	89 50 08             	mov    %edx,0x8(%eax)
f010536d:	eb 0b                	jmp    f010537a <sched_remove_exit+0xc4>
f010536f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105372:	8b 40 08             	mov    0x8(%eax),%eax
f0105375:	a3 e0 24 55 f0       	mov    %eax,0xf05524e0
f010537a:	8b 45 08             	mov    0x8(%ebp),%eax
f010537d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105384:	8b 45 08             	mov    0x8(%ebp),%eax
f0105387:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010538e:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f0105393:	48                   	dec    %eax
f0105394:	a3 ec 24 55 f0       	mov    %eax,0xf05524ec
		env->env_status = ENV_UNKNOWN;
f0105399:	8b 45 08             	mov    0x8(%ebp),%eax
f010539c:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	}
}
f01053a3:	90                   	nop
f01053a4:	c9                   	leave  
f01053a5:	c3                   	ret    

f01053a6 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f01053a6:	55                   	push   %ebp
f01053a7:	89 e5                	mov    %esp,%ebp
f01053a9:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01053ac:	83 ec 0c             	sub    $0xc,%esp
f01053af:	68 60 24 55 f0       	push   $0xf0552460
f01053b4:	e8 c7 93 00 00       	call   f010e780 <acquire_spinlock>
f01053b9:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f01053bc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01053c0:	75 19                	jne    f01053db <sched_new_env+0x35>
f01053c2:	68 4b 43 12 f0       	push   $0xf012434b
f01053c7:	68 06 42 12 f0       	push   $0xf0124206
f01053cc:	68 f6 00 00 00       	push   $0xf6
f01053d1:	68 1b 42 12 f0       	push   $0xf012421b
f01053d6:	e8 3f af ff ff       	call   f010031a <_panic>
	{
		sched_insert_new(e);
f01053db:	83 ec 0c             	sub    $0xc,%esp
f01053de:	ff 75 08             	pushl  0x8(%ebp)
f01053e1:	e8 e9 fc ff ff       	call   f01050cf <sched_insert_new>
f01053e6:	83 c4 10             	add    $0x10,%esp
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01053e9:	83 ec 0c             	sub    $0xc,%esp
f01053ec:	68 60 24 55 f0       	push   $0xf0552460
f01053f1:	e8 11 94 00 00       	call   f010e807 <release_spinlock>
f01053f6:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01053f9:	90                   	nop
f01053fa:	c9                   	leave  
f01053fb:	c3                   	ret    

f01053fc <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01053fc:	55                   	push   %ebp
f01053fd:	89 e5                	mov    %esp,%ebp
f01053ff:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105402:	83 ec 0c             	sub    $0xc,%esp
f0105405:	68 60 24 55 f0       	push   $0xf0552460
f010540a:	e8 71 93 00 00       	call   f010e780 <acquire_spinlock>
f010540f:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105412:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105419:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f010541e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105421:	eb 53                	jmp    f0105476 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0105423:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105426:	8b 40 10             	mov    0x10(%eax),%eax
f0105429:	3b 45 08             	cmp    0x8(%ebp),%eax
f010542c:	75 40                	jne    f010546e <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f010542e:	83 ec 0c             	sub    $0xc,%esp
f0105431:	ff 75 f4             	pushl  -0xc(%ebp)
f0105434:	e8 06 fd ff ff       	call   f010513f <sched_remove_new>
f0105439:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready0(ptr_env);
f010543c:	83 ec 0c             	sub    $0xc,%esp
f010543f:	ff 75 f4             	pushl  -0xc(%ebp)
f0105442:	e8 a7 fa ff ff       	call   f0104eee <sched_insert_ready0>
f0105447:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010544a:	e8 af 19 00 00       	call   f0106dfe <mycpu>
f010544f:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105455:	85 c0                	test   %eax,%eax
f0105457:	75 46                	jne    f010549f <sched_run_env+0xa3>
			{
				release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105459:	83 ec 0c             	sub    $0xc,%esp
f010545c:	68 60 24 55 f0       	push   $0xf0552460
f0105461:	e8 a1 93 00 00       	call   f010e807 <release_spinlock>
f0105466:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f0105469:	e8 45 10 00 00       	call   f01064b3 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010546e:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105473:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105476:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010547a:	74 08                	je     f0105484 <sched_run_env+0x88>
f010547c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010547f:	8b 40 08             	mov    0x8(%eax),%eax
f0105482:	eb 05                	jmp    f0105489 <sched_run_env+0x8d>
f0105484:	b8 00 00 00 00       	mov    $0x0,%eax
f0105489:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f010548e:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105493:	85 c0                	test   %eax,%eax
f0105495:	75 8c                	jne    f0105423 <sched_run_env+0x27>
f0105497:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010549b:	75 86                	jne    f0105423 <sched_run_env+0x27>
f010549d:	eb 01                	jmp    f01054a0 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f010549f:	90                   	nop
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01054a0:	83 ec 0c             	sub    $0xc,%esp
f01054a3:	68 60 24 55 f0       	push   $0xf0552460
f01054a8:	e8 5a 93 00 00       	call   f010e807 <release_spinlock>
f01054ad:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f01054b0:	90                   	nop
f01054b1:	c9                   	leave  
f01054b2:	c3                   	ret    

f01054b3 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f01054b3:	55                   	push   %ebp
f01054b4:	89 e5                	mov    %esp,%ebp
f01054b6:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_spinlock(&ProcessQueues.qlock);
f01054b9:	83 ec 0c             	sub    $0xc,%esp
f01054bc:	68 60 24 55 f0       	push   $0xf0552460
f01054c1:	e8 d3 94 00 00       	call   f010e999 <holding_spinlock>
f01054c6:	83 c4 10             	add    $0x10,%esp
f01054c9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01054cc:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01054d0:	75 10                	jne    f01054e2 <sched_exit_env+0x2f>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f01054d2:	83 ec 0c             	sub    $0xc,%esp
f01054d5:	68 60 24 55 f0       	push   $0xf0552460
f01054da:	e8 a1 92 00 00       	call   f010e780 <acquire_spinlock>
f01054df:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01054e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01054e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01054f0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01054f4:	75 59                	jne    f010554f <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01054f6:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f01054fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01054fe:	eb 28                	jmp    f0105528 <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f0105500:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105503:	8b 40 10             	mov    0x10(%eax),%eax
f0105506:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105509:	75 15                	jne    f0105520 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f010550b:	83 ec 0c             	sub    $0xc,%esp
f010550e:	ff 75 f4             	pushl  -0xc(%ebp)
f0105511:	e8 29 fc ff ff       	call   f010513f <sched_remove_new>
f0105516:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105519:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105520:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105525:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105528:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010552c:	74 08                	je     f0105536 <sched_exit_env+0x83>
f010552e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105531:	8b 40 08             	mov    0x8(%eax),%eax
f0105534:	eb 05                	jmp    f010553b <sched_exit_env+0x88>
f0105536:	b8 00 00 00 00       	mov    $0x0,%eax
f010553b:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f0105540:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105545:	85 c0                	test   %eax,%eax
f0105547:	75 b7                	jne    f0105500 <sched_exit_env+0x4d>
f0105549:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010554d:	75 b1                	jne    f0105500 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f010554f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105553:	0f 85 89 01 00 00    	jne    f01056e2 <sched_exit_env+0x22f>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105559:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105560:	e9 69 01 00 00       	jmp    f01056ce <sched_exit_env+0x21b>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105565:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105568:	83 c0 09             	add    $0x9,%eax
f010556b:	c1 e0 04             	shl    $0x4,%eax
f010556e:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105573:	8b 00                	mov    (%eax),%eax
f0105575:	85 c0                	test   %eax,%eax
f0105577:	0f 84 48 01 00 00    	je     f01056c5 <sched_exit_env+0x212>
			{
				ptr_env=NULL;
f010557d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105584:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105587:	83 c0 09             	add    $0x9,%eax
f010558a:	c1 e0 04             	shl    $0x4,%eax
f010558d:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105592:	8b 00                	mov    (%eax),%eax
f0105594:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105597:	e9 e3 00 00 00       	jmp    f010567f <sched_exit_env+0x1cc>
				{
					if(ptr_env->env_id == envId)
f010559c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010559f:	8b 40 10             	mov    0x10(%eax),%eax
f01055a2:	3b 45 08             	cmp    0x8(%ebp),%eax
f01055a5:	0f 85 c1 00 00 00    	jne    f010566c <sched_exit_env+0x1b9>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01055ab:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01055af:	75 17                	jne    f01055c8 <sched_exit_env+0x115>
f01055b1:	83 ec 04             	sub    $0x4,%esp
f01055b4:	68 57 42 12 f0       	push   $0xf0124257
f01055b9:	68 44 01 00 00       	push   $0x144
f01055be:	68 1b 42 12 f0       	push   $0xf012421b
f01055c3:	e8 52 ad ff ff       	call   f010031a <_panic>
f01055c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055cb:	8b 40 08             	mov    0x8(%eax),%eax
f01055ce:	85 c0                	test   %eax,%eax
f01055d0:	74 11                	je     f01055e3 <sched_exit_env+0x130>
f01055d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055d5:	8b 40 08             	mov    0x8(%eax),%eax
f01055d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01055db:	8b 52 0c             	mov    0xc(%edx),%edx
f01055de:	89 50 0c             	mov    %edx,0xc(%eax)
f01055e1:	eb 17                	jmp    f01055fa <sched_exit_env+0x147>
f01055e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055e6:	8b 40 0c             	mov    0xc(%eax),%eax
f01055e9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01055ec:	83 c2 09             	add    $0x9,%edx
f01055ef:	c1 e2 04             	shl    $0x4,%edx
f01055f2:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f01055f8:	89 02                	mov    %eax,(%edx)
f01055fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055fd:	8b 40 0c             	mov    0xc(%eax),%eax
f0105600:	85 c0                	test   %eax,%eax
f0105602:	74 11                	je     f0105615 <sched_exit_env+0x162>
f0105604:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105607:	8b 40 0c             	mov    0xc(%eax),%eax
f010560a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010560d:	8b 52 08             	mov    0x8(%edx),%edx
f0105610:	89 50 08             	mov    %edx,0x8(%eax)
f0105613:	eb 17                	jmp    f010562c <sched_exit_env+0x179>
f0105615:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105618:	8b 40 08             	mov    0x8(%eax),%eax
f010561b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010561e:	83 c2 09             	add    $0x9,%edx
f0105621:	c1 e2 04             	shl    $0x4,%edx
f0105624:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f010562a:	89 02                	mov    %eax,(%edx)
f010562c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010562f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105636:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105639:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105640:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105643:	83 c0 09             	add    $0x9,%eax
f0105646:	c1 e0 04             	shl    $0x4,%eax
f0105649:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f010564e:	8b 00                	mov    (%eax),%eax
f0105650:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105653:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105656:	83 c0 09             	add    $0x9,%eax
f0105659:	c1 e0 04             	shl    $0x4,%eax
f010565c:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105661:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105663:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f010566a:	eb 59                	jmp    f01056c5 <sched_exit_env+0x212>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010566c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010566f:	83 c0 09             	add    $0x9,%eax
f0105672:	c1 e0 04             	shl    $0x4,%eax
f0105675:	05 68 24 55 f0       	add    $0xf0552468,%eax
f010567a:	8b 00                	mov    (%eax),%eax
f010567c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010567f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105683:	74 08                	je     f010568d <sched_exit_env+0x1da>
f0105685:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105688:	8b 40 08             	mov    0x8(%eax),%eax
f010568b:	eb 05                	jmp    f0105692 <sched_exit_env+0x1df>
f010568d:	b8 00 00 00 00       	mov    $0x0,%eax
f0105692:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0105695:	83 c2 09             	add    $0x9,%edx
f0105698:	c1 e2 04             	shl    $0x4,%edx
f010569b:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f01056a1:	89 02                	mov    %eax,(%edx)
f01056a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01056a6:	83 c0 09             	add    $0x9,%eax
f01056a9:	c1 e0 04             	shl    $0x4,%eax
f01056ac:	05 68 24 55 f0       	add    $0xf0552468,%eax
f01056b1:	8b 00                	mov    (%eax),%eax
f01056b3:	85 c0                	test   %eax,%eax
f01056b5:	0f 85 e1 fe ff ff    	jne    f010559c <sched_exit_env+0xe9>
f01056bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01056bf:	0f 85 d7 fe ff ff    	jne    f010559c <sched_exit_env+0xe9>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01056c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01056c9:	75 16                	jne    f01056e1 <sched_exit_env+0x22e>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01056cb:	ff 45 ec             	incl   -0x14(%ebp)
f01056ce:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01056d3:	0f b6 c0             	movzbl %al,%eax
f01056d6:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01056d9:	0f 8f 86 fe ff ff    	jg     f0105565 <sched_exit_env+0xb2>
f01056df:	eb 01                	jmp    f01056e2 <sched_exit_env+0x22f>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f01056e1:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f01056e2:	e8 8a 4d 00 00       	call   f010a471 <get_cpu_proc>
f01056e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01056ea:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01056ee:	75 19                	jne    f0105709 <sched_exit_env+0x256>
f01056f0:	68 53 43 12 f0       	push   $0xf0124353
f01056f5:	68 06 42 12 f0       	push   $0xf0124206
f01056fa:	68 4e 01 00 00       	push   $0x14e
f01056ff:	68 1b 42 12 f0       	push   $0xf012421b
f0105704:	e8 11 ac ff ff       	call   f010031a <_panic>
	if (!found)
f0105709:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010570d:	75 18                	jne    f0105727 <sched_exit_env+0x274>
	{
		if (cur_env->env_id == envId)
f010570f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105712:	8b 40 10             	mov    0x10(%eax),%eax
f0105715:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105718:	75 0d                	jne    f0105727 <sched_exit_env+0x274>
		{
			ptr_env = cur_env;
f010571a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010571d:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0105720:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0105727:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010572b:	74 1e                	je     f010574b <sched_exit_env+0x298>
	{
		sched_insert_exit(ptr_env);
f010572d:	83 ec 0c             	sub    $0xc,%esp
f0105730:	ff 75 f4             	pushl  -0xc(%ebp)
f0105733:	e8 f7 fa ff ff       	call   f010522f <sched_insert_exit>
f0105738:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f010573b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010573e:	8b 40 10             	mov    0x10(%eax),%eax
f0105741:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105744:	75 05                	jne    f010574b <sched_exit_env+0x298>
		{
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0105746:	e8 b3 4e 00 00       	call   f010a5fe <sched>
		}
	}
	if (!lock_already_held)
f010574b:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010574f:	75 10                	jne    f0105761 <sched_exit_env+0x2ae>
	{
		release_spinlock(&ProcessQueues.qlock);
f0105751:	83 ec 0c             	sub    $0xc,%esp
f0105754:	68 60 24 55 f0       	push   $0xf0552460
f0105759:	e8 a9 90 00 00       	call   f010e807 <release_spinlock>
f010575e:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0105761:	90                   	nop
f0105762:	c9                   	leave  
f0105763:	c3                   	ret    

f0105764 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0105764:	55                   	push   %ebp
f0105765:	89 e5                	mov    %esp,%ebp
f0105767:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010576a:	83 ec 0c             	sub    $0xc,%esp
f010576d:	68 60 24 55 f0       	push   $0xf0552460
f0105772:	e8 09 90 00 00       	call   f010e780 <acquire_spinlock>
f0105777:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010577a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0105781:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0105788:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010578c:	75 79                	jne    f0105807 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f010578e:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105793:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105796:	eb 48                	jmp    f01057e0 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0105798:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010579b:	8b 40 10             	mov    0x10(%eax),%eax
f010579e:	3b 45 08             	cmp    0x8(%ebp),%eax
f01057a1:	75 35                	jne    f01057d8 <sched_kill_env+0x74>
			{
				cprintf("killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f01057a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057a6:	8d 50 20             	lea    0x20(%eax),%edx
f01057a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057ac:	8b 40 10             	mov    0x10(%eax),%eax
f01057af:	83 ec 04             	sub    $0x4,%esp
f01057b2:	52                   	push   %edx
f01057b3:	50                   	push   %eax
f01057b4:	68 64 43 12 f0       	push   $0xf0124364
f01057b9:	e8 ae b7 ff ff       	call   f0100f6c <cprintf>
f01057be:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f01057c1:	83 ec 0c             	sub    $0xc,%esp
f01057c4:	ff 75 f4             	pushl  -0xc(%ebp)
f01057c7:	e8 73 f9 ff ff       	call   f010513f <sched_remove_new>
f01057cc:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01057cf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f01057d6:	eb 2f                	jmp    f0105807 <sched_kill_env+0xa3>
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01057d8:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f01057dd:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01057e0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01057e4:	74 08                	je     f01057ee <sched_kill_env+0x8a>
f01057e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01057e9:	8b 40 08             	mov    0x8(%eax),%eax
f01057ec:	eb 05                	jmp    f01057f3 <sched_kill_env+0x8f>
f01057ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01057f3:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f01057f8:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f01057fd:	85 c0                	test   %eax,%eax
f01057ff:	75 97                	jne    f0105798 <sched_kill_env+0x34>
f0105801:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105805:	75 91                	jne    f0105798 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0105807:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010580b:	0f 85 a7 01 00 00    	jne    f01059b8 <sched_kill_env+0x254>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105811:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0105818:	e9 87 01 00 00       	jmp    f01059a4 <sched_kill_env+0x240>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010581d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105820:	83 c0 09             	add    $0x9,%eax
f0105823:	c1 e0 04             	shl    $0x4,%eax
f0105826:	05 60 24 55 f0       	add    $0xf0552460,%eax
f010582b:	8b 00                	mov    (%eax),%eax
f010582d:	85 c0                	test   %eax,%eax
f010582f:	0f 84 66 01 00 00    	je     f010599b <sched_kill_env+0x237>
			{
				ptr_env=NULL;
f0105835:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010583c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010583f:	83 c0 09             	add    $0x9,%eax
f0105842:	c1 e0 04             	shl    $0x4,%eax
f0105845:	05 60 24 55 f0       	add    $0xf0552460,%eax
f010584a:	8b 00                	mov    (%eax),%eax
f010584c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010584f:	e9 01 01 00 00       	jmp    f0105955 <sched_kill_env+0x1f1>
				{
					if(ptr_env->env_id == envId)
f0105854:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105857:	8b 40 10             	mov    0x10(%eax),%eax
f010585a:	3b 45 08             	cmp    0x8(%ebp),%eax
f010585d:	0f 85 df 00 00 00    	jne    f0105942 <sched_kill_env+0x1de>
					{
						cprintf("killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0105863:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105866:	8d 50 20             	lea    0x20(%eax),%edx
f0105869:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010586c:	8b 40 10             	mov    0x10(%eax),%eax
f010586f:	ff 75 ec             	pushl  -0x14(%ebp)
f0105872:	52                   	push   %edx
f0105873:	50                   	push   %eax
f0105874:	68 8c 43 12 f0       	push   $0xf012438c
f0105879:	e8 ee b6 ff ff       	call   f0100f6c <cprintf>
f010587e:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105881:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105885:	75 17                	jne    f010589e <sched_kill_env+0x13a>
f0105887:	83 ec 04             	sub    $0x4,%esp
f010588a:	68 57 42 12 f0       	push   $0xf0124257
f010588f:	68 91 01 00 00       	push   $0x191
f0105894:	68 1b 42 12 f0       	push   $0xf012421b
f0105899:	e8 7c aa ff ff       	call   f010031a <_panic>
f010589e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058a1:	8b 40 08             	mov    0x8(%eax),%eax
f01058a4:	85 c0                	test   %eax,%eax
f01058a6:	74 11                	je     f01058b9 <sched_kill_env+0x155>
f01058a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ab:	8b 40 08             	mov    0x8(%eax),%eax
f01058ae:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058b1:	8b 52 0c             	mov    0xc(%edx),%edx
f01058b4:	89 50 0c             	mov    %edx,0xc(%eax)
f01058b7:	eb 17                	jmp    f01058d0 <sched_kill_env+0x16c>
f01058b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058bc:	8b 40 0c             	mov    0xc(%eax),%eax
f01058bf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058c2:	83 c2 09             	add    $0x9,%edx
f01058c5:	c1 e2 04             	shl    $0x4,%edx
f01058c8:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f01058ce:	89 02                	mov    %eax,(%edx)
f01058d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058d3:	8b 40 0c             	mov    0xc(%eax),%eax
f01058d6:	85 c0                	test   %eax,%eax
f01058d8:	74 11                	je     f01058eb <sched_kill_env+0x187>
f01058da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058dd:	8b 40 0c             	mov    0xc(%eax),%eax
f01058e0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058e3:	8b 52 08             	mov    0x8(%edx),%edx
f01058e6:	89 50 08             	mov    %edx,0x8(%eax)
f01058e9:	eb 17                	jmp    f0105902 <sched_kill_env+0x19e>
f01058eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01058ee:	8b 40 08             	mov    0x8(%eax),%eax
f01058f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01058f4:	83 c2 09             	add    $0x9,%edx
f01058f7:	c1 e2 04             	shl    $0x4,%edx
f01058fa:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f0105900:	89 02                	mov    %eax,(%edx)
f0105902:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105905:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010590c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010590f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105916:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105919:	83 c0 09             	add    $0x9,%eax
f010591c:	c1 e0 04             	shl    $0x4,%eax
f010591f:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105924:	8b 00                	mov    (%eax),%eax
f0105926:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105929:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010592c:	83 c0 09             	add    $0x9,%eax
f010592f:	c1 e0 04             	shl    $0x4,%eax
f0105932:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105937:	89 10                	mov    %edx,(%eax)
						found = 1;
f0105939:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0105940:	eb 59                	jmp    f010599b <sched_kill_env+0x237>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105942:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105945:	83 c0 09             	add    $0x9,%eax
f0105948:	c1 e0 04             	shl    $0x4,%eax
f010594b:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105950:	8b 00                	mov    (%eax),%eax
f0105952:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105955:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105959:	74 08                	je     f0105963 <sched_kill_env+0x1ff>
f010595b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010595e:	8b 40 08             	mov    0x8(%eax),%eax
f0105961:	eb 05                	jmp    f0105968 <sched_kill_env+0x204>
f0105963:	b8 00 00 00 00       	mov    $0x0,%eax
f0105968:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010596b:	83 c2 09             	add    $0x9,%edx
f010596e:	c1 e2 04             	shl    $0x4,%edx
f0105971:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0105977:	89 02                	mov    %eax,(%edx)
f0105979:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010597c:	83 c0 09             	add    $0x9,%eax
f010597f:	c1 e0 04             	shl    $0x4,%eax
f0105982:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105987:	8b 00                	mov    (%eax),%eax
f0105989:	85 c0                	test   %eax,%eax
f010598b:	0f 85 c3 fe ff ff    	jne    f0105854 <sched_kill_env+0xf0>
f0105991:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105995:	0f 85 b9 fe ff ff    	jne    f0105854 <sched_kill_env+0xf0>
						found = 1;
						break;
					}
				}
			}
			if (found)
f010599b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010599f:	75 16                	jne    f01059b7 <sched_kill_env+0x253>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01059a1:	ff 45 ec             	incl   -0x14(%ebp)
f01059a4:	a0 60 51 55 f0       	mov    0xf0555160,%al
f01059a9:	0f b6 c0             	movzbl %al,%eax
f01059ac:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f01059af:	0f 8f 68 fe ff ff    	jg     f010581d <sched_kill_env+0xb9>
f01059b5:	eb 01                	jmp    f01059b8 <sched_kill_env+0x254>
						break;
					}
				}
			}
			if (found)
				break;
f01059b7:	90                   	nop
		}
	}
	if (!found)
f01059b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01059bc:	0f 85 80 00 00 00    	jne    f0105a42 <sched_kill_env+0x2de>
	{
		ptr_env=NULL;
f01059c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01059c9:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f01059ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01059d1:	eb 48                	jmp    f0105a1b <sched_kill_env+0x2b7>
		{
			if(ptr_env->env_id == envId)
f01059d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059d6:	8b 40 10             	mov    0x10(%eax),%eax
f01059d9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01059dc:	75 35                	jne    f0105a13 <sched_kill_env+0x2af>
			{
				cprintf("killing[%d] %s from the EXIT queue...", ptr_env->env_id, ptr_env->prog_name);
f01059de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059e1:	8d 50 20             	lea    0x20(%eax),%edx
f01059e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01059e7:	8b 40 10             	mov    0x10(%eax),%eax
f01059ea:	83 ec 04             	sub    $0x4,%esp
f01059ed:	52                   	push   %edx
f01059ee:	50                   	push   %eax
f01059ef:	68 b8 43 12 f0       	push   $0xf01243b8
f01059f4:	e8 73 b5 ff ff       	call   f0100f6c <cprintf>
f01059f9:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f01059fc:	83 ec 0c             	sub    $0xc,%esp
f01059ff:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a02:	e8 af f8 ff ff       	call   f01052b6 <sched_remove_exit>
f0105a07:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0105a0a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0105a11:	eb 2f                	jmp    f0105a42 <sched_kill_env+0x2de>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105a13:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105a18:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105a1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a1f:	74 08                	je     f0105a29 <sched_kill_env+0x2c5>
f0105a21:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105a24:	8b 40 08             	mov    0x8(%eax),%eax
f0105a27:	eb 05                	jmp    f0105a2e <sched_kill_env+0x2ca>
f0105a29:	b8 00 00 00 00       	mov    $0x0,%eax
f0105a2e:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f0105a33:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105a38:	85 c0                	test   %eax,%eax
f0105a3a:	75 97                	jne    f01059d3 <sched_kill_env+0x26f>
f0105a3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105a40:	75 91                	jne    f01059d3 <sched_kill_env+0x26f>
				found = 1;
				break;
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105a42:	83 ec 0c             	sub    $0xc,%esp
f0105a45:	68 60 24 55 f0       	push   $0xf0552460
f0105a4a:	e8 b8 8d 00 00       	call   f010e807 <release_spinlock>
f0105a4f:	83 c4 10             	add    $0x10,%esp

	if (found)
f0105a52:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105a56:	74 23                	je     f0105a7b <sched_kill_env+0x317>
	{
		env_free(ptr_env);
f0105a58:	83 ec 0c             	sub    $0xc,%esp
f0105a5b:	ff 75 f4             	pushl  -0xc(%ebp)
f0105a5e:	e8 c6 49 00 00       	call   f010a429 <env_free>
f0105a63:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f0105a66:	83 ec 0c             	sub    $0xc,%esp
f0105a69:	68 de 43 12 f0       	push   $0xf01243de
f0105a6e:	e8 f9 b4 ff ff       	call   f0100f6c <cprintf>
f0105a73:	83 c4 10             	add    $0x10,%esp
			//fos_scheduler();
			sched();
		}
	}

}
f0105a76:	e9 a4 00 00 00       	jmp    f0105b1f <sched_kill_env+0x3bb>
		env_free(ptr_env);
		cprintf("DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0105a7b:	e8 f1 49 00 00       	call   f010a471 <get_cpu_proc>
f0105a80:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0105a83:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0105a87:	75 19                	jne    f0105aa2 <sched_kill_env+0x33e>
f0105a89:	68 53 43 12 f0       	push   $0xf0124353
f0105a8e:	68 06 42 12 f0       	push   $0xf0124206
f0105a93:	68 b3 01 00 00       	push   $0x1b3
f0105a98:	68 1b 42 12 f0       	push   $0xf012421b
f0105a9d:	e8 78 a8 ff ff       	call   f010031a <_panic>

		if (cur_env->env_id == envId)
f0105aa2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105aa5:	8b 40 10             	mov    0x10(%eax),%eax
f0105aa8:	3b 45 08             	cmp    0x8(%ebp),%eax
f0105aab:	75 72                	jne    f0105b1f <sched_kill_env+0x3bb>
		{
			ptr_env = cur_env;
f0105aad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105ab0:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0105ab3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ab6:	8b 40 18             	mov    0x18(%eax),%eax
f0105ab9:	83 f8 02             	cmp    $0x2,%eax
f0105abc:	74 19                	je     f0105ad7 <sched_kill_env+0x373>
f0105abe:	68 e4 43 12 f0       	push   $0xf01243e4
f0105ac3:	68 06 42 12 f0       	push   $0xf0124206
f0105ac8:	68 b8 01 00 00       	push   $0x1b8
f0105acd:	68 1b 42 12 f0       	push   $0xf012421b
f0105ad2:	e8 43 a8 ff ff       	call   f010031a <_panic>
			cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105ad7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ada:	8d 50 20             	lea    0x20(%eax),%edx
f0105add:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ae0:	8b 40 10             	mov    0x10(%eax),%eax
f0105ae3:	83 ec 04             	sub    $0x4,%esp
f0105ae6:	52                   	push   %edx
f0105ae7:	50                   	push   %eax
f0105ae8:	68 08 44 12 f0       	push   $0xf0124408
f0105aed:	e8 7a b4 ff ff       	call   f0100f6c <cprintf>
f0105af2:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105af5:	83 ec 0c             	sub    $0xc,%esp
f0105af8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105afb:	e8 29 49 00 00       	call   f010a429 <env_free>
f0105b00:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105b03:	83 ec 0c             	sub    $0xc,%esp
f0105b06:	68 de 43 12 f0       	push   $0xf01243de
f0105b0b:	e8 5c b4 ff ff       	call   f0100f6c <cprintf>
f0105b10:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0105b13:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			sched();
f0105b1a:	e8 df 4a 00 00       	call   f010a5fe <sched>
		}
	}

}
f0105b1f:	90                   	nop
f0105b20:	c9                   	leave  
f0105b21:	c3                   	ret    

f0105b22 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0105b22:	55                   	push   %ebp
f0105b23:	89 e5                	mov    %esp,%ebp
f0105b25:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105b28:	83 ec 0c             	sub    $0xc,%esp
f0105b2b:	68 60 24 55 f0       	push   $0xf0552460
f0105b30:	e8 4b 8c 00 00       	call   f010e780 <acquire_spinlock>
f0105b35:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105b38:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105b3d:	85 c0                	test   %eax,%eax
f0105b3f:	74 69                	je     f0105baa <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0105b41:	83 ec 0c             	sub    $0xc,%esp
f0105b44:	68 34 44 12 f0       	push   $0xf0124434
f0105b49:	e8 1e b4 ff ff       	call   f0100f6c <cprintf>
f0105b4e:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b51:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105b56:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b59:	eb 26                	jmp    f0105b81 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105b5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b5e:	8d 50 20             	lea    0x20(%eax),%edx
f0105b61:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b64:	8b 40 10             	mov    0x10(%eax),%eax
f0105b67:	83 ec 04             	sub    $0x4,%esp
f0105b6a:	52                   	push   %edx
f0105b6b:	50                   	push   %eax
f0105b6c:	68 56 44 12 f0       	push   $0xf0124456
f0105b71:	e8 f6 b3 ff ff       	call   f0100f6c <cprintf>
f0105b76:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105b79:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105b7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105b81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105b85:	74 08                	je     f0105b8f <sched_print_all+0x6d>
f0105b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105b8a:	8b 40 08             	mov    0x8(%eax),%eax
f0105b8d:	eb 05                	jmp    f0105b94 <sched_print_all+0x72>
f0105b8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0105b94:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f0105b99:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105b9e:	85 c0                	test   %eax,%eax
f0105ba0:	75 b9                	jne    f0105b5b <sched_print_all+0x39>
f0105ba2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105ba6:	75 b3                	jne    f0105b5b <sched_print_all+0x39>
f0105ba8:	eb 10                	jmp    f0105bba <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0105baa:	83 ec 0c             	sub    $0xc,%esp
f0105bad:	68 60 44 12 f0       	push   $0xf0124460
f0105bb2:	e8 b5 b3 ff ff       	call   f0100f6c <cprintf>
f0105bb7:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105bba:	83 ec 0c             	sub    $0xc,%esp
f0105bbd:	68 7c 44 12 f0       	push   $0xf012447c
f0105bc2:	e8 a5 b3 ff ff       	call   f0100f6c <cprintf>
f0105bc7:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105bca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105bd1:	e9 d7 00 00 00       	jmp    f0105cad <sched_print_all+0x18b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105bd6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105bd9:	83 c0 09             	add    $0x9,%eax
f0105bdc:	c1 e0 04             	shl    $0x4,%eax
f0105bdf:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105be4:	8b 00                	mov    (%eax),%eax
f0105be6:	85 c0                	test   %eax,%eax
f0105be8:	0f 84 99 00 00 00    	je     f0105c87 <sched_print_all+0x165>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0105bee:	83 ec 08             	sub    $0x8,%esp
f0105bf1:	ff 75 f0             	pushl  -0x10(%ebp)
f0105bf4:	68 b0 44 12 f0       	push   $0xf01244b0
f0105bf9:	e8 6e b3 ff ff       	call   f0100f6c <cprintf>
f0105bfe:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105c04:	83 c0 09             	add    $0x9,%eax
f0105c07:	c1 e0 04             	shl    $0x4,%eax
f0105c0a:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105c0f:	8b 00                	mov    (%eax),%eax
f0105c11:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c14:	eb 31                	jmp    f0105c47 <sched_print_all+0x125>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105c16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c19:	8d 50 20             	lea    0x20(%eax),%edx
f0105c1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c1f:	8b 40 10             	mov    0x10(%eax),%eax
f0105c22:	83 ec 04             	sub    $0x4,%esp
f0105c25:	52                   	push   %edx
f0105c26:	50                   	push   %eax
f0105c27:	68 56 44 12 f0       	push   $0xf0124456
f0105c2c:	e8 3b b3 ff ff       	call   f0100f6c <cprintf>
f0105c31:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105c34:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105c37:	83 c0 09             	add    $0x9,%eax
f0105c3a:	c1 e0 04             	shl    $0x4,%eax
f0105c3d:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105c42:	8b 00                	mov    (%eax),%eax
f0105c44:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105c47:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c4b:	74 08                	je     f0105c55 <sched_print_all+0x133>
f0105c4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105c50:	8b 40 08             	mov    0x8(%eax),%eax
f0105c53:	eb 05                	jmp    f0105c5a <sched_print_all+0x138>
f0105c55:	b8 00 00 00 00       	mov    $0x0,%eax
f0105c5a:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105c5d:	83 c2 09             	add    $0x9,%edx
f0105c60:	c1 e2 04             	shl    $0x4,%edx
f0105c63:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0105c69:	89 02                	mov    %eax,(%edx)
f0105c6b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105c6e:	83 c0 09             	add    $0x9,%eax
f0105c71:	c1 e0 04             	shl    $0x4,%eax
f0105c74:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0105c79:	8b 00                	mov    (%eax),%eax
f0105c7b:	85 c0                	test   %eax,%eax
f0105c7d:	75 97                	jne    f0105c16 <sched_print_all+0xf4>
f0105c7f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105c83:	75 91                	jne    f0105c16 <sched_print_all+0xf4>
f0105c85:	eb 13                	jmp    f0105c9a <sched_print_all+0x178>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f0105c87:	83 ec 08             	sub    $0x8,%esp
f0105c8a:	ff 75 f0             	pushl  -0x10(%ebp)
f0105c8d:	68 d8 44 12 f0       	push   $0xf01244d8
f0105c92:	e8 d5 b2 ff ff       	call   f0100f6c <cprintf>
f0105c97:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0105c9a:	83 ec 0c             	sub    $0xc,%esp
f0105c9d:	68 7c 44 12 f0       	push   $0xf012447c
f0105ca2:	e8 c5 b2 ff ff       	call   f0100f6c <cprintf>
f0105ca7:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105caa:	ff 45 f0             	incl   -0x10(%ebp)
f0105cad:	a0 60 51 55 f0       	mov    0xf0555160,%al
f0105cb2:	0f b6 c0             	movzbl %al,%eax
f0105cb5:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0105cb8:	0f 8f 18 ff ff ff    	jg     f0105bd6 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0105cbe:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f0105cc3:	85 c0                	test   %eax,%eax
f0105cc5:	74 69                	je     f0105d30 <sched_print_all+0x20e>
	{
		cprintf("The processes in EXIT queue are:\n");
f0105cc7:	83 ec 0c             	sub    $0xc,%esp
f0105cca:	68 fc 44 12 f0       	push   $0xf01244fc
f0105ccf:	e8 98 b2 ff ff       	call   f0100f6c <cprintf>
f0105cd4:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cd7:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f0105cdc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105cdf:	eb 26                	jmp    f0105d07 <sched_print_all+0x1e5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0105ce1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ce4:	8d 50 20             	lea    0x20(%eax),%edx
f0105ce7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105cea:	8b 40 10             	mov    0x10(%eax),%eax
f0105ced:	83 ec 04             	sub    $0x4,%esp
f0105cf0:	52                   	push   %edx
f0105cf1:	50                   	push   %eax
f0105cf2:	68 56 44 12 f0       	push   $0xf0124456
f0105cf7:	e8 70 b2 ff ff       	call   f0100f6c <cprintf>
f0105cfc:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0105cff:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105d04:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105d07:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d0b:	74 08                	je     f0105d15 <sched_print_all+0x1f3>
f0105d0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105d10:	8b 40 08             	mov    0x8(%eax),%eax
f0105d13:	eb 05                	jmp    f0105d1a <sched_print_all+0x1f8>
f0105d15:	b8 00 00 00 00       	mov    $0x0,%eax
f0105d1a:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f0105d1f:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f0105d24:	85 c0                	test   %eax,%eax
f0105d26:	75 b9                	jne    f0105ce1 <sched_print_all+0x1bf>
f0105d28:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105d2c:	75 b3                	jne    f0105ce1 <sched_print_all+0x1bf>
f0105d2e:	eb 10                	jmp    f0105d40 <sched_print_all+0x21e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0105d30:	83 ec 0c             	sub    $0xc,%esp
f0105d33:	68 1e 45 12 f0       	push   $0xf012451e
f0105d38:	e8 2f b2 ff ff       	call   f0100f6c <cprintf>
f0105d3d:	83 c4 10             	add    $0x10,%esp
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d40:	83 ec 0c             	sub    $0xc,%esp
f0105d43:	68 60 24 55 f0       	push   $0xf0552460
f0105d48:	e8 ba 8a 00 00       	call   f010e807 <release_spinlock>
f0105d4d:	83 c4 10             	add    $0x10,%esp
}
f0105d50:	90                   	nop
f0105d51:	c9                   	leave  
f0105d52:	c3                   	ret    

f0105d53 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f0105d53:	55                   	push   %ebp
f0105d54:	89 e5                	mov    %esp,%ebp
f0105d56:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105d59:	83 ec 0c             	sub    $0xc,%esp
f0105d5c:	68 60 24 55 f0       	push   $0xf0552460
f0105d61:	e8 1a 8a 00 00       	call   f010e780 <acquire_spinlock>
f0105d66:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0105d69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0105d70:	a1 dc 24 55 f0       	mov    0xf05524dc,%eax
f0105d75:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f0105d78:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105d7f:	eb 24                	jmp    f0105da5 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0105d81:	83 ec 0c             	sub    $0xc,%esp
f0105d84:	68 d0 24 55 f0       	push   $0xf05524d0
f0105d89:	e8 7c ef ff ff       	call   f0104d0a <dequeue>
f0105d8e:	83 c4 10             	add    $0x10,%esp
f0105d91:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready0(ptr_env);
f0105d94:	83 ec 0c             	sub    $0xc,%esp
f0105d97:	ff 75 f0             	pushl  -0x10(%ebp)
f0105d9a:	e8 4f f1 ff ff       	call   f0104eee <sched_insert_ready0>
f0105d9f:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0105da2:	ff 45 f4             	incl   -0xc(%ebp)
f0105da5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105da8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0105dab:	7c d4                	jl     f0105d81 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready0(ptr_env);
	}

	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105dad:	83 ec 0c             	sub    $0xc,%esp
f0105db0:	68 60 24 55 f0       	push   $0xf0552460
f0105db5:	e8 4d 8a 00 00       	call   f010e807 <release_spinlock>
f0105dba:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0105dbd:	e8 3c 10 00 00       	call   f0106dfe <mycpu>
f0105dc2:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0105dc8:	85 c0                	test   %eax,%eax
f0105dca:	75 05                	jne    f0105dd1 <sched_run_all+0x7e>
		fos_scheduler();
f0105dcc:	e8 e2 06 00 00       	call   f01064b3 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0105dd1:	83 ec 04             	sub    $0x4,%esp
f0105dd4:	68 3c 45 12 f0       	push   $0xf012453c
f0105dd9:	68 15 02 00 00       	push   $0x215
f0105dde:	68 1b 42 12 f0       	push   $0xf012421b
f0105de3:	e8 32 a5 ff ff       	call   f010031a <_panic>

f0105de8 <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f0105de8:	55                   	push   %ebp
f0105de9:	89 e5                	mov    %esp,%ebp
f0105deb:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0105dee:	83 ec 0c             	sub    $0xc,%esp
f0105df1:	68 60 24 55 f0       	push   $0xf0552460
f0105df6:	e8 85 89 00 00       	call   f010e780 <acquire_spinlock>
f0105dfb:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0105dfe:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105e03:	85 c0                	test   %eax,%eax
f0105e05:	0f 84 95 00 00 00    	je     f0105ea0 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f0105e0b:	83 ec 0c             	sub    $0xc,%esp
f0105e0e:	68 78 45 12 f0       	push   $0xf0124578
f0105e13:	e8 54 b1 ff ff       	call   f0100f6c <cprintf>
f0105e18:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e1b:	a1 d0 24 55 f0       	mov    0xf05524d0,%eax
f0105e20:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e23:	eb 52                	jmp    f0105e77 <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105e25:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e28:	8d 50 20             	lea    0x20(%eax),%edx
f0105e2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e2e:	8b 40 10             	mov    0x10(%eax),%eax
f0105e31:	83 ec 04             	sub    $0x4,%esp
f0105e34:	52                   	push   %edx
f0105e35:	50                   	push   %eax
f0105e36:	68 a4 45 12 f0       	push   $0xf01245a4
f0105e3b:	e8 2c b1 ff ff       	call   f0100f6c <cprintf>
f0105e40:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f0105e43:	83 ec 0c             	sub    $0xc,%esp
f0105e46:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e49:	e8 f1 f2 ff ff       	call   f010513f <sched_remove_new>
f0105e4e:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0105e51:	83 ec 0c             	sub    $0xc,%esp
f0105e54:	ff 75 f4             	pushl  -0xc(%ebp)
f0105e57:	e8 cd 45 00 00       	call   f010a429 <env_free>
f0105e5c:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0105e5f:	83 ec 0c             	sub    $0xc,%esp
f0105e62:	68 de 43 12 f0       	push   $0xf01243de
f0105e67:	e8 00 b1 ff ff       	call   f0100f6c <cprintf>
f0105e6c:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0105e6f:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105e74:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e77:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e7b:	74 08                	je     f0105e85 <sched_kill_all+0x9d>
f0105e7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e80:	8b 40 08             	mov    0x8(%eax),%eax
f0105e83:	eb 05                	jmp    f0105e8a <sched_kill_all+0xa2>
f0105e85:	b8 00 00 00 00       	mov    $0x0,%eax
f0105e8a:	a3 d8 24 55 f0       	mov    %eax,0xf05524d8
f0105e8f:	a1 d8 24 55 f0       	mov    0xf05524d8,%eax
f0105e94:	85 c0                	test   %eax,%eax
f0105e96:	75 8d                	jne    f0105e25 <sched_kill_all+0x3d>
f0105e98:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105e9c:	75 87                	jne    f0105e25 <sched_kill_all+0x3d>
f0105e9e:	eb 10                	jmp    f0105eb0 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0105ea0:	83 ec 0c             	sub    $0xc,%esp
f0105ea3:	68 b7 45 12 f0       	push   $0xf01245b7
f0105ea8:	e8 bf b0 ff ff       	call   f0100f6c <cprintf>
f0105ead:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0105eb0:	83 ec 0c             	sub    $0xc,%esp
f0105eb3:	68 7c 44 12 f0       	push   $0xf012447c
f0105eb8:	e8 af b0 ff ff       	call   f0100f6c <cprintf>
f0105ebd:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0105ec0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0105ec7:	e9 b8 01 00 00       	jmp    f0106084 <sched_kill_all+0x29c>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0105ecc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105ecf:	83 c0 09             	add    $0x9,%eax
f0105ed2:	c1 e0 04             	shl    $0x4,%eax
f0105ed5:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105eda:	8b 00                	mov    (%eax),%eax
f0105edc:	85 c0                	test   %eax,%eax
f0105ede:	0f 84 7a 01 00 00    	je     f010605e <sched_kill_all+0x276>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0105ee4:	83 ec 08             	sub    $0x8,%esp
f0105ee7:	ff 75 f0             	pushl  -0x10(%ebp)
f0105eea:	68 d4 45 12 f0       	push   $0xf01245d4
f0105eef:	e8 78 b0 ff ff       	call   f0100f6c <cprintf>
f0105ef4:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0105ef7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105efa:	83 c0 09             	add    $0x9,%eax
f0105efd:	c1 e0 04             	shl    $0x4,%eax
f0105f00:	05 60 24 55 f0       	add    $0xf0552460,%eax
f0105f05:	8b 00                	mov    (%eax),%eax
f0105f07:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105f0a:	e9 07 01 00 00       	jmp    f0106016 <sched_kill_all+0x22e>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0105f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f12:	8d 50 20             	lea    0x20(%eax),%edx
f0105f15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f18:	8b 40 10             	mov    0x10(%eax),%eax
f0105f1b:	83 ec 04             	sub    $0x4,%esp
f0105f1e:	52                   	push   %edx
f0105f1f:	50                   	push   %eax
f0105f20:	68 a4 45 12 f0       	push   $0xf01245a4
f0105f25:	e8 42 b0 ff ff       	call   f0100f6c <cprintf>
f0105f2a:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0105f2d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105f31:	75 17                	jne    f0105f4a <sched_kill_all+0x162>
f0105f33:	83 ec 04             	sub    $0x4,%esp
f0105f36:	68 57 42 12 f0       	push   $0xf0124257
f0105f3b:	68 37 02 00 00       	push   $0x237
f0105f40:	68 1b 42 12 f0       	push   $0xf012421b
f0105f45:	e8 d0 a3 ff ff       	call   f010031a <_panic>
f0105f4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f4d:	8b 40 08             	mov    0x8(%eax),%eax
f0105f50:	85 c0                	test   %eax,%eax
f0105f52:	74 11                	je     f0105f65 <sched_kill_all+0x17d>
f0105f54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f57:	8b 40 08             	mov    0x8(%eax),%eax
f0105f5a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f5d:	8b 52 0c             	mov    0xc(%edx),%edx
f0105f60:	89 50 0c             	mov    %edx,0xc(%eax)
f0105f63:	eb 17                	jmp    f0105f7c <sched_kill_all+0x194>
f0105f65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f68:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f6b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105f6e:	83 c2 09             	add    $0x9,%edx
f0105f71:	c1 e2 04             	shl    $0x4,%edx
f0105f74:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f0105f7a:	89 02                	mov    %eax,(%edx)
f0105f7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f7f:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f82:	85 c0                	test   %eax,%eax
f0105f84:	74 11                	je     f0105f97 <sched_kill_all+0x1af>
f0105f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f89:	8b 40 0c             	mov    0xc(%eax),%eax
f0105f8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f8f:	8b 52 08             	mov    0x8(%edx),%edx
f0105f92:	89 50 08             	mov    %edx,0x8(%eax)
f0105f95:	eb 17                	jmp    f0105fae <sched_kill_all+0x1c6>
f0105f97:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105f9a:	8b 40 08             	mov    0x8(%eax),%eax
f0105f9d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105fa0:	83 c2 09             	add    $0x9,%edx
f0105fa3:	c1 e2 04             	shl    $0x4,%edx
f0105fa6:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f0105fac:	89 02                	mov    %eax,(%edx)
f0105fae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fb1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0105fb8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105fbb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0105fc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105fc5:	83 c0 09             	add    $0x9,%eax
f0105fc8:	c1 e0 04             	shl    $0x4,%eax
f0105fcb:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105fd0:	8b 00                	mov    (%eax),%eax
f0105fd2:	8d 50 ff             	lea    -0x1(%eax),%edx
f0105fd5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105fd8:	83 c0 09             	add    $0x9,%eax
f0105fdb:	c1 e0 04             	shl    $0x4,%eax
f0105fde:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f0105fe3:	89 10                	mov    %edx,(%eax)
				env_free(ptr_env);
f0105fe5:	83 ec 0c             	sub    $0xc,%esp
f0105fe8:	ff 75 f4             	pushl  -0xc(%ebp)
f0105feb:	e8 39 44 00 00       	call   f010a429 <env_free>
f0105ff0:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0105ff3:	83 ec 0c             	sub    $0xc,%esp
f0105ff6:	68 de 43 12 f0       	push   $0xf01243de
f0105ffb:	e8 6c af ff ff       	call   f0100f6c <cprintf>
f0106000:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106003:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106006:	83 c0 09             	add    $0x9,%eax
f0106009:	c1 e0 04             	shl    $0x4,%eax
f010600c:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0106011:	8b 00                	mov    (%eax),%eax
f0106013:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106016:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010601a:	74 08                	je     f0106024 <sched_kill_all+0x23c>
f010601c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010601f:	8b 40 08             	mov    0x8(%eax),%eax
f0106022:	eb 05                	jmp    f0106029 <sched_kill_all+0x241>
f0106024:	b8 00 00 00 00       	mov    $0x0,%eax
f0106029:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010602c:	83 c2 09             	add    $0x9,%edx
f010602f:	c1 e2 04             	shl    $0x4,%edx
f0106032:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0106038:	89 02                	mov    %eax,(%edx)
f010603a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010603d:	83 c0 09             	add    $0x9,%eax
f0106040:	c1 e0 04             	shl    $0x4,%eax
f0106043:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0106048:	8b 00                	mov    (%eax),%eax
f010604a:	85 c0                	test   %eax,%eax
f010604c:	0f 85 bd fe ff ff    	jne    f0105f0f <sched_kill_all+0x127>
f0106052:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106056:	0f 85 b3 fe ff ff    	jne    f0105f0f <sched_kill_all+0x127>
f010605c:	eb 13                	jmp    f0106071 <sched_kill_all+0x289>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f010605e:	83 ec 08             	sub    $0x8,%esp
f0106061:	ff 75 f0             	pushl  -0x10(%ebp)
f0106064:	68 d8 44 12 f0       	push   $0xf01244d8
f0106069:	e8 fe ae ff ff       	call   f0100f6c <cprintf>
f010606e:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f0106071:	83 ec 0c             	sub    $0xc,%esp
f0106074:	68 7c 44 12 f0       	push   $0xf012447c
f0106079:	e8 ee ae ff ff       	call   f0100f6c <cprintf>
f010607e:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106081:	ff 45 f0             	incl   -0x10(%ebp)
f0106084:	a0 60 51 55 f0       	mov    0xf0555160,%al
f0106089:	0f b6 c0             	movzbl %al,%eax
f010608c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010608f:	0f 8f 37 fe ff ff    	jg     f0105ecc <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0106095:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f010609a:	85 c0                	test   %eax,%eax
f010609c:	0f 84 95 00 00 00    	je     f0106137 <sched_kill_all+0x34f>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f01060a2:	83 ec 0c             	sub    $0xc,%esp
f01060a5:	68 08 46 12 f0       	push   $0xf0124608
f01060aa:	e8 bd ae ff ff       	call   f0100f6c <cprintf>
f01060af:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01060b2:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f01060b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01060ba:	eb 52                	jmp    f010610e <sched_kill_all+0x326>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01060bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060bf:	8d 50 20             	lea    0x20(%eax),%edx
f01060c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060c5:	8b 40 10             	mov    0x10(%eax),%eax
f01060c8:	83 ec 04             	sub    $0x4,%esp
f01060cb:	52                   	push   %edx
f01060cc:	50                   	push   %eax
f01060cd:	68 a4 45 12 f0       	push   $0xf01245a4
f01060d2:	e8 95 ae ff ff       	call   f0100f6c <cprintf>
f01060d7:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f01060da:	83 ec 0c             	sub    $0xc,%esp
f01060dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01060e0:	e8 d1 f1 ff ff       	call   f01052b6 <sched_remove_exit>
f01060e5:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01060e8:	83 ec 0c             	sub    $0xc,%esp
f01060eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01060ee:	e8 36 43 00 00       	call   f010a429 <env_free>
f01060f3:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f01060f6:	83 ec 0c             	sub    $0xc,%esp
f01060f9:	68 de 43 12 f0       	push   $0xf01243de
f01060fe:	e8 69 ae ff ff       	call   f0100f6c <cprintf>
f0106103:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106106:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f010610b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010610e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106112:	74 08                	je     f010611c <sched_kill_all+0x334>
f0106114:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106117:	8b 40 08             	mov    0x8(%eax),%eax
f010611a:	eb 05                	jmp    f0106121 <sched_kill_all+0x339>
f010611c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106121:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f0106126:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f010612b:	85 c0                	test   %eax,%eax
f010612d:	75 8d                	jne    f01060bc <sched_kill_all+0x2d4>
f010612f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106133:	75 87                	jne    f01060bc <sched_kill_all+0x2d4>
f0106135:	eb 10                	jmp    f0106147 <sched_kill_all+0x35f>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f0106137:	83 ec 0c             	sub    $0xc,%esp
f010613a:	68 1e 45 12 f0       	push   $0xf012451e
f010613f:	e8 28 ae ff ff       	call   f0100f6c <cprintf>
f0106144:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f0106147:	e8 25 43 00 00       	call   f010a471 <get_cpu_proc>
f010614c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f010614f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0106153:	74 6b                	je     f01061c0 <sched_kill_all+0x3d8>
	{
		ptr_env = cur_env;
f0106155:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106158:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f010615b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010615e:	8b 40 18             	mov    0x18(%eax),%eax
f0106161:	83 f8 02             	cmp    $0x2,%eax
f0106164:	74 19                	je     f010617f <sched_kill_all+0x397>
f0106166:	68 e4 43 12 f0       	push   $0xf01243e4
f010616b:	68 06 42 12 f0       	push   $0xf0124206
f0106170:	68 57 02 00 00       	push   $0x257
f0106175:	68 1b 42 12 f0       	push   $0xf012421b
f010617a:	e8 9b a1 ff ff       	call   f010031a <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010617f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106182:	8d 50 20             	lea    0x20(%eax),%edx
f0106185:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106188:	8b 40 10             	mov    0x10(%eax),%eax
f010618b:	83 ec 04             	sub    $0x4,%esp
f010618e:	52                   	push   %edx
f010618f:	50                   	push   %eax
f0106190:	68 08 44 12 f0       	push   $0xf0124408
f0106195:	e8 d2 ad ff ff       	call   f0100f6c <cprintf>
f010619a:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010619d:	83 ec 0c             	sub    $0xc,%esp
f01061a0:	ff 75 f4             	pushl  -0xc(%ebp)
f01061a3:	e8 81 42 00 00       	call   f010a429 <env_free>
f01061a8:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f01061ab:	83 ec 0c             	sub    $0xc,%esp
f01061ae:	68 de 43 12 f0       	push   $0xf01243de
f01061b3:	e8 b4 ad ff ff       	call   f0100f6c <cprintf>
f01061b8:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f01061bb:	e8 3e 44 00 00       	call   f010a5fe <sched>
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01061c0:	83 ec 0c             	sub    $0xc,%esp
f01061c3:	68 60 24 55 f0       	push   $0xf0552460
f01061c8:	e8 3a 86 00 00       	call   f010e807 <release_spinlock>
f01061cd:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f01061d0:	e8 ce bb ff ff       	call   f0101da3 <get_into_prompt>

f01061d5 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f01061d5:	55                   	push   %ebp
f01061d6:	89 e5                	mov    %esp,%ebp
f01061d8:	83 ec 18             	sub    $0x18,%esp
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01061db:	83 ec 0c             	sub    $0xc,%esp
f01061de:	68 60 24 55 f0       	push   $0xf0552460
f01061e3:	e8 98 85 00 00       	call   f010e780 <acquire_spinlock>
f01061e8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01061eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01061f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01061f9:	e9 59 01 00 00       	jmp    f0106357 <sched_exit_all_ready_envs+0x182>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f01061fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106201:	83 c0 09             	add    $0x9,%eax
f0106204:	c1 e0 04             	shl    $0x4,%eax
f0106207:	05 60 24 55 f0       	add    $0xf0552460,%eax
f010620c:	8b 00                	mov    (%eax),%eax
f010620e:	85 c0                	test   %eax,%eax
f0106210:	0f 84 3e 01 00 00    	je     f0106354 <sched_exit_all_ready_envs+0x17f>
		{
			ptr_env=NULL;
f0106216:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010621d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106220:	83 c0 09             	add    $0x9,%eax
f0106223:	c1 e0 04             	shl    $0x4,%eax
f0106226:	05 60 24 55 f0       	add    $0xf0552460,%eax
f010622b:	8b 00                	mov    (%eax),%eax
f010622d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106230:	e9 d9 00 00 00       	jmp    f010630e <sched_exit_all_ready_envs+0x139>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106235:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106239:	75 17                	jne    f0106252 <sched_exit_all_ready_envs+0x7d>
f010623b:	83 ec 04             	sub    $0x4,%esp
f010623e:	68 57 42 12 f0       	push   $0xf0124257
f0106243:	68 79 02 00 00       	push   $0x279
f0106248:	68 1b 42 12 f0       	push   $0xf012421b
f010624d:	e8 c8 a0 ff ff       	call   f010031a <_panic>
f0106252:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106255:	8b 40 08             	mov    0x8(%eax),%eax
f0106258:	85 c0                	test   %eax,%eax
f010625a:	74 11                	je     f010626d <sched_exit_all_ready_envs+0x98>
f010625c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010625f:	8b 40 08             	mov    0x8(%eax),%eax
f0106262:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106265:	8b 52 0c             	mov    0xc(%edx),%edx
f0106268:	89 50 0c             	mov    %edx,0xc(%eax)
f010626b:	eb 17                	jmp    f0106284 <sched_exit_all_ready_envs+0xaf>
f010626d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106270:	8b 40 0c             	mov    0xc(%eax),%eax
f0106273:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106276:	83 c2 09             	add    $0x9,%edx
f0106279:	c1 e2 04             	shl    $0x4,%edx
f010627c:	81 c2 64 24 55 f0    	add    $0xf0552464,%edx
f0106282:	89 02                	mov    %eax,(%edx)
f0106284:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106287:	8b 40 0c             	mov    0xc(%eax),%eax
f010628a:	85 c0                	test   %eax,%eax
f010628c:	74 11                	je     f010629f <sched_exit_all_ready_envs+0xca>
f010628e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106291:	8b 40 0c             	mov    0xc(%eax),%eax
f0106294:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106297:	8b 52 08             	mov    0x8(%edx),%edx
f010629a:	89 50 08             	mov    %edx,0x8(%eax)
f010629d:	eb 17                	jmp    f01062b6 <sched_exit_all_ready_envs+0xe1>
f010629f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062a2:	8b 40 08             	mov    0x8(%eax),%eax
f01062a5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01062a8:	83 c2 09             	add    $0x9,%edx
f01062ab:	c1 e2 04             	shl    $0x4,%edx
f01062ae:	81 c2 60 24 55 f0    	add    $0xf0552460,%edx
f01062b4:	89 02                	mov    %eax,(%edx)
f01062b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062b9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01062c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01062c3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01062ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062cd:	83 c0 09             	add    $0x9,%eax
f01062d0:	c1 e0 04             	shl    $0x4,%eax
f01062d3:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f01062d8:	8b 00                	mov    (%eax),%eax
f01062da:	8d 50 ff             	lea    -0x1(%eax),%edx
f01062dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062e0:	83 c0 09             	add    $0x9,%eax
f01062e3:	c1 e0 04             	shl    $0x4,%eax
f01062e6:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f01062eb:	89 10                	mov    %edx,(%eax)
				sched_insert_exit(ptr_env);
f01062ed:	83 ec 0c             	sub    $0xc,%esp
f01062f0:	ff 75 f4             	pushl  -0xc(%ebp)
f01062f3:	e8 37 ef ff ff       	call   f010522f <sched_insert_exit>
f01062f8:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f01062fb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01062fe:	83 c0 09             	add    $0x9,%eax
f0106301:	c1 e0 04             	shl    $0x4,%eax
f0106304:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0106309:	8b 00                	mov    (%eax),%eax
f010630b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010630e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106312:	74 08                	je     f010631c <sched_exit_all_ready_envs+0x147>
f0106314:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106317:	8b 40 08             	mov    0x8(%eax),%eax
f010631a:	eb 05                	jmp    f0106321 <sched_exit_all_ready_envs+0x14c>
f010631c:	b8 00 00 00 00       	mov    $0x0,%eax
f0106321:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106324:	83 c2 09             	add    $0x9,%edx
f0106327:	c1 e2 04             	shl    $0x4,%edx
f010632a:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f0106330:	89 02                	mov    %eax,(%edx)
f0106332:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0106335:	83 c0 09             	add    $0x9,%eax
f0106338:	c1 e0 04             	shl    $0x4,%eax
f010633b:	05 68 24 55 f0       	add    $0xf0552468,%eax
f0106340:	8b 00                	mov    (%eax),%eax
f0106342:	85 c0                	test   %eax,%eax
f0106344:	0f 85 eb fe ff ff    	jne    f0106235 <sched_exit_all_ready_envs+0x60>
f010634a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010634e:	0f 85 e1 fe ff ff    	jne    f0106235 <sched_exit_all_ready_envs+0x60>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106354:	ff 45 f0             	incl   -0x10(%ebp)
f0106357:	a0 60 51 55 f0       	mov    0xf0555160,%al
f010635c:	0f b6 c0             	movzbl %al,%eax
f010635f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0106362:	0f 8f 96 fe ff ff    	jg     f01061fe <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_spinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106368:	83 ec 0c             	sub    $0xc,%esp
f010636b:	68 60 24 55 f0       	push   $0xf0552460
f0106370:	e8 92 84 00 00       	call   f010e807 <release_spinlock>
f0106375:	83 c4 10             	add    $0x10,%esp
}
f0106378:	90                   	nop
f0106379:	c9                   	leave  
f010637a:	c3                   	ret    

f010637b <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f010637b:	55                   	push   %ebp
f010637c:	89 e5                	mov    %esp,%ebp
	return ticks;
f010637e:	a1 c8 50 55 f0       	mov    0xf05550c8,%eax
f0106383:	8b 15 cc 50 55 f0    	mov    0xf05550cc,%edx
}
f0106389:	5d                   	pop    %ebp
f010638a:	c3                   	ret    

f010638b <env_get_nice>:
int env_get_nice(struct Env* e)
{
f010638b:	55                   	push   %ebp
f010638c:	89 e5                	mov    %esp,%ebp
f010638e:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106391:	83 ec 04             	sub    $0x4,%esp
f0106394:	68 34 46 12 f0       	push   $0xf0124634
f0106399:	68 8c 02 00 00       	push   $0x28c
f010639e:	68 1b 42 12 f0       	push   $0xf012421b
f01063a3:	e8 72 9f ff ff       	call   f010031a <_panic>

f01063a8 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f01063a8:	55                   	push   %ebp
f01063a9:	89 e5                	mov    %esp,%ebp
f01063ab:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_set_nice
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01063ae:	83 ec 04             	sub    $0x4,%esp
f01063b1:	68 34 46 12 f0       	push   $0xf0124634
f01063b6:	68 94 02 00 00       	push   $0x294
f01063bb:	68 1b 42 12 f0       	push   $0xf012421b
f01063c0:	e8 55 9f ff ff       	call   f010031a <_panic>

f01063c5 <env_get_recent_cpu>:
}

int env_get_recent_cpu(struct Env* e)
{
f01063c5:	55                   	push   %ebp
f01063c6:	89 e5                	mov    %esp,%ebp
f01063c8:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] BSD Scheduler - env_get_recent_cpu
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01063cb:	83 ec 04             	sub    $0x4,%esp
f01063ce:	68 34 46 12 f0       	push   $0xf0124634
f01063d3:	68 9c 02 00 00       	push   $0x29c
f01063d8:	68 1b 42 12 f0       	push   $0xf012421b
f01063dd:	e8 38 9f ff ff       	call   f010031a <_panic>

f01063e2 <get_load_average>:
}
int get_load_average()
{
f01063e2:	55                   	push   %ebp
f01063e3:	89 e5                	mov    %esp,%ebp
f01063e5:	83 ec 08             	sub    $0x8,%esp
	//return 1;
	//[PROJECT] BSD Scheduler - get_load_average
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f01063e8:	83 ec 04             	sub    $0x4,%esp
f01063eb:	68 34 46 12 f0       	push   $0xf0124634
f01063f0:	68 a4 02 00 00       	push   $0x2a4
f01063f5:	68 1b 42 12 f0       	push   $0xf012421b
f01063fa:	e8 1b 9f ff ff       	call   f010031a <_panic>

f01063ff <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){if(scheduler_method == SCH_RR) return 1; return 0;}
f01063ff:	55                   	push   %ebp
f0106400:	89 e5                	mov    %esp,%ebp
f0106402:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f0106407:	85 c0                	test   %eax,%eax
f0106409:	75 07                	jne    f0106412 <isSchedMethodRR+0x13>
f010640b:	b8 01 00 00 00       	mov    $0x1,%eax
f0106410:	eb 05                	jmp    f0106417 <isSchedMethodRR+0x18>
f0106412:	b8 00 00 00 00       	mov    $0x0,%eax
f0106417:	5d                   	pop    %ebp
f0106418:	c3                   	ret    

f0106419 <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){if(scheduler_method == SCH_MLFQ) return 1; return 0;}
f0106419:	55                   	push   %ebp
f010641a:	89 e5                	mov    %esp,%ebp
f010641c:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f0106421:	83 f8 01             	cmp    $0x1,%eax
f0106424:	75 07                	jne    f010642d <isSchedMethodMLFQ+0x14>
f0106426:	b8 01 00 00 00       	mov    $0x1,%eax
f010642b:	eb 05                	jmp    f0106432 <isSchedMethodMLFQ+0x19>
f010642d:	b8 00 00 00 00       	mov    $0x0,%eax
f0106432:	5d                   	pop    %ebp
f0106433:	c3                   	ret    

f0106434 <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){if(scheduler_method == SCH_BSD) return 1; return 0;}
f0106434:	55                   	push   %ebp
f0106435:	89 e5                	mov    %esp,%ebp
f0106437:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f010643c:	83 f8 02             	cmp    $0x2,%eax
f010643f:	75 07                	jne    f0106448 <isSchedMethodBSD+0x14>
f0106441:	b8 01 00 00 00       	mov    $0x1,%eax
f0106446:	eb 05                	jmp    f010644d <isSchedMethodBSD+0x19>
f0106448:	b8 00 00 00 00       	mov    $0x0,%eax
f010644d:	5d                   	pop    %ebp
f010644e:	c3                   	ret    

f010644f <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f010644f:	55                   	push   %ebp
f0106450:	89 e5                	mov    %esp,%ebp
f0106452:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f0106455:	c7 05 e8 4b 55 f0 00 	movl   $0x0,0xf0554be8
f010645c:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f010645f:	83 ec 0c             	sub    $0xc,%esp
f0106462:	6a 0a                	push   $0xa
f0106464:	e8 6d 02 00 00       	call   f01066d6 <sched_init_RR>
f0106469:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f010646c:	83 ec 0c             	sub    $0xc,%esp
f010646f:	68 d0 24 55 f0       	push   $0xf05524d0
f0106474:	e8 bf e7 ff ff       	call   f0104c38 <init_queue>
f0106479:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f010647c:	83 ec 0c             	sub    $0xc,%esp
f010647f:	68 e0 24 55 f0       	push   $0xf05524e0
f0106484:	e8 af e7 ff ff       	call   f0104c38 <init_queue>
f0106489:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f010648c:	e8 6d 09 00 00       	call   f0106dfe <mycpu>
f0106491:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0106498:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_spinlock(&ProcessQueues.qlock, "process queues lock");
f010649b:	83 ec 08             	sub    $0x8,%esp
f010649e:	68 48 46 12 f0       	push   $0xf0124648
f01064a3:	68 60 24 55 f0       	push   $0xf0552460
f01064a8:	e8 a2 82 00 00       	call   f010e74f <init_spinlock>
f01064ad:	83 c4 10             	add    $0x10,%esp
}
f01064b0:	90                   	nop
f01064b1:	c9                   	leave  
f01064b2:	c3                   	ret    

f01064b3 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f01064b3:	55                   	push   %ebp
f01064b4:	89 e5                	mov    %esp,%ebp
f01064b6:	53                   	push   %ebx
f01064b7:	83 ec 24             	sub    $0x24,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01064ba:	9c                   	pushf  
f01064bb:	58                   	pop    %eax
f01064bc:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f01064bf:	8b 45 d8             	mov    -0x28(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f01064c2:	25 00 02 00 00       	and    $0x200,%eax
f01064c7:	85 c0                	test   %eax,%eax
f01064c9:	74 14                	je     f01064df <fos_scheduler+0x2c>
		panic("fos_scheduler: called while the interrupt is enabled!");
f01064cb:	83 ec 04             	sub    $0x4,%esp
f01064ce:	68 5c 46 12 f0       	push   $0xf012465c
f01064d3:	6a 37                	push   $0x37
f01064d5:	68 92 46 12 f0       	push   $0xf0124692
f01064da:	e8 3b 9e ff ff       	call   f010031a <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f01064df:	e8 1a 09 00 00       	call   f0106dfe <mycpu>
f01064e4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f01064e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01064ea:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f01064f1:	00 00 00 

	chk1();
f01064f4:	e8 ff 91 01 00       	call   f011f6f8 <chk1>
	c->scheduler_status = SCH_STARTED;
f01064f9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01064fc:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0106503:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0106506:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f010650d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106514:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_spinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f0106515:	83 ec 0c             	sub    $0xc,%esp
f0106518:	68 60 24 55 f0       	push   $0xf0552460
f010651d:	e8 5e 82 00 00       	call   f010e780 <acquire_spinlock>
f0106522:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f0106525:	a1 14 4f 55 f0       	mov    0xf0554f14,%eax
f010652a:	8b 04 85 4c 99 17 f0 	mov    -0xfe866b4(,%eax,4),%eax
f0106531:	ff d0                	call   *%eax
f0106533:	89 45 e8             	mov    %eax,-0x18(%ebp)

			//temporarily set the curenv by the next env JUST for checking the scheduler
			//Then: reset it again
			struct Env* old_curenv = get_cpu_proc();
f0106536:	e8 36 3f 00 00       	call   f010a471 <get_cpu_proc>
f010653b:	89 45 e0             	mov    %eax,-0x20(%ebp)
			set_cpu_proc(next_env) ;
f010653e:	83 ec 0c             	sub    $0xc,%esp
f0106541:	ff 75 e8             	pushl  -0x18(%ebp)
f0106544:	e8 51 3f 00 00       	call   f010a49a <set_cpu_proc>
f0106549:	83 c4 10             	add    $0x10,%esp
			chk2(next_env) ;
f010654c:	83 ec 0c             	sub    $0xc,%esp
f010654f:	ff 75 e8             	pushl  -0x18(%ebp)
f0106552:	e8 a7 91 01 00       	call   f011f6fe <chk2>
f0106557:	83 c4 10             	add    $0x10,%esp
			set_cpu_proc(old_curenv) ;
f010655a:	83 ec 0c             	sub    $0xc,%esp
f010655d:	ff 75 e0             	pushl  -0x20(%ebp)
f0106560:	e8 35 3f 00 00       	call   f010a49a <set_cpu_proc>
f0106565:	83 c4 10             	add    $0x10,%esp

			//sched_print_all();

			if(next_env != NULL)
f0106568:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010656c:	0f 84 d6 00 00 00    	je     f0106648 <fos_scheduler+0x195>
				/*2024: Replaced by context_switch()*/
				//env_run(next_env);

				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f0106572:	83 ec 0c             	sub    $0xc,%esp
f0106575:	ff 75 e8             	pushl  -0x18(%ebp)
f0106578:	e8 1d 3f 00 00       	call   f010a49a <set_cpu_proc>
f010657d:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f0106580:	83 ec 0c             	sub    $0xc,%esp
f0106583:	ff 75 e8             	pushl  -0x18(%ebp)
f0106586:	e8 96 41 00 00       	call   f010a721 <switchuvm>
f010658b:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f010658e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106591:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f0106598:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010659b:	8b 40 04             	mov    0x4(%eax),%eax
f010659e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01065a1:	83 c2 04             	add    $0x4,%edx
f01065a4:	83 ec 08             	sub    $0x8,%esp
f01065a7:	50                   	push   %eax
f01065a8:	52                   	push   %edx
f01065a9:	e8 92 e2 ff ff       	call   f0104840 <context_switch>
f01065ae:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01065b1:	9c                   	pushf  
f01065b2:	58                   	pop    %eax
f01065b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f01065b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax

				//ensure that the scheduler is invoked while interrupt is disabled
				if (read_eflags() & FL_IF)
f01065b9:	25 00 02 00 00       	and    $0x200,%eax
f01065be:	85 c0                	test   %eax,%eax
f01065c0:	74 14                	je     f01065d6 <fos_scheduler+0x123>
					panic("fos_scheduler: invoked while the interrupt is enabled!");
f01065c2:	83 ec 04             	sub    $0x4,%esp
f01065c5:	68 a4 46 12 f0       	push   $0xf01246a4
f01065ca:	6a 74                	push   $0x74
f01065cc:	68 92 46 12 f0       	push   $0xf0124692
f01065d1:	e8 44 9d ff ff       	call   f010031a <_panic>

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f01065d6:	e8 ae e3 ff ff       	call   f0104989 <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, curenv == NULL? 0 : curenv->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f01065db:	e8 91 3e 00 00       	call   f010a471 <get_cpu_proc>
f01065e0:	89 c2                	mov    %eax,%edx
f01065e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01065e5:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01065eb:	39 c2                	cmp    %eax,%edx
f01065ed:	74 16                	je     f0106605 <fos_scheduler+0x152>
f01065ef:	68 db 46 12 f0       	push   $0xf01246db
f01065f4:	68 f5 46 12 f0       	push   $0xf01246f5
f01065f9:	6a 7d                	push   $0x7d
f01065fb:	68 92 46 12 f0       	push   $0xf0124692
f0106600:	e8 15 9d ff ff       	call   f010031a <_panic>
				int status = c->proc->env_status ;
f0106605:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106608:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010660e:	8b 40 18             	mov    0x18(%eax),%eax
f0106611:	89 45 dc             	mov    %eax,-0x24(%ebp)
				assert(status != ENV_RUNNING);
f0106614:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
f0106618:	75 16                	jne    f0106630 <fos_scheduler+0x17d>
f010661a:	68 0a 47 12 f0       	push   $0xf012470a
f010661f:	68 f5 46 12 f0       	push   $0xf01246f5
f0106624:	6a 7f                	push   $0x7f
f0106626:	68 92 46 12 f0       	push   $0xf0124692
f010662b:	e8 ea 9c ff ff       	call   f010031a <_panic>
				if (status == ENV_READY)
f0106630:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f0106634:	74 12                	je     f0106648 <fos_scheduler+0x195>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f0106636:	e8 cf 40 00 00       	call   f010a70a <switchkvm>
					set_cpu_proc(NULL);
f010663b:	83 ec 0c             	sub    $0xc,%esp
f010663e:	6a 00                	push   $0x0
f0106640:	e8 55 3e 00 00       	call   f010a49a <set_cpu_proc>
f0106645:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f0106648:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010664c:	0f 85 d3 fe ff ff    	jne    f0106525 <fos_scheduler+0x72>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f0106652:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f0106659:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106660:	eb 4d                	jmp    f01066af <fos_scheduler+0x1fc>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f0106662:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f0106668:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010666b:	89 d0                	mov    %edx,%eax
f010666d:	c1 e0 06             	shl    $0x6,%eax
f0106670:	29 d0                	sub    %edx,%eax
f0106672:	c1 e0 02             	shl    $0x2,%eax
f0106675:	01 d0                	add    %edx,%eax
f0106677:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f010667e:	01 d8                	add    %ebx,%eax
f0106680:	c1 e0 03             	shl    $0x3,%eax
f0106683:	01 d0                	add    %edx,%eax
f0106685:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010668c:	29 c2                	sub    %eax,%edx
f010668e:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0106695:	89 c2                	mov    %eax,%edx
f0106697:	89 d0                	mov    %edx,%eax
f0106699:	01 c8                	add    %ecx,%eax
f010669b:	8b 40 18             	mov    0x18(%eax),%eax
f010669e:	83 f8 03             	cmp    $0x3,%eax
f01066a1:	75 09                	jne    f01066ac <fos_scheduler+0x1f9>
			{
				is_any_blocked = 1;
f01066a3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f01066aa:	eb 0b                	jmp    f01066b7 <fos_scheduler+0x204>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f01066ac:	ff 45 f0             	incl   -0x10(%ebp)
f01066af:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01066b2:	83 f8 07             	cmp    $0x7,%eax
f01066b5:	76 ab                	jbe    f0106662 <fos_scheduler+0x1af>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_spinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f01066b7:	83 ec 0c             	sub    $0xc,%esp
f01066ba:	68 60 24 55 f0       	push   $0xf0552460
f01066bf:	e8 43 81 00 00       	call   f010e807 <release_spinlock>
f01066c4:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);

	} while (is_any_blocked > 0);
f01066c7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01066cb:	0f 8f 43 fe ff ff    	jg     f0106514 <fos_scheduler+0x61>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f01066d1:	e8 cd b6 ff ff       	call   f0101da3 <get_into_prompt>

f01066d6 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f01066d6:	55                   	push   %ebp
f01066d7:	89 e5                	mov    %esp,%ebp
f01066d9:	83 ec 28             	sub    $0x28,%esp
f01066dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01066df:	88 45 e4             	mov    %al,-0x1c(%ebp)

	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f01066e2:	c6 05 60 51 55 f0 01 	movb   $0x1,0xf0555160
	//cprintf("sizeof(struct Env_Queue) = %x\n", sizeof(struct Env_Queue));
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
	//cprintf("num_of_ready_queues * sizeof(uint8) = %x\n", num_of_ready_queues * sizeof(uint8));

#endif
	quantums[0] = quantum;
f01066e9:	8a 45 e4             	mov    -0x1c(%ebp),%al
f01066ec:	a2 e4 4d 55 f0       	mov    %al,0xf0554de4
	kclock_set_quantum(quantums[0]);
f01066f1:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f01066f6:	0f b6 c0             	movzbl %al,%eax
f01066f9:	83 ec 0c             	sub    $0xc,%esp
f01066fc:	50                   	push   %eax
f01066fd:	e8 50 e3 ff ff       	call   f0104a52 <kclock_set_quantum>
f0106702:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0106705:	83 ec 0c             	sub    $0xc,%esp
f0106708:	68 f0 24 55 f0       	push   $0xf05524f0
f010670d:	e8 26 e5 ff ff       	call   f0104c38 <init_queue>
f0106712:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0106715:	e8 97 e4 ff ff       	call   f0104bb1 <kclock_read_cnt0_latch>
f010671a:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f010671e:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0106722:	83 ec 08             	sub    $0x8,%esp
f0106725:	50                   	push   %eax
f0106726:	68 20 47 12 f0       	push   $0xf0124720
f010672b:	e8 3c a8 ff ff       	call   f0100f6c <cprintf>
f0106730:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0106733:	e8 c6 06 00 00       	call   f0106dfe <mycpu>
f0106738:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010673f:	00 00 00 
	scheduler_method = SCH_RR;
f0106742:	c7 05 14 4f 55 f0 00 	movl   $0x0,0xf0554f14
f0106749:	00 00 00 
	//=========================================
	//=========================================
}
f010674c:	90                   	nop
f010674d:	c9                   	leave  
f010674e:	c3                   	ret    

f010674f <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f010674f:	55                   	push   %ebp
f0106750:	89 e5                	mov    %esp,%ebp
f0106752:	83 ec 18             	sub    $0x18,%esp
f0106755:	8b 45 08             	mov    0x8(%ebp),%eax
f0106758:	88 45 f4             	mov    %al,-0xc(%ebp)
	//=========================================
	//DON'T CHANGE THESE LINES=================
	sched_delete_ready_queues();
f010675b:	e8 88 e7 ff ff       	call   f0104ee8 <sched_delete_ready_queues>
	//=========================================
	//=========================================
	//[PROJECT] MLFQ Scheduler - sched_init_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106760:	83 ec 04             	sub    $0x4,%esp
f0106763:	68 48 47 12 f0       	push   $0xf0124748
f0106768:	68 ce 00 00 00       	push   $0xce
f010676d:	68 92 46 12 f0       	push   $0xf0124692
f0106772:	e8 a3 9b ff ff       	call   f010031a <_panic>

f0106777 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0106777:	55                   	push   %ebp
f0106778:	89 e5                	mov    %esp,%ebp
f010677a:	83 ec 18             	sub    $0x18,%esp
f010677d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106780:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106783:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0106786:	88 45 f0             	mov    %al,-0x10(%ebp)
	//[PROJECT] BSD Scheduler - sched_init_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106789:	83 ec 04             	sub    $0x4,%esp
f010678c:	68 48 47 12 f0       	push   $0xf0124748
f0106791:	68 e4 00 00 00       	push   $0xe4
f0106796:	68 92 46 12 f0       	push   $0xf0124692
f010679b:	e8 7a 9b ff ff       	call   f010031a <_panic>

f01067a0 <fos_scheduler_RR>:

//=========================
// [6] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f01067a0:	55                   	push   %ebp
f01067a1:	89 e5                	mov    %esp,%ebp
f01067a3:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f01067a6:	83 ec 0c             	sub    $0xc,%esp
f01067a9:	68 60 24 55 f0       	push   $0xf0552460
f01067ae:	e8 e6 81 00 00       	call   f010e999 <holding_spinlock>
f01067b3:	83 c4 10             	add    $0x10,%esp
f01067b6:	85 c0                	test   %eax,%eax
f01067b8:	75 17                	jne    f01067d1 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f01067ba:	83 ec 04             	sub    $0x4,%esp
f01067bd:	68 5c 47 12 f0       	push   $0xf012475c
f01067c2:	68 fe 00 00 00       	push   $0xfe
f01067c7:	68 92 46 12 f0       	push   $0xf0124692
f01067cc:	e8 49 9b ff ff       	call   f010031a <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f01067d1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f01067d8:	e8 94 3c 00 00       	call   f010a471 <get_cpu_proc>
f01067dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f01067e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01067e4:	74 13                	je     f01067f9 <fos_scheduler_RR+0x59>
	{
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f01067e6:	83 ec 08             	sub    $0x8,%esp
f01067e9:	ff 75 f0             	pushl  -0x10(%ebp)
f01067ec:	68 f0 24 55 f0       	push   $0xf05524f0
f01067f1:	e8 83 e4 ff ff       	call   f0104c79 <enqueue>
f01067f6:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f01067f9:	83 ec 0c             	sub    $0xc,%esp
f01067fc:	68 f0 24 55 f0       	push   $0xf05524f0
f0106801:	e8 04 e5 ff ff       	call   f0104d0a <dequeue>
f0106806:	83 c4 10             	add    $0x10,%esp
f0106809:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f010680c:	a0 e4 4d 55 f0       	mov    0xf0554de4,%al
f0106811:	0f b6 c0             	movzbl %al,%eax
f0106814:	83 ec 0c             	sub    $0xc,%esp
f0106817:	50                   	push   %eax
f0106818:	e8 35 e2 ff ff       	call   f0104a52 <kclock_set_quantum>
f010681d:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0106820:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106823:	c9                   	leave  
f0106824:	c3                   	ret    

f0106825 <fos_scheduler_MLFQ>:

//=========================
// [6] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0106825:	55                   	push   %ebp
f0106826:	89 e5                	mov    %esp,%ebp
f0106828:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010682b:	83 ec 0c             	sub    $0xc,%esp
f010682e:	68 60 24 55 f0       	push   $0xf0552460
f0106833:	e8 61 81 00 00       	call   f010e999 <holding_spinlock>
f0106838:	83 c4 10             	add    $0x10,%esp
f010683b:	85 c0                	test   %eax,%eax
f010683d:	75 17                	jne    f0106856 <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f010683f:	83 ec 04             	sub    $0x4,%esp
f0106842:	68 a8 47 12 f0       	push   $0xf01247a8
f0106847:	68 1d 01 00 00       	push   $0x11d
f010684c:	68 92 46 12 f0       	push   $0xf0124692
f0106851:	e8 c4 9a ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] MLFQ Scheduler - fos_scheduler_MLFQ
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f0106856:	83 ec 04             	sub    $0x4,%esp
f0106859:	68 48 47 12 f0       	push   $0xf0124748
f010685e:	68 23 01 00 00       	push   $0x123
f0106863:	68 92 46 12 f0       	push   $0xf0124692
f0106868:	e8 ad 9a ff ff       	call   f010031a <_panic>

f010686d <fos_scheduler_BSD>:

//=========================
// [7] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f010686d:	55                   	push   %ebp
f010686e:	89 e5                	mov    %esp,%ebp
f0106870:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_spinlock(&ProcessQueues.qlock))
f0106873:	83 ec 0c             	sub    $0xc,%esp
f0106876:	68 60 24 55 f0       	push   $0xf0552460
f010687b:	e8 19 81 00 00       	call   f010e999 <holding_spinlock>
f0106880:	83 c4 10             	add    $0x10,%esp
f0106883:	85 c0                	test   %eax,%eax
f0106885:	75 17                	jne    f010689e <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0106887:	83 ec 04             	sub    $0x4,%esp
f010688a:	68 f8 47 12 f0       	push   $0xf01247f8
f010688f:	68 2e 01 00 00       	push   $0x12e
f0106894:	68 92 46 12 f0       	push   $0xf0124692
f0106899:	e8 7c 9a ff ff       	call   f010031a <_panic>
	/****************************************************************************************/

	//[PROJECT] BSD Scheduler - fos_scheduler_BSD
	//Your code is here
	//Comment the following line
	panic("Not implemented yet");
f010689e:	83 ec 04             	sub    $0x4,%esp
f01068a1:	68 48 47 12 f0       	push   $0xf0124748
f01068a6:	68 34 01 00 00       	push   $0x134
f01068ab:	68 92 46 12 f0       	push   $0xf0124692
f01068b0:	e8 65 9a ff ff       	call   f010031a <_panic>

f01068b5 <clock_interrupt_handler>:
//========================================
// [8] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f01068b5:	55                   	push   %ebp
f01068b6:	89 e5                	mov    %esp,%ebp
f01068b8:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodBSD())
f01068bb:	e8 74 fb ff ff       	call   f0106434 <isSchedMethodBSD>
f01068c0:	85 c0                	test   %eax,%eax
f01068c2:	74 17                	je     f01068db <clock_interrupt_handler+0x26>
	{
		//[PROJECT] BSD Scheduler - clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("Not implemented yet");
f01068c4:	83 ec 04             	sub    $0x4,%esp
f01068c7:	68 48 47 12 f0       	push   $0xf0124748
f01068cc:	68 43 01 00 00       	push   $0x143
f01068d1:	68 92 46 12 f0       	push   $0xf0124692
f01068d6:	e8 3f 9a ff ff       	call   f010031a <_panic>
	}



	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f01068db:	a1 c8 50 55 f0       	mov    0xf05550c8,%eax
f01068e0:	8b 15 cc 50 55 f0    	mov    0xf05550cc,%edx
f01068e6:	83 c0 01             	add    $0x1,%eax
f01068e9:	83 d2 00             	adc    $0x0,%edx
f01068ec:	a3 c8 50 55 f0       	mov    %eax,0xf05550c8
f01068f1:	89 15 cc 50 55 f0    	mov    %edx,0xf05550cc
	struct Env* p = get_cpu_proc();
f01068f7:	e8 75 3b 00 00       	call   f010a471 <get_cpu_proc>
f01068fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f01068ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106903:	74 30                	je     f0106935 <clock_interrupt_handler+0x80>
	{
	}
	else
	{
		p->nClocks++ ;
f0106905:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106908:	8b 80 68 da 01 00    	mov    0x1da68(%eax),%eax
f010690e:	8d 50 01             	lea    0x1(%eax),%edx
f0106911:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106914:	89 90 68 da 01 00    	mov    %edx,0x1da68(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010691a:	83 ec 0c             	sub    $0xc,%esp
f010691d:	6a 01                	push   $0x1
f010691f:	e8 4b 7a 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f0106924:	83 c4 10             	add    $0x10,%esp
f0106927:	85 c0                	test   %eax,%eax
f0106929:	74 05                	je     f0106930 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f010692b:	e8 08 00 00 00       	call   f0106938 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0106930:	e8 6a 3c 00 00       	call   f010a59f <yield>
	}
	/*****************************************/
}
f0106935:	90                   	nop
f0106936:	c9                   	leave  
f0106937:	c3                   	ret    

f0106938 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0106938:	55                   	push   %ebp
f0106939:	89 e5                	mov    %esp,%ebp
f010693b:	53                   	push   %ebx
f010693c:	83 ec 34             	sub    $0x34,%esp
	struct Env *curr_env_ptr = get_cpu_proc();
f010693f:	e8 2d 3b 00 00       	call   f010a471 <get_cpu_proc>
f0106944:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(curr_env_ptr != NULL)
f0106947:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010694b:	0f 84 9d 01 00 00    	je     f0106aee <update_WS_time_stamps+0x1b6>
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f0106951:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0106958:	e9 99 00 00 00       	jmp    f01069f6 <update_WS_time_stamps+0xbe>
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
f010695d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106960:	89 d0                	mov    %edx,%eax
f0106962:	01 c0                	add    %eax,%eax
f0106964:	01 d0                	add    %edx,%eax
f0106966:	c1 e0 03             	shl    $0x3,%eax
f0106969:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010696f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106972:	01 d0                	add    %edx,%eax
f0106974:	83 c0 08             	add    $0x8,%eax
f0106977:	89 45 e8             	mov    %eax,-0x18(%ebp)
					if( wse->empty == 1)
f010697a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010697d:	8a 40 04             	mov    0x4(%eax),%al
f0106980:	3c 01                	cmp    $0x1,%al
f0106982:	74 6e                	je     f01069f2 <update_WS_time_stamps+0xba>
						continue;
#endif
					//update the time if the page was referenced
					uint32 page_va = wse->virtual_address ;
f0106984:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106987:	8b 00                	mov    (%eax),%eax
f0106989:	89 45 e4             	mov    %eax,-0x1c(%ebp)
					uint32 perm = pt_get_page_permissions(curr_env_ptr->env_page_directory, page_va) ;
f010698c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010698f:	8b 40 64             	mov    0x64(%eax),%eax
f0106992:	83 ec 08             	sub    $0x8,%esp
f0106995:	ff 75 e4             	pushl  -0x1c(%ebp)
f0106998:	50                   	push   %eax
f0106999:	e8 4f 1f 00 00       	call   f01088ed <pt_get_page_permissions>
f010699e:	83 c4 10             	add    $0x10,%esp
f01069a1:	89 45 e0             	mov    %eax,-0x20(%ebp)
					uint32 oldTimeStamp = wse->time_stamp;
f01069a4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01069a7:	8b 40 08             	mov    0x8(%eax),%eax
f01069aa:	89 45 dc             	mov    %eax,-0x24(%ebp)

					if (perm & PERM_USED)
f01069ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01069b0:	83 e0 20             	and    $0x20,%eax
f01069b3:	85 c0                	test   %eax,%eax
f01069b5:	74 2b                	je     f01069e2 <update_WS_time_stamps+0xaa>
					{
						wse->time_stamp = (oldTimeStamp>>2) | 0x80000000;
f01069b7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01069ba:	c1 e8 02             	shr    $0x2,%eax
f01069bd:	0d 00 00 00 80       	or     $0x80000000,%eax
f01069c2:	89 c2                	mov    %eax,%edx
f01069c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01069c7:	89 50 08             	mov    %edx,0x8(%eax)
						pt_set_page_permissions(curr_env_ptr->env_page_directory, page_va, 0 , PERM_USED) ;
f01069ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01069cd:	8b 40 64             	mov    0x64(%eax),%eax
f01069d0:	6a 20                	push   $0x20
f01069d2:	6a 00                	push   $0x0
f01069d4:	ff 75 e4             	pushl  -0x1c(%ebp)
f01069d7:	50                   	push   %eax
f01069d8:	e8 4c 1e 00 00       	call   f0108829 <pt_set_page_permissions>
f01069dd:	83 c4 10             	add    $0x10,%esp
f01069e0:	eb 11                	jmp    f01069f3 <update_WS_time_stamps+0xbb>
					}
					else
					{
						wse->time_stamp = (oldTimeStamp>>2);
f01069e2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01069e5:	c1 e8 02             	shr    $0x2,%eax
f01069e8:	89 c2                	mov    %eax,%edx
f01069ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01069ed:	89 50 08             	mov    %edx,0x8(%eax)
f01069f0:	eb 01                	jmp    f01069f3 <update_WS_time_stamps+0xbb>
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
				{
					wse = &(curr_env_ptr->ptr_pageWorkingSet[i]);
					if( wse->empty == 1)
						continue;
f01069f2:	90                   	nop
			int i ;
#if USE_KHEAP
			LIST_FOREACH(wse, &(curr_env_ptr->page_WS_list))
			{
#else
				for (i = 0 ; i < (curr_env_ptr->page_WS_max_size); i++)
f01069f3:	ff 45 f4             	incl   -0xc(%ebp)
f01069f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01069f9:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f01069ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a02:	39 c2                	cmp    %eax,%edx
f0106a04:	0f 87 53 ff ff ff    	ja     f010695d <update_WS_time_stamps+0x25>
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106a0a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106a11:	e9 ce 00 00 00       	jmp    f0106ae4 <update_WS_time_stamps+0x1ac>
				{
					if( curr_env_ptr->__ptr_tws[t].empty != 1)
f0106a16:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106a19:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a1c:	89 d0                	mov    %edx,%eax
f0106a1e:	01 c0                	add    %eax,%eax
f0106a20:	01 d0                	add    %edx,%eax
f0106a22:	c1 e0 03             	shl    $0x3,%eax
f0106a25:	01 c8                	add    %ecx,%eax
f0106a27:	05 60 d5 01 00       	add    $0x1d560,%eax
f0106a2c:	8a 00                	mov    (%eax),%al
f0106a2e:	3c 01                	cmp    $0x1,%al
f0106a30:	0f 84 ab 00 00 00    	je     f0106ae1 <update_WS_time_stamps+0x1a9>
					{
						//update the time if the page was referenced
						uint32 table_va = curr_env_ptr->__ptr_tws[t].virtual_address;
f0106a36:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106a39:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a3c:	89 d0                	mov    %edx,%eax
f0106a3e:	01 c0                	add    %eax,%eax
f0106a40:	01 d0                	add    %edx,%eax
f0106a42:	c1 e0 03             	shl    $0x3,%eax
f0106a45:	01 c8                	add    %ecx,%eax
f0106a47:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0106a4c:	8b 00                	mov    (%eax),%eax
f0106a4e:	89 45 d8             	mov    %eax,-0x28(%ebp)
						uint32 oldTimeStamp = curr_env_ptr->__ptr_tws[t].time_stamp;
f0106a51:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106a54:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a57:	89 d0                	mov    %edx,%eax
f0106a59:	01 c0                	add    %eax,%eax
f0106a5b:	01 d0                	add    %edx,%eax
f0106a5d:	c1 e0 03             	shl    $0x3,%eax
f0106a60:	01 c8                	add    %ecx,%eax
f0106a62:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106a67:	8b 00                	mov    (%eax),%eax
f0106a69:	89 45 d4             	mov    %eax,-0x2c(%ebp)

						if (pd_is_table_used(curr_env_ptr->env_page_directory, table_va))
f0106a6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106a6f:	8b 40 64             	mov    0x64(%eax),%eax
f0106a72:	83 ec 08             	sub    $0x8,%esp
f0106a75:	ff 75 d8             	pushl  -0x28(%ebp)
f0106a78:	50                   	push   %eax
f0106a79:	e8 4b 1f 00 00       	call   f01089c9 <pd_is_table_used>
f0106a7e:	83 c4 10             	add    $0x10,%esp
f0106a81:	85 c0                	test   %eax,%eax
f0106a83:	74 3c                	je     f0106ac1 <update_WS_time_stamps+0x189>
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2) | 0x80000000;
f0106a85:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106a88:	c1 e8 02             	shr    $0x2,%eax
f0106a8b:	0d 00 00 00 80       	or     $0x80000000,%eax
f0106a90:	89 c1                	mov    %eax,%ecx
f0106a92:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106a95:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106a98:	89 d0                	mov    %edx,%eax
f0106a9a:	01 c0                	add    %eax,%eax
f0106a9c:	01 d0                	add    %edx,%eax
f0106a9e:	c1 e0 03             	shl    $0x3,%eax
f0106aa1:	01 d8                	add    %ebx,%eax
f0106aa3:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106aa8:	89 08                	mov    %ecx,(%eax)
							pd_set_table_unused(curr_env_ptr->env_page_directory, table_va);
f0106aaa:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106aad:	8b 40 64             	mov    0x64(%eax),%eax
f0106ab0:	83 ec 08             	sub    $0x8,%esp
f0106ab3:	ff 75 d8             	pushl  -0x28(%ebp)
f0106ab6:	50                   	push   %eax
f0106ab7:	e8 31 1f 00 00       	call   f01089ed <pd_set_table_unused>
f0106abc:	83 c4 10             	add    $0x10,%esp
f0106abf:	eb 20                	jmp    f0106ae1 <update_WS_time_stamps+0x1a9>
						}
						else
						{
							curr_env_ptr->__ptr_tws[t].time_stamp = (oldTimeStamp>>2);
f0106ac1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0106ac4:	c1 e8 02             	shr    $0x2,%eax
f0106ac7:	89 c1                	mov    %eax,%ecx
f0106ac9:	8b 5d ec             	mov    -0x14(%ebp),%ebx
f0106acc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106acf:	89 d0                	mov    %edx,%eax
f0106ad1:	01 c0                	add    %eax,%eax
f0106ad3:	01 d0                	add    %edx,%eax
f0106ad5:	c1 e0 03             	shl    $0x3,%eax
f0106ad8:	01 d8                	add    %ebx,%eax
f0106ada:	05 64 d5 01 00       	add    $0x1d564,%eax
f0106adf:	89 08                	mov    %ecx,(%eax)
				}
			}

			{
				int t ;
				for (t = 0 ; t < __TWS_MAX_SIZE; t++)
f0106ae1:	ff 45 f0             	incl   -0x10(%ebp)
f0106ae4:	83 7d f0 31          	cmpl   $0x31,-0x10(%ebp)
f0106ae8:	0f 8e 28 ff ff ff    	jle    f0106a16 <update_WS_time_stamps+0xde>
						}
					}
				}
			}
		}
	}
f0106aee:	90                   	nop
f0106aef:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0106af2:	c9                   	leave  
f0106af3:	c3                   	ret    

f0106af4 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0106af4:	55                   	push   %ebp
f0106af5:	89 e5                	mov    %esp,%ebp
f0106af7:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0106afa:	c7 05 0c 1a 55 f0 01 	movl   $0x1,0xf0551a0c
f0106b01:	00 00 00 
f0106b04:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0106b0b:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106b0f:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0106b12:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106b15:	ee                   	out    %al,(%dx)
f0106b16:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0106b1d:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0106b21:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0106b24:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106b27:	ee                   	out    %al,(%dx)
f0106b28:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0106b2f:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0106b33:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0106b36:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106b39:	ee                   	out    %al,(%dx)
f0106b3a:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0106b41:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0106b45:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0106b48:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0106b4b:	ee                   	out    %al,(%dx)
f0106b4c:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0106b53:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0106b57:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0106b5a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0106b5d:	ee                   	out    %al,(%dx)
f0106b5e:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0106b65:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0106b69:	8a 45 b7             	mov    -0x49(%ebp),%al
f0106b6c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0106b6f:	ee                   	out    %al,(%dx)
f0106b70:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0106b77:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0106b7b:	8a 45 b8             	mov    -0x48(%ebp),%al
f0106b7e:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0106b81:	ee                   	out    %al,(%dx)
f0106b82:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0106b89:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0106b8d:	8a 45 b9             	mov    -0x47(%ebp),%al
f0106b90:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0106b93:	ee                   	out    %al,(%dx)
f0106b94:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0106b9b:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0106b9f:	8a 45 ba             	mov    -0x46(%ebp),%al
f0106ba2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0106ba5:	ee                   	out    %al,(%dx)
f0106ba6:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0106bad:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0106bb1:	8a 45 bb             	mov    -0x45(%ebp),%al
f0106bb4:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0106bb7:	ee                   	out    %al,(%dx)
f0106bb8:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0106bbf:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0106bc3:	8a 45 bc             	mov    -0x44(%ebp),%al
f0106bc6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0106bc9:	ee                   	out    %al,(%dx)
f0106bca:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0106bd1:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0106bd5:	8a 45 bd             	mov    -0x43(%ebp),%al
f0106bd8:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0106bdb:	ee                   	out    %al,(%dx)
f0106bdc:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0106be3:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0106be7:	8a 45 be             	mov    -0x42(%ebp),%al
f0106bea:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0106bed:	ee                   	out    %al,(%dx)
f0106bee:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0106bf5:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0106bf9:	8a 45 bf             	mov    -0x41(%ebp),%al
f0106bfc:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0106bff:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0106c00:	66 a1 58 99 17 f0    	mov    0xf0179958,%ax
f0106c06:	66 83 f8 ff          	cmp    $0xffff,%ax
f0106c0a:	74 15                	je     f0106c21 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0106c0c:	66 a1 58 99 17 f0    	mov    0xf0179958,%ax
f0106c12:	0f b7 c0             	movzwl %ax,%eax
f0106c15:	83 ec 0c             	sub    $0xc,%esp
f0106c18:	50                   	push   %eax
f0106c19:	e8 06 00 00 00       	call   f0106c24 <irq_setmask_8259A>
f0106c1e:	83 c4 10             	add    $0x10,%esp
}
f0106c21:	90                   	nop
f0106c22:	c9                   	leave  
f0106c23:	c3                   	ret    

f0106c24 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0106c24:	55                   	push   %ebp
f0106c25:	89 e5                	mov    %esp,%ebp
f0106c27:	83 ec 14             	sub    $0x14,%esp
f0106c2a:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c2d:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0106c31:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106c36:	85 c0                	test   %eax,%eax
f0106c38:	74 34                	je     f0106c6e <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0106c3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c3d:	0f b6 c0             	movzbl %al,%eax
f0106c40:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0106c47:	88 45 f6             	mov    %al,-0xa(%ebp)
f0106c4a:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106c4d:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106c50:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0106c51:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0106c54:	66 c1 e8 08          	shr    $0x8,%ax
f0106c58:	0f b6 c0             	movzbl %al,%eax
f0106c5b:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0106c62:	88 45 f7             	mov    %al,-0x9(%ebp)
f0106c65:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106c68:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106c6b:	ee                   	out    %al,(%dx)
f0106c6c:	eb 01                	jmp    f0106c6f <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0106c6e:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0106c6f:	c9                   	leave  
f0106c70:	c3                   	ret    

f0106c71 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0106c71:	55                   	push   %ebp
f0106c72:	89 e5                	mov    %esp,%ebp
f0106c74:	53                   	push   %ebx
f0106c75:	83 ec 14             	sub    $0x14,%esp
f0106c78:	8b 45 08             	mov    0x8(%ebp),%eax
f0106c7b:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106c7e:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106c83:	85 c0                	test   %eax,%eax
f0106c85:	74 58                	je     f0106cdf <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106c87:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106c8b:	77 08                	ja     f0106c95 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0106c8d:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106c93:	eb 0a                	jmp    f0106c9f <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106c95:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106c9b:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0106c9f:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106ca3:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106ca6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ca9:	89 c2                	mov    %eax,%edx
f0106cab:	ec                   	in     (%dx),%al
f0106cac:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106caf:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106cb2:	88 c2                	mov    %al,%dl
f0106cb4:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106cb8:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106cbd:	88 c1                	mov    %al,%cl
f0106cbf:	d3 e3                	shl    %cl,%ebx
f0106cc1:	89 d8                	mov    %ebx,%eax
f0106cc3:	09 d0                	or     %edx,%eax
f0106cc5:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106cc8:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106ccc:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106cd0:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106cd3:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106cd6:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106cd9:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106cdc:	ee                   	out    %al,(%dx)
f0106cdd:	eb 01                	jmp    f0106ce0 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106cdf:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0106ce0:	83 c4 14             	add    $0x14,%esp
f0106ce3:	5b                   	pop    %ebx
f0106ce4:	5d                   	pop    %ebp
f0106ce5:	c3                   	ret    

f0106ce6 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0106ce6:	55                   	push   %ebp
f0106ce7:	89 e5                	mov    %esp,%ebp
f0106ce9:	53                   	push   %ebx
f0106cea:	83 ec 14             	sub    $0x14,%esp
f0106ced:	8b 45 08             	mov    0x8(%ebp),%eax
f0106cf0:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106cf3:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106cf8:	85 c0                	test   %eax,%eax
f0106cfa:	74 5a                	je     f0106d56 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106cfc:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106d00:	77 08                	ja     f0106d0a <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0106d02:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106d08:	eb 0a                	jmp    f0106d14 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0106d0a:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106d10:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0106d14:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106d18:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106d1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d1e:	89 c2                	mov    %eax,%edx
f0106d20:	ec                   	in     (%dx),%al
f0106d21:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0106d24:	8a 45 ee             	mov    -0x12(%ebp),%al
f0106d27:	88 c2                	mov    %al,%dl
f0106d29:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106d2d:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106d32:	88 c1                	mov    %al,%cl
f0106d34:	d3 e3                	shl    %cl,%ebx
f0106d36:	89 d8                	mov    %ebx,%eax
f0106d38:	f7 d0                	not    %eax
f0106d3a:	21 d0                	and    %edx,%eax
f0106d3c:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0106d3f:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0106d43:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0106d47:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0106d4a:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106d4d:	8a 45 ef             	mov    -0x11(%ebp),%al
f0106d50:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106d53:	ee                   	out    %al,(%dx)
f0106d54:	eb 01                	jmp    f0106d57 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0106d56:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0106d57:	83 c4 14             	add    $0x14,%esp
f0106d5a:	5b                   	pop    %ebx
f0106d5b:	5d                   	pop    %ebp
f0106d5c:	c3                   	ret    

f0106d5d <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0106d5d:	55                   	push   %ebp
f0106d5e:	89 e5                	mov    %esp,%ebp
f0106d60:	53                   	push   %ebx
f0106d61:	83 ec 14             	sub    $0x14,%esp
f0106d64:	8b 45 08             	mov    0x8(%ebp),%eax
f0106d67:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0106d6a:	a1 0c 1a 55 f0       	mov    0xf0551a0c,%eax
f0106d6f:	85 c0                	test   %eax,%eax
f0106d71:	75 07                	jne    f0106d7a <irq_get_mask+0x1d>
		return -1;
f0106d73:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0106d78:	eb 45                	jmp    f0106dbf <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0106d7a:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0106d7e:	77 08                	ja     f0106d88 <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0106d80:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0106d86:	eb 0a                	jmp    f0106d92 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0106d88:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0106d8e:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0106d92:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0106d96:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0106d99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d9c:	89 c2                	mov    %eax,%edx
f0106d9e:	ec                   	in     (%dx),%al
f0106d9f:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0106da2:	8a 45 f3             	mov    -0xd(%ebp),%al
f0106da5:	88 c2                	mov    %al,%dl
f0106da7:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0106dab:	bb 01 00 00 00       	mov    $0x1,%ebx
f0106db0:	88 c1                	mov    %al,%cl
f0106db2:	d3 e3                	shl    %cl,%ebx
f0106db4:	89 d8                	mov    %ebx,%eax
f0106db6:	21 d0                	and    %edx,%eax
f0106db8:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f0106dbb:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0106dbf:	83 c4 14             	add    $0x14,%esp
f0106dc2:	5b                   	pop    %ebx
f0106dc3:	5d                   	pop    %ebp
f0106dc4:	c3                   	ret    

f0106dc5 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0106dc5:	55                   	push   %ebp
f0106dc6:	89 e5                	mov    %esp,%ebp
f0106dc8:	83 ec 14             	sub    $0x14,%esp
f0106dcb:	8b 45 08             	mov    0x8(%ebp),%eax
f0106dce:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0106dd1:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0106dd5:	76 12                	jbe    f0106de9 <pic_sendEOI+0x24>
f0106dd7:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0106dde:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0106de2:	8a 45 f7             	mov    -0x9(%ebp),%al
f0106de5:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0106de8:	ee                   	out    %al,(%dx)
f0106de9:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0106df0:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0106df4:	8a 45 f6             	mov    -0xa(%ebp),%al
f0106df7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0106dfa:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f0106dfb:	90                   	nop
f0106dfc:	c9                   	leave  
f0106dfd:	c3                   	ret    

f0106dfe <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0106dfe:	55                   	push   %ebp
f0106dff:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0106e01:	b8 00 4c 55 f0       	mov    $0xf0554c00,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0106e06:	5d                   	pop    %ebp
f0106e07:	c3                   	ret    

f0106e08 <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f0106e08:	55                   	push   %ebp
f0106e09:	89 e5                	mov    %esp,%ebp
f0106e0b:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0106e0e:	e8 eb ff ff ff       	call   f0106dfe <mycpu>
f0106e13:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0106e16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e19:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0106e20:	00 00 00 
  c->ncli = 0;
f0106e23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e26:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0106e2d:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106e30:	9c                   	pushf  
f0106e31:	58                   	pop    %eax
f0106e32:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0106e35:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f0106e38:	25 00 02 00 00       	and    $0x200,%eax
f0106e3d:	85 c0                	test   %eax,%eax
f0106e3f:	0f 95 c0             	setne  %al
f0106e42:	0f b6 d0             	movzbl %al,%edx
f0106e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e48:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f0106e4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e51:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f0106e58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e5b:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f0106e62:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f0106e65:	8b 45 08             	mov    0x8(%ebp),%eax
f0106e68:	40                   	inc    %eax
f0106e69:	c1 e0 0f             	shl    $0xf,%eax
f0106e6c:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f0106e71:	29 c2                	sub    %eax,%edx
f0106e73:	89 d0                	mov    %edx,%eax
f0106e75:	89 c2                	mov    %eax,%edx
f0106e77:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e7a:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f0106e7d:	e8 18 01 00 00       	call   f0106f9a <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f0106e82:	e8 49 50 00 00       	call   f010bed0 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f0106e87:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e8a:	83 c0 0c             	add    $0xc,%eax
f0106e8d:	83 ec 04             	sub    $0x4,%esp
f0106e90:	6a 68                	push   $0x68
f0106e92:	6a 00                	push   $0x0
f0106e94:	50                   	push   %eax
f0106e95:	e8 87 98 01 00       	call   f0120721 <memset>
f0106e9a:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f0106e9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ea0:	05 a4 00 00 00       	add    $0xa4,%eax
f0106ea5:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0106ea8:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f0106eaf:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106eb2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106eb5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0106eb8:	f0 87 02             	lock xchg %eax,(%edx)
f0106ebb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f0106ebe:	90                   	nop
f0106ebf:	c9                   	leave  
f0106ec0:	c3                   	ret    

f0106ec1 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0106ec1:	55                   	push   %ebp
f0106ec2:	89 e5                	mov    %esp,%ebp
f0106ec4:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106ec7:	9c                   	pushf  
f0106ec8:	58                   	pop    %eax
f0106ec9:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f0106ecc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f0106ecf:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0106ed2:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0106ed3:	e8 26 ff ff ff       	call   f0106dfe <mycpu>
f0106ed8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f0106edb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ede:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106ee4:	85 c0                	test   %eax,%eax
f0106ee6:	75 13                	jne    f0106efb <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0106ee8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106eeb:	25 00 02 00 00       	and    $0x200,%eax
f0106ef0:	89 c2                	mov    %eax,%edx
f0106ef2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ef5:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f0106efb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106efe:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f04:	8d 50 01             	lea    0x1(%eax),%edx
f0106f07:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f0a:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f0106f10:	90                   	nop
f0106f11:	c9                   	leave  
f0106f12:	c3                   	ret    

f0106f13 <popcli>:

void popcli(void)
{
f0106f13:	55                   	push   %ebp
f0106f14:	89 e5                	mov    %esp,%ebp
f0106f16:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0106f19:	9c                   	pushf  
f0106f1a:	58                   	pop    %eax
f0106f1b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f0106f1e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0106f21:	25 00 02 00 00       	and    $0x200,%eax
f0106f26:	85 c0                	test   %eax,%eax
f0106f28:	74 14                	je     f0106f3e <popcli+0x2b>
    panic("popcli - interruptible");
f0106f2a:	83 ec 04             	sub    $0x4,%esp
f0106f2d:	68 45 48 12 f0       	push   $0xf0124845
f0106f32:	6a 5e                	push   $0x5e
f0106f34:	68 5c 48 12 f0       	push   $0xf012485c
f0106f39:	e8 dc 93 ff ff       	call   f010031a <_panic>
  struct cpu* c = mycpu();
f0106f3e:	e8 bb fe ff ff       	call   f0106dfe <mycpu>
f0106f43:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f0106f46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f49:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f4f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106f52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f55:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f0106f5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f5e:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f64:	85 c0                	test   %eax,%eax
f0106f66:	79 14                	jns    f0106f7c <popcli+0x69>
    panic("popcli");
f0106f68:	83 ec 04             	sub    $0x4,%esp
f0106f6b:	68 6b 48 12 f0       	push   $0xf012486b
f0106f70:	6a 61                	push   $0x61
f0106f72:	68 5c 48 12 f0       	push   $0xf012485c
f0106f77:	e8 9e 93 ff ff       	call   f010031a <_panic>
  if(c->ncli == 0 && c->intena)
f0106f7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f7f:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0106f85:	85 c0                	test   %eax,%eax
f0106f87:	75 0e                	jne    f0106f97 <popcli+0x84>
f0106f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f8c:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0106f92:	85 c0                	test   %eax,%eax
f0106f94:	74 01                	je     f0106f97 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0106f96:	fb                   	sti    
    sti();
}
f0106f97:	90                   	nop
f0106f98:	c9                   	leave  
f0106f99:	c3                   	ret    

f0106f9a <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f0106f9a:	55                   	push   %ebp
f0106f9b:	89 e5                	mov    %esp,%ebp
f0106f9d:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f0106fa0:	e8 1c ff ff ff       	call   f0106ec1 <pushcli>

	c = mycpu();
f0106fa5:	e8 54 fe ff ff       	call   f0106dfe <mycpu>
f0106faa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f0106fad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fb0:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f0106fb7:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f0106fbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fc1:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0106fc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fca:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f0106fd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fd3:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0106fda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fdd:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0106fe3:	83 e2 f0             	and    $0xfffffff0,%edx
f0106fe6:	83 ca 0a             	or     $0xa,%edx
f0106fe9:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0106fef:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ff2:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0106ff8:	83 ca 10             	or     $0x10,%edx
f0106ffb:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107001:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107004:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010700a:	83 e2 9f             	and    $0xffffff9f,%edx
f010700d:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107013:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107016:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010701c:	83 ca 80             	or     $0xffffff80,%edx
f010701f:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0107025:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107028:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010702e:	83 ca 0f             	or     $0xf,%edx
f0107031:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107037:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010703a:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107040:	83 e2 ef             	and    $0xffffffef,%edx
f0107043:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f0107049:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010704c:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107052:	83 e2 df             	and    $0xffffffdf,%edx
f0107055:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010705b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010705e:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107064:	83 ca 40             	or     $0x40,%edx
f0107067:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010706d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107070:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f0107076:	83 ca 80             	or     $0xffffff80,%edx
f0107079:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f010707f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107082:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f0107089:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010708c:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0107093:	ff ff 
f0107095:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107098:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f010709f:	00 00 
f01070a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070a4:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f01070ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070ae:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070b4:	83 e2 f0             	and    $0xfffffff0,%edx
f01070b7:	83 ca 02             	or     $0x2,%edx
f01070ba:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01070c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070c3:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070c9:	83 ca 10             	or     $0x10,%edx
f01070cc:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01070d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070d5:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070db:	83 e2 9f             	and    $0xffffff9f,%edx
f01070de:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01070e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070e7:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f01070ed:	83 ca 80             	or     $0xffffff80,%edx
f01070f0:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f01070f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070f9:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01070ff:	83 ca 0f             	or     $0xf,%edx
f0107102:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107108:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010710b:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107111:	83 e2 ef             	and    $0xffffffef,%edx
f0107114:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010711a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010711d:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107123:	83 e2 df             	and    $0xffffffdf,%edx
f0107126:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010712c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010712f:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107135:	83 ca 40             	or     $0x40,%edx
f0107138:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010713e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107141:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0107147:	83 ca 80             	or     $0xffffff80,%edx
f010714a:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0107150:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107153:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f010715a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010715d:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f0107164:	ff ff 
f0107166:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107169:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f0107170:	00 00 
f0107172:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107175:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f010717c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010717f:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0107185:	83 e2 f0             	and    $0xfffffff0,%edx
f0107188:	83 ca 0a             	or     $0xa,%edx
f010718b:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0107191:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107194:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010719a:	83 ca 10             	or     $0x10,%edx
f010719d:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071a6:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01071ac:	83 ca 60             	or     $0x60,%edx
f01071af:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071b8:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01071be:	83 ca 80             	or     $0xffffff80,%edx
f01071c1:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f01071c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ca:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01071d0:	83 ca 0f             	or     $0xf,%edx
f01071d3:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01071d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071dc:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01071e2:	83 e2 ef             	and    $0xffffffef,%edx
f01071e5:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01071eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071ee:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f01071f4:	83 e2 df             	and    $0xffffffdf,%edx
f01071f7:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f01071fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107200:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107206:	83 ca 40             	or     $0x40,%edx
f0107209:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010720f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107212:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0107218:	83 ca 80             	or     $0xffffff80,%edx
f010721b:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0107221:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107224:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f010722b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010722e:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f0107235:	ff ff 
f0107237:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010723a:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f0107241:	00 00 
f0107243:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107246:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f010724d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107250:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f0107256:	83 e2 f0             	and    $0xfffffff0,%edx
f0107259:	83 ca 02             	or     $0x2,%edx
f010725c:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107262:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107265:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010726b:	83 ca 10             	or     $0x10,%edx
f010726e:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107274:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107277:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010727d:	83 ca 60             	or     $0x60,%edx
f0107280:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107286:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107289:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f010728f:	83 ca 80             	or     $0xffffff80,%edx
f0107292:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0107298:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010729b:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072a1:	83 ca 0f             	or     $0xf,%edx
f01072a4:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ad:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072b3:	83 e2 ef             	and    $0xffffffef,%edx
f01072b6:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072bf:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072c5:	83 e2 df             	and    $0xffffffdf,%edx
f01072c8:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072d1:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072d7:	83 ca 40             	or     $0x40,%edx
f01072da:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072e3:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f01072e9:	83 ca 80             	or     $0xffffff80,%edx
f01072ec:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f01072f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072f5:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f01072fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ff:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0107306:	00 00 00 
f0107309:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f0107310:	00 00 00 

	popcli();	//enable interrupt
f0107313:	e8 fb fb ff ff       	call   f0106f13 <popcli>


}
f0107318:	90                   	nop
f0107319:	c9                   	leave  
f010731a:	c3                   	ret    

f010731b <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f010731b:	55                   	push   %ebp
f010731c:	89 e5                	mov    %esp,%ebp
f010731e:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0107321:	83 ec 08             	sub    $0x8,%esp
f0107324:	68 00 10 00 00       	push   $0x1000
f0107329:	68 00 10 00 00       	push   $0x1000
f010732e:	e8 35 02 00 00       	call   f0107568 <boot_allocate_space>
f0107333:	83 c4 10             	add    $0x10,%esp
f0107336:	a3 dc 50 55 f0       	mov    %eax,0xf05550dc
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f010733b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107340:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107343:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f010734a:	77 14                	ja     f0107360 <initialize_kernel_VM+0x45>
f010734c:	ff 75 e0             	pushl  -0x20(%ebp)
f010734f:	68 74 48 12 f0       	push   $0xf0124874
f0107354:	6a 57                	push   $0x57
f0107356:	68 a8 48 12 f0       	push   $0xf01248a8
f010735b:	e8 ba 8f ff ff       	call   f010031a <_panic>
f0107360:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107363:	05 00 00 00 10       	add    $0x10000000,%eax
f0107368:	a3 e4 51 55 f0       	mov    %eax,0xf05551e4
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f010736d:	c7 45 dc 00 10 17 f0 	movl   $0xf0171000,-0x24(%ebp)
f0107374:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f010737b:	77 14                	ja     f0107391 <initialize_kernel_VM+0x76>
f010737d:	ff 75 dc             	pushl  -0x24(%ebp)
f0107380:	68 74 48 12 f0       	push   $0xf0124874
f0107385:	6a 63                	push   $0x63
f0107387:	68 a8 48 12 f0       	push   $0xf01248a8
f010738c:	e8 89 8f ff ff       	call   f010031a <_panic>
f0107391:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107394:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f010739a:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010739f:	83 ec 0c             	sub    $0xc,%esp
f01073a2:	6a 02                	push   $0x2
f01073a4:	52                   	push   %edx
f01073a5:	68 00 80 00 00       	push   $0x8000
f01073aa:	68 00 80 bf ef       	push   $0xefbf8000
f01073af:	50                   	push   %eax
f01073b0:	e8 27 02 00 00       	call   f01075dc <boot_map_range>
f01073b5:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01073b8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01073bf:	eb 24                	jmp    f01073e5 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f01073c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01073c4:	40                   	inc    %eax
f01073c5:	c1 e0 0f             	shl    $0xf,%eax
f01073c8:	ba 00 00 c0 ef       	mov    $0xefc00000,%edx
f01073cd:	29 c2                	sub    %eax,%edx
f01073cf:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01073d4:	6a 01                	push   $0x1
f01073d6:	6a 00                	push   $0x0
f01073d8:	52                   	push   %edx
f01073d9:	50                   	push   %eax
f01073da:	e8 4a 14 00 00       	call   f0108829 <pt_set_page_permissions>
f01073df:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f01073e2:	ff 45 f4             	incl   -0xc(%ebp)
f01073e5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073e9:	7e d6                	jle    f01073c1 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f01073eb:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f01073f2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f01073f9:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f0107400:	eb 25                	jmp    f0107427 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0107402:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0107405:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107408:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010740d:	83 ec 04             	sub    $0x4,%esp
f0107410:	6a 01                	push   $0x1
f0107412:	52                   	push   %edx
f0107413:	50                   	push   %eax
f0107414:	e8 37 02 00 00       	call   f0107650 <boot_get_page_table>
f0107419:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010741c:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0107423:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0107427:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010742b:	72 d5                	jb     f0107402 <initialize_kernel_VM+0xe7>
f010742d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0107431:	77 06                	ja     f0107439 <initialize_kernel_VM+0x11e>
f0107433:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f0107437:	76 c9                	jbe    f0107402 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f0107439:	8b 15 b8 4c 55 f0    	mov    0xf0554cb8,%edx
f010743f:	89 d0                	mov    %edx,%eax
f0107441:	01 c0                	add    %eax,%eax
f0107443:	01 d0                	add    %edx,%eax
f0107445:	c1 e0 03             	shl    $0x3,%eax
f0107448:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f010744b:	83 ec 08             	sub    $0x8,%esp
f010744e:	68 00 10 00 00       	push   $0x1000
f0107453:	ff 75 d8             	pushl  -0x28(%ebp)
f0107456:	e8 0d 01 00 00       	call   f0107568 <boot_allocate_space>
f010745b:	83 c4 10             	add    $0x10,%esp
f010745e:	a3 20 4f 55 f0       	mov    %eax,0xf0554f20
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f0107463:	c7 45 d4 00 c0 30 00 	movl   $0x30c000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f010746a:	83 ec 08             	sub    $0x8,%esp
f010746d:	68 00 10 00 00       	push   $0x1000
f0107472:	ff 75 d4             	pushl  -0x2c(%ebp)
f0107475:	e8 ee 00 00 00       	call   f0107568 <boot_allocate_space>
f010747a:	83 c4 10             	add    $0x10,%esp
f010747d:	a3 c0 22 55 f0       	mov    %eax,0xf05522c0
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f0107482:	e8 32 05 00 00       	call   f01079b9 <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f0107487:	83 ec 0c             	sub    $0xc,%esp
f010748a:	6a 08                	push   $0x8
f010748c:	e8 39 78 01 00       	call   f011ecca <nearest_pow2_ceil>
f0107491:	83 c4 10             	add    $0x10,%esp
f0107494:	83 ec 04             	sub    $0x4,%esp
f0107497:	50                   	push   %eax
f0107498:	6a 08                	push   $0x8
f010749a:	68 c8 48 12 f0       	push   $0xf01248c8
f010749f:	e8 c8 9a ff ff       	call   f0100f6c <cprintf>
f01074a4:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f01074a7:	c7 45 d0 60 d3 0e 00 	movl   $0xed360,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f01074ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01074b1:	83 ec 08             	sub    $0x8,%esp
f01074b4:	68 00 10 00 00       	push   $0x1000
f01074b9:	50                   	push   %eax
f01074ba:	e8 a9 00 00 00       	call   f0107568 <boot_allocate_space>
f01074bf:	83 c4 10             	add    $0x10,%esp
f01074c2:	a3 10 1a 55 f0       	mov    %eax,0xf0551a10
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f01074c7:	a1 10 1a 55 f0       	mov    0xf0551a10,%eax
f01074cc:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01074cf:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f01074d6:	77 17                	ja     f01074ef <initialize_kernel_VM+0x1d4>
f01074d8:	ff 75 cc             	pushl  -0x34(%ebp)
f01074db:	68 74 48 12 f0       	push   $0xf0124874
f01074e0:	68 b1 00 00 00       	push   $0xb1
f01074e5:	68 a8 48 12 f0       	push   $0xf01248a8
f01074ea:	e8 2b 8e ff ff       	call   f010031a <_panic>
f01074ef:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01074f2:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f01074f8:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01074fb:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107500:	83 ec 0c             	sub    $0xc,%esp
f0107503:	6a 04                	push   $0x4
f0107505:	51                   	push   %ecx
f0107506:	52                   	push   %edx
f0107507:	68 00 00 c0 ee       	push   $0xeec00000
f010750c:	50                   	push   %eax
f010750d:	e8 ca 00 00 00       	call   f01075dc <boot_map_range>
f0107512:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f0107515:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010751a:	05 ec 0e 00 00       	add    $0xeec,%eax
f010751f:	8b 15 dc 50 55 f0    	mov    0xf05550dc,%edx
f0107525:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f010752b:	8b 12                	mov    (%edx),%edx
f010752d:	83 ca 05             	or     $0x5,%edx
f0107530:	89 10                	mov    %edx,(%eax)
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#else
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f0107532:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107537:	83 ec 0c             	sub    $0xc,%esp
f010753a:	6a 02                	push   $0x2
f010753c:	6a 00                	push   $0x0
f010753e:	68 ff ff ff 0f       	push   $0xfffffff
f0107543:	68 00 00 00 f0       	push   $0xf0000000
f0107548:	50                   	push   %eax
f0107549:	e8 8e 00 00 00       	call   f01075dc <boot_map_range>
f010754e:	83 c4 20             	add    $0x20,%esp
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f0107551:	e8 17 85 01 00       	call   f011fa6d <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f0107556:	c7 05 e0 4b 55 f0 19 	movl   $0x19,0xf0554be0
f010755d:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f0107560:	e8 20 03 00 00       	call   f0107885 <turn_on_paging>
}
f0107565:	90                   	nop
f0107566:	c9                   	leave  
f0107567:	c3                   	ret    

f0107568 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f0107568:	55                   	push   %ebp
f0107569:	89 e5                	mov    %esp,%ebp
f010756b:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f010756e:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f0107573:	85 c0                	test   %eax,%eax
f0107575:	75 0a                	jne    f0107581 <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f0107577:	c7 05 d8 50 55 f0 a8 	movl   $0xf05779a8,0xf05550d8
f010757e:	79 57 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f0107581:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107584:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107587:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f010758c:	89 c2                	mov    %eax,%edx
f010758e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107591:	01 d0                	add    %edx,%eax
f0107593:	48                   	dec    %eax
f0107594:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0107597:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010759a:	ba 00 00 00 00       	mov    $0x0,%edx
f010759f:	f7 75 f4             	divl   -0xc(%ebp)
f01075a2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01075a5:	29 d0                	sub    %edx,%eax
f01075a7:	a3 d8 50 55 f0       	mov    %eax,0xf05550d8

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f01075ac:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f01075b1:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f01075b4:	8b 15 d8 50 55 f0    	mov    0xf05550d8,%edx
f01075ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01075bd:	01 d0                	add    %edx,%eax
f01075bf:	a3 d8 50 55 f0       	mov    %eax,0xf05550d8

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f01075c4:	83 ec 04             	sub    $0x4,%esp
f01075c7:	ff 75 08             	pushl  0x8(%ebp)
f01075ca:	6a 00                	push   $0x0
f01075cc:	ff 75 ec             	pushl  -0x14(%ebp)
f01075cf:	e8 4d 91 01 00       	call   f0120721 <memset>
f01075d4:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f01075d7:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f01075da:	c9                   	leave  
f01075db:	c3                   	ret    

f01075dc <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f01075dc:	55                   	push   %ebp
f01075dd:	89 e5                	mov    %esp,%ebp
f01075df:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f01075e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01075e9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01075f0:	eb 53                	jmp    f0107645 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f01075f2:	83 ec 04             	sub    $0x4,%esp
f01075f5:	6a 01                	push   $0x1
f01075f7:	ff 75 0c             	pushl  0xc(%ebp)
f01075fa:	ff 75 08             	pushl  0x8(%ebp)
f01075fd:	e8 4e 00 00 00       	call   f0107650 <boot_get_page_table>
f0107602:	83 c4 10             	add    $0x10,%esp
f0107605:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0107608:	8b 45 0c             	mov    0xc(%ebp),%eax
f010760b:	c1 e8 0c             	shr    $0xc,%eax
f010760e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0107613:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0107616:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107619:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107620:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107623:	01 c2                	add    %eax,%edx
f0107625:	8b 45 18             	mov    0x18(%ebp),%eax
f0107628:	0b 45 14             	or     0x14(%ebp),%eax
f010762b:	83 c8 01             	or     $0x1,%eax
f010762e:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f0107630:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f0107637:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f010763e:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f0107645:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107648:	3b 45 10             	cmp    0x10(%ebp),%eax
f010764b:	72 a5                	jb     f01075f2 <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f010764d:	90                   	nop
f010764e:	c9                   	leave  
f010764f:	c3                   	ret    

f0107650 <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f0107650:	55                   	push   %ebp
f0107651:	89 e5                	mov    %esp,%ebp
f0107653:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f0107656:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107659:	c1 e8 16             	shr    $0x16,%eax
f010765c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f010765f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107662:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107669:	8b 45 08             	mov    0x8(%ebp),%eax
f010766c:	01 d0                	add    %edx,%eax
f010766e:	8b 00                	mov    (%eax),%eax
f0107670:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f0107673:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107676:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010767b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f010767e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107681:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0107684:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107687:	c1 e8 0c             	shr    $0xc,%eax
f010768a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010768d:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0107692:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0107695:	72 17                	jb     f01076ae <boot_get_page_table+0x5e>
f0107697:	ff 75 e8             	pushl  -0x18(%ebp)
f010769a:	68 f0 48 12 f0       	push   $0xf01248f0
f010769f:	68 33 01 00 00       	push   $0x133
f01076a4:	68 a8 48 12 f0       	push   $0xf01248a8
f01076a9:	e8 6c 8c ff ff       	call   f010031a <_panic>
f01076ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01076b1:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01076b6:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f01076b9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01076bd:	75 72                	jne    f0107731 <boot_get_page_table+0xe1>
	{
		if (create)
f01076bf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01076c3:	74 65                	je     f010772a <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f01076c5:	83 ec 08             	sub    $0x8,%esp
f01076c8:	68 00 10 00 00       	push   $0x1000
f01076cd:	68 00 10 00 00       	push   $0x1000
f01076d2:	e8 91 fe ff ff       	call   f0107568 <boot_allocate_space>
f01076d7:	83 c4 10             	add    $0x10,%esp
f01076da:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f01076dd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01076e0:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01076e3:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01076ea:	77 17                	ja     f0107703 <boot_get_page_table+0xb3>
f01076ec:	ff 75 dc             	pushl  -0x24(%ebp)
f01076ef:	68 74 48 12 f0       	push   $0xf0124874
f01076f4:	68 39 01 00 00       	push   $0x139
f01076f9:	68 a8 48 12 f0       	push   $0xf01248a8
f01076fe:	e8 17 8c ff ff       	call   f010031a <_panic>
f0107703:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107706:	05 00 00 00 10       	add    $0x10000000,%eax
f010770b:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f010770e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107711:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0107718:	8b 45 08             	mov    0x8(%ebp),%eax
f010771b:	01 d0                	add    %edx,%eax
f010771d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107720:	83 ca 03             	or     $0x3,%edx
f0107723:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f0107725:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107728:	eb 0a                	jmp    f0107734 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f010772a:	b8 00 00 00 00       	mov    $0x0,%eax
f010772f:	eb 03                	jmp    f0107734 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f0107731:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0107734:	c9                   	leave  
f0107735:	c3                   	ret    

f0107736 <nvram_read>:


int nvram_read(int r)
{
f0107736:	55                   	push   %ebp
f0107737:	89 e5                	mov    %esp,%ebp
f0107739:	53                   	push   %ebx
f010773a:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f010773d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107740:	83 ec 0c             	sub    $0xc,%esp
f0107743:	50                   	push   %eax
f0107744:	e8 12 d1 ff ff       	call   f010485b <mc146818_read>
f0107749:	83 c4 10             	add    $0x10,%esp
f010774c:	89 c3                	mov    %eax,%ebx
f010774e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107751:	40                   	inc    %eax
f0107752:	83 ec 0c             	sub    $0xc,%esp
f0107755:	50                   	push   %eax
f0107756:	e8 00 d1 ff ff       	call   f010485b <mc146818_read>
f010775b:	83 c4 10             	add    $0x10,%esp
f010775e:	c1 e0 08             	shl    $0x8,%eax
f0107761:	09 d8                	or     %ebx,%eax
}
f0107763:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107766:	c9                   	leave  
f0107767:	c3                   	ret    

f0107768 <detect_memory>:

void detect_memory()
{
f0107768:	55                   	push   %ebp
f0107769:	89 e5                	mov    %esp,%ebp
f010776b:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f010776e:	83 ec 0c             	sub    $0xc,%esp
f0107771:	6a 15                	push   $0x15
f0107773:	e8 be ff ff ff       	call   f0107736 <nvram_read>
f0107778:	83 c4 10             	add    $0x10,%esp
f010777b:	c1 e0 0a             	shl    $0xa,%eax
f010777e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107781:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107784:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0107789:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f010778c:	83 ec 0c             	sub    $0xc,%esp
f010778f:	6a 17                	push   $0x17
f0107791:	e8 a0 ff ff ff       	call   f0107736 <nvram_read>
f0107796:	83 c4 10             	add    $0x10,%esp
f0107799:	c1 e0 0a             	shl    $0xa,%eax
f010779c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010779f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01077a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01077a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f01077aa:	83 ec 0c             	sub    $0xc,%esp
f01077ad:	6a 34                	push   $0x34
f01077af:	e8 82 ff ff ff       	call   f0107736 <nvram_read>
f01077b4:	83 c4 10             	add    $0x10,%esp
f01077b7:	c1 e0 10             	shl    $0x10,%eax
f01077ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01077bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01077c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01077c5:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f01077c8:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01077cc:	74 18                	je     f01077e6 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f01077ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01077d1:	05 00 00 00 01       	add    $0x1000000,%eax
f01077d6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f01077d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01077dc:	2d 00 00 10 00       	sub    $0x100000,%eax
f01077e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01077e4:	eb 19                	jmp    f01077ff <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f01077e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01077ea:	74 0d                	je     f01077f9 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f01077ec:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077ef:	05 00 00 10 00       	add    $0x100000,%eax
f01077f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01077f7:	eb 06                	jmp    f01077ff <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f01077f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01077fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f01077ff:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	if(USE_KHEAP == 0 && maxpa > kernel_virtual_area)
f0107806:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107809:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010780c:	76 32                	jbe    f0107840 <detect_memory+0xd8>
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
f010780e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0107811:	c1 e8 0a             	shr    $0xa,%eax
f0107814:	89 c2                	mov    %eax,%edx
f0107816:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107819:	c1 e8 0a             	shr    $0xa,%eax
f010781c:	83 ec 04             	sub    $0x4,%esp
f010781f:	52                   	push   %edx
f0107820:	50                   	push   %eax
f0107821:	68 20 49 12 f0       	push   $0xf0124920
f0107826:	e8 41 97 ff ff       	call   f0100f6c <cprintf>
f010782b:	83 c4 10             	add    $0x10,%esp
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
f010782e:	83 ec 0c             	sub    $0xc,%esp
f0107831:	68 68 49 12 f0       	push   $0xf0124968
f0107836:	e8 31 97 ff ff       	call   f0100f6c <cprintf>
f010783b:	83 c4 10             	add    $0x10,%esp
		while(1);
f010783e:	eb fe                	jmp    f010783e <detect_memory+0xd6>
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0107840:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107843:	c1 e8 0c             	shr    $0xc,%eax
f0107846:	a3 b8 4c 55 f0       	mov    %eax,0xf0554cb8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f010784b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010784e:	c1 e8 0a             	shr    $0xa,%eax
f0107851:	83 ec 08             	sub    $0x8,%esp
f0107854:	50                   	push   %eax
f0107855:	68 00 4a 12 f0       	push   $0xf0124a00
f010785a:	e8 0d 97 ff ff       	call   f0100f6c <cprintf>
f010785f:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0107862:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107865:	c1 e8 0a             	shr    $0xa,%eax
f0107868:	89 c2                	mov    %eax,%edx
f010786a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010786d:	c1 e8 0a             	shr    $0xa,%eax
f0107870:	83 ec 04             	sub    $0x4,%esp
f0107873:	52                   	push   %edx
f0107874:	50                   	push   %eax
f0107875:	68 23 4a 12 f0       	push   $0xf0124a23
f010787a:	e8 ed 96 ff ff       	call   f0100f6c <cprintf>
f010787f:	83 c4 10             	add    $0x10,%esp
}
f0107882:	90                   	nop
f0107883:	c9                   	leave  
f0107884:	c3                   	ret    

f0107885 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0107885:	55                   	push   %ebp
f0107886:	89 e5                	mov    %esp,%ebp
f0107888:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f010788b:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0107892:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107899:	eb 24                	jmp    f01078bf <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f010789b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01078a0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01078a3:	c1 e2 02             	shl    $0x2,%edx
f01078a6:	01 c2                	add    %eax,%edx
f01078a8:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01078ad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01078b0:	c1 e1 02             	shl    $0x2,%ecx
f01078b3:	01 c8                	add    %ecx,%eax
f01078b5:	8b 00                	mov    (%eax),%eax
f01078b7:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f01078b9:	ff 45 f4             	incl   -0xc(%ebp)
f01078bc:	ff 45 f0             	incl   -0x10(%ebp)
f01078bf:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f01078c4:	c1 e8 16             	shr    $0x16,%eax
f01078c7:	89 c2                	mov    %eax,%edx
f01078c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01078cc:	39 c2                	cmp    %eax,%edx
f01078ce:	77 cb                	ja     f010789b <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f01078d0:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01078d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01078d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01078db:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f01078de:	0f 20 c0             	mov    %cr0,%eax
f01078e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01078e4:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f01078e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f01078ea:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f01078f1:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f01078f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01078f8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f01078fb:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01078fe:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0107901:	e8 bb f5 ff ff       	call   f0106ec1 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0107906:	e8 f3 f4 ff ff       	call   f0106dfe <mycpu>
f010790b:	83 c0 74             	add    $0x74,%eax
f010790e:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0107911:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0107918:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010791b:	48                   	dec    %eax
f010791c:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0107920:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0107923:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0107927:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010792a:	c1 e8 10             	shr    $0x10,%eax
f010792d:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0107931:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0107934:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0107937:	e8 d7 f5 ff ff       	call   f0106f13 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f010793c:	b8 23 00 00 00       	mov    $0x23,%eax
f0107941:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0107943:	b8 23 00 00 00       	mov    $0x23,%eax
f0107948:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f010794a:	b8 10 00 00 00       	mov    $0x10,%eax
f010794f:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0107951:	b8 10 00 00 00       	mov    $0x10,%eax
f0107956:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0107958:	b8 10 00 00 00       	mov    $0x10,%eax
f010795d:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f010795f:	ea 66 79 10 f0 08 00 	ljmp   $0x8,$0xf0107966
	asm volatile("lldt %%ax" :: "a" (0));
f0107966:	b8 00 00 00 00       	mov    $0x0,%eax
f010796b:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f010796e:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0107975:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f010797c:	eb 19                	jmp    f0107997 <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f010797e:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107983:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107986:	c1 e2 02             	shl    $0x2,%edx
f0107989:	01 d0                	add    %edx,%eax
f010798b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0107991:	ff 45 ec             	incl   -0x14(%ebp)
f0107994:	ff 45 e8             	incl   -0x18(%ebp)
f0107997:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f010799c:	c1 e8 16             	shr    $0x16,%eax
f010799f:	89 c2                	mov    %eax,%edx
f01079a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01079a4:	39 c2                	cmp    %eax,%edx
f01079a6:	77 d6                	ja     f010797e <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f01079a8:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01079ad:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01079b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01079b3:	0f 22 d8             	mov    %eax,%cr3

}
f01079b6:	90                   	nop
f01079b7:	c9                   	leave  
f01079b8:	c3                   	ret    

f01079b9 <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f01079b9:	55                   	push   %ebp
f01079ba:	89 e5                	mov    %esp,%ebp
f01079bc:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01079bf:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01079c4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01079c7:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f01079ce:	77 17                	ja     f01079e7 <setup_listing_to_all_page_tables_entries+0x2e>
f01079d0:	ff 75 f4             	pushl  -0xc(%ebp)
f01079d3:	68 74 48 12 f0       	push   $0xf0124874
f01079d8:	68 cf 01 00 00       	push   $0x1cf
f01079dd:	68 a8 48 12 f0       	push   $0xf01248a8
f01079e2:	e8 33 89 ff ff       	call   f010031a <_panic>
f01079e7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01079ea:	05 00 00 00 10       	add    $0x10000000,%eax
f01079ef:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f01079f2:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01079f7:	05 fc 0e 00 00       	add    $0xefc,%eax
f01079fc:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01079ff:	83 ca 03             	or     $0x3,%edx
f0107a02:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0107a04:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107a09:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0107a0f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0107a14:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107a17:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0107a1e:	77 17                	ja     f0107a37 <setup_listing_to_all_page_tables_entries+0x7e>
f0107a20:	ff 75 ec             	pushl  -0x14(%ebp)
f0107a23:	68 74 48 12 f0       	push   $0xf0124874
f0107a28:	68 d4 01 00 00       	push   $0x1d4
f0107a2d:	68 a8 48 12 f0       	push   $0xf01248a8
f0107a32:	e8 e3 88 ff ff       	call   f010031a <_panic>
f0107a37:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107a3a:	05 00 00 00 10       	add    $0x10000000,%eax
f0107a3f:	83 c8 05             	or     $0x5,%eax
f0107a42:	89 02                	mov    %eax,(%edx)

}
f0107a44:	90                   	nop
f0107a45:	c9                   	leave  
f0107a46:	c3                   	ret    

f0107a47 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0107a47:	55                   	push   %ebp
f0107a48:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0107a4a:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a4d:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0107a53:	29 d0                	sub    %edx,%eax
f0107a55:	c1 f8 03             	sar    $0x3,%eax
f0107a58:	89 c2                	mov    %eax,%edx
f0107a5a:	89 d0                	mov    %edx,%eax
f0107a5c:	c1 e0 02             	shl    $0x2,%eax
f0107a5f:	01 d0                	add    %edx,%eax
f0107a61:	c1 e0 02             	shl    $0x2,%eax
f0107a64:	01 d0                	add    %edx,%eax
f0107a66:	c1 e0 02             	shl    $0x2,%eax
f0107a69:	01 d0                	add    %edx,%eax
f0107a6b:	89 c1                	mov    %eax,%ecx
f0107a6d:	c1 e1 08             	shl    $0x8,%ecx
f0107a70:	01 c8                	add    %ecx,%eax
f0107a72:	89 c1                	mov    %eax,%ecx
f0107a74:	c1 e1 10             	shl    $0x10,%ecx
f0107a77:	01 c8                	add    %ecx,%eax
f0107a79:	01 c0                	add    %eax,%eax
f0107a7b:	01 d0                	add    %edx,%eax
}
f0107a7d:	5d                   	pop    %ebp
f0107a7e:	c3                   	ret    

f0107a7f <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0107a7f:	55                   	push   %ebp
f0107a80:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0107a82:	ff 75 08             	pushl  0x8(%ebp)
f0107a85:	e8 bd ff ff ff       	call   f0107a47 <to_frame_number>
f0107a8a:	83 c4 04             	add    $0x4,%esp
f0107a8d:	c1 e0 0c             	shl    $0xc,%eax
}
f0107a90:	c9                   	leave  
f0107a91:	c3                   	ret    

f0107a92 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0107a92:	55                   	push   %ebp
f0107a93:	89 e5                	mov    %esp,%ebp
f0107a95:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0107a98:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a9b:	c1 e8 0c             	shr    $0xc,%eax
f0107a9e:	89 c2                	mov    %eax,%edx
f0107aa0:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0107aa5:	39 c2                	cmp    %eax,%edx
f0107aa7:	72 14                	jb     f0107abd <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0107aa9:	83 ec 04             	sub    $0x4,%esp
f0107aac:	68 40 4a 12 f0       	push   $0xf0124a40
f0107ab1:	6a 55                	push   $0x55
f0107ab3:	68 65 4a 12 f0       	push   $0xf0124a65
f0107ab8:	e8 5d 88 ff ff       	call   f010031a <_panic>
	return &frames_info[PPN(physical_address)];
f0107abd:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f0107ac3:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ac6:	c1 e8 0c             	shr    $0xc,%eax
f0107ac9:	89 c1                	mov    %eax,%ecx
f0107acb:	89 c8                	mov    %ecx,%eax
f0107acd:	01 c0                	add    %eax,%eax
f0107acf:	01 c8                	add    %ecx,%eax
f0107ad1:	c1 e0 03             	shl    $0x3,%eax
f0107ad4:	01 d0                	add    %edx,%eax
}
f0107ad6:	c9                   	leave  
f0107ad7:	c3                   	ret    

f0107ad8 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0107ad8:	55                   	push   %ebp
f0107ad9:	89 e5                	mov    %esp,%ebp
f0107adb:	83 ec 10             	sub    $0x10,%esp
f0107ade:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107ae1:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0107ae4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0107ae7:	0f 01 38             	invlpg (%eax)
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(virtual_address);
}
f0107aea:	90                   	nop
f0107aeb:	c9                   	leave  
f0107aec:	c3                   	ret    

f0107aed <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0107aed:	55                   	push   %ebp
f0107aee:	89 e5                	mov    %esp,%ebp
f0107af0:	53                   	push   %ebx
f0107af1:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0107af4:	c7 05 20 25 55 f0 00 	movl   $0x0,0xf0552520
f0107afb:	00 00 00 
f0107afe:	c7 05 24 25 55 f0 00 	movl   $0x0,0xf0552524
f0107b05:	00 00 00 
f0107b08:	c7 05 2c 25 55 f0 00 	movl   $0x0,0xf055252c
f0107b0f:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0107b12:	c7 05 30 25 55 f0 00 	movl   $0x0,0xf0552530
f0107b19:	00 00 00 
f0107b1c:	c7 05 34 25 55 f0 00 	movl   $0x0,0xf0552534
f0107b23:	00 00 00 
f0107b26:	c7 05 3c 25 55 f0 00 	movl   $0x0,0xf055253c
f0107b2d:	00 00 00 

	//Initialize the corresponding lock
	init_spinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0107b30:	83 ec 08             	sub    $0x8,%esp
f0107b33:	68 7f 4a 12 f0       	push   $0xf0124a7f
f0107b38:	68 40 25 55 f0       	push   $0xf0552540
f0107b3d:	e8 0d 6c 00 00       	call   f010e74f <init_spinlock>
f0107b42:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0107b45:	a1 20 4f 55 f0       	mov    0xf0554f20,%eax
f0107b4a:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0107b50:	a1 20 4f 55 f0       	mov    0xf0554f20,%eax
f0107b55:	83 c0 18             	add    $0x18,%eax
f0107b58:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0107b5e:	a1 20 4f 55 f0       	mov    0xf0554f20,%eax
f0107b63:	83 c0 30             	add    $0x30,%eax
f0107b66:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0107b6c:	c7 05 b4 4f 55 f0 00 	movl   $0xf0001000,0xf0554fb4
f0107b73:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0107b76:	c7 05 64 51 55 f0 00 	movl   $0xf0002000,0xf0555164
f0107b7d:	20 00 f0 
	i =0;
f0107b80:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0107b87:	eb 1f                	jmp    f0107ba8 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0107b89:	8b 15 b4 4f 55 f0    	mov    0xf0554fb4,%edx
f0107b8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107b92:	01 d0                	add    %edx,%eax
f0107b94:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0107b97:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0107b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107ba0:	01 d0                	add    %edx,%eax
f0107ba2:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0107ba5:	ff 45 f4             	incl   -0xc(%ebp)
f0107ba8:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0107baf:	7e d8                	jle    f0107b89 <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0107bb1:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0107bb8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107bbb:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0107bc0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0107bc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107bc6:	ba 00 00 00 00       	mov    $0x0,%edx
f0107bcb:	f7 75 f0             	divl   -0x10(%ebp)
f0107bce:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107bd1:	29 d0                	sub    %edx,%eax
f0107bd3:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107bd6:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0107bdd:	e9 e8 00 00 00       	jmp    f0107cca <initialize_paging+0x1dd>
	{

		initialize_frame_info(&(frames_info[i]));
f0107be2:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107be8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107beb:	89 d0                	mov    %edx,%eax
f0107bed:	01 c0                	add    %eax,%eax
f0107bef:	01 d0                	add    %edx,%eax
f0107bf1:	c1 e0 03             	shl    $0x3,%eax
f0107bf4:	01 c8                	add    %ecx,%eax
f0107bf6:	83 ec 0c             	sub    $0xc,%esp
f0107bf9:	50                   	push   %eax
f0107bfa:	e8 b7 02 00 00       	call   f0107eb6 <initialize_frame_info>
f0107bff:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107c02:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c08:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c0b:	89 d0                	mov    %edx,%eax
f0107c0d:	01 c0                	add    %eax,%eax
f0107c0f:	01 d0                	add    %edx,%eax
f0107c11:	c1 e0 03             	shl    $0x3,%eax
f0107c14:	01 c8                	add    %ecx,%eax
f0107c16:	85 c0                	test   %eax,%eax
f0107c18:	75 14                	jne    f0107c2e <initialize_paging+0x141>
f0107c1a:	83 ec 04             	sub    $0x4,%esp
f0107c1d:	68 90 4a 12 f0       	push   $0xf0124a90
f0107c22:	6a 60                	push   $0x60
f0107c24:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0107c29:	e8 ec 86 ff ff       	call   f010031a <_panic>
f0107c2e:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c34:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c37:	89 d0                	mov    %edx,%eax
f0107c39:	01 c0                	add    %eax,%eax
f0107c3b:	01 d0                	add    %edx,%eax
f0107c3d:	c1 e0 03             	shl    $0x3,%eax
f0107c40:	01 c8                	add    %ecx,%eax
f0107c42:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107c48:	89 10                	mov    %edx,(%eax)
f0107c4a:	8b 00                	mov    (%eax),%eax
f0107c4c:	85 c0                	test   %eax,%eax
f0107c4e:	74 1f                	je     f0107c6f <initialize_paging+0x182>
f0107c50:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107c56:	8b 1d 20 4f 55 f0    	mov    0xf0554f20,%ebx
f0107c5c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107c5f:	89 c8                	mov    %ecx,%eax
f0107c61:	01 c0                	add    %eax,%eax
f0107c63:	01 c8                	add    %ecx,%eax
f0107c65:	c1 e0 03             	shl    $0x3,%eax
f0107c68:	01 d8                	add    %ebx,%eax
f0107c6a:	89 42 04             	mov    %eax,0x4(%edx)
f0107c6d:	eb 19                	jmp    f0107c88 <initialize_paging+0x19b>
f0107c6f:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c75:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c78:	89 d0                	mov    %edx,%eax
f0107c7a:	01 c0                	add    %eax,%eax
f0107c7c:	01 d0                	add    %edx,%eax
f0107c7e:	c1 e0 03             	shl    $0x3,%eax
f0107c81:	01 c8                	add    %ecx,%eax
f0107c83:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f0107c88:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107c8e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107c91:	89 d0                	mov    %edx,%eax
f0107c93:	01 c0                	add    %eax,%eax
f0107c95:	01 d0                	add    %edx,%eax
f0107c97:	c1 e0 03             	shl    $0x3,%eax
f0107c9a:	01 c8                	add    %ecx,%eax
f0107c9c:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f0107ca1:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107ca7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107caa:	89 d0                	mov    %edx,%eax
f0107cac:	01 c0                	add    %eax,%eax
f0107cae:	01 d0                	add    %edx,%eax
f0107cb0:	c1 e0 03             	shl    $0x3,%eax
f0107cb3:	01 c8                	add    %ecx,%eax
f0107cb5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107cbc:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f0107cc1:	40                   	inc    %eax
f0107cc2:	a3 2c 25 55 f0       	mov    %eax,0xf055252c
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0107cc7:	ff 45 f4             	incl   -0xc(%ebp)
f0107cca:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107ccd:	85 c0                	test   %eax,%eax
f0107ccf:	79 05                	jns    f0107cd6 <initialize_paging+0x1e9>
f0107cd1:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107cd6:	c1 f8 0c             	sar    $0xc,%eax
f0107cd9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107cdc:	0f 8f 00 ff ff ff    	jg     f0107be2 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107ce2:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0107ce9:	eb 1d                	jmp    f0107d08 <initialize_paging+0x21b>
	{
		frames_info[i].references = 1;
f0107ceb:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107cf1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107cf4:	89 d0                	mov    %edx,%eax
f0107cf6:	01 c0                	add    %eax,%eax
f0107cf8:	01 d0                	add    %edx,%eax
f0107cfa:	c1 e0 03             	shl    $0x3,%eax
f0107cfd:	01 c8                	add    %ecx,%eax
f0107cff:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0107d05:	ff 45 f4             	incl   -0xc(%ebp)
f0107d08:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0107d0f:	7e da                	jle    f0107ceb <initialize_paging+0x1fe>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0107d11:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0107d18:	a1 d8 50 55 f0       	mov    0xf05550d8,%eax
f0107d1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0107d20:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0107d27:	77 14                	ja     f0107d3d <initialize_paging+0x250>
f0107d29:	ff 75 e0             	pushl  -0x20(%ebp)
f0107d2c:	68 d0 4a 12 f0       	push   $0xf0124ad0
f0107d31:	6a 68                	push   $0x68
f0107d33:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0107d38:	e8 dd 85 ff ff       	call   f010031a <_panic>
f0107d3d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0107d40:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0107d46:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0107d49:	01 d0                	add    %edx,%eax
f0107d4b:	48                   	dec    %eax
f0107d4c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0107d4f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d52:	ba 00 00 00 00       	mov    $0x0,%edx
f0107d57:	f7 75 e4             	divl   -0x1c(%ebp)
f0107d5a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0107d5d:	29 d0                	sub    %edx,%eax
f0107d5f:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107d62:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0107d69:	eb 1d                	jmp    f0107d88 <initialize_paging+0x29b>
	{
		frames_info[i].references = 1;
f0107d6b:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107d71:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107d74:	89 d0                	mov    %edx,%eax
f0107d76:	01 c0                	add    %eax,%eax
f0107d78:	01 d0                	add    %edx,%eax
f0107d7a:	c1 e0 03             	shl    $0x3,%eax
f0107d7d:	01 c8                	add    %ecx,%eax
f0107d7f:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0107d85:	ff 45 f4             	incl   -0xc(%ebp)
f0107d88:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107d8b:	85 c0                	test   %eax,%eax
f0107d8d:	79 05                	jns    f0107d94 <initialize_paging+0x2a7>
f0107d8f:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107d94:	c1 f8 0c             	sar    $0xc,%eax
f0107d97:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0107d9a:	7f cf                	jg     f0107d6b <initialize_paging+0x27e>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0107d9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0107d9f:	85 c0                	test   %eax,%eax
f0107da1:	79 05                	jns    f0107da8 <initialize_paging+0x2bb>
f0107da3:	05 ff 0f 00 00       	add    $0xfff,%eax
f0107da8:	c1 f8 0c             	sar    $0xc,%eax
f0107dab:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107dae:	e9 e8 00 00 00       	jmp    f0107e9b <initialize_paging+0x3ae>
	{
		initialize_frame_info(&(frames_info[i]));
f0107db3:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107db9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107dbc:	89 d0                	mov    %edx,%eax
f0107dbe:	01 c0                	add    %eax,%eax
f0107dc0:	01 d0                	add    %edx,%eax
f0107dc2:	c1 e0 03             	shl    $0x3,%eax
f0107dc5:	01 c8                	add    %ecx,%eax
f0107dc7:	83 ec 0c             	sub    $0xc,%esp
f0107dca:	50                   	push   %eax
f0107dcb:	e8 e6 00 00 00       	call   f0107eb6 <initialize_frame_info>
f0107dd0:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0107dd3:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107dd9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107ddc:	89 d0                	mov    %edx,%eax
f0107dde:	01 c0                	add    %eax,%eax
f0107de0:	01 d0                	add    %edx,%eax
f0107de2:	c1 e0 03             	shl    $0x3,%eax
f0107de5:	01 c8                	add    %ecx,%eax
f0107de7:	85 c0                	test   %eax,%eax
f0107de9:	75 14                	jne    f0107dff <initialize_paging+0x312>
f0107deb:	83 ec 04             	sub    $0x4,%esp
f0107dee:	68 90 4a 12 f0       	push   $0xf0124a90
f0107df3:	6a 74                	push   $0x74
f0107df5:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0107dfa:	e8 1b 85 ff ff       	call   f010031a <_panic>
f0107dff:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e05:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e08:	89 d0                	mov    %edx,%eax
f0107e0a:	01 c0                	add    %eax,%eax
f0107e0c:	01 d0                	add    %edx,%eax
f0107e0e:	c1 e0 03             	shl    $0x3,%eax
f0107e11:	01 c8                	add    %ecx,%eax
f0107e13:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107e19:	89 10                	mov    %edx,(%eax)
f0107e1b:	8b 00                	mov    (%eax),%eax
f0107e1d:	85 c0                	test   %eax,%eax
f0107e1f:	74 1f                	je     f0107e40 <initialize_paging+0x353>
f0107e21:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107e27:	8b 1d 20 4f 55 f0    	mov    0xf0554f20,%ebx
f0107e2d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0107e30:	89 c8                	mov    %ecx,%eax
f0107e32:	01 c0                	add    %eax,%eax
f0107e34:	01 c8                	add    %ecx,%eax
f0107e36:	c1 e0 03             	shl    $0x3,%eax
f0107e39:	01 d8                	add    %ebx,%eax
f0107e3b:	89 42 04             	mov    %eax,0x4(%edx)
f0107e3e:	eb 19                	jmp    f0107e59 <initialize_paging+0x36c>
f0107e40:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e46:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e49:	89 d0                	mov    %edx,%eax
f0107e4b:	01 c0                	add    %eax,%eax
f0107e4d:	01 d0                	add    %edx,%eax
f0107e4f:	c1 e0 03             	shl    $0x3,%eax
f0107e52:	01 c8                	add    %ecx,%eax
f0107e54:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f0107e59:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e62:	89 d0                	mov    %edx,%eax
f0107e64:	01 c0                	add    %eax,%eax
f0107e66:	01 d0                	add    %edx,%eax
f0107e68:	c1 e0 03             	shl    $0x3,%eax
f0107e6b:	01 c8                	add    %ecx,%eax
f0107e6d:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f0107e72:	8b 0d 20 4f 55 f0    	mov    0xf0554f20,%ecx
f0107e78:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e7b:	89 d0                	mov    %edx,%eax
f0107e7d:	01 c0                	add    %eax,%eax
f0107e7f:	01 d0                	add    %edx,%eax
f0107e81:	c1 e0 03             	shl    $0x3,%eax
f0107e84:	01 c8                	add    %ecx,%eax
f0107e86:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107e8d:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f0107e92:	40                   	inc    %eax
f0107e93:	a3 2c 25 55 f0       	mov    %eax,0xf055252c
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0107e98:	ff 45 f4             	incl   -0xc(%ebp)
f0107e9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107e9e:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0107ea3:	39 c2                	cmp    %eax,%edx
f0107ea5:	0f 82 08 ff ff ff    	jb     f0107db3 <initialize_paging+0x2c6>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f0107eab:	e8 ef b9 ff ff       	call   f010389f <initialize_disk_page_file>
}
f0107eb0:	90                   	nop
f0107eb1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0107eb4:	c9                   	leave  
f0107eb5:	c3                   	ret    

f0107eb6 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0107eb6:	55                   	push   %ebp
f0107eb7:	89 e5                	mov    %esp,%ebp
f0107eb9:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f0107ebc:	83 ec 04             	sub    $0x4,%esp
f0107ebf:	6a 18                	push   $0x18
f0107ec1:	6a 00                	push   $0x0
f0107ec3:	ff 75 08             	pushl  0x8(%ebp)
f0107ec6:	e8 56 88 01 00       	call   f0120721 <memset>
f0107ecb:	83 c4 10             	add    $0x10,%esp
}
f0107ece:	90                   	nop
f0107ecf:	c9                   	leave  
f0107ed0:	c3                   	ret    

f0107ed1 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0107ed1:	55                   	push   %ebp
f0107ed2:	89 e5                	mov    %esp,%ebp
f0107ed4:	83 ec 18             	sub    $0x18,%esp
	//cprintf("allocate_frame...\n");

	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f0107ed7:	83 ec 0c             	sub    $0xc,%esp
f0107eda:	68 40 25 55 f0       	push   $0xf0552540
f0107edf:	e8 b5 6a 00 00       	call   f010e999 <holding_spinlock>
f0107ee4:	83 c4 10             	add    $0x10,%esp
f0107ee7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0107eea:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107eee:	75 10                	jne    f0107f00 <allocate_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0107ef0:	83 ec 0c             	sub    $0xc,%esp
f0107ef3:	68 40 25 55 f0       	push   $0xf0552540
f0107ef8:	e8 83 68 00 00       	call   f010e780 <acquire_spinlock>
f0107efd:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0107f00:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0107f06:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f09:	89 10                	mov    %edx,(%eax)
	int c = 0;
f0107f0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (*ptr_frame_info == NULL)
f0107f12:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f15:	8b 00                	mov    (%eax),%eax
f0107f17:	85 c0                	test   %eax,%eax
f0107f19:	75 17                	jne    f0107f32 <allocate_frame+0x61>
	{
		//[PROJECT] Free RAM when it's FULL
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f0107f1b:	83 ec 04             	sub    $0x4,%esp
f0107f1e:	68 04 4b 12 f0       	push   $0xf0124b04
f0107f23:	68 a2 00 00 00       	push   $0xa2
f0107f28:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0107f2d:	e8 e8 83 ff ff       	call   f010031a <_panic>
		// When allocating new frame, if there's no free frame, then you should:
		//	1-	If any process has exited (those with status ENV_EXIT), then remove one or more of these exited processes from the main memory
		//	2-	otherwise, free at least 1 frame from the user working set by applying the FIFO algorithm
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f0107f32:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f35:	8b 00                	mov    (%eax),%eax
f0107f37:	85 c0                	test   %eax,%eax
f0107f39:	75 17                	jne    f0107f52 <allocate_frame+0x81>
f0107f3b:	83 ec 04             	sub    $0x4,%esp
f0107f3e:	68 51 4b 12 f0       	push   $0xf0124b51
f0107f43:	68 a8 00 00 00       	push   $0xa8
f0107f48:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0107f4d:	e8 c8 83 ff ff       	call   f010031a <_panic>
f0107f52:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f55:	8b 00                	mov    (%eax),%eax
f0107f57:	8b 00                	mov    (%eax),%eax
f0107f59:	85 c0                	test   %eax,%eax
f0107f5b:	74 14                	je     f0107f71 <allocate_frame+0xa0>
f0107f5d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f60:	8b 00                	mov    (%eax),%eax
f0107f62:	8b 00                	mov    (%eax),%eax
f0107f64:	8b 55 08             	mov    0x8(%ebp),%edx
f0107f67:	8b 12                	mov    (%edx),%edx
f0107f69:	8b 52 04             	mov    0x4(%edx),%edx
f0107f6c:	89 50 04             	mov    %edx,0x4(%eax)
f0107f6f:	eb 0d                	jmp    f0107f7e <allocate_frame+0xad>
f0107f71:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f74:	8b 00                	mov    (%eax),%eax
f0107f76:	8b 40 04             	mov    0x4(%eax),%eax
f0107f79:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f0107f7e:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f81:	8b 00                	mov    (%eax),%eax
f0107f83:	8b 40 04             	mov    0x4(%eax),%eax
f0107f86:	85 c0                	test   %eax,%eax
f0107f88:	74 13                	je     f0107f9d <allocate_frame+0xcc>
f0107f8a:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f8d:	8b 00                	mov    (%eax),%eax
f0107f8f:	8b 40 04             	mov    0x4(%eax),%eax
f0107f92:	8b 55 08             	mov    0x8(%ebp),%edx
f0107f95:	8b 12                	mov    (%edx),%edx
f0107f97:	8b 12                	mov    (%edx),%edx
f0107f99:	89 10                	mov    %edx,(%eax)
f0107f9b:	eb 0c                	jmp    f0107fa9 <allocate_frame+0xd8>
f0107f9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fa0:	8b 00                	mov    (%eax),%eax
f0107fa2:	8b 00                	mov    (%eax),%eax
f0107fa4:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f0107fa9:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fac:	8b 00                	mov    (%eax),%eax
f0107fae:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0107fb4:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fb7:	8b 00                	mov    (%eax),%eax
f0107fb9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0107fc0:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f0107fc5:	48                   	dec    %eax
f0107fc6:	a3 2c 25 55 f0       	mov    %eax,0xf055252c

	/******************* PAGE BUFFERING CODE *******************
	 ***********************************************************/
	if((*ptr_frame_info)->isBuffered)
f0107fcb:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fce:	8b 00                	mov    (%eax),%eax
f0107fd0:	8a 40 14             	mov    0x14(%eax),%al
f0107fd3:	84 c0                	test   %al,%al
f0107fd5:	74 20                	je     f0107ff7 <allocate_frame+0x126>
	{
		pt_clear_page_table_entry((*ptr_frame_info)->proc->env_page_directory,(*ptr_frame_info)->bufferedVA);
f0107fd7:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fda:	8b 00                	mov    (%eax),%eax
f0107fdc:	8b 50 10             	mov    0x10(%eax),%edx
f0107fdf:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fe2:	8b 00                	mov    (%eax),%eax
f0107fe4:	8b 40 0c             	mov    0xc(%eax),%eax
f0107fe7:	8b 40 64             	mov    0x64(%eax),%eax
f0107fea:	83 ec 08             	sub    $0x8,%esp
f0107fed:	52                   	push   %edx
f0107fee:	50                   	push   %eax
f0107fef:	e8 42 09 00 00       	call   f0108936 <pt_clear_page_table_entry>
f0107ff4:	83 c4 10             	add    $0x10,%esp
		//pt_set_page_permissions((*ptr_frame_info)->environment->env_pgdir, (*ptr_frame_info)->va, 0, PERM_BUFFERED);
	}
	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f0107ff7:	8b 45 08             	mov    0x8(%ebp),%eax
f0107ffa:	8b 00                	mov    (%eax),%eax
f0107ffc:	83 ec 0c             	sub    $0xc,%esp
f0107fff:	50                   	push   %eax
f0108000:	e8 b1 fe ff ff       	call   f0107eb6 <initialize_frame_info>
f0108005:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f0108008:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010800c:	75 10                	jne    f010801e <allocate_frame+0x14d>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010800e:	83 ec 0c             	sub    $0xc,%esp
f0108011:	68 40 25 55 f0       	push   $0xf0552540
f0108016:	e8 ec 67 00 00       	call   f010e807 <release_spinlock>
f010801b:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f010801e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0108023:	c9                   	leave  
f0108024:	c3                   	ret    

f0108025 <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f0108025:	55                   	push   %ebp
f0108026:	89 e5                	mov    %esp,%ebp
f0108028:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_spinlock(&MemFrameLists.mfllock);
f010802b:	83 ec 0c             	sub    $0xc,%esp
f010802e:	68 40 25 55 f0       	push   $0xf0552540
f0108033:	e8 61 69 00 00       	call   f010e999 <holding_spinlock>
f0108038:	83 c4 10             	add    $0x10,%esp
f010803b:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010803e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108042:	75 10                	jne    f0108054 <free_frame+0x2f>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f0108044:	83 ec 0c             	sub    $0xc,%esp
f0108047:	68 40 25 55 f0       	push   $0xf0552540
f010804c:	e8 2f 67 00 00       	call   f010e780 <acquire_spinlock>
f0108051:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0108054:	83 ec 0c             	sub    $0xc,%esp
f0108057:	ff 75 08             	pushl  0x8(%ebp)
f010805a:	e8 57 fe ff ff       	call   f0107eb6 <initialize_frame_info>
f010805f:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f0108062:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0108066:	75 17                	jne    f010807f <free_frame+0x5a>
f0108068:	83 ec 04             	sub    $0x4,%esp
f010806b:	68 90 4a 12 f0       	push   $0xf0124a90
f0108070:	68 cf 00 00 00       	push   $0xcf
f0108075:	68 b3 4a 12 f0       	push   $0xf0124ab3
f010807a:	e8 9b 82 ff ff       	call   f010031a <_panic>
f010807f:	8b 15 20 25 55 f0    	mov    0xf0552520,%edx
f0108085:	8b 45 08             	mov    0x8(%ebp),%eax
f0108088:	89 10                	mov    %edx,(%eax)
f010808a:	8b 45 08             	mov    0x8(%ebp),%eax
f010808d:	8b 00                	mov    (%eax),%eax
f010808f:	85 c0                	test   %eax,%eax
f0108091:	74 0d                	je     f01080a0 <free_frame+0x7b>
f0108093:	a1 20 25 55 f0       	mov    0xf0552520,%eax
f0108098:	8b 55 08             	mov    0x8(%ebp),%edx
f010809b:	89 50 04             	mov    %edx,0x4(%eax)
f010809e:	eb 08                	jmp    f01080a8 <free_frame+0x83>
f01080a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01080a3:	a3 24 25 55 f0       	mov    %eax,0xf0552524
f01080a8:	8b 45 08             	mov    0x8(%ebp),%eax
f01080ab:	a3 20 25 55 f0       	mov    %eax,0xf0552520
f01080b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01080b3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01080ba:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f01080bf:	40                   	inc    %eax
f01080c0:	a3 2c 25 55 f0       	mov    %eax,0xf055252c
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f01080c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01080c9:	75 10                	jne    f01080db <free_frame+0xb6>
	{
		release_spinlock(&MemFrameLists.mfllock);
f01080cb:	83 ec 0c             	sub    $0xc,%esp
f01080ce:	68 40 25 55 f0       	push   $0xf0552540
f01080d3:	e8 2f 67 00 00       	call   f010e807 <release_spinlock>
f01080d8:	83 c4 10             	add    $0x10,%esp
	}
}
f01080db:	90                   	nop
f01080dc:	c9                   	leave  
f01080dd:	c3                   	ret    

f01080de <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f01080de:	55                   	push   %ebp
f01080df:	89 e5                	mov    %esp,%ebp
f01080e1:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f01080e4:	8b 45 08             	mov    0x8(%ebp),%eax
f01080e7:	8b 40 08             	mov    0x8(%eax),%eax
f01080ea:	48                   	dec    %eax
f01080eb:	8b 55 08             	mov    0x8(%ebp),%edx
f01080ee:	66 89 42 08          	mov    %ax,0x8(%edx)
f01080f2:	8b 45 08             	mov    0x8(%ebp),%eax
f01080f5:	8b 40 08             	mov    0x8(%eax),%eax
f01080f8:	66 85 c0             	test   %ax,%ax
f01080fb:	75 0e                	jne    f010810b <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f01080fd:	83 ec 0c             	sub    $0xc,%esp
f0108100:	ff 75 08             	pushl  0x8(%ebp)
f0108103:	e8 1d ff ff ff       	call   f0108025 <free_frame>
f0108108:	83 c4 10             	add    $0x10,%esp
}
f010810b:	90                   	nop
f010810c:	c9                   	leave  
f010810d:	c3                   	ret    

f010810e <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f010810e:	55                   	push   %ebp
f010810f:	89 e5                	mov    %esp,%ebp
f0108111:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0108114:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108117:	c1 e8 16             	shr    $0x16,%eax
f010811a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108121:	8b 45 08             	mov    0x8(%ebp),%eax
f0108124:	01 d0                	add    %edx,%eax
f0108126:	8b 00                	mov    (%eax),%eax
f0108128:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f010812b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010812e:	83 e0 01             	and    $0x1,%eax
f0108131:	85 c0                	test   %eax,%eax
f0108133:	74 4e                	je     f0108183 <get_page_table+0x75>
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108135:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108138:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010813d:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108140:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108143:	c1 e8 0c             	shr    $0xc,%eax
f0108146:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108149:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010814e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0108151:	72 17                	jb     f010816a <get_page_table+0x5c>
f0108153:	ff 75 f0             	pushl  -0x10(%ebp)
f0108156:	68 70 4b 12 f0       	push   $0xf0124b70
f010815b:	68 fb 00 00 00       	push   $0xfb
f0108160:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0108165:	e8 b0 81 ff ff       	call   f010031a <_panic>
f010816a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010816d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108172:	89 c2                	mov    %eax,%edx
f0108174:	8b 45 10             	mov    0x10(%ebp),%eax
f0108177:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f0108179:	b8 00 00 00 00       	mov    $0x0,%eax
f010817e:	e9 8f 00 00 00       	jmp    f0108212 <get_page_table+0x104>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f0108183:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108187:	74 7b                	je     f0108204 <get_page_table+0xf6>
f0108189:	8b 45 0c             	mov    0xc(%ebp),%eax
f010818c:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f010818f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108192:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0108195:	83 ec 0c             	sub    $0xc,%esp
f0108198:	6a 00                	push   $0x0
f010819a:	e8 b5 62 00 00       	call   f010e454 <fault_handler>
f010819f:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01081a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01081a5:	c1 e8 16             	shr    $0x16,%eax
f01081a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01081af:	8b 45 08             	mov    0x8(%ebp),%eax
f01081b2:	01 d0                	add    %edx,%eax
f01081b4:	8b 00                	mov    (%eax),%eax
f01081b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01081b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081bc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01081c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01081c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01081c7:	c1 e8 0c             	shr    $0xc,%eax
f01081ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01081cd:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01081d2:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f01081d5:	72 17                	jb     f01081ee <get_page_table+0xe0>
f01081d7:	ff 75 e8             	pushl  -0x18(%ebp)
f01081da:	68 70 4b 12 f0       	push   $0xf0124b70
f01081df:	68 13 01 00 00       	push   $0x113
f01081e4:	68 b3 4a 12 f0       	push   $0xf0124ab3
f01081e9:	e8 2c 81 ff ff       	call   f010031a <_panic>
f01081ee:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01081f1:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01081f6:	89 c2                	mov    %eax,%edx
f01081f8:	8b 45 10             	mov    0x10(%ebp),%eax
f01081fb:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f01081fd:	b8 00 00 00 00       	mov    $0x0,%eax
f0108202:	eb 0e                	jmp    f0108212 <get_page_table+0x104>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0108204:	8b 45 10             	mov    0x10(%ebp),%eax
f0108207:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f010820d:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f0108212:	c9                   	leave  
f0108213:	c3                   	ret    

f0108214 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f0108214:	55                   	push   %ebp
f0108215:	89 e5                	mov    %esp,%ebp
f0108217:	83 ec 18             	sub    $0x18,%esp
	memset(ptr_page_table , 0, PAGE_SIZE);
	tlbflush();

#else
	uint32 * ptr_page_table ;
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
f010821a:	83 ec 04             	sub    $0x4,%esp
f010821d:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0108220:	50                   	push   %eax
f0108221:	ff 75 0c             	pushl  0xc(%ebp)
f0108224:	ff 75 08             	pushl  0x8(%ebp)
f0108227:	e8 08 00 00 00       	call   f0108234 <__static_cpt>
f010822c:	83 c4 10             	add    $0x10,%esp
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f010822f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0108232:	c9                   	leave  
f0108233:	c3                   	ret    

f0108234 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0108234:	55                   	push   %ebp
f0108235:	89 e5                	mov    %esp,%ebp
f0108237:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f010823a:	83 ec 0c             	sub    $0xc,%esp
f010823d:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0108240:	50                   	push   %eax
f0108241:	e8 8b fc ff ff       	call   f0107ed1 <allocate_frame>
f0108246:	83 c4 10             	add    $0x10,%esp
f0108249:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f010824c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010824f:	83 ec 0c             	sub    $0xc,%esp
f0108252:	50                   	push   %eax
f0108253:	e8 27 f8 ff ff       	call   f0107a7f <to_physical_address>
f0108258:	83 c4 10             	add    $0x10,%esp
f010825b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010825e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108261:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108264:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108267:	c1 e8 0c             	shr    $0xc,%eax
f010826a:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010826d:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0108272:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0108275:	72 17                	jb     f010828e <__static_cpt+0x5a>
f0108277:	ff 75 ec             	pushl  -0x14(%ebp)
f010827a:	68 70 4b 12 f0       	push   $0xf0124b70
f010827f:	68 4e 01 00 00       	push   $0x14e
f0108284:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0108289:	e8 8c 80 ff ff       	call   f010031a <_panic>
f010828e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108291:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108296:	89 c2                	mov    %eax,%edx
f0108298:	8b 45 10             	mov    0x10(%ebp),%eax
f010829b:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f010829d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01082a0:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01082a6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01082a9:	c1 e8 16             	shr    $0x16,%eax
f01082ac:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01082b3:	8b 45 08             	mov    0x8(%ebp),%eax
f01082b6:	01 d0                	add    %edx,%eax
f01082b8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01082bb:	83 ca 07             	or     $0x7,%edx
f01082be:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01082c0:	8b 45 10             	mov    0x10(%ebp),%eax
f01082c3:	8b 00                	mov    (%eax),%eax
f01082c5:	83 ec 04             	sub    $0x4,%esp
f01082c8:	68 00 10 00 00       	push   $0x1000
f01082cd:	6a 00                	push   $0x0
f01082cf:	50                   	push   %eax
f01082d0:	e8 4c 84 01 00       	call   f0120721 <memset>
f01082d5:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01082d8:	0f 20 d8             	mov    %cr3,%eax
f01082db:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01082de:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01082e1:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01082e4:	90                   	nop
f01082e5:	c9                   	leave  
f01082e6:	c3                   	ret    

f01082e7 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01082e7:	55                   	push   %ebp
f01082e8:	89 e5                	mov    %esp,%ebp
f01082ea:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01082ed:	ff 75 0c             	pushl  0xc(%ebp)
f01082f0:	e8 8a f7 ff ff       	call   f0107a7f <to_physical_address>
f01082f5:	83 c4 04             	add    $0x4,%esp
f01082f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01082fb:	83 ec 04             	sub    $0x4,%esp
f01082fe:	8d 45 e8             	lea    -0x18(%ebp),%eax
f0108301:	50                   	push   %eax
f0108302:	ff 75 10             	pushl  0x10(%ebp)
f0108305:	ff 75 08             	pushl  0x8(%ebp)
f0108308:	e8 01 fe ff ff       	call   f010810e <get_page_table>
f010830d:	83 c4 10             	add    $0x10,%esp
f0108310:	83 f8 01             	cmp    $0x1,%eax
f0108313:	75 15                	jne    f010832a <map_frame+0x43>
			uint32* ptr_page_table2 =NULL;
			//cprintf("======> After the table created at %x\n\n", get_page_table(ptr_page_directory, virtual_address,&ptr_page_table2));
		}
#else
		{
			__static_cpt(ptr_page_directory, (uint32)virtual_address, &ptr_page_table);
f0108315:	83 ec 04             	sub    $0x4,%esp
f0108318:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010831b:	50                   	push   %eax
f010831c:	ff 75 10             	pushl  0x10(%ebp)
f010831f:	ff 75 08             	pushl  0x8(%ebp)
f0108322:	e8 0d ff ff ff       	call   f0108234 <__static_cpt>
f0108327:	83 c4 10             	add    $0x10,%esp
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f010832a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010832d:	8b 55 10             	mov    0x10(%ebp),%edx
f0108330:	c1 ea 0c             	shr    $0xc,%edx
f0108333:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108339:	c1 e2 02             	shl    $0x2,%edx
f010833c:	01 d0                	add    %edx,%eax
f010833e:	8b 00                	mov    (%eax),%eax
f0108340:	89 45 f0             	mov    %eax,-0x10(%ebp)

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0108343:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108346:	83 e0 01             	and    $0x1,%eax
f0108349:	85 c0                	test   %eax,%eax
f010834b:	74 25                	je     f0108372 <map_frame+0x8b>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f010834d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108350:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108355:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108358:	75 07                	jne    f0108361 <map_frame+0x7a>
			return 0;
f010835a:	b8 00 00 00 00       	mov    $0x0,%eax
f010835f:	eb 68                	jmp    f01083c9 <map_frame+0xe2>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0108361:	83 ec 08             	sub    $0x8,%esp
f0108364:	ff 75 10             	pushl  0x10(%ebp)
f0108367:	ff 75 08             	pushl  0x8(%ebp)
f010836a:	e8 d2 00 00 00       	call   f0108441 <unmap_frame>
f010836f:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0108372:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108375:	8b 40 08             	mov    0x8(%eax),%eax
f0108378:	40                   	inc    %eax
f0108379:	8b 55 0c             	mov    0xc(%ebp),%edx
f010837c:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * [DONE] map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108380:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108383:	8b 55 10             	mov    0x10(%ebp),%edx
f0108386:	c1 ea 0c             	shr    $0xc,%edx
f0108389:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010838f:	c1 e2 02             	shl    $0x2,%edx
f0108392:	01 d0                	add    %edx,%eax
f0108394:	8b 00                	mov    (%eax),%eax
f0108396:	25 00 0e 00 00       	and    $0xe00,%eax
f010839b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f010839e:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01083a1:	8b 55 10             	mov    0x10(%ebp),%edx
f01083a4:	c1 ea 0c             	shr    $0xc,%edx
f01083a7:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01083ad:	c1 e2 02             	shl    $0x2,%edx
f01083b0:	01 c2                	add    %eax,%edx
f01083b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b5:	0b 45 ec             	or     -0x14(%ebp),%eax
f01083b8:	89 c1                	mov    %eax,%ecx
f01083ba:	8b 45 14             	mov    0x14(%ebp),%eax
f01083bd:	09 c8                	or     %ecx,%eax
f01083bf:	83 c8 01             	or     $0x1,%eax
f01083c2:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01083c4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01083c9:	c9                   	leave  
f01083ca:	c3                   	ret    

f01083cb <get_frame_info>:
// Return 0 if there is no frame mapped at virtual_address.
//
// Hint: implement using get_page_table() and get_frame_info().
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01083cb:	55                   	push   %ebp
f01083cc:	89 e5                	mov    %esp,%ebp
f01083ce:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	//cprintf(".gfi .1\n %x, %x, %x, \n", ptr_page_directory, virtual_address, ptr_page_table);
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01083d1:	83 ec 04             	sub    $0x4,%esp
f01083d4:	ff 75 10             	pushl  0x10(%ebp)
f01083d7:	ff 75 0c             	pushl  0xc(%ebp)
f01083da:	ff 75 08             	pushl  0x8(%ebp)
f01083dd:	e8 2c fd ff ff       	call   f010810e <get_page_table>
f01083e2:	83 c4 10             	add    $0x10,%esp
f01083e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf(".gfi .15\n");
	if((*ptr_page_table) != 0)
f01083e8:	8b 45 10             	mov    0x10(%ebp),%eax
f01083eb:	8b 00                	mov    (%eax),%eax
f01083ed:	85 c0                	test   %eax,%eax
f01083ef:	74 49                	je     f010843a <get_frame_info+0x6f>
	{
		uint32 index_page_table = PTX(virtual_address);
f01083f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01083f4:	c1 e8 0c             	shr    $0xc,%eax
f01083f7:	25 ff 03 00 00       	and    $0x3ff,%eax
f01083fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf(".gfi .2\n");
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f01083ff:	8b 45 10             	mov    0x10(%ebp),%eax
f0108402:	8b 00                	mov    (%eax),%eax
f0108404:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108407:	c1 e2 02             	shl    $0x2,%edx
f010840a:	01 d0                	add    %edx,%eax
f010840c:	8b 00                	mov    (%eax),%eax
f010840e:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		//if( page_table_entry != 0)
		if( (page_table_entry & ~0xFFF) != 0)
f0108411:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108414:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108419:	85 c0                	test   %eax,%eax
f010841b:	74 16                	je     f0108433 <get_frame_info+0x68>
		{
			//cprintf(".gfi .3\n");
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010841d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108420:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108425:	83 ec 0c             	sub    $0xc,%esp
f0108428:	50                   	push   %eax
f0108429:	e8 64 f6 ff ff       	call   f0107a92 <to_frame_info>
f010842e:	83 c4 10             	add    $0x10,%esp
f0108431:	eb 0c                	jmp    f010843f <get_frame_info+0x74>
		}
		return 0;
f0108433:	b8 00 00 00 00       	mov    $0x0,%eax
f0108438:	eb 05                	jmp    f010843f <get_frame_info+0x74>
	}
	return 0;
f010843a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010843f:	c9                   	leave  
f0108440:	c3                   	ret    

f0108441 <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f0108441:	55                   	push   %ebp
f0108442:	89 e5                	mov    %esp,%ebp
f0108444:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0108447:	83 ec 04             	sub    $0x4,%esp
f010844a:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010844d:	50                   	push   %eax
f010844e:	ff 75 0c             	pushl  0xc(%ebp)
f0108451:	ff 75 08             	pushl  0x8(%ebp)
f0108454:	e8 72 ff ff ff       	call   f01083cb <get_frame_info>
f0108459:	83 c4 10             	add    $0x10,%esp
f010845c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f010845f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108463:	74 7d                	je     f01084e2 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0108465:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108468:	8a 40 14             	mov    0x14(%eax),%al
f010846b:	84 c0                	test   %al,%al
f010846d:	74 1c                	je     f010848b <unmap_frame+0x4a>
f010846f:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0108476:	77 13                	ja     f010848b <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0108478:	83 ec 08             	sub    $0x8,%esp
f010847b:	ff 75 0c             	pushl  0xc(%ebp)
f010847e:	68 a0 4b 12 f0       	push   $0xf0124ba0
f0108483:	e8 e4 8a ff ff       	call   f0100f6c <cprintf>
f0108488:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f010848b:	83 ec 0c             	sub    $0xc,%esp
f010848e:	ff 75 f4             	pushl  -0xc(%ebp)
f0108491:	e8 48 fc ff ff       	call   f01080de <decrement_references>
f0108496:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * [DONE] unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0108499:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010849c:	8b 55 0c             	mov    0xc(%ebp),%edx
f010849f:	c1 ea 0c             	shr    $0xc,%edx
f01084a2:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01084a8:	c1 e2 02             	shl    $0x2,%edx
f01084ab:	01 d0                	add    %edx,%eax
f01084ad:	8b 00                	mov    (%eax),%eax
f01084af:	25 00 0e 00 00       	and    $0xe00,%eax
f01084b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01084b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01084ba:	8b 55 0c             	mov    0xc(%ebp),%edx
f01084bd:	c1 ea 0c             	shr    $0xc,%edx
f01084c0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01084c6:	c1 e2 02             	shl    $0x2,%edx
f01084c9:	01 c2                	add    %eax,%edx
f01084cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01084ce:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01084d0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01084d3:	83 ec 08             	sub    $0x8,%esp
f01084d6:	50                   	push   %eax
f01084d7:	ff 75 08             	pushl  0x8(%ebp)
f01084da:	e8 f9 f5 ff ff       	call   f0107ad8 <tlb_invalidate>
f01084df:	83 c4 10             	add    $0x10,%esp
	}
}
f01084e2:	90                   	nop
f01084e3:	c9                   	leave  
f01084e4:	c3                   	ret    

f01084e5 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01084e5:	55                   	push   %ebp
f01084e6:	89 e5                	mov    %esp,%ebp
f01084e8:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01084eb:	ff 75 0c             	pushl  0xc(%ebp)
f01084ee:	e8 8c f5 ff ff       	call   f0107a7f <to_physical_address>
f01084f3:	83 c4 04             	add    $0x4,%esp
f01084f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f01084f9:	8b 45 10             	mov    0x10(%ebp),%eax
f01084fc:	c1 e8 16             	shr    $0x16,%eax
f01084ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108506:	8b 45 08             	mov    0x8(%ebp),%eax
f0108509:	01 d0                	add    %edx,%eax
f010850b:	8b 00                	mov    (%eax),%eax
f010850d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0108510:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108513:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108518:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010851b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010851e:	c1 e8 0c             	shr    $0xc,%eax
f0108521:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108524:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0108529:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f010852c:	72 17                	jb     f0108545 <loadtime_map_frame+0x60>
f010852e:	ff 75 ec             	pushl  -0x14(%ebp)
f0108531:	68 70 4b 12 f0       	push   $0xf0124b70
f0108536:	68 f9 01 00 00       	push   $0x1f9
f010853b:	68 b3 4a 12 f0       	push   $0xf0124ab3
f0108540:	e8 d5 7d ff ff       	call   f010031a <_panic>
f0108545:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108548:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010854d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0108550:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108554:	75 15                	jne    f010856b <loadtime_map_frame+0x86>
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
		}
#else
		{
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
f0108556:	83 ec 04             	sub    $0x4,%esp
f0108559:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010855c:	50                   	push   %eax
f010855d:	ff 75 10             	pushl  0x10(%ebp)
f0108560:	ff 75 08             	pushl  0x8(%ebp)
f0108563:	e8 cc fc ff ff       	call   f0108234 <__static_cpt>
f0108568:	83 c4 10             	add    $0x10,%esp
		}
#endif
	}

	ptr_frame_info->references++;
f010856b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010856e:	8b 40 08             	mov    0x8(%eax),%eax
f0108571:	40                   	inc    %eax
f0108572:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108575:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f0108579:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010857c:	8b 55 10             	mov    0x10(%ebp),%edx
f010857f:	c1 ea 0c             	shr    $0xc,%edx
f0108582:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108588:	c1 e2 02             	shl    $0x2,%edx
f010858b:	01 c2                	add    %eax,%edx
f010858d:	8b 45 14             	mov    0x14(%ebp),%eax
f0108590:	0b 45 f4             	or     -0xc(%ebp),%eax
f0108593:	83 c8 01             	or     $0x1,%eax
f0108596:	89 02                	mov    %eax,(%edx)

	return 0;
f0108598:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010859d:	c9                   	leave  
f010859e:	c3                   	ret    

f010859f <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f010859f:	55                   	push   %ebp
f01085a0:	89 e5                	mov    %esp,%ebp
f01085a2:	57                   	push   %edi
f01085a3:	56                   	push   %esi
f01085a4:	53                   	push   %ebx
f01085a5:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01085a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f01085af:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f01085b6:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_spinlock(&MemFrameLists.mfllock);
f01085bd:	83 ec 0c             	sub    $0xc,%esp
f01085c0:	68 40 25 55 f0       	push   $0xf0552540
f01085c5:	e8 cf 63 00 00       	call   f010e999 <holding_spinlock>
f01085ca:	83 c4 10             	add    $0x10,%esp
f01085cd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f01085d0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01085d4:	75 10                	jne    f01085e6 <calculate_available_frames+0x47>
	{
		acquire_spinlock(&MemFrameLists.mfllock);
f01085d6:	83 ec 0c             	sub    $0xc,%esp
f01085d9:	68 40 25 55 f0       	push   $0xf0552540
f01085de:	e8 9d 61 00 00       	call   f010e780 <acquire_spinlock>
f01085e3:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f01085e6:	a1 20 25 55 f0       	mov    0xf0552520,%eax
f01085eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01085ee:	eb 1a                	jmp    f010860a <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f01085f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01085f3:	8a 40 14             	mov    0x14(%eax),%al
f01085f6:	84 c0                	test   %al,%al
f01085f8:	74 05                	je     f01085ff <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f01085fa:	ff 45 dc             	incl   -0x24(%ebp)
f01085fd:	eb 03                	jmp    f0108602 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f01085ff:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_spinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0108602:	a1 28 25 55 f0       	mov    0xf0552528,%eax
f0108607:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010860a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010860e:	74 07                	je     f0108617 <calculate_available_frames+0x78>
f0108610:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108613:	8b 00                	mov    (%eax),%eax
f0108615:	eb 05                	jmp    f010861c <calculate_available_frames+0x7d>
f0108617:	b8 00 00 00 00       	mov    $0x0,%eax
f010861c:	a3 28 25 55 f0       	mov    %eax,0xf0552528
f0108621:	a1 28 25 55 f0       	mov    0xf0552528,%eax
f0108626:	85 c0                	test   %eax,%eax
f0108628:	75 c6                	jne    f01085f0 <calculate_available_frames+0x51>
f010862a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010862e:	75 c0                	jne    f01085f0 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0108630:	a1 3c 25 55 f0       	mov    0xf055253c,%eax
f0108635:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f0108638:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010863c:	75 10                	jne    f010864e <calculate_available_frames+0xaf>
	{
		release_spinlock(&MemFrameLists.mfllock);
f010863e:	83 ec 0c             	sub    $0xc,%esp
f0108641:	68 40 25 55 f0       	push   $0xf0552540
f0108646:	e8 bc 61 00 00       	call   f010e807 <release_spinlock>
f010864b:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f010864e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108651:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0108654:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108657:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f010865a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010865d:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0108660:	8b 45 08             	mov    0x8(%ebp),%eax
f0108663:	89 c3                	mov    %eax,%ebx
f0108665:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0108668:	ba 03 00 00 00       	mov    $0x3,%edx
f010866d:	89 df                	mov    %ebx,%edi
f010866f:	89 c6                	mov    %eax,%esi
f0108671:	89 d1                	mov    %edx,%ecx
f0108673:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f0108675:	8b 45 08             	mov    0x8(%ebp),%eax
f0108678:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010867b:	5b                   	pop    %ebx
f010867c:	5e                   	pop    %esi
f010867d:	5f                   	pop    %edi
f010867e:	5d                   	pop    %ebp
f010867f:	c2 04 00             	ret    $0x4

f0108682 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init(uint32 numOfElements)
{
f0108682:	55                   	push   %ebp
f0108683:	89 e5                	mov    %esp,%ebp
f0108685:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
	init_spinlock(&AllShares.shareslock, "shares lock");
#else
	panic("not handled when KERN HEAP is disabled");
f0108688:	83 ec 04             	sub    $0x4,%esp
f010868b:	68 d0 4b 12 f0       	push   $0xf0124bd0
f0108690:	6a 1e                	push   $0x1e
f0108692:	68 f8 4b 12 f0       	push   $0xf0124bf8
f0108697:	e8 7e 7c ff ff       	call   f010031a <_panic>

f010869c <create_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* create_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f010869c:	55                   	push   %ebp
f010869d:	89 e5                	mov    %esp,%ebp
f010869f:	83 ec 18             	sub    $0x18,%esp
f01086a2:	8b 45 14             	mov    0x14(%ebp),%eax
f01086a5:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_share is not implemented yet");
f01086a8:	83 ec 04             	sub    $0x4,%esp
f01086ab:	68 1c 4c 12 f0       	push   $0xf0124c1c
f01086b0:	6a 32                	push   $0x32
f01086b2:	68 f8 4b 12 f0       	push   $0xf0124bf8
f01086b7:	e8 5e 7c ff ff       	call   f010031a <_panic>

f01086bc <get_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* get_share(int32 ownerID, char* name)
{
f01086bc:	55                   	push   %ebp
f01086bd:	89 e5                	mov    %esp,%ebp
f01086bf:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("get_share is not implemented yet");
f01086c2:	83 ec 04             	sub    $0x4,%esp
f01086c5:	68 40 4c 12 f0       	push   $0xf0124c40
f01086ca:	6a 42                	push   $0x42
f01086cc:	68 f8 4b 12 f0       	push   $0xf0124bf8
f01086d1:	e8 44 7c ff ff       	call   f010031a <_panic>

f01086d6 <free_share>:
// [3] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f01086d6:	55                   	push   %ebp
f01086d7:	89 e5                	mov    %esp,%ebp
f01086d9:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_share is not implemented yet");
f01086dc:	83 ec 04             	sub    $0x4,%esp
f01086df:	68 64 4c 12 f0       	push   $0xf0124c64
f01086e4:	6a 50                	push   $0x50
f01086e6:	68 f8 4b 12 f0       	push   $0xf0124bf8
f01086eb:	e8 2a 7c ff ff       	call   f010031a <_panic>

f01086f0 <create_frames_storage>:
//===========================
// [4] Create frames_storage:
//===========================
// Create the frames_storage and initialize it by 0
inline struct FrameInfo** create_frames_storage(int numOfFrames)
{
f01086f0:	55                   	push   %ebp
f01086f1:	89 e5                	mov    %esp,%ebp
f01086f3:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("create_frames_storage is not implemented yet");
f01086f6:	83 ec 04             	sub    $0x4,%esp
f01086f9:	68 88 4c 12 f0       	push   $0xf0124c88
f01086fe:	6a 5c                	push   $0x5c
f0108700:	68 f8 4b 12 f0       	push   $0xf0124bf8
f0108705:	e8 10 7c ff ff       	call   f010031a <_panic>

f010870a <createSharedObject>:

//=========================
// [5] Create Share Object:
//=========================
int createSharedObject(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010870a:	55                   	push   %ebp
f010870b:	89 e5                	mov    %esp,%ebp
f010870d:	83 ec 18             	sub    $0x18,%esp
f0108710:	8b 45 14             	mov    0x14(%ebp),%eax
f0108713:	88 45 f4             	mov    %al,-0xc(%ebp)
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("createSharedObject is not implemented yet");
f0108716:	83 ec 04             	sub    $0x4,%esp
f0108719:	68 b8 4c 12 f0       	push   $0xf0124cb8
f010871e:	6a 68                	push   $0x68
f0108720:	68 f8 4b 12 f0       	push   $0xf0124bf8
f0108725:	e8 f0 7b ff ff       	call   f010031a <_panic>

f010872a <getSizeOfSharedObject>:

//==============================
// [6] Get Size of Share Object:
//==============================
int getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010872a:	55                   	push   %ebp
f010872b:	89 e5                	mov    %esp,%ebp
f010872d:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = get_share(ownerID, shareName);
f0108730:	83 ec 08             	sub    $0x8,%esp
f0108733:	ff 75 0c             	pushl  0xc(%ebp)
f0108736:	ff 75 08             	pushl  0x8(%ebp)
f0108739:	e8 7e ff ff ff       	call   f01086bc <get_share>
f010873e:	83 c4 10             	add    $0x10,%esp
f0108741:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0108744:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108748:	75 07                	jne    f0108751 <getSizeOfSharedObject+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f010874a:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f010874f:	eb 06                	jmp    f0108757 <getSizeOfSharedObject+0x2d>
	else
		return ptr_share->size;
f0108751:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108754:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0108757:	c9                   	leave  
f0108758:	c3                   	ret    

f0108759 <getSharedObject>:

//======================
// [7] Get Share Object:
//======================
int getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f0108759:	55                   	push   %ebp
f010875a:	89 e5                	mov    %esp,%ebp
f010875c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("getSharedObject is not implemented yet");
f010875f:	83 ec 04             	sub    $0x4,%esp
f0108762:	68 e4 4c 12 f0       	push   $0xf0124ce4
f0108767:	68 89 00 00 00       	push   $0x89
f010876c:	68 f8 4b 12 f0       	push   $0xf0124bf8
f0108771:	e8 a4 7b ff ff       	call   f010031a <_panic>

f0108776 <freeSharedObject>:

//===================
// Free Share Object:
//===================
int freeSharedObject(int32 sharedObjectID, void *startVA)
{
f0108776:	55                   	push   %ebp
f0108777:	89 e5                	mov    %esp,%ebp
f0108779:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] BONUS
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("freeSharedObject is not implemented yet");
f010877c:	83 ec 04             	sub    $0x4,%esp
f010877f:	68 0c 4d 12 f0       	push   $0xf0124d0c
f0108784:	68 9a 00 00 00       	push   $0x9a
f0108789:	68 f8 4b 12 f0       	push   $0xf0124bf8
f010878e:	e8 87 7b ff ff       	call   f010031a <_panic>

f0108793 <initialize_kheap_dynamic_allocator>:
//Remember: call the initialize_dynamic_allocator(..) to complete the initialization
//Return:
//	On success: 0
//	Otherwise (if no memory OR initial size exceed the given limit): E_NO_MEM
int initialize_kheap_dynamic_allocator(uint32 daStart, uint32 initSizeToAllocate, uint32 daLimit)
{
f0108793:	55                   	push   %ebp
f0108794:	89 e5                	mov    %esp,%ebp
f0108796:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] initialize_kheap_dynamic_allocator
	// Write your code here, remove the panic and write your code
	panic("initialize_kheap_dynamic_allocator() is not implemented yet...!!");
f0108799:	83 ec 04             	sub    $0x4,%esp
f010879c:	68 34 4d 12 f0       	push   $0xf0124d34
f01087a1:	6a 11                	push   $0x11
f01087a3:	68 75 4d 12 f0       	push   $0xf0124d75
f01087a8:	e8 6d 7b ff ff       	call   f010031a <_panic>

f01087ad <sbrk>:
}

void* sbrk(int numOfPages)
{
f01087ad:	55                   	push   %ebp
f01087ae:	89 e5                	mov    %esp,%ebp
	 * 	1) Allocating additional pages for a kernel dynamic allocator will fail if the free frames are exhausted
	 * 		or the break exceed the limit of the dynamic allocator. If sbrk fails, kernel should panic(...)
	 */

	//MS2: COMMENT THIS LINE BEFORE START CODING====
	return (void*)-1 ;
f01087b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	//====================================================

	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("sbrk() is not implemented yet...!!");
}
f01087b5:	5d                   	pop    %ebp
f01087b6:	c3                   	ret    

f01087b7 <kmalloc>:


void* kmalloc(unsigned int size)
{
f01087b7:	55                   	push   %ebp
f01087b8:	89 e5                	mov    %esp,%ebp
f01087ba:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f01087bd:	83 ec 04             	sub    $0x4,%esp
f01087c0:	68 88 4d 12 f0       	push   $0xf0124d88
f01087c5:	6a 2e                	push   $0x2e
f01087c7:	68 75 4d 12 f0       	push   $0xf0124d75
f01087cc:	e8 74 7c ff ff       	call   f0100445 <_panic_into_prompt>

f01087d1 <kfree>:
	// use "isKHeapPlacementStrategyFIRSTFIT() ..." functions to check the current strategy

}

void kfree(void* virtual_address)
{
f01087d1:	55                   	push   %ebp
f01087d2:	89 e5                	mov    %esp,%ebp
f01087d4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] Implement this function
	// Write your code here, remove the panic and write your code
	panic("kfree() is not implemented yet...!!");
f01087d7:	83 ec 04             	sub    $0x4,%esp
f01087da:	68 b0 4d 12 f0       	push   $0xf0124db0
f01087df:	6a 38                	push   $0x38
f01087e1:	68 75 4d 12 f0       	push   $0xf0124d75
f01087e6:	e8 2f 7b ff ff       	call   f010031a <_panic>

f01087eb <kheap_virtual_address>:
	//refer to the project presentation and documentation for details

}

unsigned int kheap_virtual_address(unsigned int physical_address)
{
f01087eb:	55                   	push   %ebp
f01087ec:	89 e5                	mov    %esp,%ebp
f01087ee:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_virtual_address
	// Write your code here, remove the panic and write your code
	panic("kheap_virtual_address() is not implemented yet...!!");
f01087f1:	83 ec 04             	sub    $0x4,%esp
f01087f4:	68 d4 4d 12 f0       	push   $0xf0124dd4
f01087f9:	6a 43                	push   $0x43
f01087fb:	68 75 4d 12 f0       	push   $0xf0124d75
f0108800:	e8 15 7b ff ff       	call   f010031a <_panic>

f0108805 <kheap_physical_address>:

	//EFFICIENT IMPLEMENTATION ~O(1) IS REQUIRED ==================
}

unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0108805:	55                   	push   %ebp
f0108806:	89 e5                	mov    %esp,%ebp
f0108808:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS2] [KERNEL HEAP] kheap_physical_address
	// Write your code here, remove the panic and write your code
	panic("kheap_physical_address() is not implemented yet...!!");
f010880b:	83 ec 04             	sub    $0x4,%esp
f010880e:	68 08 4e 12 f0       	push   $0xf0124e08
f0108813:	6a 4f                	push   $0x4f
f0108815:	68 75 4d 12 f0       	push   $0xf0124d75
f010881a:	e8 fb 7a ff ff       	call   f010031a <_panic>

f010881f <krealloc>:

//	A call with virtual_address = null is equivalent to kmalloc().
//	A call with new_size = zero is equivalent to kfree().

void *krealloc(void *virtual_address, uint32 new_size)
{
f010881f:	55                   	push   %ebp
f0108820:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2 BONUS2] Kernel Heap Realloc
	// Write your code here, remove the panic and write your code
	return NULL;
f0108822:	b8 00 00 00 00       	mov    $0x0,%eax
	panic("krealloc() is not implemented yet...!!");
}
f0108827:	5d                   	pop    %ebp
f0108828:	c3                   	ret    

f0108829 <pt_set_page_permissions>:
 */
#include "memory_manager.h"

/*[2.1] PAGE TABLE ENTRIES MANIPULATION */
inline void pt_set_page_permissions(uint32* page_directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0108829:	55                   	push   %ebp
f010882a:	89 e5                	mov    %esp,%ebp
f010882c:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010882f:	83 ec 04             	sub    $0x4,%esp
f0108832:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108835:	50                   	push   %eax
f0108836:	ff 75 0c             	pushl  0xc(%ebp)
f0108839:	ff 75 08             	pushl  0x8(%ebp)
f010883c:	e8 cd f8 ff ff       	call   f010810e <get_page_table>
f0108841:	83 c4 10             	add    $0x10,%esp
f0108844:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108847:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010884a:	85 c0                	test   %eax,%eax
f010884c:	74 64                	je     f01088b2 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f010884e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108851:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108854:	c1 ea 0c             	shr    $0xc,%edx
f0108857:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010885d:	c1 e2 02             	shl    $0x2,%edx
f0108860:	01 c2                	add    %eax,%edx
f0108862:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108865:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108868:	c1 e9 0c             	shr    $0xc,%ecx
f010886b:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0108871:	c1 e1 02             	shl    $0x2,%ecx
f0108874:	01 c8                	add    %ecx,%eax
f0108876:	8b 00                	mov    (%eax),%eax
f0108878:	0b 45 10             	or     0x10(%ebp),%eax
f010887b:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f010887d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108880:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108883:	c1 ea 0c             	shr    $0xc,%edx
f0108886:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010888c:	c1 e2 02             	shl    $0x2,%edx
f010888f:	01 d0                	add    %edx,%eax
f0108891:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108894:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0108897:	c1 e9 0c             	shr    $0xc,%ecx
f010889a:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f01088a0:	c1 e1 02             	shl    $0x2,%ecx
f01088a3:	01 ca                	add    %ecx,%edx
f01088a5:	8b 12                	mov    (%edx),%edx
f01088a7:	8b 4d 14             	mov    0x14(%ebp),%ecx
f01088aa:	f7 d1                	not    %ecx
f01088ac:	21 ca                	and    %ecx,%edx
f01088ae:	89 10                	mov    %edx,(%eax)
f01088b0:	eb 27                	jmp    f01088d9 <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f01088b2:	83 ec 08             	sub    $0x8,%esp
f01088b5:	ff 75 0c             	pushl  0xc(%ebp)
f01088b8:	68 40 4e 12 f0       	push   $0xf0124e40
f01088bd:	e8 aa 86 ff ff       	call   f0100f6c <cprintf>
f01088c2:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f01088c5:	83 ec 04             	sub    $0x4,%esp
f01088c8:	68 68 4e 12 f0       	push   $0xf0124e68
f01088cd:	6a 1c                	push   $0x1c
f01088cf:	68 dc 4e 12 f0       	push   $0xf0124edc
f01088d4:	e8 41 7a ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01088d9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088dc:	83 ec 08             	sub    $0x8,%esp
f01088df:	50                   	push   %eax
f01088e0:	6a 00                	push   $0x0
f01088e2:	e8 f1 f1 ff ff       	call   f0107ad8 <tlb_invalidate>
f01088e7:	83 c4 10             	add    $0x10,%esp
}
f01088ea:	90                   	nop
f01088eb:	c9                   	leave  
f01088ec:	c3                   	ret    

f01088ed <pt_get_page_permissions>:

inline int pt_get_page_permissions(uint32* page_directory, uint32 virtual_address )
{
f01088ed:	55                   	push   %ebp
f01088ee:	89 e5                	mov    %esp,%ebp
f01088f0:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f01088f3:	83 ec 04             	sub    $0x4,%esp
f01088f6:	8d 45 f0             	lea    -0x10(%ebp),%eax
f01088f9:	50                   	push   %eax
f01088fa:	ff 75 0c             	pushl  0xc(%ebp)
f01088fd:	ff 75 08             	pushl  0x8(%ebp)
f0108900:	e8 09 f8 ff ff       	call   f010810e <get_page_table>
f0108905:	83 c4 10             	add    $0x10,%esp
f0108908:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, return the permissions
	if (ptr_page_table != NULL)
f010890b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010890e:	85 c0                	test   %eax,%eax
f0108910:	74 1d                	je     f010892f <pt_get_page_permissions+0x42>
	{
		//cprintf("va=%x perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
		return (ptr_page_table[PTX(virtual_address)] & 0x00000FFF);
f0108912:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108915:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108918:	c1 ea 0c             	shr    $0xc,%edx
f010891b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108921:	c1 e2 02             	shl    $0x2,%edx
f0108924:	01 d0                	add    %edx,%eax
f0108926:	8b 00                	mov    (%eax),%eax
f0108928:	25 ff 0f 00 00       	and    $0xfff,%eax
f010892d:	eb 05                	jmp    f0108934 <pt_get_page_permissions+0x47>
	}
	//[3] Else, return -1
	else
	{
		//cprintf("va=%x not exist and has no page table\n", virtual_address);
		return -1;
f010892f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	}
}
f0108934:	c9                   	leave  
f0108935:	c3                   	ret    

f0108936 <pt_clear_page_table_entry>:

inline void pt_clear_page_table_entry(uint32* page_directory, uint32 virtual_address)
{
f0108936:	55                   	push   %ebp
f0108937:	89 e5                	mov    %esp,%ebp
f0108939:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(page_directory, virtual_address, &ptr_page_table);
f010893c:	83 ec 04             	sub    $0x4,%esp
f010893f:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0108942:	50                   	push   %eax
f0108943:	ff 75 0c             	pushl  0xc(%ebp)
f0108946:	ff 75 08             	pushl  0x8(%ebp)
f0108949:	e8 c0 f7 ff ff       	call   f010810e <get_page_table>
f010894e:	83 c4 10             	add    $0x10,%esp
f0108951:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0108954:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108957:	85 c0                	test   %eax,%eax
f0108959:	74 46                	je     f01089a1 <pt_clear_page_table_entry+0x6b>
	{
		cprintf("va=%x before clearing has perm = %x\n", virtual_address, ptr_page_table[PTX(virtual_address)]);
f010895b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010895e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108961:	c1 ea 0c             	shr    $0xc,%edx
f0108964:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010896a:	c1 e2 02             	shl    $0x2,%edx
f010896d:	01 d0                	add    %edx,%eax
f010896f:	8b 00                	mov    (%eax),%eax
f0108971:	83 ec 04             	sub    $0x4,%esp
f0108974:	50                   	push   %eax
f0108975:	ff 75 0c             	pushl  0xc(%ebp)
f0108978:	68 f8 4e 12 f0       	push   $0xf0124ef8
f010897d:	e8 ea 85 ff ff       	call   f0100f6c <cprintf>
f0108982:	83 c4 10             	add    $0x10,%esp
		ptr_page_table[PTX(virtual_address)] = 0;
f0108985:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108988:	8b 55 0c             	mov    0xc(%ebp),%edx
f010898b:	c1 ea 0c             	shr    $0xc,%edx
f010898e:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0108994:	c1 e2 02             	shl    $0x2,%edx
f0108997:	01 d0                	add    %edx,%eax
f0108999:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010899f:	eb 14                	jmp    f01089b5 <pt_clear_page_table_entry+0x7f>
	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_clear_page_table_entry() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f01089a1:	83 ec 04             	sub    $0x4,%esp
f01089a4:	68 20 4f 12 f0       	push   $0xf0124f20
f01089a9:	6a 47                	push   $0x47
f01089ab:	68 dc 4e 12 f0       	push   $0xf0124edc
f01089b0:	e8 65 79 ff ff       	call   f010031a <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f01089b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01089b8:	83 ec 08             	sub    $0x8,%esp
f01089bb:	50                   	push   %eax
f01089bc:	6a 00                	push   $0x0
f01089be:	e8 15 f1 ff ff       	call   f0107ad8 <tlb_invalidate>
f01089c3:	83 c4 10             	add    $0x10,%esp
}
f01089c6:	90                   	nop
f01089c7:	c9                   	leave  
f01089c8:	c3                   	ret    

f01089c9 <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* page_directory, uint32 virtual_address)
{
f01089c9:	55                   	push   %ebp
f01089ca:	89 e5                	mov    %esp,%ebp
	return ( (page_directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f01089cc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01089cf:	c1 e8 16             	shr    $0x16,%eax
f01089d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01089d9:	8b 45 08             	mov    0x8(%ebp),%eax
f01089dc:	01 d0                	add    %edx,%eax
f01089de:	8b 00                	mov    (%eax),%eax
f01089e0:	83 e0 20             	and    $0x20,%eax
f01089e3:	85 c0                	test   %eax,%eax
f01089e5:	0f 95 c0             	setne  %al
f01089e8:	0f b6 c0             	movzbl %al,%eax
}
f01089eb:	5d                   	pop    %ebp
f01089ec:	c3                   	ret    

f01089ed <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* page_directory, uint32 virtual_address)
{
f01089ed:	55                   	push   %ebp
f01089ee:	89 e5                	mov    %esp,%ebp
f01089f0:	83 ec 08             	sub    $0x8,%esp
	page_directory[PDX(virtual_address)] &= (~PERM_USED);
f01089f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01089f6:	c1 e8 16             	shr    $0x16,%eax
f01089f9:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108a00:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a03:	01 d0                	add    %edx,%eax
f0108a05:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108a08:	c1 ea 16             	shr    $0x16,%edx
f0108a0b:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0108a12:	8b 55 08             	mov    0x8(%ebp),%edx
f0108a15:	01 ca                	add    %ecx,%edx
f0108a17:	8b 12                	mov    (%edx),%edx
f0108a19:	83 e2 df             	and    $0xffffffdf,%edx
f0108a1c:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0108a1e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a21:	83 ec 08             	sub    $0x8,%esp
f0108a24:	50                   	push   %eax
f0108a25:	6a 00                	push   $0x0
f0108a27:	e8 ac f0 ff ff       	call   f0107ad8 <tlb_invalidate>
f0108a2c:	83 c4 10             	add    $0x10,%esp
}
f0108a2f:	90                   	nop
f0108a30:	c9                   	leave  
f0108a31:	c3                   	ret    

f0108a32 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* page_directory, uint32 virtual_address)
{
f0108a32:	55                   	push   %ebp
f0108a33:	89 e5                	mov    %esp,%ebp
f0108a35:	83 ec 10             	sub    $0x10,%esp
	page_directory[PDX(virtual_address)] = 0 ;
f0108a38:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108a3b:	c1 e8 16             	shr    $0x16,%eax
f0108a3e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108a45:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a48:	01 d0                	add    %edx,%eax
f0108a4a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0108a50:	0f 20 d8             	mov    %cr3,%eax
f0108a53:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0108a56:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108a59:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f0108a5c:	90                   	nop
f0108a5d:	c9                   	leave  
f0108a5e:	c3                   	ret    

f0108a5f <env_page_ws_get_size>:
		}
	}
}
#else
inline uint32 env_page_ws_get_size(struct Env *e)
{
f0108a5f:	55                   	push   %ebp
f0108a60:	89 e5                	mov    %esp,%ebp
f0108a62:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0108a65:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0108a6c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<e->page_WS_max_size; i++) if(e->ptr_pageWorkingSet[i].empty == 0) counter++;
f0108a73:	eb 22                	jmp    f0108a97 <env_page_ws_get_size+0x38>
f0108a75:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108a78:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0108a7b:	89 d0                	mov    %edx,%eax
f0108a7d:	01 c0                	add    %eax,%eax
f0108a7f:	01 d0                	add    %edx,%eax
f0108a81:	c1 e0 03             	shl    $0x3,%eax
f0108a84:	01 c8                	add    %ecx,%eax
f0108a86:	05 8c 00 00 00       	add    $0x8c,%eax
f0108a8b:	8a 00                	mov    (%eax),%al
f0108a8d:	84 c0                	test   %al,%al
f0108a8f:	75 03                	jne    f0108a94 <env_page_ws_get_size+0x35>
f0108a91:	ff 45 f8             	incl   -0x8(%ebp)
f0108a94:	ff 45 fc             	incl   -0x4(%ebp)
f0108a97:	8b 45 08             	mov    0x8(%ebp),%eax
f0108a9a:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108aa0:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0108aa3:	39 c2                	cmp    %eax,%edx
f0108aa5:	77 ce                	ja     f0108a75 <env_page_ws_get_size+0x16>
	return counter;
f0108aa7:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0108aaa:	c9                   	leave  
f0108aab:	c3                   	ret    

f0108aac <env_page_ws_invalidate>:

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0108aac:	55                   	push   %ebp
f0108aad:	89 e5                	mov    %esp,%ebp
f0108aaf:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f0108ab2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<e->page_WS_max_size; i++)
f0108ab9:	eb 4e                	jmp    f0108b09 <env_page_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->ptr_pageWorkingSet[i].virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f0108abb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108abe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ac1:	89 d0                	mov    %edx,%eax
f0108ac3:	01 c0                	add    %eax,%eax
f0108ac5:	01 d0                	add    %edx,%eax
f0108ac7:	c1 e0 03             	shl    $0x3,%eax
f0108aca:	01 c8                	add    %ecx,%eax
f0108acc:	05 88 00 00 00       	add    $0x88,%eax
f0108ad1:	8b 00                	mov    (%eax),%eax
f0108ad3:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108ad6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108ad9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108ade:	89 c2                	mov    %eax,%edx
f0108ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108ae3:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108ae6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108ae9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108aee:	39 c2                	cmp    %eax,%edx
f0108af0:	75 14                	jne    f0108b06 <env_page_ws_invalidate+0x5a>
		{
			env_page_ws_clear_entry(e, i);
f0108af2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108af5:	83 ec 08             	sub    $0x8,%esp
f0108af8:	50                   	push   %eax
f0108af9:	ff 75 08             	pushl  0x8(%ebp)
f0108afc:	e8 ce 00 00 00       	call   f0108bcf <env_page_ws_clear_entry>
f0108b01:	83 c4 10             	add    $0x10,%esp
			break;
f0108b04:	eb 13                	jmp    f0108b19 <env_page_ws_invalidate+0x6d>
}

inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<e->page_WS_max_size; i++)
f0108b06:	ff 45 f4             	incl   -0xc(%ebp)
f0108b09:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b0c:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0108b12:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b15:	39 c2                	cmp    %eax,%edx
f0108b17:	77 a2                	ja     f0108abb <env_page_ws_invalidate+0xf>
		{
			env_page_ws_clear_entry(e, i);
			break;
		}
	}
}
f0108b19:	90                   	nop
f0108b1a:	c9                   	leave  
f0108b1b:	c3                   	ret    

f0108b1c <env_page_ws_set_entry>:

inline void env_page_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f0108b1c:	55                   	push   %ebp
f0108b1d:	89 e5                	mov    %esp,%ebp
f0108b1f:	53                   	push   %ebx
f0108b20:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < e->page_WS_max_size);
f0108b23:	8b 45 08             	mov    0x8(%ebp),%eax
f0108b26:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108b2c:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108b2f:	77 19                	ja     f0108b4a <env_page_ws_set_entry+0x2e>
f0108b31:	68 98 4f 12 f0       	push   $0xf0124f98
f0108b36:	68 ce 4f 12 f0       	push   $0xf0124fce
f0108b3b:	68 a7 00 00 00       	push   $0xa7
f0108b40:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0108b45:	e8 d0 77 ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f0108b4a:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0108b51:	76 19                	jbe    f0108b6c <env_page_ws_set_entry+0x50>
f0108b53:	68 04 50 12 f0       	push   $0xf0125004
f0108b58:	68 ce 4f 12 f0       	push   $0xf0124fce
f0108b5d:	68 a8 00 00 00       	push   $0xa8
f0108b62:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0108b67:	e8 ae 77 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f0108b6c:	8b 45 10             	mov    0x10(%ebp),%eax
f0108b6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b75:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108b7a:	89 c1                	mov    %eax,%ecx
f0108b7c:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0108b7f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b82:	89 d0                	mov    %edx,%eax
f0108b84:	01 c0                	add    %eax,%eax
f0108b86:	01 d0                	add    %edx,%eax
f0108b88:	c1 e0 03             	shl    $0x3,%eax
f0108b8b:	01 d8                	add    %ebx,%eax
f0108b8d:	05 88 00 00 00       	add    $0x88,%eax
f0108b92:	89 08                	mov    %ecx,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 0;
f0108b94:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108b97:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108b9a:	89 d0                	mov    %edx,%eax
f0108b9c:	01 c0                	add    %eax,%eax
f0108b9e:	01 d0                	add    %edx,%eax
f0108ba0:	c1 e0 03             	shl    $0x3,%eax
f0108ba3:	01 c8                	add    %ecx,%eax
f0108ba5:	05 8c 00 00 00       	add    $0x8c,%eax
f0108baa:	c6 00 00             	movb   $0x0,(%eax)

	e->ptr_pageWorkingSet[entry_index].time_stamp = 0x80000000;
f0108bad:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108bb0:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108bb3:	89 d0                	mov    %edx,%eax
f0108bb5:	01 c0                	add    %eax,%eax
f0108bb7:	01 d0                	add    %edx,%eax
f0108bb9:	c1 e0 03             	shl    $0x3,%eax
f0108bbc:	01 c8                	add    %ecx,%eax
f0108bbe:	05 90 00 00 00       	add    $0x90,%eax
f0108bc3:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	//e->ptr_pageWorkingSet[entry_index].time_stamp = time;
	return;
f0108bc9:	90                   	nop
}
f0108bca:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108bcd:	c9                   	leave  
f0108bce:	c3                   	ret    

f0108bcf <env_page_ws_clear_entry>:

inline void env_page_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0108bcf:	55                   	push   %ebp
f0108bd0:	89 e5                	mov    %esp,%ebp
f0108bd2:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108bd5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108bd8:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108bde:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108be1:	77 19                	ja     f0108bfc <env_page_ws_clear_entry+0x2d>
f0108be3:	68 38 50 12 f0       	push   $0xf0125038
f0108be8:	68 ce 4f 12 f0       	push   $0xf0124fce
f0108bed:	68 b3 00 00 00       	push   $0xb3
f0108bf2:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0108bf7:	e8 1e 77 ff ff       	call   f010031a <_panic>
	e->ptr_pageWorkingSet[entry_index].virtual_address = 0;
f0108bfc:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108bff:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c02:	89 d0                	mov    %edx,%eax
f0108c04:	01 c0                	add    %eax,%eax
f0108c06:	01 d0                	add    %edx,%eax
f0108c08:	c1 e0 03             	shl    $0x3,%eax
f0108c0b:	01 c8                	add    %ecx,%eax
f0108c0d:	05 88 00 00 00       	add    $0x88,%eax
f0108c12:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->ptr_pageWorkingSet[entry_index].empty = 1;
f0108c18:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c1b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c1e:	89 d0                	mov    %edx,%eax
f0108c20:	01 c0                	add    %eax,%eax
f0108c22:	01 d0                	add    %edx,%eax
f0108c24:	c1 e0 03             	shl    $0x3,%eax
f0108c27:	01 c8                	add    %ecx,%eax
f0108c29:	05 8c 00 00 00       	add    $0x8c,%eax
f0108c2e:	c6 00 01             	movb   $0x1,(%eax)
	e->ptr_pageWorkingSet[entry_index].time_stamp = 0;
f0108c31:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c34:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c37:	89 d0                	mov    %edx,%eax
f0108c39:	01 c0                	add    %eax,%eax
f0108c3b:	01 d0                	add    %edx,%eax
f0108c3d:	c1 e0 03             	shl    $0x3,%eax
f0108c40:	01 c8                	add    %ecx,%eax
f0108c42:	05 90 00 00 00       	add    $0x90,%eax
f0108c47:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f0108c4d:	90                   	nop
f0108c4e:	c9                   	leave  
f0108c4f:	c3                   	ret    

f0108c50 <env_page_ws_get_virtual_address>:

inline uint32 env_page_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f0108c50:	55                   	push   %ebp
f0108c51:	89 e5                	mov    %esp,%ebp
f0108c53:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108c56:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c59:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108c5f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108c62:	77 19                	ja     f0108c7d <env_page_ws_get_virtual_address+0x2d>
f0108c64:	68 38 50 12 f0       	push   $0xf0125038
f0108c69:	68 ce 4f 12 f0       	push   $0xf0124fce
f0108c6e:	68 bb 00 00 00       	push   $0xbb
f0108c73:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0108c78:	e8 9d 76 ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->ptr_pageWorkingSet[entry_index].virtual_address,PAGE_SIZE);
f0108c7d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108c80:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108c83:	89 d0                	mov    %edx,%eax
f0108c85:	01 c0                	add    %eax,%eax
f0108c87:	01 d0                	add    %edx,%eax
f0108c89:	c1 e0 03             	shl    $0x3,%eax
f0108c8c:	01 c8                	add    %ecx,%eax
f0108c8e:	05 88 00 00 00       	add    $0x88,%eax
f0108c93:	8b 00                	mov    (%eax),%eax
f0108c95:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c9b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f0108ca0:	c9                   	leave  
f0108ca1:	c3                   	ret    

f0108ca2 <env_page_ws_get_time_stamp>:

inline uint32 env_page_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0108ca2:	55                   	push   %ebp
f0108ca3:	89 e5                	mov    %esp,%ebp
f0108ca5:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < (e->page_WS_max_size));
f0108ca8:	8b 45 08             	mov    0x8(%ebp),%eax
f0108cab:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108cb1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0108cb4:	77 19                	ja     f0108ccf <env_page_ws_get_time_stamp+0x2d>
f0108cb6:	68 38 50 12 f0       	push   $0xf0125038
f0108cbb:	68 ce 4f 12 f0       	push   $0xf0124fce
f0108cc0:	68 c1 00 00 00       	push   $0xc1
f0108cc5:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0108cca:	e8 4b 76 ff ff       	call   f010031a <_panic>
	return e->ptr_pageWorkingSet[entry_index].time_stamp;
f0108ccf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108cd2:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108cd5:	89 d0                	mov    %edx,%eax
f0108cd7:	01 c0                	add    %eax,%eax
f0108cd9:	01 d0                	add    %edx,%eax
f0108cdb:	c1 e0 03             	shl    $0x3,%eax
f0108cde:	01 c8                	add    %ecx,%eax
f0108ce0:	05 90 00 00 00       	add    $0x90,%eax
f0108ce5:	8b 00                	mov    (%eax),%eax
}
f0108ce7:	c9                   	leave  
f0108ce8:	c3                   	ret    

f0108ce9 <env_page_ws_is_entry_empty>:

inline uint32 env_page_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0108ce9:	55                   	push   %ebp
f0108cea:	89 e5                	mov    %esp,%ebp
	return e->ptr_pageWorkingSet[entry_index].empty;
f0108cec:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108cef:	8b 55 0c             	mov    0xc(%ebp),%edx
f0108cf2:	89 d0                	mov    %edx,%eax
f0108cf4:	01 c0                	add    %eax,%eax
f0108cf6:	01 d0                	add    %edx,%eax
f0108cf8:	c1 e0 03             	shl    $0x3,%eax
f0108cfb:	01 c8                	add    %ecx,%eax
f0108cfd:	05 8c 00 00 00       	add    $0x8c,%eax
f0108d02:	8a 00                	mov    (%eax),%al
f0108d04:	0f b6 c0             	movzbl %al,%eax
}
f0108d07:	5d                   	pop    %ebp
f0108d08:	c3                   	ret    

f0108d09 <env_page_ws_print>:

void env_page_ws_print(struct Env *e)
{
f0108d09:	55                   	push   %ebp
f0108d0a:	89 e5                	mov    %esp,%ebp
f0108d0c:	53                   	push   %ebx
f0108d0d:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0108d10:	83 ec 0c             	sub    $0xc,%esp
f0108d13:	6a 02                	push   $0x2
f0108d15:	e8 55 56 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f0108d1a:	83 c4 10             	add    $0x10,%esp
f0108d1d:	85 c0                	test   %eax,%eax
f0108d1f:	0f 84 fe 00 00 00    	je     f0108e23 <env_page_ws_print+0x11a>
	{
		int i = 0;
f0108d25:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f0108d2c:	83 ec 0c             	sub    $0xc,%esp
f0108d2f:	68 70 50 12 f0       	push   $0xf0125070
f0108d34:	e8 33 82 ff ff       	call   f0100f6c <cprintf>
f0108d39:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0108d3c:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d3f:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f0108d45:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108d48:	eb 2c                	jmp    f0108d76 <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0108d4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d4d:	8b 10                	mov    (%eax),%edx
f0108d4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d52:	8d 48 01             	lea    0x1(%eax),%ecx
f0108d55:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0108d58:	83 ec 04             	sub    $0x4,%esp
f0108d5b:	52                   	push   %edx
f0108d5c:	50                   	push   %eax
f0108d5d:	68 8a 50 12 f0       	push   $0xf012508a
f0108d62:	e8 05 82 ff ff       	call   f0100f6c <cprintf>
f0108d67:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f0108d6a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d6d:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0108d73:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108d76:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108d7a:	74 08                	je     f0108d84 <env_page_ws_print+0x7b>
f0108d7c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d7f:	8b 40 10             	mov    0x10(%eax),%eax
f0108d82:	eb 05                	jmp    f0108d89 <env_page_ws_print+0x80>
f0108d84:	b8 00 00 00 00       	mov    $0x0,%eax
f0108d89:	8b 55 08             	mov    0x8(%ebp),%edx
f0108d8c:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f0108d92:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d95:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0108d9b:	85 c0                	test   %eax,%eax
f0108d9d:	75 ab                	jne    f0108d4a <env_page_ws_print+0x41>
f0108d9f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108da3:	75 a5                	jne    f0108d4a <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f0108da5:	83 ec 0c             	sub    $0xc,%esp
f0108da8:	68 92 50 12 f0       	push   $0xf0125092
f0108dad:	e8 ba 81 ff ff       	call   f0100f6c <cprintf>
f0108db2:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0108db5:	8b 45 08             	mov    0x8(%ebp),%eax
f0108db8:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f0108dbe:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108dc1:	eb 2c                	jmp    f0108def <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f0108dc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108dc6:	8b 10                	mov    (%eax),%edx
f0108dc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108dcb:	8d 48 01             	lea    0x1(%eax),%ecx
f0108dce:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0108dd1:	83 ec 04             	sub    $0x4,%esp
f0108dd4:	52                   	push   %edx
f0108dd5:	50                   	push   %eax
f0108dd6:	68 8a 50 12 f0       	push   $0xf012508a
f0108ddb:	e8 8c 81 ff ff       	call   f0100f6c <cprintf>
f0108de0:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f0108de3:	8b 45 08             	mov    0x8(%ebp),%eax
f0108de6:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0108dec:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108def:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108df3:	74 08                	je     f0108dfd <env_page_ws_print+0xf4>
f0108df5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108df8:	8b 40 10             	mov    0x10(%eax),%eax
f0108dfb:	eb 05                	jmp    f0108e02 <env_page_ws_print+0xf9>
f0108dfd:	b8 00 00 00 00       	mov    $0x0,%eax
f0108e02:	8b 55 08             	mov    0x8(%ebp),%edx
f0108e05:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f0108e0b:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e0e:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0108e14:	85 c0                	test   %eax,%eax
f0108e16:	75 ab                	jne    f0108dc3 <env_page_ws_print+0xba>
f0108e18:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108e1c:	75 a5                	jne    f0108dc3 <env_page_ws_print+0xba>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f0108e1e:	e9 9f 01 00 00       	jmp    f0108fc2 <env_page_ws_print+0x2b9>
		}
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
f0108e23:	83 ec 0c             	sub    $0xc,%esp
f0108e26:	68 ad 50 12 f0       	push   $0xf01250ad
f0108e2b:	e8 3c 81 ff ff       	call   f0100f6c <cprintf>
f0108e30:	83 c4 10             	add    $0x10,%esp
		for(i=0; i< (e->page_WS_max_size); i++ )
f0108e33:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0108e3a:	e9 71 01 00 00       	jmp    f0108fb0 <env_page_ws_print+0x2a7>
		{
			if (e->ptr_pageWorkingSet[i].empty)
f0108e3f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108e42:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108e45:	89 d0                	mov    %edx,%eax
f0108e47:	01 c0                	add    %eax,%eax
f0108e49:	01 d0                	add    %edx,%eax
f0108e4b:	c1 e0 03             	shl    $0x3,%eax
f0108e4e:	01 c8                	add    %ecx,%eax
f0108e50:	05 8c 00 00 00       	add    $0x8c,%eax
f0108e55:	8a 00                	mov    (%eax),%al
f0108e57:	84 c0                	test   %al,%al
f0108e59:	74 43                	je     f0108e9e <env_page_ws_print+0x195>
			{
				cprintf("EMPTY LOCATION");
f0108e5b:	83 ec 0c             	sub    $0xc,%esp
f0108e5e:	68 b7 50 12 f0       	push   $0xf01250b7
f0108e63:	e8 04 81 ff ff       	call   f0100f6c <cprintf>
f0108e68:	83 c4 10             	add    $0x10,%esp
				if(i==e->page_last_WS_index )
f0108e6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0108e6e:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0108e74:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0108e77:	75 10                	jne    f0108e89 <env_page_ws_print+0x180>
				{
					cprintf("		<--");
f0108e79:	83 ec 0c             	sub    $0xc,%esp
f0108e7c:	68 c6 50 12 f0       	push   $0xf01250c6
f0108e81:	e8 e6 80 ff ff       	call   f0100f6c <cprintf>
f0108e86:	83 c4 10             	add    $0x10,%esp
				}
				cprintf("\n");
f0108e89:	83 ec 0c             	sub    $0xc,%esp
f0108e8c:	68 cc 50 12 f0       	push   $0xf01250cc
f0108e91:	e8 d6 80 ff ff       	call   f0100f6c <cprintf>
f0108e96:	83 c4 10             	add    $0x10,%esp
				continue;
f0108e99:	e9 0f 01 00 00       	jmp    f0108fad <env_page_ws_print+0x2a4>
			}
			uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f0108e9e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108ea1:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108ea4:	89 d0                	mov    %edx,%eax
f0108ea6:	01 c0                	add    %eax,%eax
f0108ea8:	01 d0                	add    %edx,%eax
f0108eaa:	c1 e0 03             	shl    $0x3,%eax
f0108ead:	01 c8                	add    %ecx,%eax
f0108eaf:	05 88 00 00 00       	add    $0x88,%eax
f0108eb4:	8b 00                	mov    (%eax),%eax
f0108eb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 time_stamp = e->ptr_pageWorkingSet[i].time_stamp;
f0108eb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108ebc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108ebf:	89 d0                	mov    %edx,%eax
f0108ec1:	01 c0                	add    %eax,%eax
f0108ec3:	01 d0                	add    %edx,%eax
f0108ec5:	c1 e0 03             	shl    $0x3,%eax
f0108ec8:	01 c8                	add    %ecx,%eax
f0108eca:	05 90 00 00 00       	add    $0x90,%eax
f0108ecf:	8b 00                	mov    (%eax),%eax
f0108ed1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f0108ed4:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ed7:	8b 40 64             	mov    0x64(%eax),%eax
f0108eda:	83 ec 08             	sub    $0x8,%esp
f0108edd:	ff 75 e8             	pushl  -0x18(%ebp)
f0108ee0:	50                   	push   %eax
f0108ee1:	e8 07 fa ff ff       	call   f01088ed <pt_get_page_permissions>
f0108ee6:	83 c4 10             	add    $0x10,%esp
f0108ee9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f0108eec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108eef:	83 e0 40             	and    $0x40,%eax
f0108ef2:	85 c0                	test   %eax,%eax
f0108ef4:	0f 95 c0             	setne  %al
f0108ef7:	88 45 df             	mov    %al,-0x21(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f0108efa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108efd:	83 e0 20             	and    $0x20,%eax
f0108f00:	85 c0                	test   %eax,%eax
f0108f02:	0f 95 c0             	setne  %al
f0108f05:	88 45 de             	mov    %al,-0x22(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f0108f08:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108f0b:	25 00 02 00 00       	and    $0x200,%eax
f0108f10:	85 c0                	test   %eax,%eax
f0108f12:	0f 95 c0             	setne  %al
f0108f15:	88 45 dd             	mov    %al,-0x23(%ebp)


			cprintf("address @ %d = %x",i, e->ptr_pageWorkingSet[i].virtual_address);
f0108f18:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f1b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108f1e:	89 d0                	mov    %edx,%eax
f0108f20:	01 c0                	add    %eax,%eax
f0108f22:	01 d0                	add    %edx,%eax
f0108f24:	c1 e0 03             	shl    $0x3,%eax
f0108f27:	01 c8                	add    %ecx,%eax
f0108f29:	05 88 00 00 00       	add    $0x88,%eax
f0108f2e:	8b 00                	mov    (%eax),%eax
f0108f30:	83 ec 04             	sub    $0x4,%esp
f0108f33:	50                   	push   %eax
f0108f34:	ff 75 ec             	pushl  -0x14(%ebp)
f0108f37:	68 ce 50 12 f0       	push   $0xf01250ce
f0108f3c:	e8 2b 80 ff ff       	call   f0100f6c <cprintf>
f0108f41:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d", isUsed, isModified, isBuffered, time_stamp, e->ptr_pageWorkingSet[i].sweeps_counter) ;
f0108f44:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108f47:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108f4a:	89 d0                	mov    %edx,%eax
f0108f4c:	01 c0                	add    %eax,%eax
f0108f4e:	01 d0                	add    %edx,%eax
f0108f50:	c1 e0 03             	shl    $0x3,%eax
f0108f53:	01 c8                	add    %ecx,%eax
f0108f55:	05 94 00 00 00       	add    $0x94,%eax
f0108f5a:	8b 18                	mov    (%eax),%ebx
f0108f5c:	0f be 4d dd          	movsbl -0x23(%ebp),%ecx
f0108f60:	0f be 55 df          	movsbl -0x21(%ebp),%edx
f0108f64:	0f be 45 de          	movsbl -0x22(%ebp),%eax
f0108f68:	83 ec 08             	sub    $0x8,%esp
f0108f6b:	53                   	push   %ebx
f0108f6c:	ff 75 e4             	pushl  -0x1c(%ebp)
f0108f6f:	51                   	push   %ecx
f0108f70:	52                   	push   %edx
f0108f71:	50                   	push   %eax
f0108f72:	68 e0 50 12 f0       	push   $0xf01250e0
f0108f77:	e8 f0 7f ff ff       	call   f0100f6c <cprintf>
f0108f7c:	83 c4 20             	add    $0x20,%esp

			if(i==e->page_last_WS_index )
f0108f7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0108f82:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0108f88:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0108f8b:	75 10                	jne    f0108f9d <env_page_ws_print+0x294>
			{
				cprintf(" <--");
f0108f8d:	83 ec 0c             	sub    $0xc,%esp
f0108f90:	68 27 51 12 f0       	push   $0xf0125127
f0108f95:	e8 d2 7f ff ff       	call   f0100f6c <cprintf>
f0108f9a:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0108f9d:	83 ec 0c             	sub    $0xc,%esp
f0108fa0:	68 cc 50 12 f0       	push   $0xf01250cc
f0108fa5:	e8 c2 7f ff ff       	call   f0100f6c <cprintf>
f0108faa:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		uint32 i;
		cprintf("PAGE WS:\n");
		for(i=0; i< (e->page_WS_max_size); i++ )
f0108fad:	ff 45 ec             	incl   -0x14(%ebp)
f0108fb0:	8b 45 08             	mov    0x8(%ebp),%eax
f0108fb3:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0108fb9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0108fbc:	0f 87 7d fe ff ff    	ja     f0108e3f <env_page_ws_print+0x136>
				cprintf(" <--");
			}
			cprintf("\n");
		}
	}
}
f0108fc2:	90                   	nop
f0108fc3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0108fc6:	c9                   	leave  
f0108fc7:	c3                   	ret    

f0108fc8 <env_table_ws_print>:
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f0108fc8:	55                   	push   %ebp
f0108fc9:	89 e5                	mov    %esp,%ebp
f0108fcb:	53                   	push   %ebx
f0108fcc:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f0108fcf:	83 ec 0c             	sub    $0xc,%esp
f0108fd2:	68 2c 51 12 f0       	push   $0xf012512c
f0108fd7:	e8 90 7f ff ff       	call   f0100f6c <cprintf>
f0108fdc:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f0108fdf:	83 ec 0c             	sub    $0xc,%esp
f0108fe2:	68 61 51 12 f0       	push   $0xf0125161
f0108fe7:	e8 80 7f ff ff       	call   f0100f6c <cprintf>
f0108fec:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f0108fef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0108ff6:	e9 16 01 00 00       	jmp    f0109111 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f0108ffb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0108ffe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109001:	89 d0                	mov    %edx,%eax
f0109003:	01 c0                	add    %eax,%eax
f0109005:	01 d0                	add    %edx,%eax
f0109007:	c1 e0 03             	shl    $0x3,%eax
f010900a:	01 c8                	add    %ecx,%eax
f010900c:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109011:	8a 00                	mov    (%eax),%al
f0109013:	84 c0                	test   %al,%al
f0109015:	74 43                	je     f010905a <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f0109017:	83 ec 0c             	sub    $0xc,%esp
f010901a:	68 b7 50 12 f0       	push   $0xf01250b7
f010901f:	e8 48 7f ff ff       	call   f0100f6c <cprintf>
f0109024:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f0109027:	8b 45 08             	mov    0x8(%ebp),%eax
f010902a:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f0109030:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109033:	75 10                	jne    f0109045 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f0109035:	83 ec 0c             	sub    $0xc,%esp
f0109038:	68 c6 50 12 f0       	push   $0xf01250c6
f010903d:	e8 2a 7f ff ff       	call   f0100f6c <cprintf>
f0109042:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f0109045:	83 ec 0c             	sub    $0xc,%esp
f0109048:	68 cc 50 12 f0       	push   $0xf01250cc
f010904d:	e8 1a 7f ff ff       	call   f0100f6c <cprintf>
f0109052:	83 c4 10             	add    $0x10,%esp
			continue;
f0109055:	e9 b4 00 00 00       	jmp    f010910e <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010905a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010905d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109060:	89 d0                	mov    %edx,%eax
f0109062:	01 c0                	add    %eax,%eax
f0109064:	01 d0                	add    %edx,%eax
f0109066:	c1 e0 03             	shl    $0x3,%eax
f0109069:	01 c8                	add    %ecx,%eax
f010906b:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109070:	8b 00                	mov    (%eax),%eax
f0109072:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f0109075:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109078:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010907b:	89 d0                	mov    %edx,%eax
f010907d:	01 c0                	add    %eax,%eax
f010907f:	01 d0                	add    %edx,%eax
f0109081:	c1 e0 03             	shl    $0x3,%eax
f0109084:	01 c8                	add    %ecx,%eax
f0109086:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010908b:	8b 00                	mov    (%eax),%eax
f010908d:	83 ec 04             	sub    $0x4,%esp
f0109090:	50                   	push   %eax
f0109091:	ff 75 f4             	pushl  -0xc(%ebp)
f0109094:	68 6c 51 12 f0       	push   $0xf012516c
f0109099:	e8 ce 7e ff ff       	call   f0100f6c <cprintf>
f010909e:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f01090a1:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01090a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01090a7:	89 d0                	mov    %edx,%eax
f01090a9:	01 c0                	add    %eax,%eax
f01090ab:	01 d0                	add    %edx,%eax
f01090ad:	c1 e0 03             	shl    $0x3,%eax
f01090b0:	01 c8                	add    %ecx,%eax
f01090b2:	05 64 d5 01 00       	add    $0x1d564,%eax
f01090b7:	8b 18                	mov    (%eax),%ebx
f01090b9:	8b 45 08             	mov    0x8(%ebp),%eax
f01090bc:	8b 40 64             	mov    0x64(%eax),%eax
f01090bf:	83 ec 08             	sub    $0x8,%esp
f01090c2:	ff 75 f0             	pushl  -0x10(%ebp)
f01090c5:	50                   	push   %eax
f01090c6:	e8 fe f8 ff ff       	call   f01089c9 <pd_is_table_used>
f01090cb:	83 c4 10             	add    $0x10,%esp
f01090ce:	83 ec 04             	sub    $0x4,%esp
f01090d1:	53                   	push   %ebx
f01090d2:	50                   	push   %eax
f01090d3:	68 84 51 12 f0       	push   $0xf0125184
f01090d8:	e8 8f 7e ff ff       	call   f0100f6c <cprintf>
f01090dd:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f01090e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01090e3:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f01090e9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01090ec:	75 10                	jne    f01090fe <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f01090ee:	83 ec 0c             	sub    $0xc,%esp
f01090f1:	68 27 51 12 f0       	push   $0xf0125127
f01090f6:	e8 71 7e ff ff       	call   f0100f6c <cprintf>
f01090fb:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f01090fe:	83 ec 0c             	sub    $0xc,%esp
f0109101:	68 cc 50 12 f0       	push   $0xf01250cc
f0109106:	e8 61 7e ff ff       	call   f0100f6c <cprintf>
f010910b:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010910e:	ff 45 f4             	incl   -0xc(%ebp)
f0109111:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f0109115:	0f 86 e0 fe ff ff    	jbe    f0108ffb <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010911b:	90                   	nop
f010911c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010911f:	c9                   	leave  
f0109120:	c3                   	ret    

f0109121 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f0109121:	55                   	push   %ebp
f0109122:	89 e5                	mov    %esp,%ebp
f0109124:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f0109127:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010912e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f0109135:	eb 22                	jmp    f0109159 <env_table_ws_get_size+0x38>
f0109137:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010913a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010913d:	89 d0                	mov    %edx,%eax
f010913f:	01 c0                	add    %eax,%eax
f0109141:	01 d0                	add    %edx,%eax
f0109143:	c1 e0 03             	shl    $0x3,%eax
f0109146:	01 c8                	add    %ecx,%eax
f0109148:	05 60 d5 01 00       	add    $0x1d560,%eax
f010914d:	8a 00                	mov    (%eax),%al
f010914f:	84 c0                	test   %al,%al
f0109151:	75 03                	jne    f0109156 <env_table_ws_get_size+0x35>
f0109153:	ff 45 f8             	incl   -0x8(%ebp)
f0109156:	ff 45 fc             	incl   -0x4(%ebp)
f0109159:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010915d:	7e d8                	jle    f0109137 <env_table_ws_get_size+0x16>
	return counter;
f010915f:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f0109162:	c9                   	leave  
f0109163:	c3                   	ret    

f0109164 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f0109164:	55                   	push   %ebp
f0109165:	89 e5                	mov    %esp,%ebp
f0109167:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010916a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f0109171:	eb 4e                	jmp    f01091c1 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f0109173:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109176:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109179:	89 d0                	mov    %edx,%eax
f010917b:	01 c0                	add    %eax,%eax
f010917d:	01 d0                	add    %edx,%eax
f010917f:	c1 e0 03             	shl    $0x3,%eax
f0109182:	01 c8                	add    %ecx,%eax
f0109184:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109189:	8b 00                	mov    (%eax),%eax
f010918b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010918e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109191:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109196:	89 c2                	mov    %eax,%edx
f0109198:	8b 45 0c             	mov    0xc(%ebp),%eax
f010919b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010919e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01091a1:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f01091a6:	39 c2                	cmp    %eax,%edx
f01091a8:	75 14                	jne    f01091be <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f01091aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01091ad:	83 ec 08             	sub    $0x8,%esp
f01091b0:	50                   	push   %eax
f01091b1:	ff 75 08             	pushl  0x8(%ebp)
f01091b4:	e8 bc 00 00 00       	call   f0109275 <env_table_ws_clear_entry>
f01091b9:	83 c4 10             	add    $0x10,%esp
			break;
f01091bc:	eb 09                	jmp    f01091c7 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f01091be:	ff 45 f4             	incl   -0xc(%ebp)
f01091c1:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f01091c5:	7e ac                	jle    f0109173 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f01091c7:	90                   	nop
f01091c8:	c9                   	leave  
f01091c9:	c3                   	ret    

f01091ca <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f01091ca:	55                   	push   %ebp
f01091cb:	89 e5                	mov    %esp,%ebp
f01091cd:	53                   	push   %ebx
f01091ce:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01091d1:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01091d5:	76 19                	jbe    f01091f0 <env_table_ws_set_entry+0x26>
f01091d7:	68 a8 51 12 f0       	push   $0xf01251a8
f01091dc:	68 ce 4f 12 f0       	push   $0xf0124fce
f01091e1:	68 37 01 00 00       	push   $0x137
f01091e6:	68 e4 4f 12 f0       	push   $0xf0124fe4
f01091eb:	e8 2a 71 ff ff       	call   f010031a <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f01091f0:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f01091f7:	76 19                	jbe    f0109212 <env_table_ws_set_entry+0x48>
f01091f9:	68 04 50 12 f0       	push   $0xf0125004
f01091fe:	68 ce 4f 12 f0       	push   $0xf0124fce
f0109203:	68 38 01 00 00       	push   $0x138
f0109208:	68 e4 4f 12 f0       	push   $0xf0124fe4
f010920d:	e8 08 71 ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f0109212:	8b 45 10             	mov    0x10(%ebp),%eax
f0109215:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109218:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010921b:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f0109220:	89 c1                	mov    %eax,%ecx
f0109222:	8b 5d 08             	mov    0x8(%ebp),%ebx
f0109225:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109228:	89 d0                	mov    %edx,%eax
f010922a:	01 c0                	add    %eax,%eax
f010922c:	01 d0                	add    %edx,%eax
f010922e:	c1 e0 03             	shl    $0x3,%eax
f0109231:	01 d8                	add    %ebx,%eax
f0109233:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109238:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010923a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010923d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109240:	89 d0                	mov    %edx,%eax
f0109242:	01 c0                	add    %eax,%eax
f0109244:	01 d0                	add    %edx,%eax
f0109246:	c1 e0 03             	shl    $0x3,%eax
f0109249:	01 c8                	add    %ecx,%eax
f010924b:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109250:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x80000000;
f0109253:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109256:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109259:	89 d0                	mov    %edx,%eax
f010925b:	01 c0                	add    %eax,%eax
f010925d:	01 d0                	add    %edx,%eax
f010925f:	c1 e0 03             	shl    $0x3,%eax
f0109262:	01 c8                	add    %ecx,%eax
f0109264:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109269:	c7 00 00 00 00 80    	movl   $0x80000000,(%eax)
	return;
f010926f:	90                   	nop
}
f0109270:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109273:	c9                   	leave  
f0109274:	c3                   	ret    

f0109275 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f0109275:	55                   	push   %ebp
f0109276:	89 e5                	mov    %esp,%ebp
f0109278:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010927b:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010927f:	76 19                	jbe    f010929a <env_table_ws_clear_entry+0x25>
f0109281:	68 a8 51 12 f0       	push   $0xf01251a8
f0109286:	68 ce 4f 12 f0       	push   $0xf0124fce
f010928b:	68 43 01 00 00       	push   $0x143
f0109290:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0109295:	e8 80 70 ff ff       	call   f010031a <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010929a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010929d:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092a0:	89 d0                	mov    %edx,%eax
f01092a2:	01 c0                	add    %eax,%eax
f01092a4:	01 d0                	add    %edx,%eax
f01092a6:	c1 e0 03             	shl    $0x3,%eax
f01092a9:	01 c8                	add    %ecx,%eax
f01092ab:	05 5c d5 01 00       	add    $0x1d55c,%eax
f01092b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f01092b6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092b9:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092bc:	89 d0                	mov    %edx,%eax
f01092be:	01 c0                	add    %eax,%eax
f01092c0:	01 d0                	add    %edx,%eax
f01092c2:	c1 e0 03             	shl    $0x3,%eax
f01092c5:	01 c8                	add    %ecx,%eax
f01092c7:	05 60 d5 01 00       	add    $0x1d560,%eax
f01092cc:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f01092cf:	8b 4d 08             	mov    0x8(%ebp),%ecx
f01092d2:	8b 55 0c             	mov    0xc(%ebp),%edx
f01092d5:	89 d0                	mov    %edx,%eax
f01092d7:	01 c0                	add    %eax,%eax
f01092d9:	01 d0                	add    %edx,%eax
f01092db:	c1 e0 03             	shl    $0x3,%eax
f01092de:	01 c8                	add    %ecx,%eax
f01092e0:	05 64 d5 01 00       	add    $0x1d564,%eax
f01092e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f01092eb:	90                   	nop
f01092ec:	c9                   	leave  
f01092ed:	c3                   	ret    

f01092ee <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f01092ee:	55                   	push   %ebp
f01092ef:	89 e5                	mov    %esp,%ebp
f01092f1:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f01092f4:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f01092f8:	76 19                	jbe    f0109313 <env_table_ws_get_virtual_address+0x25>
f01092fa:	68 a8 51 12 f0       	push   $0xf01251a8
f01092ff:	68 ce 4f 12 f0       	push   $0xf0124fce
f0109304:	68 4b 01 00 00       	push   $0x14b
f0109309:	68 e4 4f 12 f0       	push   $0xf0124fe4
f010930e:	e8 07 70 ff ff       	call   f010031a <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f0109313:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109316:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109319:	89 d0                	mov    %edx,%eax
f010931b:	01 c0                	add    %eax,%eax
f010931d:	01 d0                	add    %edx,%eax
f010931f:	c1 e0 03             	shl    $0x3,%eax
f0109322:	01 c8                	add    %ecx,%eax
f0109324:	05 5c d5 01 00       	add    $0x1d55c,%eax
f0109329:	8b 00                	mov    (%eax),%eax
f010932b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010932e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109331:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f0109336:	c9                   	leave  
f0109337:	c3                   	ret    

f0109338 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f0109338:	55                   	push   %ebp
f0109339:	89 e5                	mov    %esp,%ebp
f010933b:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010933e:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f0109342:	76 19                	jbe    f010935d <env_table_ws_get_time_stamp+0x25>
f0109344:	68 a8 51 12 f0       	push   $0xf01251a8
f0109349:	68 ce 4f 12 f0       	push   $0xf0124fce
f010934e:	68 52 01 00 00       	push   $0x152
f0109353:	68 e4 4f 12 f0       	push   $0xf0124fe4
f0109358:	e8 bd 6f ff ff       	call   f010031a <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010935d:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0109360:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109363:	89 d0                	mov    %edx,%eax
f0109365:	01 c0                	add    %eax,%eax
f0109367:	01 d0                	add    %edx,%eax
f0109369:	c1 e0 03             	shl    $0x3,%eax
f010936c:	01 c8                	add    %ecx,%eax
f010936e:	05 64 d5 01 00       	add    $0x1d564,%eax
f0109373:	8b 00                	mov    (%eax),%eax
}
f0109375:	c9                   	leave  
f0109376:	c3                   	ret    

f0109377 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f0109377:	55                   	push   %ebp
f0109378:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010937a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010937d:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109380:	89 d0                	mov    %edx,%eax
f0109382:	01 c0                	add    %eax,%eax
f0109384:	01 d0                	add    %edx,%eax
f0109386:	c1 e0 03             	shl    $0x3,%eax
f0109389:	01 c8                	add    %ecx,%eax
f010938b:	05 60 d5 01 00       	add    $0x1d560,%eax
f0109390:	8a 00                	mov    (%eax),%al
f0109392:	0f b6 c0             	movzbl %al,%eax
}
f0109395:	5d                   	pop    %ebp
f0109396:	c3                   	ret    

f0109397 <double_WS_Size>:
///=================================================================================================
///=================================================================================================
///=================================================================================================

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f0109397:	55                   	push   %ebp
f0109398:	89 e5                	mov    %esp,%ebp
f010939a:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010939d:	83 ec 04             	sub    $0x4,%esp
f01093a0:	68 d9 51 12 f0       	push   $0xf01251d9
f01093a5:	68 62 01 00 00       	push   $0x162
f01093aa:	68 e4 4f 12 f0       	push   $0xf0124fe4
f01093af:	e8 66 6f ff ff       	call   f010031a <_panic>

f01093b4 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f01093b4:	55                   	push   %ebp
f01093b5:	89 e5                	mov    %esp,%ebp
f01093b7:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f01093ba:	83 ec 04             	sub    $0x4,%esp
f01093bd:	68 d9 51 12 f0       	push   $0xf01251d9
f01093c2:	68 67 01 00 00       	push   $0x167
f01093c7:	68 e4 4f 12 f0       	push   $0xf0124fe4
f01093cc:	e8 49 6f ff ff       	call   f010031a <_panic>

f01093d1 <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f01093d1:	55                   	push   %ebp
f01093d2:	89 e5                	mov    %esp,%ebp
f01093d4:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] cut_paste_pages
	// Write your code here, remove the panic and write your code
	panic("cut_paste_pages() is not implemented yet...!!");
f01093d7:	83 ec 04             	sub    $0x4,%esp
f01093da:	68 ec 51 12 f0       	push   $0xf01251ec
f01093df:	6a 21                	push   $0x21
f01093e1:	68 1a 52 12 f0       	push   $0xf012521a
f01093e6:	e8 2f 6f ff ff       	call   f010031a <_panic>

f01093eb <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f01093eb:	55                   	push   %ebp
f01093ec:	89 e5                	mov    %esp,%ebp
f01093ee:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] copy_paste_chunk
	// Write your code here, remove the //panic and write your code
	panic("copy_paste_chunk() is not implemented yet...!!");
f01093f1:	83 ec 04             	sub    $0x4,%esp
f01093f4:	68 38 52 12 f0       	push   $0xf0125238
f01093f9:	6a 34                	push   $0x34
f01093fb:	68 1a 52 12 f0       	push   $0xf012521a
f0109400:	e8 15 6f ff ff       	call   f010031a <_panic>

f0109405 <share_chunk>:
//	It should set the permissions of the second range by the given perms
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, share the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f0109405:	55                   	push   %ebp
f0109406:	89 e5                	mov    %esp,%ebp
f0109408:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] share_chunk
	// Write your code here, remove the //panic and write your code
	panic("share_chunk() is not implemented yet...!!");
f010940b:	83 ec 04             	sub    $0x4,%esp
f010940e:	68 68 52 12 f0       	push   $0xf0125268
f0109413:	6a 44                	push   $0x44
f0109415:	68 1a 52 12 f0       	push   $0xf012521a
f010941a:	e8 fb 6e ff ff       	call   f010031a <_panic>

f010941f <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010941f:	55                   	push   %ebp
f0109420:	89 e5                	mov    %esp,%ebp
f0109422:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] allocate_chunk
	// Write your code here, remove the //panic and write your code
	panic("allocate_chunk() is not implemented yet...!!");
f0109425:	83 ec 04             	sub    $0x4,%esp
f0109428:	68 94 52 12 f0       	push   $0xf0125294
f010942d:	6a 52                	push   $0x52
f010942f:	68 1a 52 12 f0       	push   $0xf012521a
f0109434:	e8 e1 6e ff ff       	call   f010031a <_panic>

f0109439 <calculate_allocated_space>:

//=====================================
// 5) CALCULATE ALLOCATED SPACE IN RAM:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f0109439:	55                   	push   %ebp
f010943a:	89 e5                	mov    %esp,%ebp
f010943c:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_allocated_space
	// Write your code here, remove the panic and write your code
	panic("calculate_allocated_space() is not implemented yet...!!");
f010943f:	83 ec 04             	sub    $0x4,%esp
f0109442:	68 c4 52 12 f0       	push   $0xf01252c4
f0109447:	6a 5c                	push   $0x5c
f0109449:	68 1a 52 12 f0       	push   $0xf012521a
f010944e:	e8 c7 6e ff ff       	call   f010031a <_panic>

f0109453 <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f0109453:	55                   	push   %ebp
f0109454:	89 e5                	mov    %esp,%ebp
f0109456:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [CHUNK OPERATIONS] calculate_required_frames
	// Write your code here, remove the panic and write your code
	panic("calculate_required_frames() is not implemented yet...!!");
f0109459:	83 ec 04             	sub    $0x4,%esp
f010945c:	68 fc 52 12 f0       	push   $0xf01252fc
f0109461:	6a 69                	push   $0x69
f0109463:	68 1a 52 12 f0       	push   $0xf012521a
f0109468:	e8 ad 6e ff ff       	call   f010031a <_panic>

f010946d <sys_sbrk>:

//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
void* sys_sbrk(int numOfPages)
{
f010946d:	55                   	push   %ebp
f010946e:	89 e5                	mov    %esp,%ebp
f0109470:	83 ec 18             	sub    $0x18,%esp
	 * 		or the break exceed the limit of the dynamic allocator. If sys_sbrk fails, the net effect should
	 * 		be that sys_sbrk returns (void*) -1 and that the segment break and the process heap are unaffected.
	 * 		You might have to undo any operations you have done so far in this case.
	 */

	struct Env* env = get_cpu_proc(); //the current running Environment to adjust its break limit
f0109473:	e8 f9 0f 00 00       	call   f010a471 <get_cpu_proc>
f0109478:	89 45 f4             	mov    %eax,-0xc(%ebp)

	/*====================================*/
	/*Remove this line before start coding*/
	return (void*)-1 ;
f010947b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	/*====================================*/

	//[PROJECT'24.MS2] Implement this function

}
f0109480:	c9                   	leave  
f0109481:	c3                   	ret    

f0109482 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109482:	55                   	push   %ebp
f0109483:	89 e5                	mov    %esp,%ebp
f0109485:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f0109488:	e8 9d 56 01 00       	call   f011eb2a <inctst>
	return;
f010948d:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] allocate_user_mem
	// Write your code here, remove the panic and write your code
	panic("allocate_user_mem() is not implemented yet...!!");
}
f010948e:	c9                   	leave  
f010948f:	c3                   	ret    

f0109490 <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f0109490:	55                   	push   %ebp
f0109491:	89 e5                	mov    %esp,%ebp
f0109493:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/
	/*Remove this line before start coding*/
	inctst();
f0109496:	e8 8f 56 01 00       	call   f011eb2a <inctst>
	return;
f010949b:	90                   	nop
	/*====================================*/

	//[PROJECT'24.MS2] [USER HEAP - KERNEL SIDE] free_user_mem
	// Write your code here, remove the panic and write your code
	panic("free_user_mem() is not implemented yet...!!");
}
f010949c:	c9                   	leave  
f010949d:	c3                   	ret    

f010949e <__free_user_mem_with_buffering>:

//=====================================
// 2) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010949e:	55                   	push   %ebp
f010949f:	89 e5                	mov    %esp,%ebp
f01094a1:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f01094a4:	83 ec 04             	sub    $0x4,%esp
f01094a7:	68 34 53 12 f0       	push   $0xf0125334
f01094ac:	68 bc 00 00 00       	push   $0xbc
f01094b1:	68 1a 52 12 f0       	push   $0xf012521a
f01094b6:	e8 5f 6e ff ff       	call   f010031a <_panic>

f01094bb <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f01094bb:	55                   	push   %ebp
f01094bc:	89 e5                	mov    %esp,%ebp
f01094be:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] [USER HEAP - KERNEL SIDE] move_user_mem
	//your code is here, remove the panic and write your code
	panic("move_user_mem() is not implemented yet...!!");
f01094c1:	83 ec 04             	sub    $0x4,%esp
f01094c4:	68 74 53 12 f0       	push   $0xf0125374
f01094c9:	68 c6 00 00 00       	push   $0xc6
f01094ce:	68 1a 52 12 f0       	push   $0xf012521a
f01094d3:	e8 42 6e ff ff       	call   f010031a <_panic>

f01094d8 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01094d8:	55                   	push   %ebp
f01094d9:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01094db:	8b 45 08             	mov    0x8(%ebp),%eax
f01094de:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f01094e4:	29 d0                	sub    %edx,%eax
f01094e6:	c1 f8 03             	sar    $0x3,%eax
f01094e9:	89 c2                	mov    %eax,%edx
f01094eb:	89 d0                	mov    %edx,%eax
f01094ed:	c1 e0 02             	shl    $0x2,%eax
f01094f0:	01 d0                	add    %edx,%eax
f01094f2:	c1 e0 02             	shl    $0x2,%eax
f01094f5:	01 d0                	add    %edx,%eax
f01094f7:	c1 e0 02             	shl    $0x2,%eax
f01094fa:	01 d0                	add    %edx,%eax
f01094fc:	89 c1                	mov    %eax,%ecx
f01094fe:	c1 e1 08             	shl    $0x8,%ecx
f0109501:	01 c8                	add    %ecx,%eax
f0109503:	89 c1                	mov    %eax,%ecx
f0109505:	c1 e1 10             	shl    $0x10,%ecx
f0109508:	01 c8                	add    %ecx,%eax
f010950a:	01 c0                	add    %eax,%eax
f010950c:	01 d0                	add    %edx,%eax
}
f010950e:	5d                   	pop    %ebp
f010950f:	c3                   	ret    

f0109510 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0109510:	55                   	push   %ebp
f0109511:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0109513:	ff 75 08             	pushl  0x8(%ebp)
f0109516:	e8 bd ff ff ff       	call   f01094d8 <to_frame_number>
f010951b:	83 c4 04             	add    $0x4,%esp
f010951e:	c1 e0 0c             	shl    $0xc,%eax
}
f0109521:	c9                   	leave  
f0109522:	c3                   	ret    

f0109523 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f0109523:	55                   	push   %ebp
f0109524:	89 e5                	mov    %esp,%ebp
f0109526:	56                   	push   %esi
f0109527:	53                   	push   %ebx
f0109528:	83 ec 10             	sub    $0x10,%esp
	int iEnv = NENV-1;
f010952b:	c7 45 f4 07 00 00 00 	movl   $0x7,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f0109532:	e9 28 02 00 00       	jmp    f010975f <env_init+0x23c>
	{
		envs[iEnv].env_status = ENV_FREE;
f0109537:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010953d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109540:	89 d0                	mov    %edx,%eax
f0109542:	c1 e0 06             	shl    $0x6,%eax
f0109545:	29 d0                	sub    %edx,%eax
f0109547:	c1 e0 02             	shl    $0x2,%eax
f010954a:	01 d0                	add    %edx,%eax
f010954c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109553:	01 d8                	add    %ebx,%eax
f0109555:	c1 e0 03             	shl    $0x3,%eax
f0109558:	01 d0                	add    %edx,%eax
f010955a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109561:	29 c2                	sub    %eax,%edx
f0109563:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010956a:	89 c2                	mov    %eax,%edx
f010956c:	89 d0                	mov    %edx,%eax
f010956e:	01 c8                	add    %ecx,%eax
f0109570:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f0109577:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010957d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109580:	89 d0                	mov    %edx,%eax
f0109582:	c1 e0 06             	shl    $0x6,%eax
f0109585:	29 d0                	sub    %edx,%eax
f0109587:	c1 e0 02             	shl    $0x2,%eax
f010958a:	01 d0                	add    %edx,%eax
f010958c:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109593:	01 d8                	add    %ebx,%eax
f0109595:	c1 e0 03             	shl    $0x3,%eax
f0109598:	01 d0                	add    %edx,%eax
f010959a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01095a1:	29 c2                	sub    %eax,%edx
f01095a3:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01095aa:	89 c2                	mov    %eax,%edx
f01095ac:	89 d0                	mov    %edx,%eax
f01095ae:	01 c8                	add    %ecx,%eax
f01095b0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f01095b7:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f01095bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01095c0:	89 d0                	mov    %edx,%eax
f01095c2:	c1 e0 06             	shl    $0x6,%eax
f01095c5:	29 d0                	sub    %edx,%eax
f01095c7:	c1 e0 02             	shl    $0x2,%eax
f01095ca:	01 d0                	add    %edx,%eax
f01095cc:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01095d3:	01 d8                	add    %ebx,%eax
f01095d5:	c1 e0 03             	shl    $0x3,%eax
f01095d8:	01 d0                	add    %edx,%eax
f01095da:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01095e1:	29 c2                	sub    %eax,%edx
f01095e3:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01095ea:	89 c2                	mov    %eax,%edx
f01095ec:	89 d0                	mov    %edx,%eax
f01095ee:	01 c8                	add    %ecx,%eax
f01095f0:	85 c0                	test   %eax,%eax
f01095f2:	75 14                	jne    f0109608 <env_init+0xe5>
f01095f4:	83 ec 04             	sub    $0x4,%esp
f01095f7:	68 a0 53 12 f0       	push   $0xf01253a0
f01095fc:	6a 64                	push   $0x64
f01095fe:	68 c3 53 12 f0       	push   $0xf01253c3
f0109603:	e8 12 6d ff ff       	call   f010031a <_panic>
f0109608:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010960e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109611:	89 d0                	mov    %edx,%eax
f0109613:	c1 e0 06             	shl    $0x6,%eax
f0109616:	29 d0                	sub    %edx,%eax
f0109618:	c1 e0 02             	shl    $0x2,%eax
f010961b:	01 d0                	add    %edx,%eax
f010961d:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f0109624:	01 d8                	add    %ebx,%eax
f0109626:	c1 e0 03             	shl    $0x3,%eax
f0109629:	01 d0                	add    %edx,%eax
f010962b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109632:	29 c2                	sub    %eax,%edx
f0109634:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010963b:	89 c2                	mov    %eax,%edx
f010963d:	89 d0                	mov    %edx,%eax
f010963f:	01 c8                	add    %ecx,%eax
f0109641:	8b 15 14 1a 55 f0    	mov    0xf0551a14,%edx
f0109647:	89 50 08             	mov    %edx,0x8(%eax)
f010964a:	8b 40 08             	mov    0x8(%eax),%eax
f010964d:	85 c0                	test   %eax,%eax
f010964f:	74 44                	je     f0109695 <env_init+0x172>
f0109651:	8b 0d 14 1a 55 f0    	mov    0xf0551a14,%ecx
f0109657:	8b 1d 10 1a 55 f0    	mov    0xf0551a10,%ebx
f010965d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109660:	89 d0                	mov    %edx,%eax
f0109662:	c1 e0 06             	shl    $0x6,%eax
f0109665:	29 d0                	sub    %edx,%eax
f0109667:	c1 e0 02             	shl    $0x2,%eax
f010966a:	01 d0                	add    %edx,%eax
f010966c:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
f0109673:	01 f0                	add    %esi,%eax
f0109675:	c1 e0 03             	shl    $0x3,%eax
f0109678:	01 d0                	add    %edx,%eax
f010967a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109681:	29 c2                	sub    %eax,%edx
f0109683:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010968a:	89 c2                	mov    %eax,%edx
f010968c:	89 d0                	mov    %edx,%eax
f010968e:	01 d8                	add    %ebx,%eax
f0109690:	89 41 0c             	mov    %eax,0xc(%ecx)
f0109693:	eb 3e                	jmp    f01096d3 <env_init+0x1b0>
f0109695:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f010969b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010969e:	89 d0                	mov    %edx,%eax
f01096a0:	c1 e0 06             	shl    $0x6,%eax
f01096a3:	29 d0                	sub    %edx,%eax
f01096a5:	c1 e0 02             	shl    $0x2,%eax
f01096a8:	01 d0                	add    %edx,%eax
f01096aa:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01096b1:	01 d8                	add    %ebx,%eax
f01096b3:	c1 e0 03             	shl    $0x3,%eax
f01096b6:	01 d0                	add    %edx,%eax
f01096b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01096bf:	29 c2                	sub    %eax,%edx
f01096c1:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f01096c8:	89 c2                	mov    %eax,%edx
f01096ca:	89 d0                	mov    %edx,%eax
f01096cc:	01 c8                	add    %ecx,%eax
f01096ce:	a3 18 1a 55 f0       	mov    %eax,0xf0551a18
f01096d3:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f01096d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01096dc:	89 d0                	mov    %edx,%eax
f01096de:	c1 e0 06             	shl    $0x6,%eax
f01096e1:	29 d0                	sub    %edx,%eax
f01096e3:	c1 e0 02             	shl    $0x2,%eax
f01096e6:	01 d0                	add    %edx,%eax
f01096e8:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f01096ef:	01 d8                	add    %ebx,%eax
f01096f1:	c1 e0 03             	shl    $0x3,%eax
f01096f4:	01 d0                	add    %edx,%eax
f01096f6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01096fd:	29 c2                	sub    %eax,%edx
f01096ff:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109706:	89 c2                	mov    %eax,%edx
f0109708:	89 d0                	mov    %edx,%eax
f010970a:	01 c8                	add    %ecx,%eax
f010970c:	a3 14 1a 55 f0       	mov    %eax,0xf0551a14
f0109711:	8b 0d 10 1a 55 f0    	mov    0xf0551a10,%ecx
f0109717:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010971a:	89 d0                	mov    %edx,%eax
f010971c:	c1 e0 06             	shl    $0x6,%eax
f010971f:	29 d0                	sub    %edx,%eax
f0109721:	c1 e0 02             	shl    $0x2,%eax
f0109724:	01 d0                	add    %edx,%eax
f0109726:	8d 1c 85 00 00 00 00 	lea    0x0(,%eax,4),%ebx
f010972d:	01 d8                	add    %ebx,%eax
f010972f:	c1 e0 03             	shl    $0x3,%eax
f0109732:	01 d0                	add    %edx,%eax
f0109734:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010973b:	29 c2                	sub    %eax,%edx
f010973d:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f0109744:	89 c2                	mov    %eax,%edx
f0109746:	89 d0                	mov    %edx,%eax
f0109748:	01 c8                	add    %ecx,%eax
f010974a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0109751:	a1 20 1a 55 f0       	mov    0xf0551a20,%eax
f0109756:	40                   	inc    %eax
f0109757:	a3 20 1a 55 f0       	mov    %eax,0xf0551a20
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010975c:	ff 4d f4             	decl   -0xc(%ebp)
f010975f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109763:	0f 89 ce fd ff ff    	jns    f0109537 <env_init+0x14>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f0109769:	90                   	nop
f010976a:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010976d:	5b                   	pop    %ebx
f010976e:	5e                   	pop    %esi
f010976f:	5d                   	pop    %ebp
f0109770:	c3                   	ret    

f0109771 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f0109771:	55                   	push   %ebp
f0109772:	89 e5                	mov    %esp,%ebp
f0109774:	57                   	push   %edi
f0109775:	56                   	push   %esi
f0109776:	53                   	push   %ebx
f0109777:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[1] get pointer to the start of the "user_program_name" program in memory
	// Hint: use "get_user_program_info" function,
	// you should set the following "ptr_program_start" by the start address of the user program
	uint8* ptr_program_start = 0;
f010977d:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

	struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f0109784:	83 ec 0c             	sub    $0xc,%esp
f0109787:	ff 75 08             	pushl  0x8(%ebp)
f010978a:	e8 c8 24 00 00       	call   f010bc57 <get_user_program_info>
f010978f:	83 c4 10             	add    $0x10,%esp
f0109792:	89 45 b4             	mov    %eax,-0x4c(%ebp)
	if(ptr_user_program_info == 0)
f0109795:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0109799:	75 0a                	jne    f01097a5 <env_create+0x34>
	{
		return NULL;
f010979b:	b8 00 00 00 00       	mov    $0x0,%eax
f01097a0:	e9 2a 0c 00 00       	jmp    f010a3cf <env_create+0xc5e>
	}
	ptr_program_start = ptr_user_program_info->ptr_start ;
f01097a5:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01097a8:	8b 40 08             	mov    0x8(%eax),%eax
f01097ab:	89 45 b8             	mov    %eax,-0x48(%ebp)

	//[2] allocate new environment, (from the free environment list)
	//if there's no one, return NULL
	// Hint: use "allocate_environment" function
	struct Env* e = NULL;
f01097ae:	c7 85 40 ff ff ff 00 	movl   $0x0,-0xc0(%ebp)
f01097b5:	00 00 00 
	if(allocate_environment(&e) < 0)
f01097b8:	83 ec 0c             	sub    $0xc,%esp
f01097bb:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f01097c1:	50                   	push   %eax
f01097c2:	e8 23 11 00 00       	call   f010a8ea <allocate_environment>
f01097c7:	83 c4 10             	add    $0x10,%esp
f01097ca:	85 c0                	test   %eax,%eax
f01097cc:	79 0a                	jns    f01097d8 <env_create+0x67>
	{
		return NULL;
f01097ce:	b8 00 00 00 00       	mov    $0x0,%eax
f01097d3:	e9 f7 0b 00 00       	jmp    f010a3cf <env_create+0xc5e>
	}

	//[2.5 - 2012] Set program name inside the environment
	//e->prog_name = ptr_user_program_info->name ;
	//2017: changed to fixed size array to be abale to access it from user side
	if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f01097d8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01097db:	8b 00                	mov    (%eax),%eax
f01097dd:	83 ec 0c             	sub    $0xc,%esp
f01097e0:	50                   	push   %eax
f01097e1:	e8 4d 6d 01 00       	call   f0120533 <strlen>
f01097e6:	83 c4 10             	add    $0x10,%esp
f01097e9:	83 f8 3f             	cmp    $0x3f,%eax
f01097ec:	7f 1d                	jg     f010980b <env_create+0x9a>
		strcpy(e->prog_name, ptr_user_program_info->name);
f01097ee:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01097f1:	8b 00                	mov    (%eax),%eax
f01097f3:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f01097f9:	83 c2 20             	add    $0x20,%edx
f01097fc:	83 ec 08             	sub    $0x8,%esp
f01097ff:	50                   	push   %eax
f0109800:	52                   	push   %edx
f0109801:	e8 7c 6d 01 00       	call   f0120582 <strcpy>
f0109806:	83 c4 10             	add    $0x10,%esp
f0109809:	eb 1d                	jmp    f0109828 <env_create+0xb7>
	else
		strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010980b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010980e:	8b 00                	mov    (%eax),%eax
f0109810:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109816:	83 c2 20             	add    $0x20,%edx
f0109819:	83 ec 04             	sub    $0x4,%esp
f010981c:	6a 3f                	push   $0x3f
f010981e:	50                   	push   %eax
f010981f:	52                   	push   %edx
f0109820:	e8 8b 6d 01 00       	call   f01205b0 <strncpy>
f0109825:	83 c4 10             	add    $0x10,%esp
		phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
	}
#else
	{
		int r;
		struct FrameInfo *p = NULL;
f0109828:	c7 85 3c ff ff ff 00 	movl   $0x0,-0xc4(%ebp)
f010982f:	00 00 00 

		allocate_frame(&p) ;
f0109832:	83 ec 0c             	sub    $0xc,%esp
f0109835:	8d 85 3c ff ff ff    	lea    -0xc4(%ebp),%eax
f010983b:	50                   	push   %eax
f010983c:	e8 90 e6 ff ff       	call   f0107ed1 <allocate_frame>
f0109841:	83 c4 10             	add    $0x10,%esp
		p->references = 1;
f0109844:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f010984a:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)

		ptr_user_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
f0109850:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0109856:	83 ec 0c             	sub    $0xc,%esp
f0109859:	50                   	push   %eax
f010985a:	e8 b1 fc ff ff       	call   f0109510 <to_physical_address>
f010985f:	83 c4 10             	add    $0x10,%esp
f0109862:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0109865:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109868:	c1 e8 0c             	shr    $0xc,%eax
f010986b:	89 45 ac             	mov    %eax,-0x54(%ebp)
f010986e:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0109873:	39 45 ac             	cmp    %eax,-0x54(%ebp)
f0109876:	72 17                	jb     f010988f <env_create+0x11e>
f0109878:	ff 75 b0             	pushl  -0x50(%ebp)
f010987b:	68 e0 53 12 f0       	push   $0xf01253e0
f0109880:	68 9c 00 00 00       	push   $0x9c
f0109885:	68 c3 53 12 f0       	push   $0xf01253c3
f010988a:	e8 8b 6a ff ff       	call   f010031a <_panic>
f010988f:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0109892:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109897:	89 45 a8             	mov    %eax,-0x58(%ebp)
		phys_user_page_directory = to_physical_address(p);
f010989a:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01098a0:	83 ec 0c             	sub    $0xc,%esp
f01098a3:	50                   	push   %eax
f01098a4:	e8 67 fc ff ff       	call   f0109510 <to_physical_address>
f01098a9:	83 c4 10             	add    $0x10,%esp
f01098ac:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
	//[4] initialize the new environment by the virtual address of the page directory
	// Hint: use "initialize_environment" function

	//2016
	e->page_WS_max_size = page_WS_size;
f01098af:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01098b5:	8b 55 0c             	mov    0xc(%ebp),%edx
f01098b8:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

	//2020
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f01098be:	83 ec 0c             	sub    $0xc,%esp
f01098c1:	6a 02                	push   $0x2
f01098c3:	e8 a7 4a 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f01098c8:	83 c4 10             	add    $0x10,%esp
f01098cb:	85 c0                	test   %eax,%eax
f01098cd:	74 21                	je     f01098f0 <env_create+0x17f>
	{
		e->SecondListSize = LRU_second_list_size;
f01098cf:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01098d5:	8b 55 10             	mov    0x10(%ebp),%edx
f01098d8:	89 90 34 da 01 00    	mov    %edx,0x1da34(%eax)
		e->ActiveListSize = page_WS_size - LRU_second_list_size;
f01098de:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01098e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f01098e7:	2b 55 10             	sub    0x10(%ebp),%edx
f01098ea:	89 90 30 da 01 00    	mov    %edx,0x1da30(%eax)
	}

	//2018
	if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f01098f0:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f01098f4:	75 12                	jne    f0109908 <env_create+0x197>
		e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f01098f6:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01098fc:	c7 80 3c da 01 00 0a 	movl   $0xa,0x1da3c(%eax)
f0109903:	00 00 00 
f0109906:	eb 0f                	jmp    f0109917 <env_create+0x1a6>
	else
		e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f0109908:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010990e:	8b 55 14             	mov    0x14(%ebp),%edx
f0109911:	89 90 3c da 01 00    	mov    %edx,0x1da3c(%eax)

	initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f0109917:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010991d:	83 ec 04             	sub    $0x4,%esp
f0109920:	ff 75 a4             	pushl  -0x5c(%ebp)
f0109923:	ff 75 a8             	pushl  -0x58(%ebp)
f0109926:	50                   	push   %eax
f0109927:	e8 76 18 00 00       	call   f010b1a2 <initialize_environment>
f010992c:	83 c4 10             	add    $0x10,%esp
	//	3- uint32 size_in_memory: actual size required by this segment in memory
	// 	usually size_in_file < or = size_in_memory
	//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

	//[5] 2024: Disable the interrupt before switching the directories
	pushcli();
f010992f:	e8 8d d5 ff ff       	call   f0106ec1 <pushcli>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f0109934:	0f 20 d8             	mov    %cr3,%eax
f0109937:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f010993a:	8b 45 98             	mov    -0x68(%ebp),%eax
	{
		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010993d:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f0109940:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109946:	8b 40 68             	mov    0x68(%eax),%eax
f0109949:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010994f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0109955:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f0109958:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f010995f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f0109966:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010996c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0109972:	48                   	dec    %eax
f0109973:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f0109976:	c7 85 38 ff ff ff ff 	movl   $0xffffffff,-0xc8(%ebp)
f010997d:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109980:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f0109986:	83 ec 08             	sub    $0x8,%esp
f0109989:	ff 75 b8             	pushl  -0x48(%ebp)
f010998c:	50                   	push   %eax
f010998d:	e8 d7 1f 00 00       	call   f010b969 <PROGRAM_SEGMENT_FIRST>
f0109992:	83 c4 0c             	add    $0xc,%esp
f0109995:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f010999b:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f01099a1:	b9 05 00 00 00       	mov    $0x5,%ecx
f01099a6:	89 c7                	mov    %eax,%edi
f01099a8:	89 d6                	mov    %edx,%esi
f01099aa:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01099ac:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01099b2:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01099b5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01099b8:	8b 40 10             	mov    0x10(%eax),%eax
f01099bb:	83 f8 ff             	cmp    $0xffffffff,%eax
f01099be:	75 07                	jne    f01099c7 <env_create+0x256>
f01099c0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01099c7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01099ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01099cd:	e9 24 03 00 00       	jmp    f0109cf6 <env_create+0x585>
		{
			segment_counter++;
f01099d2:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f01099d5:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01099dc:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f01099df:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01099e5:	83 ec 0c             	sub    $0xc,%esp
f01099e8:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f01099ee:	52                   	push   %edx
f01099ef:	ff 75 dc             	pushl  -0x24(%ebp)
f01099f2:	8d 95 20 ff ff ff    	lea    -0xe0(%ebp),%edx
f01099f8:	52                   	push   %edx
f01099f9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01099fc:	50                   	push   %eax
f01099fd:	e8 a6 0f 00 00       	call   f010a9a8 <program_segment_alloc_map_copy_workingset>
f0109a02:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f0109a05:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0109a0b:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f0109a0e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109a11:	8b 00                	mov    (%eax),%eax
f0109a13:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f0109a16:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109a19:	8b 40 0c             	mov    0xc(%eax),%eax
f0109a1c:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f0109a1f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109a22:	89 45 8c             	mov    %eax,-0x74(%ebp)
f0109a25:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0109a28:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109a2d:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f0109a30:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f0109a37:	8b 55 90             	mov    -0x70(%ebp),%edx
f0109a3a:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0109a3d:	01 d0                	add    %edx,%eax
f0109a3f:	48                   	dec    %eax
f0109a40:	89 45 80             	mov    %eax,-0x80(%ebp)
f0109a43:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109a46:	ba 00 00 00 00       	mov    $0x0,%edx
f0109a4b:	f7 75 84             	divl   -0x7c(%ebp)
f0109a4e:	8b 45 80             	mov    -0x80(%ebp),%eax
f0109a51:	29 d0                	sub    %edx,%eax
f0109a53:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f0109a59:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109a5c:	2b 45 88             	sub    -0x78(%ebp),%eax
f0109a5f:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			memset(ptr_temp_page , 0, PAGE_SIZE);
f0109a65:	a1 64 51 55 f0       	mov    0xf0555164,%eax
f0109a6a:	83 ec 04             	sub    $0x4,%esp
f0109a6d:	68 00 10 00 00       	push   $0x1000
f0109a72:	6a 00                	push   $0x0
f0109a74:	50                   	push   %eax
f0109a75:	e8 a7 6c 01 00       	call   f0120721 <memset>
f0109a7a:	83 c4 10             	add    $0x10,%esp
			uint8 *src_ptr =  (uint8*) dataSrc_va;
f0109a7d:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0109a80:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f0109a83:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0109a89:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0109a8f:	01 d0                	add    %edx,%eax
f0109a91:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109a94:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109a97:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109a9a:	eb 13                	jmp    f0109aaf <env_create+0x33e>
			{
				*dst_ptr = *src_ptr ;
f0109a9c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109a9f:	8a 10                	mov    (%eax),%dl
f0109aa1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109aa4:	88 10                	mov    %dl,(%eax)

			memset(ptr_temp_page , 0, PAGE_SIZE);
			uint8 *src_ptr =  (uint8*) dataSrc_va;
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f0109aa6:	ff 45 cc             	incl   -0x34(%ebp)
f0109aa9:	ff 45 d4             	incl   -0x2c(%ebp)
f0109aac:	ff 45 d0             	incl   -0x30(%ebp)
f0109aaf:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109ab2:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f0109ab8:	72 e2                	jb     f0109a9c <env_create+0x32b>
			{
				*dst_ptr = *src_ptr ;
			}

			if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109aba:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0109ac0:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109ac6:	83 ec 04             	sub    $0x4,%esp
f0109ac9:	52                   	push   %edx
f0109aca:	ff 75 88             	pushl  -0x78(%ebp)
f0109acd:	50                   	push   %eax
f0109ace:	e8 76 a3 ff ff       	call   f0103e49 <pf_add_env_page>
f0109ad3:	83 c4 10             	add    $0x10,%esp
f0109ad6:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109ad9:	75 17                	jne    f0109af2 <env_create+0x381>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109adb:	83 ec 04             	sub    $0x4,%esp
f0109ade:	68 10 54 12 f0       	push   $0xf0125410
f0109ae3:	68 f2 00 00 00       	push   $0xf2
f0109ae8:	68 c3 53 12 f0       	push   $0xf01253c3
f0109aed:	e8 28 68 ff ff       	call   f010031a <_panic>
			//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");


			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f0109af2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109af5:	8b 50 04             	mov    0x4(%eax),%edx
f0109af8:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109afb:	01 d0                	add    %edx,%eax
f0109afd:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0109b03:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0109b09:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109b0e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f0109b14:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109b17:	8b 50 04             	mov    0x4(%eax),%edx
f0109b1a:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109b1d:	01 d0                	add    %edx,%eax
f0109b1f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109b25:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0109b2b:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109b2e:	eb 43                	jmp    f0109b73 <env_create+0x402>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f0109b30:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0109b33:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109b39:	83 ec 04             	sub    $0x4,%esp
f0109b3c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0109b3f:	52                   	push   %edx
f0109b40:	50                   	push   %eax
f0109b41:	e8 03 a3 ff ff       	call   f0103e49 <pf_add_env_page>
f0109b46:	83 c4 10             	add    $0x10,%esp
f0109b49:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109b4c:	75 17                	jne    f0109b65 <env_create+0x3f4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109b4e:	83 ec 04             	sub    $0x4,%esp
f0109b51:	68 10 54 12 f0       	push   $0xf0125410
f0109b56:	68 ff 00 00 00       	push   $0xff
f0109b5b:	68 c3 53 12 f0       	push   $0xf01253c3
f0109b60:	e8 b5 67 ff ff       	call   f010031a <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f0109b65:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109b6c:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f0109b73:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109b76:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f0109b7c:	72 b2                	jb     f0109b30 <env_create+0x3bf>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f0109b7e:	a1 64 51 55 f0       	mov    0xf0555164,%eax
f0109b83:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f0109b86:	83 ec 04             	sub    $0x4,%esp
f0109b89:	68 00 10 00 00       	push   $0x1000
f0109b8e:	6a 00                	push   $0x0
f0109b90:	ff 75 d0             	pushl  -0x30(%ebp)
f0109b93:	e8 89 6b 01 00       	call   f0120721 <memset>
f0109b98:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109b9b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0109ba1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0109ba4:	eb 13                	jmp    f0109bb9 <env_create+0x448>
			{
				*dst_ptr = *src_ptr;
f0109ba6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0109ba9:	8a 10                	mov    (%eax),%dl
f0109bab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0109bae:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f0109bb0:	ff 45 cc             	incl   -0x34(%ebp)
f0109bb3:	ff 45 d4             	incl   -0x2c(%ebp)
f0109bb6:	ff 45 d0             	incl   -0x30(%ebp)
f0109bb9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109bbc:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f0109bc2:	72 e2                	jb     f0109ba6 <env_create+0x435>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f0109bc4:	8b 15 64 51 55 f0    	mov    0xf0555164,%edx
f0109bca:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109bd0:	83 ec 04             	sub    $0x4,%esp
f0109bd3:	52                   	push   %edx
f0109bd4:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f0109bda:	50                   	push   %eax
f0109bdb:	e8 69 a2 ff ff       	call   f0103e49 <pf_add_env_page>
f0109be0:	83 c4 10             	add    $0x10,%esp
f0109be3:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109be6:	75 17                	jne    f0109bff <env_create+0x48e>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109be8:	83 ec 04             	sub    $0x4,%esp
f0109beb:	68 10 54 12 f0       	push   $0xf0125410
f0109bf0:	68 0e 01 00 00       	push   $0x10e
f0109bf5:	68 c3 53 12 f0       	push   $0xf01253c3
f0109bfa:	e8 1b 67 ff ff       	call   f010031a <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f0109bff:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f0109c06:	10 00 00 
f0109c09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109c0c:	8b 50 04             	mov    0x4(%eax),%edx
f0109c0f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109c12:	01 c2                	add    %eax,%edx
f0109c14:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f0109c1a:	01 d0                	add    %edx,%eax
f0109c1c:	48                   	dec    %eax
f0109c1d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f0109c23:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109c29:	ba 00 00 00 00       	mov    $0x0,%edx
f0109c2e:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f0109c34:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0109c3a:	29 d0                	sub    %edx,%eax
f0109c3c:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f0109c3f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109c42:	8b 50 08             	mov    0x8(%eax),%edx
f0109c45:	8b 45 90             	mov    -0x70(%ebp),%eax
f0109c48:	01 d0                	add    %edx,%eax
f0109c4a:	2b 45 c8             	sub    -0x38(%ebp),%eax
f0109c4d:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109c53:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0109c5a:	eb 41                	jmp    f0109c9d <env_create+0x52c>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f0109c5c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109c62:	83 ec 04             	sub    $0x4,%esp
f0109c65:	6a 01                	push   $0x1
f0109c67:	ff 75 c8             	pushl  -0x38(%ebp)
f0109c6a:	50                   	push   %eax
f0109c6b:	e8 ab a0 ff ff       	call   f0103d1b <pf_add_empty_env_page>
f0109c70:	83 c4 10             	add    $0x10,%esp
f0109c73:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0109c76:	75 17                	jne    f0109c8f <env_create+0x51e>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f0109c78:	83 ec 04             	sub    $0x4,%esp
f0109c7b:	68 10 54 12 f0       	push   $0xf0125410
f0109c80:	68 1b 01 00 00       	push   $0x11b
f0109c85:	68 c3 53 12 f0       	push   $0xf01253c3
f0109c8a:	e8 8b 66 ff ff       	call   f010031a <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f0109c8f:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f0109c96:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f0109c9d:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f0109ca4:	10 00 00 
f0109ca7:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f0109cad:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f0109cb3:	01 d0                	add    %edx,%eax
f0109cb5:	48                   	dec    %eax
f0109cb6:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f0109cbc:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109cc2:	ba 00 00 00 00       	mov    $0x0,%edx
f0109cc7:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f0109ccd:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0109cd3:	29 d0                	sub    %edx,%eax
f0109cd5:	89 c2                	mov    %eax,%edx
f0109cd7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0109cda:	39 c2                	cmp    %eax,%edx
f0109cdc:	0f 87 7a ff ff ff    	ja     f0109c5c <env_create+0x4eb>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f0109ce2:	83 ec 08             	sub    $0x8,%esp
f0109ce5:	ff 75 b8             	pushl  -0x48(%ebp)
f0109ce8:	ff 75 e4             	pushl  -0x1c(%ebp)
f0109ceb:	e8 6e 1b 00 00       	call   f010b85e <PROGRAM_SEGMENT_NEXT>
f0109cf0:	83 c4 10             	add    $0x10,%esp
f0109cf3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109cf6:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109cfa:	0f 85 d2 fc ff ff    	jne    f01099d2 <env_create+0x261>
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
f0109d00:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		for(;i<(e->page_WS_max_size); i++)
f0109d07:	e9 a0 00 00 00       	jmp    f0109dac <env_create+0x63b>
		{
			if(e->ptr_pageWorkingSet[i].empty == 0)
f0109d0c:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109d12:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0109d15:	89 d0                	mov    %edx,%eax
f0109d17:	01 c0                	add    %eax,%eax
f0109d19:	01 d0                	add    %edx,%eax
f0109d1b:	c1 e0 03             	shl    $0x3,%eax
f0109d1e:	01 c8                	add    %ecx,%eax
f0109d20:	05 8c 00 00 00       	add    $0x8c,%eax
f0109d25:	8a 00                	mov    (%eax),%al
f0109d27:	84 c0                	test   %al,%al
f0109d29:	75 7e                	jne    f0109da9 <env_create+0x638>
			{
				uint32 virtual_address = e->ptr_pageWorkingSet[i].virtual_address;
f0109d2b:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109d31:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0109d34:	89 d0                	mov    %edx,%eax
f0109d36:	01 c0                	add    %eax,%eax
f0109d38:	01 d0                	add    %edx,%eax
f0109d3a:	c1 e0 03             	shl    $0x3,%eax
f0109d3d:	01 c8                	add    %ecx,%eax
f0109d3f:	05 88 00 00 00       	add    $0x88,%eax
f0109d44:	8b 00                	mov    (%eax),%eax
f0109d46:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
				uint32* ptr_page_table;

				//Here, page tables of all working set pages should be exist in memory
				//So, get_page_table should return the existing table
				get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f0109d4c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109d52:	8b 40 64             	mov    0x64(%eax),%eax
f0109d55:	83 ec 04             	sub    $0x4,%esp
f0109d58:	8d 95 1c ff ff ff    	lea    -0xe4(%ebp),%edx
f0109d5e:	52                   	push   %edx
f0109d5f:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f0109d65:	50                   	push   %eax
f0109d66:	e8 a3 e3 ff ff       	call   f010810e <get_page_table>
f0109d6b:	83 c4 10             	add    $0x10,%esp
				ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f0109d6e:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f0109d74:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f0109d7a:	c1 ea 0c             	shr    $0xc,%edx
f0109d7d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d83:	c1 e2 02             	shl    $0x2,%edx
f0109d86:	01 d0                	add    %edx,%eax
f0109d88:	8b 95 1c ff ff ff    	mov    -0xe4(%ebp),%edx
f0109d8e:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f0109d94:	c1 e9 0c             	shr    $0xc,%ecx
f0109d97:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109d9d:	c1 e1 02             	shl    $0x2,%ecx
f0109da0:	01 ca                	add    %ecx,%edx
f0109da2:	8b 12                	mov    (%edx),%edx
f0109da4:	83 e2 bf             	and    $0xffffffbf,%edx
f0109da7:	89 10                	mov    %edx,(%eax)
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
		}
#else
		int i=0;
		for(;i<(e->page_WS_max_size); i++)
f0109da9:	ff 45 c4             	incl   -0x3c(%ebp)
f0109dac:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109db2:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0109db8:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0109dbb:	39 c2                	cmp    %eax,%edx
f0109dbd:	0f 87 49 ff ff ff    	ja     f0109d0c <env_create+0x59b>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f0109dc3:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0109dc6:	8b 50 08             	mov    0x8(%eax),%edx
f0109dc9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109dcf:	83 ec 08             	sub    $0x8,%esp
f0109dd2:	52                   	push   %edx
f0109dd3:	50                   	push   %eax
f0109dd4:	e8 45 1a 00 00       	call   f010b81e <set_environment_entry_point>
f0109dd9:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f0109ddc:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109de2:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f0109de9:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f0109df0:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f0109df3:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f0109dfa:	e9 27 05 00 00       	jmp    f010a326 <env_create+0xbb5>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f0109dff:	c7 85 18 ff ff ff 00 	movl   $0x0,-0xe8(%ebp)
f0109e06:	00 00 00 
			allocate_frame(&pp);
f0109e09:	83 ec 0c             	sub    $0xc,%esp
f0109e0c:	8d 85 18 ff ff ff    	lea    -0xe8(%ebp),%eax
f0109e12:	50                   	push   %eax
f0109e13:	e8 b9 e0 ff ff       	call   f0107ed1 <allocate_frame>
f0109e18:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f0109e1b:	8b 95 18 ff ff ff    	mov    -0xe8(%ebp),%edx
f0109e21:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e27:	8b 40 64             	mov    0x64(%eax),%eax
f0109e2a:	6a 06                	push   $0x6
f0109e2c:	ff 75 c0             	pushl  -0x40(%ebp)
f0109e2f:	52                   	push   %edx
f0109e30:	50                   	push   %eax
f0109e31:	e8 af e6 ff ff       	call   f01084e5 <loadtime_map_frame>
f0109e36:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f0109e39:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0109e3c:	83 ec 04             	sub    $0x4,%esp
f0109e3f:	68 00 10 00 00       	push   $0x1000
f0109e44:	6a 00                	push   $0x0
f0109e46:	50                   	push   %eax
f0109e47:	e8 d5 68 01 00       	call   f0120721 <memset>
f0109e4c:	83 c4 10             	add    $0x10,%esp
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
					}
				}
#else
				env_page_ws_set_entry(e, e->page_last_WS_index, (uint32) stackVa) ;
f0109e4f:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e55:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f0109e5b:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e61:	83 ec 04             	sub    $0x4,%esp
f0109e64:	ff 75 c0             	pushl  -0x40(%ebp)
f0109e67:	52                   	push   %edx
f0109e68:	50                   	push   %eax
f0109e69:	e8 ae ec ff ff       	call   f0108b1c <env_page_ws_set_entry>
f0109e6e:	83 c4 10             	add    $0x10,%esp
				uint32 lastWSIndex = e->page_last_WS_index ++;
f0109e71:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109e77:	8b 82 58 d5 01 00    	mov    0x1d558(%edx),%eax
f0109e7d:	8d 48 01             	lea    0x1(%eax),%ecx
f0109e80:	89 8a 58 d5 01 00    	mov    %ecx,0x1d558(%edx)
f0109e86:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
				e->page_last_WS_index %= (e->page_WS_max_size);
f0109e8c:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109e92:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0109e98:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f0109e9e:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109ea4:	8b 9a 84 00 00 00    	mov    0x84(%edx),%ebx
f0109eaa:	ba 00 00 00 00       	mov    $0x0,%edx
f0109eaf:	f7 f3                	div    %ebx
f0109eb1:	89 d0                	mov    %edx,%eax
f0109eb3:	89 81 58 d5 01 00    	mov    %eax,0x1d558(%ecx)

				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0109eb9:	83 ec 0c             	sub    $0xc,%esp
f0109ebc:	6a 02                	push   $0x2
f0109ebe:	e8 ac 44 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f0109ec3:	83 c4 10             	add    $0x10,%esp
f0109ec6:	85 c0                	test   %eax,%eax
f0109ec8:	0f 84 34 04 00 00    	je     f010a302 <env_create+0xb91>
				{
					LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f0109ece:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109ed4:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109eda:	89 d0                	mov    %edx,%eax
f0109edc:	01 c0                	add    %eax,%eax
f0109ede:	01 d0                	add    %edx,%eax
f0109ee0:	c1 e0 03             	shl    $0x3,%eax
f0109ee3:	83 e8 80             	sub    $0xffffff80,%eax
f0109ee6:	01 c8                	add    %ecx,%eax
f0109ee8:	83 c0 08             	add    $0x8,%eax
f0109eeb:	85 c0                	test   %eax,%eax
f0109eed:	75 17                	jne    f0109f06 <env_create+0x795>
f0109eef:	83 ec 04             	sub    $0x4,%esp
f0109ef2:	68 55 54 12 f0       	push   $0xf0125455
f0109ef7:	68 7a 01 00 00       	push   $0x17a
f0109efc:	68 c3 53 12 f0       	push   $0xf01253c3
f0109f01:	e8 14 64 ff ff       	call   f010031a <_panic>
f0109f06:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109f0c:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109f12:	89 d0                	mov    %edx,%eax
f0109f14:	01 c0                	add    %eax,%eax
f0109f16:	01 d0                	add    %edx,%eax
f0109f18:	c1 e0 03             	shl    $0x3,%eax
f0109f1b:	01 c8                	add    %ecx,%eax
f0109f1d:	05 98 00 00 00       	add    $0x98,%eax
f0109f22:	8b 00                	mov    (%eax),%eax
f0109f24:	85 c0                	test   %eax,%eax
f0109f26:	74 41                	je     f0109f69 <env_create+0x7f8>
f0109f28:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109f2e:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109f34:	89 d0                	mov    %edx,%eax
f0109f36:	01 c0                	add    %eax,%eax
f0109f38:	01 d0                	add    %edx,%eax
f0109f3a:	c1 e0 03             	shl    $0x3,%eax
f0109f3d:	01 c8                	add    %ecx,%eax
f0109f3f:	05 98 00 00 00       	add    $0x98,%eax
f0109f44:	8b 10                	mov    (%eax),%edx
f0109f46:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0109f4c:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f0109f52:	89 c8                	mov    %ecx,%eax
f0109f54:	01 c0                	add    %eax,%eax
f0109f56:	01 c8                	add    %ecx,%eax
f0109f58:	c1 e0 03             	shl    $0x3,%eax
f0109f5b:	01 d8                	add    %ebx,%eax
f0109f5d:	05 9c 00 00 00       	add    $0x9c,%eax
f0109f62:	8b 00                	mov    (%eax),%eax
f0109f64:	89 42 14             	mov    %eax,0x14(%edx)
f0109f67:	eb 2a                	jmp    f0109f93 <env_create+0x822>
f0109f69:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109f6f:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0109f75:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f0109f7b:	89 c8                	mov    %ecx,%eax
f0109f7d:	01 c0                	add    %eax,%eax
f0109f7f:	01 c8                	add    %ecx,%eax
f0109f81:	c1 e0 03             	shl    $0x3,%eax
f0109f84:	01 d8                	add    %ebx,%eax
f0109f86:	05 9c 00 00 00       	add    $0x9c,%eax
f0109f8b:	8b 00                	mov    (%eax),%eax
f0109f8d:	89 82 4c d5 01 00    	mov    %eax,0x1d54c(%edx)
f0109f93:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109f99:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109f9f:	89 d0                	mov    %edx,%eax
f0109fa1:	01 c0                	add    %eax,%eax
f0109fa3:	01 d0                	add    %edx,%eax
f0109fa5:	c1 e0 03             	shl    $0x3,%eax
f0109fa8:	01 c8                	add    %ecx,%eax
f0109faa:	05 9c 00 00 00       	add    $0x9c,%eax
f0109faf:	8b 00                	mov    (%eax),%eax
f0109fb1:	85 c0                	test   %eax,%eax
f0109fb3:	74 41                	je     f0109ff6 <env_create+0x885>
f0109fb5:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f0109fbb:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f0109fc1:	89 d0                	mov    %edx,%eax
f0109fc3:	01 c0                	add    %eax,%eax
f0109fc5:	01 d0                	add    %edx,%eax
f0109fc7:	c1 e0 03             	shl    $0x3,%eax
f0109fca:	01 c8                	add    %ecx,%eax
f0109fcc:	05 9c 00 00 00       	add    $0x9c,%eax
f0109fd1:	8b 10                	mov    (%eax),%edx
f0109fd3:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f0109fd9:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f0109fdf:	89 c8                	mov    %ecx,%eax
f0109fe1:	01 c0                	add    %eax,%eax
f0109fe3:	01 c8                	add    %ecx,%eax
f0109fe5:	c1 e0 03             	shl    $0x3,%eax
f0109fe8:	01 d8                	add    %ebx,%eax
f0109fea:	05 98 00 00 00       	add    $0x98,%eax
f0109fef:	8b 00                	mov    (%eax),%eax
f0109ff1:	89 42 10             	mov    %eax,0x10(%edx)
f0109ff4:	eb 2a                	jmp    f010a020 <env_create+0x8af>
f0109ff6:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f0109ffc:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a002:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a008:	89 c8                	mov    %ecx,%eax
f010a00a:	01 c0                	add    %eax,%eax
f010a00c:	01 c8                	add    %ecx,%eax
f010a00e:	c1 e0 03             	shl    $0x3,%eax
f010a011:	01 d8                	add    %ebx,%eax
f010a013:	05 98 00 00 00       	add    $0x98,%eax
f010a018:	8b 00                	mov    (%eax),%eax
f010a01a:	89 82 48 d5 01 00    	mov    %eax,0x1d548(%edx)
f010a020:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a026:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a02c:	89 d0                	mov    %edx,%eax
f010a02e:	01 c0                	add    %eax,%eax
f010a030:	01 d0                	add    %edx,%eax
f010a032:	c1 e0 03             	shl    $0x3,%eax
f010a035:	01 c8                	add    %ecx,%eax
f010a037:	05 98 00 00 00       	add    $0x98,%eax
f010a03c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a042:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a048:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a04e:	89 d0                	mov    %edx,%eax
f010a050:	01 c0                	add    %eax,%eax
f010a052:	01 d0                	add    %edx,%eax
f010a054:	c1 e0 03             	shl    $0x3,%eax
f010a057:	01 c8                	add    %ecx,%eax
f010a059:	05 9c 00 00 00       	add    $0x9c,%eax
f010a05e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a064:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a06a:	8b 90 54 d5 01 00    	mov    0x1d554(%eax),%edx
f010a070:	4a                   	dec    %edx
f010a071:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010a077:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a07d:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a083:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a089:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010a08f:	39 c2                	cmp    %eax,%edx
f010a091:	0f 83 38 01 00 00    	jae    f010a1cf <env_create+0xa5e>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a097:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a09d:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a0a3:	89 d0                	mov    %edx,%eax
f010a0a5:	01 c0                	add    %eax,%eax
f010a0a7:	01 d0                	add    %edx,%eax
f010a0a9:	c1 e0 03             	shl    $0x3,%eax
f010a0ac:	83 e8 80             	sub    $0xffffff80,%eax
f010a0af:	01 c8                	add    %ecx,%eax
f010a0b1:	83 c0 08             	add    $0x8,%eax
f010a0b4:	85 c0                	test   %eax,%eax
f010a0b6:	75 17                	jne    f010a0cf <env_create+0x95e>
f010a0b8:	83 ec 04             	sub    $0x4,%esp
f010a0bb:	68 a0 53 12 f0       	push   $0xf01253a0
f010a0c0:	68 7f 01 00 00       	push   $0x17f
f010a0c5:	68 c3 53 12 f0       	push   $0xf01253c3
f010a0ca:	e8 4b 62 ff ff       	call   f010031a <_panic>
f010a0cf:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a0d5:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a0db:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010a0e1:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a0e7:	89 d8                	mov    %ebx,%eax
f010a0e9:	01 c0                	add    %eax,%eax
f010a0eb:	01 d8                	add    %ebx,%eax
f010a0ed:	c1 e0 03             	shl    $0x3,%eax
f010a0f0:	01 d0                	add    %edx,%eax
f010a0f2:	05 98 00 00 00       	add    $0x98,%eax
f010a0f7:	89 08                	mov    %ecx,(%eax)
f010a0f9:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a0ff:	89 c8                	mov    %ecx,%eax
f010a101:	01 c0                	add    %eax,%eax
f010a103:	01 c8                	add    %ecx,%eax
f010a105:	c1 e0 03             	shl    $0x3,%eax
f010a108:	01 d0                	add    %edx,%eax
f010a10a:	05 98 00 00 00       	add    $0x98,%eax
f010a10f:	8b 00                	mov    (%eax),%eax
f010a111:	85 c0                	test   %eax,%eax
f010a113:	74 2e                	je     f010a143 <env_create+0x9d2>
f010a115:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a11b:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010a121:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a127:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a12d:	89 c8                	mov    %ecx,%eax
f010a12f:	01 c0                	add    %eax,%eax
f010a131:	01 c8                	add    %ecx,%eax
f010a133:	c1 e0 03             	shl    $0x3,%eax
f010a136:	83 e8 80             	sub    $0xffffff80,%eax
f010a139:	01 d8                	add    %ebx,%eax
f010a13b:	83 c0 08             	add    $0x8,%eax
f010a13e:	89 42 14             	mov    %eax,0x14(%edx)
f010a141:	eb 29                	jmp    f010a16c <env_create+0x9fb>
f010a143:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a149:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a14f:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a155:	89 c8                	mov    %ecx,%eax
f010a157:	01 c0                	add    %eax,%eax
f010a159:	01 c8                	add    %ecx,%eax
f010a15b:	c1 e0 03             	shl    $0x3,%eax
f010a15e:	83 e8 80             	sub    $0xffffff80,%eax
f010a161:	01 d8                	add    %ebx,%eax
f010a163:	83 c0 08             	add    $0x8,%eax
f010a166:	89 82 14 da 01 00    	mov    %eax,0x1da14(%edx)
f010a16c:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a172:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a178:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a17e:	89 c8                	mov    %ecx,%eax
f010a180:	01 c0                	add    %eax,%eax
f010a182:	01 c8                	add    %ecx,%eax
f010a184:	c1 e0 03             	shl    $0x3,%eax
f010a187:	83 e8 80             	sub    $0xffffff80,%eax
f010a18a:	01 d8                	add    %ebx,%eax
f010a18c:	83 c0 08             	add    $0x8,%eax
f010a18f:	89 82 10 da 01 00    	mov    %eax,0x1da10(%edx)
f010a195:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a19b:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1a1:	89 d0                	mov    %edx,%eax
f010a1a3:	01 c0                	add    %eax,%eax
f010a1a5:	01 d0                	add    %edx,%eax
f010a1a7:	c1 e0 03             	shl    $0x3,%eax
f010a1aa:	01 c8                	add    %ecx,%eax
f010a1ac:	05 9c 00 00 00       	add    $0x9c,%eax
f010a1b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a1b7:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a1bd:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010a1c3:	42                   	inc    %edx
f010a1c4:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010a1ca:	e9 33 01 00 00       	jmp    f010a302 <env_create+0xb91>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[lastWSIndex]));
f010a1cf:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a1d5:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a1db:	89 d0                	mov    %edx,%eax
f010a1dd:	01 c0                	add    %eax,%eax
f010a1df:	01 d0                	add    %edx,%eax
f010a1e1:	c1 e0 03             	shl    $0x3,%eax
f010a1e4:	83 e8 80             	sub    $0xffffff80,%eax
f010a1e7:	01 c8                	add    %ecx,%eax
f010a1e9:	83 c0 08             	add    $0x8,%eax
f010a1ec:	85 c0                	test   %eax,%eax
f010a1ee:	75 17                	jne    f010a207 <env_create+0xa96>
f010a1f0:	83 ec 04             	sub    $0x4,%esp
f010a1f3:	68 a0 53 12 f0       	push   $0xf01253a0
f010a1f8:	68 83 01 00 00       	push   $0x183
f010a1fd:	68 c3 53 12 f0       	push   $0xf01253c3
f010a202:	e8 13 61 ff ff       	call   f010031a <_panic>
f010a207:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a20d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a213:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010a219:	8b 9d 4c ff ff ff    	mov    -0xb4(%ebp),%ebx
f010a21f:	89 d8                	mov    %ebx,%eax
f010a221:	01 c0                	add    %eax,%eax
f010a223:	01 d8                	add    %ebx,%eax
f010a225:	c1 e0 03             	shl    $0x3,%eax
f010a228:	01 d0                	add    %edx,%eax
f010a22a:	05 98 00 00 00       	add    $0x98,%eax
f010a22f:	89 08                	mov    %ecx,(%eax)
f010a231:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a237:	89 c8                	mov    %ecx,%eax
f010a239:	01 c0                	add    %eax,%eax
f010a23b:	01 c8                	add    %ecx,%eax
f010a23d:	c1 e0 03             	shl    $0x3,%eax
f010a240:	01 d0                	add    %edx,%eax
f010a242:	05 98 00 00 00       	add    $0x98,%eax
f010a247:	8b 00                	mov    (%eax),%eax
f010a249:	85 c0                	test   %eax,%eax
f010a24b:	74 2e                	je     f010a27b <env_create+0xb0a>
f010a24d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a253:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010a259:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a25f:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a265:	89 c8                	mov    %ecx,%eax
f010a267:	01 c0                	add    %eax,%eax
f010a269:	01 c8                	add    %ecx,%eax
f010a26b:	c1 e0 03             	shl    $0x3,%eax
f010a26e:	83 e8 80             	sub    $0xffffff80,%eax
f010a271:	01 d8                	add    %ebx,%eax
f010a273:	83 c0 08             	add    $0x8,%eax
f010a276:	89 42 14             	mov    %eax,0x14(%edx)
f010a279:	eb 29                	jmp    f010a2a4 <env_create+0xb33>
f010a27b:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a281:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a287:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a28d:	89 c8                	mov    %ecx,%eax
f010a28f:	01 c0                	add    %eax,%eax
f010a291:	01 c8                	add    %ecx,%eax
f010a293:	c1 e0 03             	shl    $0x3,%eax
f010a296:	83 e8 80             	sub    $0xffffff80,%eax
f010a299:	01 d8                	add    %ebx,%eax
f010a29b:	83 c0 08             	add    $0x8,%eax
f010a29e:	89 82 24 da 01 00    	mov    %eax,0x1da24(%edx)
f010a2a4:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f010a2aa:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f010a2b0:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f010a2b6:	89 c8                	mov    %ecx,%eax
f010a2b8:	01 c0                	add    %eax,%eax
f010a2ba:	01 c8                	add    %ecx,%eax
f010a2bc:	c1 e0 03             	shl    $0x3,%eax
f010a2bf:	83 e8 80             	sub    $0xffffff80,%eax
f010a2c2:	01 d8                	add    %ebx,%eax
f010a2c4:	83 c0 08             	add    $0x8,%eax
f010a2c7:	89 82 20 da 01 00    	mov    %eax,0x1da20(%edx)
f010a2cd:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f010a2d3:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f010a2d9:	89 d0                	mov    %edx,%eax
f010a2db:	01 c0                	add    %eax,%eax
f010a2dd:	01 d0                	add    %edx,%eax
f010a2df:	c1 e0 03             	shl    $0x3,%eax
f010a2e2:	01 c8                	add    %ecx,%eax
f010a2e4:	05 9c 00 00 00       	add    $0x9c,%eax
f010a2e9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010a2ef:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a2f5:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f010a2fb:	42                   	inc    %edx
f010a2fc:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010a302:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a308:	83 ec 04             	sub    $0x4,%esp
f010a30b:	6a 01                	push   $0x1
f010a30d:	ff 75 c0             	pushl  -0x40(%ebp)
f010a310:	50                   	push   %eax
f010a311:	e8 05 9a ff ff       	call   f0103d1b <pf_add_empty_env_page>
f010a316:	83 c4 10             	add    $0x10,%esp
f010a319:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010a31f:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010a326:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010a329:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010a32f:	0f 83 ca fa ff ff    	jae    f0109dff <env_create+0x68e>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a335:	83 ec 0c             	sub    $0xc,%esp
f010a338:	6a 02                	push   $0x2
f010a33a:	e8 30 40 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f010a33f:	83 c4 10             	add    $0x10,%esp
f010a342:	85 c0                	test   %eax,%eax
f010a344:	74 72                	je     f010a3b8 <env_create+0xc47>
		{
			struct WorkingSetElement * elm = NULL;
f010a346:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010a34d:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a353:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f010a359:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a35c:	eb 2b                	jmp    f010a389 <env_create+0xc18>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010a35e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010a361:	8b 10                	mov    (%eax),%edx
f010a363:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a369:	8b 40 64             	mov    0x64(%eax),%eax
f010a36c:	6a 01                	push   $0x1
f010a36e:	6a 00                	push   $0x0
f010a370:	52                   	push   %edx
f010a371:	50                   	push   %eax
f010a372:	e8 b2 e4 ff ff       	call   f0108829 <pt_set_page_permissions>
f010a377:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010a37a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a380:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a386:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010a389:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f010a38f:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a393:	74 08                	je     f010a39d <env_create+0xc2c>
f010a395:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010a398:	8b 52 10             	mov    0x10(%edx),%edx
f010a39b:	eb 05                	jmp    f010a3a2 <env_create+0xc31>
f010a39d:	ba 00 00 00 00       	mov    $0x0,%edx
f010a3a2:	89 90 28 da 01 00    	mov    %edx,0x1da28(%eax)
f010a3a8:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f010a3ae:	85 c0                	test   %eax,%eax
f010a3b0:	75 ac                	jne    f010a35e <env_create+0xbed>
f010a3b2:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010a3b6:	75 a6                	jne    f010a35e <env_create+0xbed>
f010a3b8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010a3bb:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010a3be:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010a3c1:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010a3c4:	e8 4a cb ff ff       	call   f0106f13 <popcli>
//		env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010a3c9:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
}
f010a3cf:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010a3d2:	5b                   	pop    %ebx
f010a3d3:	5e                   	pop    %esi
f010a3d4:	5f                   	pop    %edi
f010a3d5:	5d                   	pop    %ebp
f010a3d6:	c3                   	ret    

f010a3d7 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010a3d7:	55                   	push   %ebp
f010a3d8:	89 e5                	mov    %esp,%ebp
f010a3da:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_spinlock(&ProcessQueues.qlock);
f010a3dd:	83 ec 0c             	sub    $0xc,%esp
f010a3e0:	68 60 24 55 f0       	push   $0xf0552460
f010a3e5:	e8 1d 44 00 00       	call   f010e807 <release_spinlock>
f010a3ea:	83 c4 10             	add    $0x10,%esp

	if (first)
f010a3ed:	a1 60 99 17 f0       	mov    0xf0179960,%eax
f010a3f2:	85 c0                	test   %eax,%eax
f010a3f4:	74 30                	je     f010a426 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010a3f6:	e8 76 00 00 00       	call   f010a471 <get_cpu_proc>
f010a3fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010a3fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a401:	8b 40 10             	mov    0x10(%eax),%eax
f010a404:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a407:	83 c2 20             	add    $0x20,%edx
f010a40a:	83 ec 04             	sub    $0x4,%esp
f010a40d:	50                   	push   %eax
f010a40e:	52                   	push   %edx
f010a40f:	68 73 54 12 f0       	push   $0xf0125473
f010a414:	e8 53 6b ff ff       	call   f0100f6c <cprintf>
f010a419:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010a41c:	c7 05 60 99 17 f0 00 	movl   $0x0,0xf0179960
f010a423:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010a426:	90                   	nop
f010a427:	c9                   	leave  
f010a428:	c3                   	ret    

f010a429 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010a429:	55                   	push   %ebp
f010a42a:	89 e5                	mov    %esp,%ebp
	/*REMOVE THIS LINE BEFORE START CODING*/
	return;
f010a42c:	90                   	nop

	// [10] free the environment (return it back to the free environment list)
	/*(ALREADY DONE for you)*/
	free_environment(e); /*(ALREADY DONE for you)*/ // (frees the environment (returns it back to the free environment list))
	/*========================*/
}
f010a42d:	5d                   	pop    %ebp
f010a42e:	c3                   	ret    

f010a42f <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010a42f:	55                   	push   %ebp
f010a430:	89 e5                	mov    %esp,%ebp
f010a432:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010a435:	e8 37 00 00 00       	call   f010a471 <get_cpu_proc>
f010a43a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010a43d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a441:	75 19                	jne    f010a45c <env_exit+0x2d>
f010a443:	68 89 54 12 f0       	push   $0xf0125489
f010a448:	68 99 54 12 f0       	push   $0xf0125499
f010a44d:	68 ea 01 00 00       	push   $0x1ea
f010a452:	68 c3 53 12 f0       	push   $0xf01253c3
f010a457:	e8 be 5e ff ff       	call   f010031a <_panic>
	sched_exit_env(cur_env->env_id);
f010a45c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a45f:	8b 40 10             	mov    0x10(%eax),%eax
f010a462:	83 ec 0c             	sub    $0xc,%esp
f010a465:	50                   	push   %eax
f010a466:	e8 48 b0 ff ff       	call   f01054b3 <sched_exit_env>
f010a46b:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch
	//fos_scheduler();
	//context_switch(&(curenv->context), mycpu()->scheduler);
}
f010a46e:	90                   	nop
f010a46f:	c9                   	leave  
f010a470:	c3                   	ret    

f010a471 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010a471:	55                   	push   %ebp
f010a472:	89 e5                	mov    %esp,%ebp
f010a474:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010a477:	e8 45 ca ff ff       	call   f0106ec1 <pushcli>
	c = mycpu();
f010a47c:	e8 7d c9 ff ff       	call   f0106dfe <mycpu>
f010a481:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010a484:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a487:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a48d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010a490:	e8 7e ca ff ff       	call   f0106f13 <popcli>
	return p;
f010a495:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010a498:	c9                   	leave  
f010a499:	c3                   	ret    

f010a49a <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010a49a:	55                   	push   %ebp
f010a49b:	89 e5                	mov    %esp,%ebp
f010a49d:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010a4a0:	e8 1c ca ff ff       	call   f0106ec1 <pushcli>
	c = mycpu();
f010a4a5:	e8 54 c9 ff ff       	call   f0106dfe <mycpu>
f010a4aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010a4ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a4b0:	8b 55 08             	mov    0x8(%ebp),%edx
f010a4b3:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010a4b9:	e8 55 ca ff ff       	call   f0106f13 <popcli>
}
f010a4be:	90                   	nop
f010a4bf:	c9                   	leave  
f010a4c0:	c3                   	ret    

f010a4c1 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010a4c1:	55                   	push   %ebp
f010a4c2:	89 e5                	mov    %esp,%ebp
f010a4c4:	53                   	push   %ebx
f010a4c5:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010a4c8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a4cc:	75 16                	jne    f010a4e4 <envid2env+0x23>
		*env_store = get_cpu_proc();
f010a4ce:	e8 9e ff ff ff       	call   f010a471 <get_cpu_proc>
f010a4d3:	89 c2                	mov    %eax,%edx
f010a4d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a4d8:	89 10                	mov    %edx,(%eax)
		return 0;
f010a4da:	b8 00 00 00 00       	mov    $0x0,%eax
f010a4df:	e9 b6 00 00 00       	jmp    f010a59a <envid2env+0xd9>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010a4e4:	8b 1d 10 1a 55 f0    	mov    0xf0551a10,%ebx
f010a4ea:	83 ec 0c             	sub    $0xc,%esp
f010a4ed:	6a 08                	push   $0x8
f010a4ef:	e8 d6 47 01 00       	call   f011ecca <nearest_pow2_ceil>
f010a4f4:	83 c4 10             	add    $0x10,%esp
f010a4f7:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a4fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4fd:	21 c2                	and    %eax,%edx
f010a4ff:	89 d0                	mov    %edx,%eax
f010a501:	c1 e0 06             	shl    $0x6,%eax
f010a504:	29 d0                	sub    %edx,%eax
f010a506:	c1 e0 02             	shl    $0x2,%eax
f010a509:	01 d0                	add    %edx,%eax
f010a50b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010a512:	01 c8                	add    %ecx,%eax
f010a514:	c1 e0 03             	shl    $0x3,%eax
f010a517:	01 d0                	add    %edx,%eax
f010a519:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010a520:	29 c2                	sub    %eax,%edx
f010a522:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010a529:	89 c2                	mov    %eax,%edx
f010a52b:	89 d0                	mov    %edx,%eax
f010a52d:	01 d8                	add    %ebx,%eax
f010a52f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010a532:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a535:	8b 40 18             	mov    0x18(%eax),%eax
f010a538:	85 c0                	test   %eax,%eax
f010a53a:	74 0b                	je     f010a547 <envid2env+0x86>
f010a53c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a53f:	8b 40 10             	mov    0x10(%eax),%eax
f010a542:	3b 45 08             	cmp    0x8(%ebp),%eax
f010a545:	74 10                	je     f010a557 <envid2env+0x96>
		*env_store = 0;
f010a547:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a54a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a550:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a555:	eb 43                	jmp    f010a59a <envid2env+0xd9>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010a557:	e8 15 ff ff ff       	call   f010a471 <get_cpu_proc>
f010a55c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010a55f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010a563:	74 28                	je     f010a58d <envid2env+0xcc>
f010a565:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a568:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010a56b:	74 20                	je     f010a58d <envid2env+0xcc>
f010a56d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a570:	8b 50 14             	mov    0x14(%eax),%edx
f010a573:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a576:	8b 40 10             	mov    0x10(%eax),%eax
f010a579:	39 c2                	cmp    %eax,%edx
f010a57b:	74 10                	je     f010a58d <envid2env+0xcc>
		*env_store = 0;
f010a57d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a580:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010a586:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010a58b:	eb 0d                	jmp    f010a59a <envid2env+0xd9>
	}

	*env_store = e;
f010a58d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a590:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a593:	89 10                	mov    %edx,(%eax)
	return 0;
f010a595:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a59a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a59d:	c9                   	leave  
f010a59e:	c3                   	ret    

f010a59f <yield>:
// 8) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010a59f:	55                   	push   %ebp
f010a5a0:	89 e5                	mov    %esp,%ebp
f010a5a2:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_spinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010a5a5:	83 ec 0c             	sub    $0xc,%esp
f010a5a8:	68 60 24 55 f0       	push   $0xf0552460
f010a5ad:	e8 ce 41 00 00       	call   f010e780 <acquire_spinlock>
f010a5b2:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010a5b5:	e8 b7 fe ff ff       	call   f010a471 <get_cpu_proc>
f010a5ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010a5bd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a5c1:	75 19                	jne    f010a5dc <yield+0x3d>
f010a5c3:	68 ae 54 12 f0       	push   $0xf01254ae
f010a5c8:	68 99 54 12 f0       	push   $0xf0125499
f010a5cd:	68 49 02 00 00       	push   $0x249
f010a5d2:	68 c3 53 12 f0       	push   $0xf01253c3
f010a5d7:	e8 3e 5d ff ff       	call   f010031a <_panic>
		p->env_status = ENV_READY;
f010a5dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a5df:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010a5e6:	e8 13 00 00 00       	call   f010a5fe <sched>
	}
	release_spinlock(&ProcessQueues.qlock); ////release lock
f010a5eb:	83 ec 0c             	sub    $0xc,%esp
f010a5ee:	68 60 24 55 f0       	push   $0xf0552460
f010a5f3:	e8 0f 42 00 00       	call   f010e807 <release_spinlock>
f010a5f8:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010a5fb:	90                   	nop
f010a5fc:	c9                   	leave  
f010a5fd:	c3                   	ret    

f010a5fe <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010a5fe:	55                   	push   %ebp
f010a5ff:	89 e5                	mov    %esp,%ebp
f010a601:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010a604:	e8 68 fe ff ff       	call   f010a471 <get_cpu_proc>
f010a609:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010a60c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a610:	75 19                	jne    f010a62b <sched+0x2d>
f010a612:	68 ae 54 12 f0       	push   $0xf01254ae
f010a617:	68 99 54 12 f0       	push   $0xf0125499
f010a61c:	68 5d 02 00 00       	push   $0x25d
f010a621:	68 c3 53 12 f0       	push   $0xf01253c3
f010a626:	e8 ef 5c ff ff       	call   f010031a <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_spinlock(&ProcessQueues.qlock))
f010a62b:	83 ec 0c             	sub    $0xc,%esp
f010a62e:	68 60 24 55 f0       	push   $0xf0552460
f010a633:	e8 61 43 00 00       	call   f010e999 <holding_spinlock>
f010a638:	83 c4 10             	add    $0x10,%esp
f010a63b:	85 c0                	test   %eax,%eax
f010a63d:	75 17                	jne    f010a656 <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010a63f:	83 ec 04             	sub    $0x4,%esp
f010a642:	68 b8 54 12 f0       	push   $0xf01254b8
f010a647:	68 61 02 00 00       	push   $0x261
f010a64c:	68 c3 53 12 f0       	push   $0xf01253c3
f010a651:	e8 c4 5c ff ff       	call   f010031a <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010a656:	e8 a3 c7 ff ff       	call   f0106dfe <mycpu>
f010a65b:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a661:	83 f8 01             	cmp    $0x1,%eax
f010a664:	74 20                	je     f010a686 <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010a666:	e8 93 c7 ff ff       	call   f0106dfe <mycpu>
f010a66b:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010a671:	50                   	push   %eax
f010a672:	68 fa 54 12 f0       	push   $0xf01254fa
f010a677:	68 64 02 00 00       	push   $0x264
f010a67c:	68 c3 53 12 f0       	push   $0xf01253c3
f010a681:	e8 94 5c ff ff       	call   f010031a <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010a686:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a689:	8b 40 18             	mov    0x18(%eax),%eax
f010a68c:	83 f8 02             	cmp    $0x2,%eax
f010a68f:	75 17                	jne    f010a6a8 <sched+0xaa>
		panic("sched a running process");
f010a691:	83 ec 04             	sub    $0x4,%esp
f010a694:	68 11 55 12 f0       	push   $0xf0125511
f010a699:	68 67 02 00 00       	push   $0x267
f010a69e:	68 c3 53 12 f0       	push   $0xf01253c3
f010a6a3:	e8 72 5c ff ff       	call   f010031a <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010a6a8:	9c                   	pushf  
f010a6a9:	58                   	pop    %eax
f010a6aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010a6ad:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010a6b0:	25 00 02 00 00       	and    $0x200,%eax
f010a6b5:	85 c0                	test   %eax,%eax
f010a6b7:	74 17                	je     f010a6d0 <sched+0xd2>
		panic("sched is interruptible!");
f010a6b9:	83 ec 04             	sub    $0x4,%esp
f010a6bc:	68 29 55 12 f0       	push   $0xf0125529
f010a6c1:	68 69 02 00 00       	push   $0x269
f010a6c6:	68 c3 53 12 f0       	push   $0xf01253c3
f010a6cb:	e8 4a 5c ff ff       	call   f010031a <_panic>
	intena = mycpu()->intena;
f010a6d0:	e8 29 c7 ff ff       	call   f0106dfe <mycpu>
f010a6d5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010a6db:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010a6de:	e8 1b c7 ff ff       	call   f0106dfe <mycpu>
f010a6e3:	8b 40 04             	mov    0x4(%eax),%eax
f010a6e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a6e9:	83 c2 04             	add    $0x4,%edx
f010a6ec:	83 ec 08             	sub    $0x8,%esp
f010a6ef:	50                   	push   %eax
f010a6f0:	52                   	push   %edx
f010a6f1:	e8 4a a1 ff ff       	call   f0104840 <context_switch>
f010a6f6:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010a6f9:	e8 00 c7 ff ff       	call   f0106dfe <mycpu>
f010a6fe:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a701:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010a707:	90                   	nop
f010a708:	c9                   	leave  
f010a709:	c3                   	ret    

f010a70a <switchkvm>:
// 10) SWITCH VIRTUAL MEMORYs:
//===============================
// [10.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010a70a:	55                   	push   %ebp
f010a70b:	89 e5                	mov    %esp,%ebp
f010a70d:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010a710:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f010a715:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a718:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010a71b:	0f 22 d8             	mov    %eax,%cr3
}
f010a71e:	90                   	nop
f010a71f:	c9                   	leave  
f010a720:	c3                   	ret    

f010a721 <switchuvm>:

// [10.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010a721:	55                   	push   %ebp
f010a722:	89 e5                	mov    %esp,%ebp
f010a724:	53                   	push   %ebx
f010a725:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010a728:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a72c:	75 17                	jne    f010a745 <switchuvm+0x24>
		panic("switchuvm: no process");
f010a72e:	83 ec 04             	sub    $0x4,%esp
f010a731:	68 41 55 12 f0       	push   $0xf0125541
f010a736:	68 7e 02 00 00       	push   $0x27e
f010a73b:	68 c3 53 12 f0       	push   $0xf01253c3
f010a740:	e8 d5 5b ff ff       	call   f010031a <_panic>
	if(proc->kstack == 0)
f010a745:	8b 45 08             	mov    0x8(%ebp),%eax
f010a748:	8b 40 70             	mov    0x70(%eax),%eax
f010a74b:	85 c0                	test   %eax,%eax
f010a74d:	75 17                	jne    f010a766 <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010a74f:	83 ec 04             	sub    $0x4,%esp
f010a752:	68 57 55 12 f0       	push   $0xf0125557
f010a757:	68 80 02 00 00       	push   $0x280
f010a75c:	68 c3 53 12 f0       	push   $0xf01253c3
f010a761:	e8 b4 5b ff ff       	call   f010031a <_panic>
	if(proc->env_page_directory == 0)
f010a766:	8b 45 08             	mov    0x8(%ebp),%eax
f010a769:	8b 40 64             	mov    0x64(%eax),%eax
f010a76c:	85 c0                	test   %eax,%eax
f010a76e:	75 17                	jne    f010a787 <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010a770:	83 ec 04             	sub    $0x4,%esp
f010a773:	68 6c 55 12 f0       	push   $0xf012556c
f010a778:	68 82 02 00 00       	push   $0x282
f010a77d:	68 c3 53 12 f0       	push   $0xf01253c3
f010a782:	e8 93 5b ff ff       	call   f010031a <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010a787:	e8 35 c7 ff ff       	call   f0106ec1 <pushcli>
	struct cpu* c = mycpu();
f010a78c:	e8 6d c6 ff ff       	call   f0106dfe <mycpu>
f010a791:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010a794:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a797:	8b 55 08             	mov    0x8(%ebp),%edx
f010a79a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010a7a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7a3:	83 c0 0c             	add    $0xc,%eax
f010a7a6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7a9:	83 c2 0c             	add    $0xc,%edx
f010a7ac:	c1 ea 10             	shr    $0x10,%edx
f010a7af:	88 d3                	mov    %dl,%bl
f010a7b1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7b4:	83 c2 0c             	add    $0xc,%edx
f010a7b7:	c1 ea 18             	shr    $0x18,%edx
f010a7ba:	88 d1                	mov    %dl,%cl
f010a7bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7bf:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010a7c6:	68 00 
f010a7c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a7cb:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010a7d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7d5:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010a7db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7de:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a7e4:	83 e2 f0             	and    $0xfffffff0,%edx
f010a7e7:	83 ca 09             	or     $0x9,%edx
f010a7ea:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a7f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a7f3:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a7f9:	83 ca 10             	or     $0x10,%edx
f010a7fc:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a802:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a805:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a80b:	83 e2 9f             	and    $0xffffff9f,%edx
f010a80e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a814:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a817:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a81d:	83 ca 80             	or     $0xffffff80,%edx
f010a820:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010a826:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a829:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a82f:	83 e2 f0             	and    $0xfffffff0,%edx
f010a832:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a838:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a83b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a841:	83 e2 ef             	and    $0xffffffef,%edx
f010a844:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a84a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a84d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a853:	83 e2 df             	and    $0xffffffdf,%edx
f010a856:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a85c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a85f:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a865:	83 ca 40             	or     $0x40,%edx
f010a868:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a86e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a871:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010a877:	83 e2 7f             	and    $0x7f,%edx
f010a87a:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010a880:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a883:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010a889:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a88c:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010a892:	83 e2 ef             	and    $0xffffffef,%edx
f010a895:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010a89b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a89e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a8a4:	8b 40 70             	mov    0x70(%eax),%eax
f010a8a7:	05 00 80 00 00       	add    $0x8000,%eax
f010a8ac:	89 c2                	mov    %eax,%edx
f010a8ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8b1:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010a8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8b7:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010a8bd:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010a8c3:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010a8c7:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010a8ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a8cd:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010a8d3:	8b 40 68             	mov    0x68(%eax),%eax
f010a8d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010a8d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a8dc:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010a8df:	e8 2f c6 ff ff       	call   f0106f13 <popcli>
}
f010a8e4:	90                   	nop
f010a8e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a8e8:	c9                   	leave  
f010a8e9:	c3                   	ret    

f010a8ea <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010a8ea:	55                   	push   %ebp
f010a8eb:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010a8ed:	8b 15 14 1a 55 f0    	mov    0xf0551a14,%edx
f010a8f3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8f6:	89 10                	mov    %edx,(%eax)
f010a8f8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8fb:	8b 00                	mov    (%eax),%eax
f010a8fd:	85 c0                	test   %eax,%eax
f010a8ff:	75 07                	jne    f010a908 <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010a901:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010a906:	eb 11                	jmp    f010a919 <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010a908:	8b 45 08             	mov    0x8(%ebp),%eax
f010a90b:	8b 00                	mov    (%eax),%eax
f010a90d:	c7 40 18 06 00 00 00 	movl   $0x6,0x18(%eax)
	return 0;
f010a914:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010a919:	5d                   	pop    %ebp
f010a91a:	c3                   	ret    

f010a91b <free_environment>:
//===============================
// 2) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010a91b:	55                   	push   %ebp
f010a91c:	89 e5                	mov    %esp,%ebp
f010a91e:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010a921:	83 ec 04             	sub    $0x4,%esp
f010a924:	68 6c da 01 00       	push   $0x1da6c
f010a929:	6a 00                	push   $0x0
f010a92b:	ff 75 08             	pushl  0x8(%ebp)
f010a92e:	e8 ee 5d 01 00       	call   f0120721 <memset>
f010a933:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010a936:	8b 45 08             	mov    0x8(%ebp),%eax
f010a939:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010a940:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010a944:	75 17                	jne    f010a95d <free_environment+0x42>
f010a946:	83 ec 04             	sub    $0x4,%esp
f010a949:	68 a0 53 12 f0       	push   $0xf01253a0
f010a94e:	68 bd 02 00 00       	push   $0x2bd
f010a953:	68 c3 53 12 f0       	push   $0xf01253c3
f010a958:	e8 bd 59 ff ff       	call   f010031a <_panic>
f010a95d:	8b 15 14 1a 55 f0    	mov    0xf0551a14,%edx
f010a963:	8b 45 08             	mov    0x8(%ebp),%eax
f010a966:	89 50 08             	mov    %edx,0x8(%eax)
f010a969:	8b 45 08             	mov    0x8(%ebp),%eax
f010a96c:	8b 40 08             	mov    0x8(%eax),%eax
f010a96f:	85 c0                	test   %eax,%eax
f010a971:	74 0d                	je     f010a980 <free_environment+0x65>
f010a973:	a1 14 1a 55 f0       	mov    0xf0551a14,%eax
f010a978:	8b 55 08             	mov    0x8(%ebp),%edx
f010a97b:	89 50 0c             	mov    %edx,0xc(%eax)
f010a97e:	eb 08                	jmp    f010a988 <free_environment+0x6d>
f010a980:	8b 45 08             	mov    0x8(%ebp),%eax
f010a983:	a3 18 1a 55 f0       	mov    %eax,0xf0551a18
f010a988:	8b 45 08             	mov    0x8(%ebp),%eax
f010a98b:	a3 14 1a 55 f0       	mov    %eax,0xf0551a14
f010a990:	8b 45 08             	mov    0x8(%ebp),%eax
f010a993:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010a99a:	a1 20 1a 55 f0       	mov    0xf0551a20,%eax
f010a99f:	40                   	inc    %eax
f010a9a0:	a3 20 1a 55 f0       	mov    %eax,0xf0551a20
}
f010a9a5:	90                   	nop
f010a9a6:	c9                   	leave  
f010a9a7:	c3                   	ret    

f010a9a8 <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010a9a8:	55                   	push   %ebp
f010a9a9:	89 e5                	mov    %esp,%ebp
f010a9ab:	53                   	push   %ebx
f010a9ac:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010a9af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9b2:	8b 40 0c             	mov    0xc(%eax),%eax
f010a9b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010a9b8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a9bb:	8b 40 08             	mov    0x8(%eax),%eax
f010a9be:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010a9c1:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010a9c8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010a9cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a9ce:	01 c2                	add    %eax,%edx
f010a9d0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a9d3:	01 d0                	add    %edx,%eax
f010a9d5:	48                   	dec    %eax
f010a9d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a9d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a9dc:	ba 00 00 00 00       	mov    $0x0,%edx
f010a9e1:	f7 75 dc             	divl   -0x24(%ebp)
f010a9e4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a9e7:	29 d0                	sub    %edx,%eax
f010a9e9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010a9ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a9ef:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a9f2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a9f5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a9fa:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010a9fd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010aa04:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)

	*allocated_pages = 0;
f010aa0b:	8b 45 10             	mov    0x10(%ebp),%eax
f010aa0e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010aa14:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010aa1b:	0f 85 35 06 00 00    	jne    f010b056 <program_segment_alloc_map_copy_workingset+0x6ae>
f010aa21:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa24:	83 c0 20             	add    $0x20,%eax
f010aa27:	83 ec 08             	sub    $0x8,%esp
f010aa2a:	68 80 55 12 f0       	push   $0xf0125580
f010aa2f:	50                   	push   %eax
f010aa30:	e8 0a 5c 01 00       	call   f012063f <strcmp>
f010aa35:	83 c4 10             	add    $0x10,%esp
f010aa38:	85 c0                	test   %eax,%eax
f010aa3a:	0f 84 16 06 00 00    	je     f010b056 <program_segment_alloc_map_copy_workingset+0x6ae>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010aa40:	8b 45 14             	mov    0x14(%ebp),%eax
f010aa43:	83 f8 06             	cmp    $0x6,%eax
f010aa46:	76 05                	jbe    f010aa4d <program_segment_alloc_map_copy_workingset+0xa5>
f010aa48:	b8 06 00 00 00       	mov    $0x6,%eax
f010aa4d:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010aa50:	e9 01 06 00 00       	jmp    f010b056 <program_segment_alloc_map_copy_workingset+0x6ae>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010aa55:	83 ec 0c             	sub    $0xc,%esp
f010aa58:	8d 45 c0             	lea    -0x40(%ebp),%eax
f010aa5b:	50                   	push   %eax
f010aa5c:	e8 70 d4 ff ff       	call   f0107ed1 <allocate_frame>
f010aa61:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010aa64:	8b 55 c0             	mov    -0x40(%ebp),%edx
f010aa67:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa6a:	8b 40 64             	mov    0x64(%eax),%eax
f010aa6d:	6a 06                	push   $0x6
f010aa6f:	ff 75 f4             	pushl  -0xc(%ebp)
f010aa72:	52                   	push   %edx
f010aa73:	50                   	push   %eax
f010aa74:	e8 6c da ff ff       	call   f01084e5 <loadtime_map_frame>
f010aa79:	83 c4 10             	add    $0x10,%esp
		wse->time_stamp = 0;
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);

#else
		LOG_STATMENT(cprintf("Updating working set entry # %d",e->page_last_WS_index));
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
f010aa7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010aa7f:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aa85:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa88:	89 d0                	mov    %edx,%eax
f010aa8a:	01 c0                	add    %eax,%eax
f010aa8c:	01 d0                	add    %edx,%eax
f010aa8e:	c1 e0 03             	shl    $0x3,%eax
f010aa91:	01 c8                	add    %ecx,%eax
f010aa93:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010aa99:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa9c:	89 02                	mov    %eax,(%edx)
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
f010aa9e:	8b 45 08             	mov    0x8(%ebp),%eax
f010aaa1:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aaa7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aaaa:	89 d0                	mov    %edx,%eax
f010aaac:	01 c0                	add    %eax,%eax
f010aaae:	01 d0                	add    %edx,%eax
f010aab0:	c1 e0 03             	shl    $0x3,%eax
f010aab3:	01 c8                	add    %ecx,%eax
f010aab5:	05 8c 00 00 00       	add    $0x8c,%eax
f010aaba:	c6 00 00             	movb   $0x0,(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
f010aabd:	8b 45 08             	mov    0x8(%ebp),%eax
f010aac0:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aac6:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aac9:	89 d0                	mov    %edx,%eax
f010aacb:	01 c0                	add    %eax,%eax
f010aacd:	01 d0                	add    %edx,%eax
f010aacf:	c1 e0 03             	shl    $0x3,%eax
f010aad2:	01 c8                	add    %ecx,%eax
f010aad4:	05 90 00 00 00       	add    $0x90,%eax
f010aad9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010aadf:	83 ec 0c             	sub    $0xc,%esp
f010aae2:	6a 02                	push   $0x2
f010aae4:	e8 86 38 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f010aae9:	83 c4 10             	add    $0x10,%esp
f010aaec:	85 c0                	test   %eax,%eax
f010aaee:	0f 84 2c 04 00 00    	je     f010af20 <program_segment_alloc_map_copy_workingset+0x578>
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
			}
#else

			LIST_REMOVE(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010aaf4:	8b 45 08             	mov    0x8(%ebp),%eax
f010aaf7:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aafd:	89 d0                	mov    %edx,%eax
f010aaff:	01 c0                	add    %eax,%eax
f010ab01:	01 d0                	add    %edx,%eax
f010ab03:	c1 e0 03             	shl    $0x3,%eax
f010ab06:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ab0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab0f:	01 d0                	add    %edx,%eax
f010ab11:	83 c0 08             	add    $0x8,%eax
f010ab14:	85 c0                	test   %eax,%eax
f010ab16:	75 17                	jne    f010ab2f <program_segment_alloc_map_copy_workingset+0x187>
f010ab18:	83 ec 04             	sub    $0x4,%esp
f010ab1b:	68 55 54 12 f0       	push   $0xf0125455
f010ab20:	68 00 03 00 00       	push   $0x300
f010ab25:	68 c3 53 12 f0       	push   $0xf01253c3
f010ab2a:	e8 eb 57 ff ff       	call   f010031a <_panic>
f010ab2f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab32:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ab38:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab3b:	89 d0                	mov    %edx,%eax
f010ab3d:	01 c0                	add    %eax,%eax
f010ab3f:	01 d0                	add    %edx,%eax
f010ab41:	c1 e0 03             	shl    $0x3,%eax
f010ab44:	01 c8                	add    %ecx,%eax
f010ab46:	05 98 00 00 00       	add    $0x98,%eax
f010ab4b:	8b 00                	mov    (%eax),%eax
f010ab4d:	85 c0                	test   %eax,%eax
f010ab4f:	74 41                	je     f010ab92 <program_segment_alloc_map_copy_workingset+0x1ea>
f010ab51:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab54:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ab5a:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab5d:	89 d0                	mov    %edx,%eax
f010ab5f:	01 c0                	add    %eax,%eax
f010ab61:	01 d0                	add    %edx,%eax
f010ab63:	c1 e0 03             	shl    $0x3,%eax
f010ab66:	01 c8                	add    %ecx,%eax
f010ab68:	05 98 00 00 00       	add    $0x98,%eax
f010ab6d:	8b 10                	mov    (%eax),%edx
f010ab6f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab72:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ab78:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ab7b:	89 c8                	mov    %ecx,%eax
f010ab7d:	01 c0                	add    %eax,%eax
f010ab7f:	01 c8                	add    %ecx,%eax
f010ab81:	c1 e0 03             	shl    $0x3,%eax
f010ab84:	01 d8                	add    %ebx,%eax
f010ab86:	05 9c 00 00 00       	add    $0x9c,%eax
f010ab8b:	8b 00                	mov    (%eax),%eax
f010ab8d:	89 42 14             	mov    %eax,0x14(%edx)
f010ab90:	eb 27                	jmp    f010abb9 <program_segment_alloc_map_copy_workingset+0x211>
f010ab92:	8b 45 08             	mov    0x8(%ebp),%eax
f010ab95:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ab9b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab9e:	89 d0                	mov    %edx,%eax
f010aba0:	01 c0                	add    %eax,%eax
f010aba2:	01 d0                	add    %edx,%eax
f010aba4:	c1 e0 03             	shl    $0x3,%eax
f010aba7:	01 c8                	add    %ecx,%eax
f010aba9:	05 9c 00 00 00       	add    $0x9c,%eax
f010abae:	8b 10                	mov    (%eax),%edx
f010abb0:	8b 45 08             	mov    0x8(%ebp),%eax
f010abb3:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010abb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010abbc:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010abc2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abc5:	89 d0                	mov    %edx,%eax
f010abc7:	01 c0                	add    %eax,%eax
f010abc9:	01 d0                	add    %edx,%eax
f010abcb:	c1 e0 03             	shl    $0x3,%eax
f010abce:	01 c8                	add    %ecx,%eax
f010abd0:	05 9c 00 00 00       	add    $0x9c,%eax
f010abd5:	8b 00                	mov    (%eax),%eax
f010abd7:	85 c0                	test   %eax,%eax
f010abd9:	74 41                	je     f010ac1c <program_segment_alloc_map_copy_workingset+0x274>
f010abdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010abde:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010abe4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abe7:	89 d0                	mov    %edx,%eax
f010abe9:	01 c0                	add    %eax,%eax
f010abeb:	01 d0                	add    %edx,%eax
f010abed:	c1 e0 03             	shl    $0x3,%eax
f010abf0:	01 c8                	add    %ecx,%eax
f010abf2:	05 9c 00 00 00       	add    $0x9c,%eax
f010abf7:	8b 10                	mov    (%eax),%edx
f010abf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010abfc:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ac02:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ac05:	89 c8                	mov    %ecx,%eax
f010ac07:	01 c0                	add    %eax,%eax
f010ac09:	01 c8                	add    %ecx,%eax
f010ac0b:	c1 e0 03             	shl    $0x3,%eax
f010ac0e:	01 d8                	add    %ebx,%eax
f010ac10:	05 98 00 00 00       	add    $0x98,%eax
f010ac15:	8b 00                	mov    (%eax),%eax
f010ac17:	89 42 10             	mov    %eax,0x10(%edx)
f010ac1a:	eb 27                	jmp    f010ac43 <program_segment_alloc_map_copy_workingset+0x29b>
f010ac1c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac1f:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac25:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac28:	89 d0                	mov    %edx,%eax
f010ac2a:	01 c0                	add    %eax,%eax
f010ac2c:	01 d0                	add    %edx,%eax
f010ac2e:	c1 e0 03             	shl    $0x3,%eax
f010ac31:	01 c8                	add    %ecx,%eax
f010ac33:	05 98 00 00 00       	add    $0x98,%eax
f010ac38:	8b 10                	mov    (%eax),%edx
f010ac3a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac3d:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010ac43:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac46:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac4c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac4f:	89 d0                	mov    %edx,%eax
f010ac51:	01 c0                	add    %eax,%eax
f010ac53:	01 d0                	add    %edx,%eax
f010ac55:	c1 e0 03             	shl    $0x3,%eax
f010ac58:	01 c8                	add    %ecx,%eax
f010ac5a:	05 98 00 00 00       	add    $0x98,%eax
f010ac5f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010ac65:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac68:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ac6e:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac71:	89 d0                	mov    %edx,%eax
f010ac73:	01 c0                	add    %eax,%eax
f010ac75:	01 d0                	add    %edx,%eax
f010ac77:	c1 e0 03             	shl    $0x3,%eax
f010ac7a:	01 c8                	add    %ecx,%eax
f010ac7c:	05 9c 00 00 00       	add    $0x9c,%eax
f010ac81:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010ac87:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac8a:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010ac90:	8d 50 ff             	lea    -0x1(%eax),%edx
f010ac93:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac96:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010ac9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ac9f:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f010aca5:	8b 45 08             	mov    0x8(%ebp),%eax
f010aca8:	8b 80 30 da 01 00    	mov    0x1da30(%eax),%eax
f010acae:	48                   	dec    %eax
f010acaf:	39 c2                	cmp    %eax,%edx
f010acb1:	0f 83 37 01 00 00    	jae    f010adee <program_segment_alloc_map_copy_workingset+0x446>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010acb7:	8b 45 08             	mov    0x8(%ebp),%eax
f010acba:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010acc0:	89 d0                	mov    %edx,%eax
f010acc2:	01 c0                	add    %eax,%eax
f010acc4:	01 d0                	add    %edx,%eax
f010acc6:	c1 e0 03             	shl    $0x3,%eax
f010acc9:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010accf:	8b 45 08             	mov    0x8(%ebp),%eax
f010acd2:	01 d0                	add    %edx,%eax
f010acd4:	83 c0 08             	add    $0x8,%eax
f010acd7:	85 c0                	test   %eax,%eax
f010acd9:	75 17                	jne    f010acf2 <program_segment_alloc_map_copy_workingset+0x34a>
f010acdb:	83 ec 04             	sub    $0x4,%esp
f010acde:	68 a0 53 12 f0       	push   $0xf01253a0
f010ace3:	68 04 03 00 00       	push   $0x304
f010ace8:	68 c3 53 12 f0       	push   $0xf01253c3
f010aced:	e8 28 56 ff ff       	call   f010031a <_panic>
f010acf2:	8b 45 08             	mov    0x8(%ebp),%eax
f010acf5:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010acfb:	8b 45 08             	mov    0x8(%ebp),%eax
f010acfe:	8b 88 10 da 01 00    	mov    0x1da10(%eax),%ecx
f010ad04:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ad07:	89 d0                	mov    %edx,%eax
f010ad09:	01 c0                	add    %eax,%eax
f010ad0b:	01 d0                	add    %edx,%eax
f010ad0d:	c1 e0 03             	shl    $0x3,%eax
f010ad10:	01 d8                	add    %ebx,%eax
f010ad12:	05 98 00 00 00       	add    $0x98,%eax
f010ad17:	89 08                	mov    %ecx,(%eax)
f010ad19:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ad1c:	89 d0                	mov    %edx,%eax
f010ad1e:	01 c0                	add    %eax,%eax
f010ad20:	01 d0                	add    %edx,%eax
f010ad22:	c1 e0 03             	shl    $0x3,%eax
f010ad25:	01 c8                	add    %ecx,%eax
f010ad27:	05 98 00 00 00       	add    $0x98,%eax
f010ad2c:	8b 00                	mov    (%eax),%eax
f010ad2e:	85 c0                	test   %eax,%eax
f010ad30:	74 2e                	je     f010ad60 <program_segment_alloc_map_copy_workingset+0x3b8>
f010ad32:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad35:	8b 90 10 da 01 00    	mov    0x1da10(%eax),%edx
f010ad3b:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad3e:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ad44:	89 c8                	mov    %ecx,%eax
f010ad46:	01 c0                	add    %eax,%eax
f010ad48:	01 c8                	add    %ecx,%eax
f010ad4a:	c1 e0 03             	shl    $0x3,%eax
f010ad4d:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010ad53:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad56:	01 c8                	add    %ecx,%eax
f010ad58:	83 c0 08             	add    $0x8,%eax
f010ad5b:	89 42 14             	mov    %eax,0x14(%edx)
f010ad5e:	eb 29                	jmp    f010ad89 <program_segment_alloc_map_copy_workingset+0x3e1>
f010ad60:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad63:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad69:	89 d0                	mov    %edx,%eax
f010ad6b:	01 c0                	add    %eax,%eax
f010ad6d:	01 d0                	add    %edx,%eax
f010ad6f:	c1 e0 03             	shl    $0x3,%eax
f010ad72:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ad78:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad7b:	01 d0                	add    %edx,%eax
f010ad7d:	8d 50 08             	lea    0x8(%eax),%edx
f010ad80:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad83:	89 90 14 da 01 00    	mov    %edx,0x1da14(%eax)
f010ad89:	8b 45 08             	mov    0x8(%ebp),%eax
f010ad8c:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ad92:	89 d0                	mov    %edx,%eax
f010ad94:	01 c0                	add    %eax,%eax
f010ad96:	01 d0                	add    %edx,%eax
f010ad98:	c1 e0 03             	shl    $0x3,%eax
f010ad9b:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ada1:	8b 45 08             	mov    0x8(%ebp),%eax
f010ada4:	01 d0                	add    %edx,%eax
f010ada6:	8d 50 08             	lea    0x8(%eax),%edx
f010ada9:	8b 45 08             	mov    0x8(%ebp),%eax
f010adac:	89 90 10 da 01 00    	mov    %edx,0x1da10(%eax)
f010adb2:	8b 45 08             	mov    0x8(%ebp),%eax
f010adb5:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010adbb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010adbe:	89 d0                	mov    %edx,%eax
f010adc0:	01 c0                	add    %eax,%eax
f010adc2:	01 d0                	add    %edx,%eax
f010adc4:	c1 e0 03             	shl    $0x3,%eax
f010adc7:	01 c8                	add    %ecx,%eax
f010adc9:	05 9c 00 00 00       	add    $0x9c,%eax
f010adce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010add4:	8b 45 08             	mov    0x8(%ebp),%eax
f010add7:	8b 80 1c da 01 00    	mov    0x1da1c(%eax),%eax
f010addd:	8d 50 01             	lea    0x1(%eax),%edx
f010ade0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ade3:	89 90 1c da 01 00    	mov    %edx,0x1da1c(%eax)
f010ade9:	e9 32 01 00 00       	jmp    f010af20 <program_segment_alloc_map_copy_workingset+0x578>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), &(e->ptr_pageWorkingSet[e->page_last_WS_index]));
f010adee:	8b 45 08             	mov    0x8(%ebp),%eax
f010adf1:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010adf7:	89 d0                	mov    %edx,%eax
f010adf9:	01 c0                	add    %eax,%eax
f010adfb:	01 d0                	add    %edx,%eax
f010adfd:	c1 e0 03             	shl    $0x3,%eax
f010ae00:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010ae06:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae09:	01 d0                	add    %edx,%eax
f010ae0b:	83 c0 08             	add    $0x8,%eax
f010ae0e:	85 c0                	test   %eax,%eax
f010ae10:	75 17                	jne    f010ae29 <program_segment_alloc_map_copy_workingset+0x481>
f010ae12:	83 ec 04             	sub    $0x4,%esp
f010ae15:	68 a0 53 12 f0       	push   $0xf01253a0
f010ae1a:	68 09 03 00 00       	push   $0x309
f010ae1f:	68 c3 53 12 f0       	push   $0xf01253c3
f010ae24:	e8 f1 54 ff ff       	call   f010031a <_panic>
f010ae29:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae2c:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010ae32:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae35:	8b 88 20 da 01 00    	mov    0x1da20(%eax),%ecx
f010ae3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010ae3e:	89 d0                	mov    %edx,%eax
f010ae40:	01 c0                	add    %eax,%eax
f010ae42:	01 d0                	add    %edx,%eax
f010ae44:	c1 e0 03             	shl    $0x3,%eax
f010ae47:	01 d8                	add    %ebx,%eax
f010ae49:	05 98 00 00 00       	add    $0x98,%eax
f010ae4e:	89 08                	mov    %ecx,(%eax)
f010ae50:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ae53:	89 d0                	mov    %edx,%eax
f010ae55:	01 c0                	add    %eax,%eax
f010ae57:	01 d0                	add    %edx,%eax
f010ae59:	c1 e0 03             	shl    $0x3,%eax
f010ae5c:	01 c8                	add    %ecx,%eax
f010ae5e:	05 98 00 00 00       	add    $0x98,%eax
f010ae63:	8b 00                	mov    (%eax),%eax
f010ae65:	85 c0                	test   %eax,%eax
f010ae67:	74 2e                	je     f010ae97 <program_segment_alloc_map_copy_workingset+0x4ef>
f010ae69:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae6c:	8b 90 20 da 01 00    	mov    0x1da20(%eax),%edx
f010ae72:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae75:	8b 88 58 d5 01 00    	mov    0x1d558(%eax),%ecx
f010ae7b:	89 c8                	mov    %ecx,%eax
f010ae7d:	01 c0                	add    %eax,%eax
f010ae7f:	01 c8                	add    %ecx,%eax
f010ae81:	c1 e0 03             	shl    $0x3,%eax
f010ae84:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010ae8a:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae8d:	01 c8                	add    %ecx,%eax
f010ae8f:	83 c0 08             	add    $0x8,%eax
f010ae92:	89 42 14             	mov    %eax,0x14(%edx)
f010ae95:	eb 29                	jmp    f010aec0 <program_segment_alloc_map_copy_workingset+0x518>
f010ae97:	8b 45 08             	mov    0x8(%ebp),%eax
f010ae9a:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aea0:	89 d0                	mov    %edx,%eax
f010aea2:	01 c0                	add    %eax,%eax
f010aea4:	01 d0                	add    %edx,%eax
f010aea6:	c1 e0 03             	shl    $0x3,%eax
f010aea9:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010aeaf:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeb2:	01 d0                	add    %edx,%eax
f010aeb4:	8d 50 08             	lea    0x8(%eax),%edx
f010aeb7:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeba:	89 90 24 da 01 00    	mov    %edx,0x1da24(%eax)
f010aec0:	8b 45 08             	mov    0x8(%ebp),%eax
f010aec3:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aec9:	89 d0                	mov    %edx,%eax
f010aecb:	01 c0                	add    %eax,%eax
f010aecd:	01 d0                	add    %edx,%eax
f010aecf:	c1 e0 03             	shl    $0x3,%eax
f010aed2:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010aed8:	8b 45 08             	mov    0x8(%ebp),%eax
f010aedb:	01 d0                	add    %edx,%eax
f010aedd:	8d 50 08             	lea    0x8(%eax),%edx
f010aee0:	8b 45 08             	mov    0x8(%ebp),%eax
f010aee3:	89 90 20 da 01 00    	mov    %edx,0x1da20(%eax)
f010aee9:	8b 45 08             	mov    0x8(%ebp),%eax
f010aeec:	8b 90 58 d5 01 00    	mov    0x1d558(%eax),%edx
f010aef2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aef5:	89 d0                	mov    %edx,%eax
f010aef7:	01 c0                	add    %eax,%eax
f010aef9:	01 d0                	add    %edx,%eax
f010aefb:	c1 e0 03             	shl    $0x3,%eax
f010aefe:	01 c8                	add    %ecx,%eax
f010af00:	05 9c 00 00 00       	add    $0x9c,%eax
f010af05:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010af0b:	8b 45 08             	mov    0x8(%ebp),%eax
f010af0e:	8b 80 2c da 01 00    	mov    0x1da2c(%eax),%eax
f010af14:	8d 50 01             	lea    0x1(%eax),%edx
f010af17:	8b 45 08             	mov    0x8(%ebp),%eax
f010af1a:	89 90 2c da 01 00    	mov    %edx,0x1da2c(%eax)
		else
		{
			e->page_last_WS_element = NULL;
		}
#else
		e->page_last_WS_index ++;
f010af20:	8b 45 08             	mov    0x8(%ebp),%eax
f010af23:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010af29:	8d 50 01             	lea    0x1(%eax),%edx
f010af2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010af2f:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
		e->page_last_WS_index %= (e->page_WS_max_size);
f010af35:	8b 45 08             	mov    0x8(%ebp),%eax
f010af38:	8b 80 58 d5 01 00    	mov    0x1d558(%eax),%eax
f010af3e:	8b 55 08             	mov    0x8(%ebp),%edx
f010af41:	8b 8a 84 00 00 00    	mov    0x84(%edx),%ecx
f010af47:	ba 00 00 00 00       	mov    $0x0,%edx
f010af4c:	f7 f1                	div    %ecx
f010af4e:	8b 45 08             	mov    0x8(%ebp),%eax
f010af51:	89 90 58 d5 01 00    	mov    %edx,0x1d558(%eax)
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010af57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af5a:	c1 e8 16             	shr    $0x16,%eax
f010af5d:	89 c2                	mov    %eax,%edx
f010af5f:	8b 45 18             	mov    0x18(%ebp),%eax
f010af62:	8b 00                	mov    (%eax),%eax
f010af64:	39 c2                	cmp    %eax,%edx
f010af66:	0f 84 d3 00 00 00    	je     f010b03f <program_segment_alloc_map_copy_workingset+0x697>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010af6c:	8b 45 08             	mov    0x8(%ebp),%eax
f010af6f:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010af75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010af78:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010af7b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010af7e:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010af83:	89 c1                	mov    %eax,%ecx
f010af85:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010af88:	89 d0                	mov    %edx,%eax
f010af8a:	01 c0                	add    %eax,%eax
f010af8c:	01 d0                	add    %edx,%eax
f010af8e:	c1 e0 03             	shl    $0x3,%eax
f010af91:	01 d8                	add    %ebx,%eax
f010af93:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010af98:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010af9a:	8b 45 08             	mov    0x8(%ebp),%eax
f010af9d:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010afa3:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010afa6:	89 d0                	mov    %edx,%eax
f010afa8:	01 c0                	add    %eax,%eax
f010afaa:	01 d0                	add    %edx,%eax
f010afac:	c1 e0 03             	shl    $0x3,%eax
f010afaf:	01 c8                	add    %ecx,%eax
f010afb1:	05 60 d5 01 00       	add    $0x1d560,%eax
f010afb6:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010afb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010afbc:	8b 90 0c da 01 00    	mov    0x1da0c(%eax),%edx
f010afc2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010afc5:	89 d0                	mov    %edx,%eax
f010afc7:	01 c0                	add    %eax,%eax
f010afc9:	01 d0                	add    %edx,%eax
f010afcb:	c1 e0 03             	shl    $0x3,%eax
f010afce:	01 c8                	add    %ecx,%eax
f010afd0:	05 64 d5 01 00       	add    $0x1d564,%eax
f010afd5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010afdb:	8b 45 08             	mov    0x8(%ebp),%eax
f010afde:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010afe4:	8d 50 01             	lea    0x1(%eax),%edx
f010afe7:	8b 45 08             	mov    0x8(%ebp),%eax
f010afea:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010aff0:	8b 45 08             	mov    0x8(%ebp),%eax
f010aff3:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010aff9:	b9 32 00 00 00       	mov    $0x32,%ecx
f010affe:	ba 00 00 00 00       	mov    $0x0,%edx
f010b003:	f7 f1                	div    %ecx
f010b005:	8b 45 08             	mov    0x8(%ebp),%eax
f010b008:	89 90 0c da 01 00    	mov    %edx,0x1da0c(%eax)
			if (e->table_last_WS_index == 0)
f010b00e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b011:	8b 80 0c da 01 00    	mov    0x1da0c(%eax),%eax
f010b017:	85 c0                	test   %eax,%eax
f010b019:	75 17                	jne    f010b032 <program_segment_alloc_map_copy_workingset+0x68a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010b01b:	83 ec 04             	sub    $0x4,%esp
f010b01e:	68 84 55 12 f0       	push   $0xf0125584
f010b023:	68 24 03 00 00       	push   $0x324
f010b028:	68 c3 53 12 f0       	push   $0xf01253c3
f010b02d:	e8 e8 52 ff ff       	call   f010031a <_panic>
			(*lastTableNumber) = PDX(iVA);
f010b032:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b035:	c1 e8 16             	shr    $0x16,%eax
f010b038:	89 c2                	mov    %eax,%edx
f010b03a:	8b 45 18             	mov    0x18(%ebp),%eax
f010b03d:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010b03f:	8b 45 10             	mov    0x10(%ebp),%eax
f010b042:	8b 00                	mov    (%eax),%eax
f010b044:	8d 50 01             	lea    0x1(%eax),%edx
f010b047:	8b 45 10             	mov    0x10(%ebp),%eax
f010b04a:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010b04c:	ff 45 f0             	incl   -0x10(%ebp)
f010b04f:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010b056:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b059:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010b05c:	73 0c                	jae    f010b06a <program_segment_alloc_map_copy_workingset+0x6c2>
f010b05e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b061:	3b 45 14             	cmp    0x14(%ebp),%eax
f010b064:	0f 82 eb f9 ff ff    	jb     f010aa55 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010b06a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b06d:	8b 00                	mov    (%eax),%eax
f010b06f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010b072:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b075:	8b 40 0c             	mov    0xc(%eax),%eax
f010b078:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b07b:	eb 10                	jmp    f010b08d <program_segment_alloc_map_copy_workingset+0x6e5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010b07d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b080:	8a 10                	mov    (%eax),%dl
f010b082:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b085:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010b087:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010b08a:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b08d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b090:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010b093:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010b096:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b09b:	89 c2                	mov    %eax,%edx
f010b09d:	8b 45 10             	mov    0x10(%ebp),%eax
f010b0a0:	8b 00                	mov    (%eax),%eax
f010b0a2:	c1 e0 0c             	shl    $0xc,%eax
f010b0a5:	01 c2                	add    %eax,%edx
f010b0a7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0aa:	39 c2                	cmp    %eax,%edx
f010b0ac:	76 1d                	jbe    f010b0cb <program_segment_alloc_map_copy_workingset+0x723>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010b0ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b0b1:	8b 50 04             	mov    0x4(%eax),%edx
f010b0b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0b7:	01 c2                	add    %eax,%edx
f010b0b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010b0bc:	39 c2                	cmp    %eax,%edx
f010b0be:	77 bd                	ja     f010b07d <program_segment_alloc_map_copy_workingset+0x6d5>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b0c0:	eb 09                	jmp    f010b0cb <program_segment_alloc_map_copy_workingset+0x723>
	{
		*dst_ptr = 0;
f010b0c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0c5:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010b0c8:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010b0cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b0ce:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b0d1:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b0d4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b0d9:	89 c2                	mov    %eax,%edx
f010b0db:	8b 45 10             	mov    0x10(%ebp),%eax
f010b0de:	8b 00                	mov    (%eax),%eax
f010b0e0:	c1 e0 0c             	shl    $0xc,%eax
f010b0e3:	01 c2                	add    %eax,%edx
f010b0e5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010b0e8:	39 c2                	cmp    %eax,%edx
f010b0ea:	77 d6                	ja     f010b0c2 <program_segment_alloc_map_copy_workingset+0x71a>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010b0ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b0f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b0f4:	c9                   	leave  
f010b0f5:	c3                   	ret    

f010b0f6 <create_user_directory>:

//==================================================
// 4) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010b0f6:	55                   	push   %ebp
f010b0f7:	89 e5                	mov    %esp,%ebp
f010b0f9:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010b0fc:	83 ec 0c             	sub    $0xc,%esp
f010b0ff:	68 00 10 00 00       	push   $0x1000
f010b104:	e8 ae d6 ff ff       	call   f01087b7 <kmalloc>
f010b109:	83 c4 10             	add    $0x10,%esp
f010b10c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010b10f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b113:	75 17                	jne    f010b12c <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010b115:	83 ec 04             	sub    $0x4,%esp
f010b118:	68 27 56 12 f0       	push   $0xf0125627
f010b11d:	68 54 03 00 00       	push   $0x354
f010b122:	68 c3 53 12 f0       	push   $0xf01253c3
f010b127:	e8 ee 51 ff ff       	call   f010031a <_panic>
	}
	return ptr_user_page_directory;
f010b12c:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010b12f:	c9                   	leave  
f010b130:	c3                   	ret    

f010b131 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 5) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010b131:	55                   	push   %ebp
f010b132:	89 e5                	mov    %esp,%ebp
f010b134:	83 ec 18             	sub    $0x18,%esp
	//remember to leave its bottom page as a GUARD PAGE (i.e. not mapped)
	//return a pointer to the start of the allocated space (including the GUARD PAGE)


#else
	if (KERNEL_HEAP_MAX - __cur_k_stk < KERNEL_STACK_SIZE)
f010b137:	a1 5c 99 17 f0       	mov    0xf017995c,%eax
f010b13c:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
f010b141:	29 c2                	sub    %eax,%edx
f010b143:	89 d0                	mov    %edx,%eax
f010b145:	3d ff 7f 00 00       	cmp    $0x7fff,%eax
f010b14a:	77 17                	ja     f010b163 <create_user_kern_stack+0x32>
		panic("Run out of kernel heap!! Unable to create a kernel stack for the process. Can't create more processes!");
f010b14c:	83 ec 04             	sub    $0x4,%esp
f010b14f:	68 44 56 12 f0       	push   $0xf0125644
f010b154:	68 6d 03 00 00       	push   $0x36d
f010b159:	68 c3 53 12 f0       	push   $0xf01253c3
f010b15e:	e8 b7 51 ff ff       	call   f010031a <_panic>
	void* kstack = (void*) __cur_k_stk;
f010b163:	a1 5c 99 17 f0       	mov    0xf017995c,%eax
f010b168:	89 45 f4             	mov    %eax,-0xc(%ebp)
	__cur_k_stk += KERNEL_STACK_SIZE;
f010b16b:	a1 5c 99 17 f0       	mov    0xf017995c,%eax
f010b170:	05 00 80 00 00       	add    $0x8000,%eax
f010b175:	a3 5c 99 17 f0       	mov    %eax,0xf017995c
	return kstack ;
f010b17a:	8b 45 f4             	mov    -0xc(%ebp),%eax
//	panic("KERNEL HEAP is OFF! user kernel stack is not supported");
#endif
}
f010b17d:	c9                   	leave  
f010b17e:	c3                   	ret    

f010b17f <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010b17f:	55                   	push   %ebp
f010b180:	89 e5                	mov    %esp,%ebp
f010b182:	83 ec 08             	sub    $0x8,%esp
	panic("delete_user_kern_stack() is not implemented yet...!!");

	//Delete the allocated space for the user kernel stack of this process "e"
	//remember to delete the bottom GUARD PAGE (i.e. not mapped)
#else
	panic("KERNEL HEAP is OFF! user kernel stack can't be deleted");
f010b185:	83 ec 04             	sub    $0x4,%esp
f010b188:	68 ac 56 12 f0       	push   $0xf01256ac
f010b18d:	68 83 03 00 00       	push   $0x383
f010b192:	68 c3 53 12 f0       	push   $0xf01253c3
f010b197:	e8 7e 51 ff ff       	call   f010031a <_panic>

f010b19c <initialize_uheap_dynamic_allocator>:
}
//===============================================
// 7) INITIALIZE DYNAMIC ALLOCATOR OF UHEAP:
//===============================================
void initialize_uheap_dynamic_allocator(struct Env* e, uint32 daStart, uint32 daLimit)
{
f010b19c:	55                   	push   %ebp
f010b19d:	89 e5                	mov    %esp,%ebp
	//[PROJECT'24.MS2] Initialize the dynamic allocator of the user heap
	//Remember:
	//	1) there's no initial allocations for the dynamic allocator of the user heap (=0)
	//	2) call the initialize_dynamic_allocator(..) to complete the initialization
	//panic("initialize_uheap_dynamic_allocator() is not implemented yet...!!");
}
f010b19f:	90                   	nop
f010b1a0:	5d                   	pop    %ebp
f010b1a1:	c3                   	ret    

f010b1a2 <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010b1a2:	55                   	push   %ebp
f010b1a3:	89 e5                	mov    %esp,%ebp
f010b1a5:	53                   	push   %ebx
f010b1a6:	83 ec 14             	sub    $0x14,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010b1a9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1ac:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b1af:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010b1b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1b5:	8b 55 10             	mov    0x10(%ebp),%edx
f010b1b8:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b1bb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b1c2:	eb 17                	jmp    f010b1db <initialize_environment+0x39>
	{
		e->env_page_directory[i] = 0 ;
f010b1c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1c7:	8b 40 64             	mov    0x64(%eax),%eax
f010b1ca:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1cd:	c1 e2 02             	shl    $0x2,%edx
f010b1d0:	01 d0                	add    %edx,%eax
f010b1d2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010b1d8:	ff 45 f4             	incl   -0xc(%ebp)
f010b1db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b1de:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010b1e3:	76 df                	jbe    f010b1c4 <initialize_environment+0x22>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b1e5:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010b1ec:	eb 22                	jmp    f010b210 <initialize_environment+0x6e>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010b1ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010b1f1:	8b 40 64             	mov    0x64(%eax),%eax
f010b1f4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b1f7:	c1 e2 02             	shl    $0x2,%edx
f010b1fa:	01 c2                	add    %eax,%edx
f010b1fc:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f010b201:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010b204:	c1 e1 02             	shl    $0x2,%ecx
f010b207:	01 c8                	add    %ecx,%eax
f010b209:	8b 00                	mov    (%eax),%eax
f010b20b:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010b20d:	ff 45 f4             	incl   -0xc(%ebp)
f010b210:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010b217:	7e d5                	jle    f010b1ee <initialize_environment+0x4c>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010b219:	8b 45 08             	mov    0x8(%ebp),%eax
f010b21c:	8b 40 64             	mov    0x64(%eax),%eax
f010b21f:	83 ec 0c             	sub    $0xc,%esp
f010b222:	50                   	push   %eax
f010b223:	e8 09 ff ff ff       	call   f010b131 <create_user_kern_stack>
f010b228:	83 c4 10             	add    $0x10,%esp
f010b22b:	89 c2                	mov    %eax,%edx
f010b22d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b230:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010b233:	8b 45 08             	mov    0x8(%ebp),%eax
f010b236:	8b 40 70             	mov    0x70(%eax),%eax
f010b239:	05 00 80 00 00       	add    $0x8000,%eax
f010b23e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		sp -= sizeof(struct Trapframe);
f010b241:	83 6d ec 44          	subl   $0x44,-0x14(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010b245:	8b 45 08             	mov    0x8(%ebp),%eax
f010b248:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b24b:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010b24d:	83 6d ec 04          	subl   $0x4,-0x14(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010b251:	ba 84 d4 10 f0       	mov    $0xf010d484,%edx
f010b256:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b259:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010b25b:	83 6d ec 20          	subl   $0x20,-0x14(%ebp)
		e->context = (struct Context *) sp;
f010b25f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b262:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010b265:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010b268:	8b 45 08             	mov    0x8(%ebp),%eax
f010b26b:	8b 40 04             	mov    0x4(%eax),%eax
f010b26e:	83 ec 04             	sub    $0x4,%esp
f010b271:	6a 20                	push   $0x20
f010b273:	6a 00                	push   $0x0
f010b275:	50                   	push   %eax
f010b276:	e8 a6 54 01 00       	call   f0120721 <memset>
f010b27b:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010b27e:	8b 45 08             	mov    0x8(%ebp),%eax
f010b281:	8b 40 04             	mov    0x4(%eax),%eax
f010b284:	ba d7 a3 10 f0       	mov    $0xf010a3d7,%edx
f010b289:	89 50 1c             	mov    %edx,0x1c(%eax)
	{
		LIST_INIT(&(e->page_WS_list));
	}
#else
	{
		uint32 env_index = (uint32)(e-envs);
f010b28c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b28f:	8b 15 10 1a 55 f0    	mov    0xf0551a10,%edx
f010b295:	29 d0                	sub    %edx,%eax
f010b297:	c1 f8 02             	sar    $0x2,%eax
f010b29a:	89 c2                	mov    %eax,%edx
f010b29c:	89 d0                	mov    %edx,%eax
f010b29e:	c1 e0 02             	shl    $0x2,%eax
f010b2a1:	01 d0                	add    %edx,%eax
f010b2a3:	c1 e0 02             	shl    $0x2,%eax
f010b2a6:	01 d0                	add    %edx,%eax
f010b2a8:	c1 e0 02             	shl    $0x2,%eax
f010b2ab:	01 d0                	add    %edx,%eax
f010b2ad:	c1 e0 02             	shl    $0x2,%eax
f010b2b0:	01 d0                	add    %edx,%eax
f010b2b2:	c1 e0 08             	shl    $0x8,%eax
f010b2b5:	29 d0                	sub    %edx,%eax
f010b2b7:	c1 e0 08             	shl    $0x8,%eax
f010b2ba:	29 d0                	sub    %edx,%eax
f010b2bc:	c1 e0 03             	shl    $0x3,%eax
f010b2bf:	01 d0                	add    %edx,%eax
f010b2c1:	c1 e0 03             	shl    $0x3,%eax
f010b2c4:	01 d0                	add    %edx,%eax
f010b2c6:	01 c0                	add    %eax,%eax
f010b2c8:	01 d0                	add    %edx,%eax
f010b2ca:	89 45 e8             	mov    %eax,-0x18(%ebp)
		e->__uptr_pws = (struct WorkingSetElement*) ( ((struct Env*)(UENVS+sizeof(struct Env)*env_index))->ptr_pageWorkingSet );
f010b2cd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010b2d0:	89 d0                	mov    %edx,%eax
f010b2d2:	c1 e0 06             	shl    $0x6,%eax
f010b2d5:	29 d0                	sub    %edx,%eax
f010b2d7:	c1 e0 02             	shl    $0x2,%eax
f010b2da:	01 d0                	add    %edx,%eax
f010b2dc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010b2e3:	01 c8                	add    %ecx,%eax
f010b2e5:	c1 e0 03             	shl    $0x3,%eax
f010b2e8:	01 d0                	add    %edx,%eax
f010b2ea:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010b2f1:	29 c2                	sub    %eax,%edx
f010b2f3:	8d 04 95 00 00 00 00 	lea    0x0(,%edx,4),%eax
f010b2fa:	89 c2                	mov    %eax,%edx
f010b2fc:	89 d0                	mov    %edx,%eax
f010b2fe:	2d 00 00 40 11       	sub    $0x11400000,%eax
f010b303:	8d 90 88 00 00 00    	lea    0x88(%eax),%edx
f010b309:	8b 45 08             	mov    0x8(%ebp),%eax
f010b30c:	89 90 38 da 01 00    	mov    %edx,0x1da38(%eax)
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b312:	83 ec 0c             	sub    $0xc,%esp
f010b315:	6a 02                	push   $0x2
f010b317:	e8 53 30 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f010b31c:	83 c4 10             	add    $0x10,%esp
f010b31f:	85 c0                	test   %eax,%eax
f010b321:	0f 84 34 01 00 00    	je     f010b45b <initialize_environment+0x2b9>
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b327:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010b32e:	e9 14 01 00 00       	jmp    f010b447 <initialize_environment+0x2a5>
		{
			LIST_INSERT_HEAD(&(e->PageWorkingSetList), &(e->ptr_pageWorkingSet[i]));
f010b333:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b336:	89 d0                	mov    %edx,%eax
f010b338:	01 c0                	add    %eax,%eax
f010b33a:	01 d0                	add    %edx,%eax
f010b33c:	c1 e0 03             	shl    $0x3,%eax
f010b33f:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b345:	8b 45 08             	mov    0x8(%ebp),%eax
f010b348:	01 d0                	add    %edx,%eax
f010b34a:	83 c0 08             	add    $0x8,%eax
f010b34d:	85 c0                	test   %eax,%eax
f010b34f:	75 17                	jne    f010b368 <initialize_environment+0x1c6>
f010b351:	83 ec 04             	sub    $0x4,%esp
f010b354:	68 a0 53 12 f0       	push   $0xf01253a0
f010b359:	68 e6 03 00 00       	push   $0x3e6
f010b35e:	68 c3 53 12 f0       	push   $0xf01253c3
f010b363:	e8 b2 4f ff ff       	call   f010031a <_panic>
f010b368:	8b 45 08             	mov    0x8(%ebp),%eax
f010b36b:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b371:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010b374:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b377:	89 c8                	mov    %ecx,%eax
f010b379:	01 c0                	add    %eax,%eax
f010b37b:	01 c8                	add    %ecx,%eax
f010b37d:	c1 e0 03             	shl    $0x3,%eax
f010b380:	01 d8                	add    %ebx,%eax
f010b382:	05 98 00 00 00       	add    $0x98,%eax
f010b387:	89 10                	mov    %edx,(%eax)
f010b389:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b38c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b38f:	89 d0                	mov    %edx,%eax
f010b391:	01 c0                	add    %eax,%eax
f010b393:	01 d0                	add    %edx,%eax
f010b395:	c1 e0 03             	shl    $0x3,%eax
f010b398:	01 c8                	add    %ecx,%eax
f010b39a:	05 98 00 00 00       	add    $0x98,%eax
f010b39f:	8b 00                	mov    (%eax),%eax
f010b3a1:	85 c0                	test   %eax,%eax
f010b3a3:	74 28                	je     f010b3cd <initialize_environment+0x22b>
f010b3a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3a8:	8b 90 48 d5 01 00    	mov    0x1d548(%eax),%edx
f010b3ae:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f010b3b1:	89 c8                	mov    %ecx,%eax
f010b3b3:	01 c0                	add    %eax,%eax
f010b3b5:	01 c8                	add    %ecx,%eax
f010b3b7:	c1 e0 03             	shl    $0x3,%eax
f010b3ba:	8d 88 80 00 00 00    	lea    0x80(%eax),%ecx
f010b3c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3c3:	01 c8                	add    %ecx,%eax
f010b3c5:	83 c0 08             	add    $0x8,%eax
f010b3c8:	89 42 14             	mov    %eax,0x14(%edx)
f010b3cb:	eb 23                	jmp    f010b3f0 <initialize_environment+0x24e>
f010b3cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b3d0:	89 d0                	mov    %edx,%eax
f010b3d2:	01 c0                	add    %eax,%eax
f010b3d4:	01 d0                	add    %edx,%eax
f010b3d6:	c1 e0 03             	shl    $0x3,%eax
f010b3d9:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b3df:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3e2:	01 d0                	add    %edx,%eax
f010b3e4:	8d 50 08             	lea    0x8(%eax),%edx
f010b3e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b3ea:	89 90 4c d5 01 00    	mov    %edx,0x1d54c(%eax)
f010b3f0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b3f3:	89 d0                	mov    %edx,%eax
f010b3f5:	01 c0                	add    %eax,%eax
f010b3f7:	01 d0                	add    %edx,%eax
f010b3f9:	c1 e0 03             	shl    $0x3,%eax
f010b3fc:	8d 90 80 00 00 00    	lea    0x80(%eax),%edx
f010b402:	8b 45 08             	mov    0x8(%ebp),%eax
f010b405:	01 d0                	add    %edx,%eax
f010b407:	8d 50 08             	lea    0x8(%eax),%edx
f010b40a:	8b 45 08             	mov    0x8(%ebp),%eax
f010b40d:	89 90 48 d5 01 00    	mov    %edx,0x1d548(%eax)
f010b413:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b416:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010b419:	89 d0                	mov    %edx,%eax
f010b41b:	01 c0                	add    %eax,%eax
f010b41d:	01 d0                	add    %edx,%eax
f010b41f:	c1 e0 03             	shl    $0x3,%eax
f010b422:	01 c8                	add    %ecx,%eax
f010b424:	05 9c 00 00 00       	add    $0x9c,%eax
f010b429:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010b42f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b432:	8b 80 54 d5 01 00    	mov    0x1d554(%eax),%eax
f010b438:	8d 50 01             	lea    0x1(%eax),%edx
f010b43b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b43e:	89 90 54 d5 01 00    	mov    %edx,0x1d554(%eax)
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
#if USE_KHEAP == 1
		//panic("not handled yet");
#else
		for (int i = 0; i < e->page_WS_max_size; ++i)
f010b444:	ff 45 f0             	incl   -0x10(%ebp)
f010b447:	8b 45 08             	mov    0x8(%ebp),%eax
f010b44a:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b450:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b453:	39 c2                	cmp    %eax,%edx
f010b455:	0f 87 d8 fe ff ff    	ja     f010b333 <initialize_environment+0x191>
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b45b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b462:	eb 54                	jmp    f010b4b8 <initialize_environment+0x316>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
f010b464:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b467:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b46a:	89 d0                	mov    %edx,%eax
f010b46c:	01 c0                	add    %eax,%eax
f010b46e:	01 d0                	add    %edx,%eax
f010b470:	c1 e0 03             	shl    $0x3,%eax
f010b473:	01 c8                	add    %ecx,%eax
f010b475:	05 88 00 00 00       	add    $0x88,%eax
f010b47a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].empty = 1;
f010b480:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b483:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b486:	89 d0                	mov    %edx,%eax
f010b488:	01 c0                	add    %eax,%eax
f010b48a:	01 d0                	add    %edx,%eax
f010b48c:	c1 e0 03             	shl    $0x3,%eax
f010b48f:	01 c8                	add    %ecx,%eax
f010b491:	05 8c 00 00 00       	add    $0x8c,%eax
f010b496:	c6 00 01             	movb   $0x1,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
f010b499:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b49c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b49f:	89 d0                	mov    %edx,%eax
f010b4a1:	01 c0                	add    %eax,%eax
f010b4a3:	01 d0                	add    %edx,%eax
f010b4a5:	c1 e0 03             	shl    $0x3,%eax
f010b4a8:	01 c8                	add    %ecx,%eax
f010b4aa:	05 90 00 00 00       	add    $0x90,%eax
f010b4af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}

	//initialize environment working set
#if USE_KHEAP
#else
	for(i=0; i< (e->page_WS_max_size); i++)
f010b4b5:	ff 45 f4             	incl   -0xc(%ebp)
f010b4b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4bb:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f010b4c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b4c4:	39 c2                	cmp    %eax,%edx
f010b4c6:	77 9c                	ja     f010b464 <initialize_environment+0x2c2>
	{
		e->ptr_pageWorkingSet[i].virtual_address = 0;
		e->ptr_pageWorkingSet[i].empty = 1;
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
f010b4c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b4cb:	c7 80 58 d5 01 00 00 	movl   $0x0,0x1d558(%eax)
f010b4d2:	00 00 00 
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b4d5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010b4dc:	eb 54                	jmp    f010b532 <initialize_environment+0x390>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010b4de:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b4e4:	89 d0                	mov    %edx,%eax
f010b4e6:	01 c0                	add    %eax,%eax
f010b4e8:	01 d0                	add    %edx,%eax
f010b4ea:	c1 e0 03             	shl    $0x3,%eax
f010b4ed:	01 c8                	add    %ecx,%eax
f010b4ef:	05 5c d5 01 00       	add    $0x1d55c,%eax
f010b4f4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010b4fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b4fd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b500:	89 d0                	mov    %edx,%eax
f010b502:	01 c0                	add    %eax,%eax
f010b504:	01 d0                	add    %edx,%eax
f010b506:	c1 e0 03             	shl    $0x3,%eax
f010b509:	01 c8                	add    %ecx,%eax
f010b50b:	05 60 d5 01 00       	add    $0x1d560,%eax
f010b510:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010b513:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010b516:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b519:	89 d0                	mov    %edx,%eax
f010b51b:	01 c0                	add    %eax,%eax
f010b51d:	01 d0                	add    %edx,%eax
f010b51f:	c1 e0 03             	shl    $0x3,%eax
f010b522:	01 c8                	add    %ecx,%eax
f010b524:	05 64 d5 01 00       	add    $0x1d564,%eax
f010b529:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010b52f:	ff 45 f4             	incl   -0xc(%ebp)
f010b532:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010b536:	7e a6                	jle    f010b4de <initialize_environment+0x33c>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010b538:	8b 45 08             	mov    0x8(%ebp),%eax
f010b53b:	c7 80 0c da 01 00 00 	movl   $0x0,0x1da0c(%eax)
f010b542:	00 00 00 

	e->pageFaultsCounter=0;
f010b545:	8b 45 08             	mov    0x8(%ebp),%eax
f010b548:	c7 80 40 da 01 00 00 	movl   $0x0,0x1da40(%eax)
f010b54f:	00 00 00 
	e->tableFaultsCounter=0;
f010b552:	8b 45 08             	mov    0x8(%ebp),%eax
f010b555:	c7 80 44 da 01 00 00 	movl   $0x0,0x1da44(%eax)
f010b55c:	00 00 00 

	e->freeingFullWSCounter = 0;
f010b55f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b562:	c7 80 48 da 01 00 00 	movl   $0x0,0x1da48(%eax)
f010b569:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010b56c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b56f:	c7 80 4c da 01 00 00 	movl   $0x0,0x1da4c(%eax)
f010b576:	00 00 00 

	e->nModifiedPages=0;
f010b579:	8b 45 08             	mov    0x8(%ebp),%eax
f010b57c:	c7 80 50 da 01 00 00 	movl   $0x0,0x1da50(%eax)
f010b583:	00 00 00 
	e->nNotModifiedPages=0;
f010b586:	8b 45 08             	mov    0x8(%ebp),%eax
f010b589:	c7 80 54 da 01 00 00 	movl   $0x0,0x1da54(%eax)
f010b590:	00 00 00 
	e->nClocks = 0;
f010b593:	8b 45 08             	mov    0x8(%ebp),%eax
f010b596:	c7 80 68 da 01 00 00 	movl   $0x0,0x1da68(%eax)
f010b59d:	00 00 00 

	//2020
	e->nPageIn = 0;
f010b5a0:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5a3:	c7 80 5c da 01 00 00 	movl   $0x0,0x1da5c(%eax)
f010b5aa:	00 00 00 
	e->nPageOut = 0;
f010b5ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5b0:	c7 80 60 da 01 00 00 	movl   $0x0,0x1da60(%eax)
f010b5b7:	00 00 00 
	e->nNewPageAdded = 0;
f010b5ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5bd:	c7 80 64 da 01 00 00 	movl   $0x0,0x1da64(%eax)
f010b5c4:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//[PROJECT'24.DONE] call initialize_uheap_dynamic_allocator(...)
	initialize_uheap_dynamic_allocator(e, USER_HEAP_START, USER_HEAP_START + DYN_ALLOC_MAX_SIZE);
f010b5c7:	83 ec 04             	sub    $0x4,%esp
f010b5ca:	68 00 00 00 82       	push   $0x82000000
f010b5cf:	68 00 00 00 80       	push   $0x80000000
f010b5d4:	ff 75 08             	pushl  0x8(%ebp)
f010b5d7:	e8 c0 fb ff ff       	call   f010b19c <initialize_uheap_dynamic_allocator>
f010b5dc:	83 c4 10             	add    $0x10,%esp

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010b5df:	83 ec 0c             	sub    $0xc,%esp
f010b5e2:	ff 75 08             	pushl  0x8(%ebp)
f010b5e5:	e8 09 00 00 00       	call   f010b5f3 <complete_environment_initialization>
f010b5ea:	83 c4 10             	add    $0x10,%esp
}
f010b5ed:	90                   	nop
f010b5ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b5f1:	c9                   	leave  
f010b5f2:	c3                   	ret    

f010b5f3 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010b5f3:	55                   	push   %ebp
f010b5f4:	89 e5                	mov    %esp,%ebp
f010b5f6:	53                   	push   %ebx
f010b5f7:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010b5fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010b5fd:	8b 40 64             	mov    0x64(%eax),%eax
f010b600:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010b606:	8b 45 08             	mov    0x8(%ebp),%eax
f010b609:	8b 40 68             	mov    0x68(%eax),%eax
f010b60c:	83 c8 03             	or     $0x3,%eax
f010b60f:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010b611:	8b 45 08             	mov    0x8(%ebp),%eax
f010b614:	8b 40 64             	mov    0x64(%eax),%eax
f010b617:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010b61d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b620:	8b 40 68             	mov    0x68(%eax),%eax
f010b623:	83 c8 05             	or     $0x5,%eax
f010b626:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010b628:	8b 45 08             	mov    0x8(%ebp),%eax
f010b62b:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010b632:	8b 45 08             	mov    0x8(%ebp),%eax
f010b635:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010b63c:	8b 45 08             	mov    0x8(%ebp),%eax
f010b63f:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010b646:	8b 45 08             	mov    0x8(%ebp),%eax
f010b649:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010b650:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010b653:	8b 45 08             	mov    0x8(%ebp),%eax
f010b656:	8b 58 10             	mov    0x10(%eax),%ebx
f010b659:	83 ec 0c             	sub    $0xc,%esp
f010b65c:	6a 08                	push   $0x8
f010b65e:	e8 9c 36 01 00       	call   f011ecff <log2_ceil>
f010b663:	83 c4 10             	add    $0x10,%esp
f010b666:	ba 01 00 00 00       	mov    $0x1,%edx
f010b66b:	88 c1                	mov    %al,%cl
f010b66d:	d3 e2                	shl    %cl,%edx
f010b66f:	89 d0                	mov    %edx,%eax
f010b671:	01 d8                	add    %ebx,%eax
f010b673:	89 c3                	mov    %eax,%ebx
f010b675:	83 ec 0c             	sub    $0xc,%esp
f010b678:	6a 08                	push   $0x8
f010b67a:	e8 4b 36 01 00       	call   f011ecca <nearest_pow2_ceil>
f010b67f:	83 c4 10             	add    $0x10,%esp
f010b682:	f7 d8                	neg    %eax
f010b684:	21 d8                	and    %ebx,%eax
f010b686:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010b689:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010b68d:	7f 1b                	jg     f010b6aa <complete_environment_initialization+0xb7>
		generation = 1 << ENVGENSHIFT;
f010b68f:	83 ec 0c             	sub    $0xc,%esp
f010b692:	6a 08                	push   $0x8
f010b694:	e8 66 36 01 00       	call   f011ecff <log2_ceil>
f010b699:	83 c4 10             	add    $0x10,%esp
f010b69c:	ba 01 00 00 00       	mov    $0x1,%edx
f010b6a1:	88 c1                	mov    %al,%cl
f010b6a3:	d3 e2                	shl    %cl,%edx
f010b6a5:	89 d0                	mov    %edx,%eax
f010b6a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010b6aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6ad:	8b 15 10 1a 55 f0    	mov    0xf0551a10,%edx
f010b6b3:	29 d0                	sub    %edx,%eax
f010b6b5:	c1 f8 02             	sar    $0x2,%eax
f010b6b8:	89 c2                	mov    %eax,%edx
f010b6ba:	89 d0                	mov    %edx,%eax
f010b6bc:	c1 e0 02             	shl    $0x2,%eax
f010b6bf:	01 d0                	add    %edx,%eax
f010b6c1:	c1 e0 02             	shl    $0x2,%eax
f010b6c4:	01 d0                	add    %edx,%eax
f010b6c6:	c1 e0 02             	shl    $0x2,%eax
f010b6c9:	01 d0                	add    %edx,%eax
f010b6cb:	c1 e0 02             	shl    $0x2,%eax
f010b6ce:	01 d0                	add    %edx,%eax
f010b6d0:	c1 e0 08             	shl    $0x8,%eax
f010b6d3:	29 d0                	sub    %edx,%eax
f010b6d5:	c1 e0 08             	shl    $0x8,%eax
f010b6d8:	29 d0                	sub    %edx,%eax
f010b6da:	c1 e0 03             	shl    $0x3,%eax
f010b6dd:	01 d0                	add    %edx,%eax
f010b6df:	c1 e0 03             	shl    $0x3,%eax
f010b6e2:	01 d0                	add    %edx,%eax
f010b6e4:	01 c0                	add    %eax,%eax
f010b6e6:	01 d0                	add    %edx,%eax
f010b6e8:	0b 45 f4             	or     -0xc(%ebp),%eax
f010b6eb:	89 c2                	mov    %eax,%edx
f010b6ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010b6f0:	89 50 10             	mov    %edx,0x10(%eax)

	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010b6f3:	e8 79 ed ff ff       	call   f010a471 <get_cpu_proc>
f010b6f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010b6fb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010b6ff:	75 0c                	jne    f010b70d <complete_environment_initialization+0x11a>
		e->env_parent_id = 0;//no parent;
f010b701:	8b 45 08             	mov    0x8(%ebp),%eax
f010b704:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b70b:	eb 0c                	jmp    f010b719 <complete_environment_initialization+0x126>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010b70d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b710:	8b 50 10             	mov    0x10(%eax),%edx
f010b713:	8b 45 08             	mov    0x8(%ebp),%eax
f010b716:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010b719:	8b 45 08             	mov    0x8(%ebp),%eax
f010b71c:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010b723:	8b 45 08             	mov    0x8(%ebp),%eax
f010b726:	c7 80 58 da 01 00 00 	movl   $0x0,0x1da58(%eax)
f010b72d:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010b730:	8b 45 08             	mov    0x8(%ebp),%eax
f010b733:	8b 00                	mov    (%eax),%eax
f010b735:	83 ec 04             	sub    $0x4,%esp
f010b738:	6a 44                	push   $0x44
f010b73a:	6a 00                	push   $0x0
f010b73c:	50                   	push   %eax
f010b73d:	e8 df 4f 01 00       	call   f0120721 <memset>
f010b742:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010b745:	8b 45 08             	mov    0x8(%ebp),%eax
f010b748:	8b 00                	mov    (%eax),%eax
f010b74a:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010b750:	8b 45 08             	mov    0x8(%ebp),%eax
f010b753:	8b 00                	mov    (%eax),%eax
f010b755:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010b75b:	8b 45 08             	mov    0x8(%ebp),%eax
f010b75e:	8b 00                	mov    (%eax),%eax
f010b760:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010b766:	8b 45 08             	mov    0x8(%ebp),%eax
f010b769:	8b 00                	mov    (%eax),%eax
f010b76b:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010b772:	8b 45 08             	mov    0x8(%ebp),%eax
f010b775:	8b 00                	mov    (%eax),%eax
f010b777:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010b77d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b780:	8b 00                	mov    (%eax),%eax
f010b782:	8b 55 08             	mov    0x8(%ebp),%edx
f010b785:	8b 12                	mov    (%edx),%edx
f010b787:	8b 52 38             	mov    0x38(%edx),%edx
f010b78a:	80 ce 02             	or     $0x2,%dh
f010b78d:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010b790:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010b794:	75 17                	jne    f010b7ad <complete_environment_initialization+0x1ba>
f010b796:	83 ec 04             	sub    $0x4,%esp
f010b799:	68 55 54 12 f0       	push   $0xf0125455
f010b79e:	68 52 04 00 00       	push   $0x452
f010b7a3:	68 c3 53 12 f0       	push   $0xf01253c3
f010b7a8:	e8 6d 4b ff ff       	call   f010031a <_panic>
f010b7ad:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7b0:	8b 40 08             	mov    0x8(%eax),%eax
f010b7b3:	85 c0                	test   %eax,%eax
f010b7b5:	74 11                	je     f010b7c8 <complete_environment_initialization+0x1d5>
f010b7b7:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7ba:	8b 40 08             	mov    0x8(%eax),%eax
f010b7bd:	8b 55 08             	mov    0x8(%ebp),%edx
f010b7c0:	8b 52 0c             	mov    0xc(%edx),%edx
f010b7c3:	89 50 0c             	mov    %edx,0xc(%eax)
f010b7c6:	eb 0b                	jmp    f010b7d3 <complete_environment_initialization+0x1e0>
f010b7c8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7cb:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7ce:	a3 18 1a 55 f0       	mov    %eax,0xf0551a18
f010b7d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7d6:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7d9:	85 c0                	test   %eax,%eax
f010b7db:	74 11                	je     f010b7ee <complete_environment_initialization+0x1fb>
f010b7dd:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7e0:	8b 40 0c             	mov    0xc(%eax),%eax
f010b7e3:	8b 55 08             	mov    0x8(%ebp),%edx
f010b7e6:	8b 52 08             	mov    0x8(%edx),%edx
f010b7e9:	89 50 08             	mov    %edx,0x8(%eax)
f010b7ec:	eb 0b                	jmp    f010b7f9 <complete_environment_initialization+0x206>
f010b7ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7f1:	8b 40 08             	mov    0x8(%eax),%eax
f010b7f4:	a3 14 1a 55 f0       	mov    %eax,0xf0551a14
f010b7f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010b7fc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010b803:	8b 45 08             	mov    0x8(%ebp),%eax
f010b806:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010b80d:	a1 20 1a 55 f0       	mov    0xf0551a20,%eax
f010b812:	48                   	dec    %eax
f010b813:	a3 20 1a 55 f0       	mov    %eax,0xf0551a20
	return ;
f010b818:	90                   	nop
}
f010b819:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010b81c:	c9                   	leave  
f010b81d:	c3                   	ret    

f010b81e <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010b81e:	55                   	push   %ebp
f010b81f:	89 e5                	mov    %esp,%ebp
f010b821:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b824:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b827:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b82a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b82d:	8b 00                	mov    (%eax),%eax
f010b82f:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b834:	74 17                	je     f010b84d <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010b836:	83 ec 04             	sub    $0x4,%esp
f010b839:	68 e3 56 12 f0       	push   $0xf01256e3
f010b83e:	68 5e 04 00 00       	push   $0x45e
f010b843:	68 c3 53 12 f0       	push   $0xf01253c3
f010b848:	e8 cd 4a ff ff       	call   f010031a <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010b84d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b850:	8b 00                	mov    (%eax),%eax
f010b852:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010b855:	8b 52 18             	mov    0x18(%edx),%edx
f010b858:	89 50 30             	mov    %edx,0x30(%eax)
}
f010b85b:	90                   	nop
f010b85c:	c9                   	leave  
f010b85d:	c3                   	ret    

f010b85e <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 11) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010b85e:	55                   	push   %ebp
f010b85f:	89 e5                	mov    %esp,%ebp
f010b861:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010b864:	8b 45 08             	mov    0x8(%ebp),%eax
f010b867:	8b 40 10             	mov    0x10(%eax),%eax
f010b86a:	8d 48 01             	lea    0x1(%eax),%ecx
f010b86d:	8b 55 08             	mov    0x8(%ebp),%edx
f010b870:	89 4a 10             	mov    %ecx,0x10(%edx)
f010b873:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b876:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b879:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b87c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b87f:	8b 00                	mov    (%eax),%eax
f010b881:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b886:	74 17                	je     f010b89f <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010b888:	83 ec 04             	sub    $0x4,%esp
f010b88b:	68 e3 56 12 f0       	push   $0xf01256e3
f010b890:	68 6c 04 00 00       	push   $0x46c
f010b895:	68 c3 53 12 f0       	push   $0xf01253c3
f010b89a:	e8 7b 4a ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010b89f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8a2:	8b 50 1c             	mov    0x1c(%eax),%edx
f010b8a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b8a8:	01 d0                	add    %edx,%eax
f010b8aa:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010b8ad:	eb 0f                	jmp    f010b8be <PROGRAM_SEGMENT_NEXT+0x60>
f010b8af:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8b2:	8b 40 10             	mov    0x10(%eax),%eax
f010b8b5:	8d 50 01             	lea    0x1(%eax),%edx
f010b8b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8bb:	89 50 10             	mov    %edx,0x10(%eax)
f010b8be:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8c1:	8b 40 10             	mov    0x10(%eax),%eax
f010b8c4:	c1 e0 05             	shl    $0x5,%eax
f010b8c7:	89 c2                	mov    %eax,%edx
f010b8c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b8cc:	01 d0                	add    %edx,%eax
f010b8ce:	8b 00                	mov    (%eax),%eax
f010b8d0:	83 f8 01             	cmp    $0x1,%eax
f010b8d3:	74 13                	je     f010b8e8 <PROGRAM_SEGMENT_NEXT+0x8a>
f010b8d5:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8d8:	8b 50 10             	mov    0x10(%eax),%edx
f010b8db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8de:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b8e1:	0f b7 c0             	movzwl %ax,%eax
f010b8e4:	39 c2                	cmp    %eax,%edx
f010b8e6:	72 c7                	jb     f010b8af <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010b8e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010b8eb:	8b 40 10             	mov    0x10(%eax),%eax
f010b8ee:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010b8f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010b8f4:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b8f7:	0f b7 c0             	movzwl %ax,%eax
f010b8fa:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010b8fd:	7e 63                	jle    f010b962 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010b8ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b902:	c1 e0 05             	shl    $0x5,%eax
f010b905:	89 c2                	mov    %eax,%edx
f010b907:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b90a:	01 d0                	add    %edx,%eax
f010b90c:	8b 50 04             	mov    0x4(%eax),%edx
f010b90f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b912:	01 c2                	add    %eax,%edx
f010b914:	8b 45 08             	mov    0x8(%ebp),%eax
f010b917:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010b919:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b91c:	c1 e0 05             	shl    $0x5,%eax
f010b91f:	89 c2                	mov    %eax,%edx
f010b921:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b924:	01 d0                	add    %edx,%eax
f010b926:	8b 50 14             	mov    0x14(%eax),%edx
f010b929:	8b 45 08             	mov    0x8(%ebp),%eax
f010b92c:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010b92f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b932:	c1 e0 05             	shl    $0x5,%eax
f010b935:	89 c2                	mov    %eax,%edx
f010b937:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b93a:	01 d0                	add    %edx,%eax
f010b93c:	8b 50 10             	mov    0x10(%eax),%edx
f010b93f:	8b 45 08             	mov    0x8(%ebp),%eax
f010b942:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010b945:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010b948:	c1 e0 05             	shl    $0x5,%eax
f010b94b:	89 c2                	mov    %eax,%edx
f010b94d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010b950:	01 d0                	add    %edx,%eax
f010b952:	8b 40 08             	mov    0x8(%eax),%eax
f010b955:	89 c2                	mov    %eax,%edx
f010b957:	8b 45 08             	mov    0x8(%ebp),%eax
f010b95a:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010b95d:	8b 45 08             	mov    0x8(%ebp),%eax
f010b960:	eb 05                	jmp    f010b967 <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010b962:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010b967:	c9                   	leave  
f010b968:	c3                   	ret    

f010b969 <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 12) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010b969:	55                   	push   %ebp
f010b96a:	89 e5                	mov    %esp,%ebp
f010b96c:	57                   	push   %edi
f010b96d:	56                   	push   %esi
f010b96e:	53                   	push   %ebx
f010b96f:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010b972:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010b979:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b97c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010b97f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b982:	8b 00                	mov    (%eax),%eax
f010b984:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010b989:	74 17                	je     f010b9a2 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010b98b:	83 ec 04             	sub    $0x4,%esp
f010b98e:	68 e3 56 12 f0       	push   $0xf01256e3
f010b993:	68 88 04 00 00       	push   $0x488
f010b998:	68 c3 53 12 f0       	push   $0xf01253c3
f010b99d:	e8 78 49 ff ff       	call   f010031a <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010b9a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9a5:	8b 50 1c             	mov    0x1c(%eax),%edx
f010b9a8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010b9ab:	01 d0                	add    %edx,%eax
f010b9ad:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010b9b0:	eb 07                	jmp    f010b9b9 <PROGRAM_SEGMENT_FIRST+0x50>
f010b9b2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9b5:	40                   	inc    %eax
f010b9b6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b9b9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9bc:	c1 e0 05             	shl    $0x5,%eax
f010b9bf:	89 c2                	mov    %eax,%edx
f010b9c1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b9c4:	01 d0                	add    %edx,%eax
f010b9c6:	8b 00                	mov    (%eax),%eax
f010b9c8:	83 f8 01             	cmp    $0x1,%eax
f010b9cb:	74 10                	je     f010b9dd <PROGRAM_SEGMENT_FIRST+0x74>
f010b9cd:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010b9d0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9d3:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b9d6:	0f b7 c0             	movzwl %ax,%eax
f010b9d9:	39 c2                	cmp    %eax,%edx
f010b9db:	72 d5                	jb     f010b9b2 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010b9dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b9e0:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010b9e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b9e6:	8b 40 2c             	mov    0x2c(%eax),%eax
f010b9e9:	0f b7 c0             	movzwl %ax,%eax
f010b9ec:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010b9ef:	7e 68                	jle    f010ba59 <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010b9f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010b9f4:	c1 e0 05             	shl    $0x5,%eax
f010b9f7:	89 c2                	mov    %eax,%edx
f010b9f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010b9fc:	01 d0                	add    %edx,%eax
f010b9fe:	8b 50 04             	mov    0x4(%eax),%edx
f010ba01:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ba04:	01 d0                	add    %edx,%eax
f010ba06:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010ba09:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba0c:	c1 e0 05             	shl    $0x5,%eax
f010ba0f:	89 c2                	mov    %eax,%edx
f010ba11:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba14:	01 d0                	add    %edx,%eax
f010ba16:	8b 40 14             	mov    0x14(%eax),%eax
f010ba19:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010ba1c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba1f:	c1 e0 05             	shl    $0x5,%eax
f010ba22:	89 c2                	mov    %eax,%edx
f010ba24:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba27:	01 d0                	add    %edx,%eax
f010ba29:	8b 40 10             	mov    0x10(%eax),%eax
f010ba2c:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010ba2f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010ba32:	c1 e0 05             	shl    $0x5,%eax
f010ba35:	89 c2                	mov    %eax,%edx
f010ba37:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010ba3a:	01 d0                	add    %edx,%eax
f010ba3c:	8b 40 08             	mov    0x8(%eax),%eax
f010ba3f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010ba42:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba45:	89 c3                	mov    %eax,%ebx
f010ba47:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ba4a:	ba 05 00 00 00       	mov    $0x5,%edx
f010ba4f:	89 df                	mov    %ebx,%edi
f010ba51:	89 c6                	mov    %eax,%esi
f010ba53:	89 d1                	mov    %edx,%ecx
f010ba55:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010ba57:	eb 1c                	jmp    f010ba75 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010ba59:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010ba60:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba63:	89 c3                	mov    %eax,%ebx
f010ba65:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010ba68:	ba 05 00 00 00       	mov    $0x5,%edx
f010ba6d:	89 df                	mov    %ebx,%edi
f010ba6f:	89 c6                	mov    %eax,%esi
f010ba71:	89 d1                	mov    %edx,%ecx
f010ba73:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010ba75:	8b 45 08             	mov    0x8(%ebp),%eax
f010ba78:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ba7b:	5b                   	pop    %ebx
f010ba7c:	5e                   	pop    %esi
f010ba7d:	5f                   	pop    %edi
f010ba7e:	5d                   	pop    %ebp
f010ba7f:	c2 04 00             	ret    $0x4

f010ba82 <cleanup_buffers>:

//===============================================================================
// 13) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010ba82:	55                   	push   %ebp
f010ba83:	89 e5                	mov    %esp,%ebp
f010ba85:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010ba88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
f010ba8f:	83 ec 0c             	sub    $0xc,%esp
f010ba92:	68 40 25 55 f0       	push   $0xf0552540
f010ba97:	e8 e4 2c 00 00       	call   f010e780 <acquire_spinlock>
f010ba9c:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010ba9f:	a1 30 25 55 f0       	mov    0xf0552530,%eax
f010baa4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010baa7:	e9 c3 00 00 00       	jmp    f010bb6f <cleanup_buffers+0xed>
		{
			if(ptr_fi->proc == e)
f010baac:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baaf:	8b 40 0c             	mov    0xc(%eax),%eax
f010bab2:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bab5:	0f 85 ac 00 00 00    	jne    f010bb67 <cleanup_buffers+0xe5>
			{
				pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->bufferedVA);
f010babb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010babe:	8b 50 10             	mov    0x10(%eax),%edx
f010bac1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bac4:	8b 40 0c             	mov    0xc(%eax),%eax
f010bac7:	8b 40 64             	mov    0x64(%eax),%eax
f010baca:	83 ec 08             	sub    $0x8,%esp
f010bacd:	52                   	push   %edx
f010bace:	50                   	push   %eax
f010bacf:	e8 62 ce ff ff       	call   f0108936 <pt_clear_page_table_entry>
f010bad4:	83 c4 10             	add    $0x10,%esp

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010bad7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010badb:	75 17                	jne    f010baf4 <cleanup_buffers+0x72>
f010badd:	83 ec 04             	sub    $0x4,%esp
f010bae0:	68 55 54 12 f0       	push   $0xf0125455
f010bae5:	68 b1 04 00 00       	push   $0x4b1
f010baea:	68 c3 53 12 f0       	push   $0xf01253c3
f010baef:	e8 26 48 ff ff       	call   f010031a <_panic>
f010baf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010baf7:	8b 00                	mov    (%eax),%eax
f010baf9:	85 c0                	test   %eax,%eax
f010bafb:	74 10                	je     f010bb0d <cleanup_buffers+0x8b>
f010bafd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb00:	8b 00                	mov    (%eax),%eax
f010bb02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb05:	8b 52 04             	mov    0x4(%edx),%edx
f010bb08:	89 50 04             	mov    %edx,0x4(%eax)
f010bb0b:	eb 0b                	jmp    f010bb18 <cleanup_buffers+0x96>
f010bb0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb10:	8b 40 04             	mov    0x4(%eax),%eax
f010bb13:	a3 34 25 55 f0       	mov    %eax,0xf0552534
f010bb18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb1b:	8b 40 04             	mov    0x4(%eax),%eax
f010bb1e:	85 c0                	test   %eax,%eax
f010bb20:	74 0f                	je     f010bb31 <cleanup_buffers+0xaf>
f010bb22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb25:	8b 40 04             	mov    0x4(%eax),%eax
f010bb28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bb2b:	8b 12                	mov    (%edx),%edx
f010bb2d:	89 10                	mov    %edx,(%eax)
f010bb2f:	eb 0a                	jmp    f010bb3b <cleanup_buffers+0xb9>
f010bb31:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb34:	8b 00                	mov    (%eax),%eax
f010bb36:	a3 30 25 55 f0       	mov    %eax,0xf0552530
f010bb3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb3e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010bb44:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb47:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010bb4e:	a1 3c 25 55 f0       	mov    0xf055253c,%eax
f010bb53:	48                   	dec    %eax
f010bb54:	a3 3c 25 55 f0       	mov    %eax,0xf055253c

				free_frame(ptr_fi);
f010bb59:	83 ec 0c             	sub    $0xc,%esp
f010bb5c:	ff 75 f4             	pushl  -0xc(%ebp)
f010bb5f:	e8 c1 c4 ff ff       	call   f0108025 <free_frame>
f010bb64:	83 c4 10             	add    $0x10,%esp
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	acquire_spinlock(&MemFrameLists.mfllock);
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010bb67:	a1 38 25 55 f0       	mov    0xf0552538,%eax
f010bb6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010bb6f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb73:	74 07                	je     f010bb7c <cleanup_buffers+0xfa>
f010bb75:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb78:	8b 00                	mov    (%eax),%eax
f010bb7a:	eb 05                	jmp    f010bb81 <cleanup_buffers+0xff>
f010bb7c:	b8 00 00 00 00       	mov    $0x0,%eax
f010bb81:	a3 38 25 55 f0       	mov    %eax,0xf0552538
f010bb86:	a1 38 25 55 f0       	mov    0xf0552538,%eax
f010bb8b:	85 c0                	test   %eax,%eax
f010bb8d:	0f 85 19 ff ff ff    	jne    f010baac <cleanup_buffers+0x2a>
f010bb93:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bb97:	0f 85 0f ff ff ff    	jne    f010baac <cleanup_buffers+0x2a>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010bb9d:	83 ec 0c             	sub    $0xc,%esp
f010bba0:	68 40 25 55 f0       	push   $0xf0552540
f010bba5:	e8 5d 2c 00 00       	call   f010e807 <release_spinlock>
f010bbaa:	83 c4 10             	add    $0x10,%esp

	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010bbad:	90                   	nop
f010bbae:	c9                   	leave  
f010bbaf:	c3                   	ret    

f010bbb0 <set_program_priority>:
#include "../disk/pagefile_manager.h"
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"

void set_program_priority(struct Env* env, int priority)
{
f010bbb0:	55                   	push   %ebp
f010bbb1:	89 e5                	mov    %esp,%ebp
f010bbb3:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010bbb6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010bbba:	7e 06                	jle    f010bbc2 <set_program_priority+0x12>
f010bbbc:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bbc0:	7e 14                	jle    f010bbd6 <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010bbc2:	83 ec 04             	sub    $0x4,%esp
f010bbc5:	68 fc 56 12 f0       	push   $0xf01256fc
f010bbca:	6a 10                	push   $0x10
f010bbcc:	68 20 57 12 f0       	push   $0xf0125720
f010bbd1:	e8 44 47 ff ff       	call   f010031a <_panic>
		return;
	}
	if(env == NULL)
f010bbd6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bbda:	74 78                	je     f010bc54 <set_program_priority+0xa4>
		return;
	switch(priority)
f010bbdc:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010bbe0:	77 56                	ja     f010bc38 <set_program_priority+0x88>
f010bbe2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbe5:	c1 e0 02             	shl    $0x2,%eax
f010bbe8:	05 5c 57 12 f0       	add    $0xf012575c,%eax
f010bbed:	8b 00                	mov    (%eax),%eax
f010bbef:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010bbf1:	83 ec 08             	sub    $0x8,%esp
f010bbf4:	6a 01                	push   $0x1
f010bbf6:	ff 75 08             	pushl  0x8(%ebp)
f010bbf9:	e8 b6 d7 ff ff       	call   f01093b4 <half_WS_Size>
f010bbfe:	83 c4 10             	add    $0x10,%esp
			break;
f010bc01:	eb 35                	jmp    f010bc38 <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010bc03:	83 ec 08             	sub    $0x8,%esp
f010bc06:	6a 00                	push   $0x0
f010bc08:	ff 75 08             	pushl  0x8(%ebp)
f010bc0b:	e8 a4 d7 ff ff       	call   f01093b4 <half_WS_Size>
f010bc10:	83 c4 10             	add    $0x10,%esp
			break;
f010bc13:	eb 23                	jmp    f010bc38 <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010bc15:	83 ec 08             	sub    $0x8,%esp
f010bc18:	6a 01                	push   $0x1
f010bc1a:	ff 75 08             	pushl  0x8(%ebp)
f010bc1d:	e8 75 d7 ff ff       	call   f0109397 <double_WS_Size>
f010bc22:	83 c4 10             	add    $0x10,%esp
			break;
f010bc25:	eb 11                	jmp    f010bc38 <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010bc27:	83 ec 08             	sub    $0x8,%esp
f010bc2a:	6a 00                	push   $0x0
f010bc2c:	ff 75 08             	pushl  0x8(%ebp)
f010bc2f:	e8 63 d7 ff ff       	call   f0109397 <double_WS_Size>
f010bc34:	83 c4 10             	add    $0x10,%esp
			break;
f010bc37:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010bc38:	8b 45 08             	mov    0x8(%ebp),%eax
f010bc3b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010bc41:	83 ec 08             	sub    $0x8,%esp
f010bc44:	50                   	push   %eax
f010bc45:	68 3d 57 12 f0       	push   $0xf012573d
f010bc4a:	e8 1d 53 ff ff       	call   f0100f6c <cprintf>
f010bc4f:	83 c4 10             	add    $0x10,%esp
f010bc52:	eb 01                	jmp    f010bc55 <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010bc54:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010bc55:	c9                   	leave  
f010bc56:	c3                   	ret    

f010bc57 <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010bc57:	55                   	push   %ebp
f010bc58:	89 e5                	mov    %esp,%ebp
f010bc5a:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bc5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bc64:	eb 29                	jmp    f010bc8f <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010bc66:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc69:	89 d0                	mov    %edx,%eax
f010bc6b:	01 c0                	add    %eax,%eax
f010bc6d:	01 d0                	add    %edx,%eax
f010bc6f:	c1 e0 02             	shl    $0x2,%eax
f010bc72:	05 80 99 17 f0       	add    $0xf0179980,%eax
f010bc77:	8b 00                	mov    (%eax),%eax
f010bc79:	83 ec 08             	sub    $0x8,%esp
f010bc7c:	50                   	push   %eax
f010bc7d:	ff 75 08             	pushl  0x8(%ebp)
f010bc80:	e8 ba 49 01 00       	call   f012063f <strcmp>
f010bc85:	83 c4 10             	add    $0x10,%esp
f010bc88:	85 c0                	test   %eax,%eax
f010bc8a:	74 0f                	je     f010bc9b <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bc8c:	ff 45 f4             	incl   -0xc(%ebp)
f010bc8f:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bc94:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bc97:	7c cd                	jl     f010bc66 <get_user_program_info+0xf>
f010bc99:	eb 01                	jmp    f010bc9c <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010bc9b:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bc9c:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bca1:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bca4:	75 1a                	jne    f010bcc0 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010bca6:	83 ec 08             	sub    $0x8,%esp
f010bca9:	ff 75 08             	pushl  0x8(%ebp)
f010bcac:	68 c5 63 12 f0       	push   $0xf01263c5
f010bcb1:	e8 b6 52 ff ff       	call   f0100f6c <cprintf>
f010bcb6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bcb9:	b8 00 00 00 00       	mov    $0x0,%eax
f010bcbe:	eb 11                	jmp    f010bcd1 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010bcc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bcc3:	89 d0                	mov    %edx,%eax
f010bcc5:	01 c0                	add    %eax,%eax
f010bcc7:	01 d0                	add    %edx,%eax
f010bcc9:	c1 e0 02             	shl    $0x2,%eax
f010bccc:	05 80 99 17 f0       	add    $0xf0179980,%eax
}
f010bcd1:	c9                   	leave  
f010bcd2:	c3                   	ret    

f010bcd3 <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010bcd3:	55                   	push   %ebp
f010bcd4:	89 e5                	mov    %esp,%ebp
f010bcd6:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bcd9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010bce0:	eb 2d                	jmp    f010bd0f <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010bce2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bce5:	89 d0                	mov    %edx,%eax
f010bce7:	01 c0                	add    %eax,%eax
f010bce9:	01 d0                	add    %edx,%eax
f010bceb:	c1 e0 02             	shl    $0x2,%eax
f010bcee:	05 80 99 17 f0       	add    $0xf0179980,%eax
f010bcf3:	8b 00                	mov    (%eax),%eax
f010bcf5:	8b 55 08             	mov    0x8(%ebp),%edx
f010bcf8:	83 c2 20             	add    $0x20,%edx
f010bcfb:	83 ec 08             	sub    $0x8,%esp
f010bcfe:	50                   	push   %eax
f010bcff:	52                   	push   %edx
f010bd00:	e8 3a 49 01 00       	call   f012063f <strcmp>
f010bd05:	83 c4 10             	add    $0x10,%esp
f010bd08:	85 c0                	test   %eax,%eax
f010bd0a:	74 0f                	je     f010bd1b <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010bd0c:	ff 45 f4             	incl   -0xc(%ebp)
f010bd0f:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bd14:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bd17:	7c c9                	jl     f010bce2 <get_user_program_info_by_env+0xf>
f010bd19:	eb 01                	jmp    f010bd1c <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010bd1b:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010bd1c:	a1 a8 9c 17 f0       	mov    0xf0179ca8,%eax
f010bd21:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010bd24:	75 17                	jne    f010bd3d <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010bd26:	83 ec 0c             	sub    $0xc,%esp
f010bd29:	68 e0 63 12 f0       	push   $0xf01263e0
f010bd2e:	e8 39 52 ff ff       	call   f0100f6c <cprintf>
f010bd33:	83 c4 10             	add    $0x10,%esp
		return 0;
f010bd36:	b8 00 00 00 00       	mov    $0x0,%eax
f010bd3b:	eb 11                	jmp    f010bd4e <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010bd3d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd40:	89 d0                	mov    %edx,%eax
f010bd42:	01 c0                	add    %eax,%eax
f010bd44:	01 d0                	add    %edx,%eax
f010bd46:	c1 e0 02             	shl    $0x2,%eax
f010bd49:	05 80 99 17 f0       	add    $0xf0179980,%eax
}
f010bd4e:	c9                   	leave  
f010bd4f:	c3                   	ret    

f010bd50 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010bd50:	55                   	push   %ebp
f010bd51:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010bd53:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd56:	83 f8 13             	cmp    $0x13,%eax
f010bd59:	77 0c                	ja     f010bd67 <trapname+0x17>
		return excnames[trapno];
f010bd5b:	8b 45 08             	mov    0x8(%ebp),%eax
f010bd5e:	8b 04 85 c0 67 12 f0 	mov    -0xfed9840(,%eax,4),%eax
f010bd65:	eb 2c                	jmp    f010bd93 <trapname+0x43>
	if (trapno == T_SYSCALL)
f010bd67:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010bd6b:	75 07                	jne    f010bd74 <trapname+0x24>
		return "System call";
f010bd6d:	b8 00 64 12 f0       	mov    $0xf0126400,%eax
f010bd72:	eb 1f                	jmp    f010bd93 <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010bd74:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010bd78:	75 07                	jne    f010bd81 <trapname+0x31>
		return "Clock Interrupt";
f010bd7a:	b8 0c 64 12 f0       	mov    $0xf012640c,%eax
f010bd7f:	eb 12                	jmp    f010bd93 <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010bd81:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010bd85:	75 07                	jne    f010bd8e <trapname+0x3e>
		return "Keyboard Interrupt";
f010bd87:	b8 1c 64 12 f0       	mov    $0xf012641c,%eax
f010bd8c:	eb 05                	jmp    f010bd93 <trapname+0x43>
	return "(unknown trap)";
f010bd8e:	b8 2f 64 12 f0       	mov    $0xf012642f,%eax
}
f010bd93:	5d                   	pop    %ebp
f010bd94:	c3                   	ret    

f010bd95 <ts_init>:


void ts_init(void)
{
f010bd95:	55                   	push   %ebp
f010bd96:	89 e5                	mov    %esp,%ebp
f010bd98:	53                   	push   %ebx
f010bd99:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010bd9c:	e8 20 b1 ff ff       	call   f0106ec1 <pushcli>

	struct cpu* c = mycpu();
f010bda1:	e8 58 b0 ff ff       	call   f0106dfe <mycpu>
f010bda6:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010bda9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdac:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010bdb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdb6:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010bdbc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdbf:	83 c0 0c             	add    $0xc,%eax
f010bdc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdc5:	83 c2 0c             	add    $0xc,%edx
f010bdc8:	c1 ea 10             	shr    $0x10,%edx
f010bdcb:	88 d3                	mov    %dl,%bl
f010bdcd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bdd0:	83 c2 0c             	add    $0xc,%edx
f010bdd3:	c1 ea 18             	shr    $0x18,%edx
f010bdd6:	88 d1                	mov    %dl,%cl
f010bdd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bddb:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010bde2:	68 00 
f010bde4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bde7:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010bdee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdf1:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010bdf7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bdfa:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be00:	83 e2 f0             	and    $0xfffffff0,%edx
f010be03:	83 ca 09             	or     $0x9,%edx
f010be06:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be0f:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be15:	83 ca 10             	or     $0x10,%edx
f010be18:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be21:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be27:	83 e2 9f             	and    $0xffffff9f,%edx
f010be2a:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be30:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be33:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be39:	83 ca 80             	or     $0xffffff80,%edx
f010be3c:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be45:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be4b:	83 e2 f0             	and    $0xfffffff0,%edx
f010be4e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be57:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be5d:	83 e2 ef             	and    $0xffffffef,%edx
f010be60:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be69:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be6f:	83 e2 df             	and    $0xffffffdf,%edx
f010be72:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be78:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be7b:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be81:	83 ca 40             	or     $0x40,%edx
f010be84:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be8d:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010be93:	83 e2 7f             	and    $0x7f,%edx
f010be96:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010be9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be9f:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010bea5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bea8:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010beae:	83 e2 ef             	and    $0xffffffef,%edx
f010beb1:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010beb7:	e8 57 b0 ff ff       	call   f0106f13 <popcli>
f010bebc:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010bec2:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010bec6:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010bec9:	90                   	nop
f010beca:	83 c4 14             	add    $0x14,%esp
f010becd:	5b                   	pop    %ebx
f010bece:	5d                   	pop    %ebp
f010becf:	c3                   	ret    

f010bed0 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010bed0:	55                   	push   %ebp
f010bed1:	89 e5                	mov    %esp,%ebp
f010bed3:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010bed6:	b8 7e d3 10 f0       	mov    $0xf010d37e,%eax
f010bedb:	66 a3 80 1a 55 f0    	mov    %ax,0xf0551a80
f010bee1:	66 c7 05 82 1a 55 f0 	movw   $0x8,0xf0551a82
f010bee8:	08 00 
f010beea:	a0 84 1a 55 f0       	mov    0xf0551a84,%al
f010beef:	83 e0 e0             	and    $0xffffffe0,%eax
f010bef2:	a2 84 1a 55 f0       	mov    %al,0xf0551a84
f010bef7:	a0 84 1a 55 f0       	mov    0xf0551a84,%al
f010befc:	83 e0 1f             	and    $0x1f,%eax
f010beff:	a2 84 1a 55 f0       	mov    %al,0xf0551a84
f010bf04:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf09:	83 e0 f0             	and    $0xfffffff0,%eax
f010bf0c:	83 c8 0e             	or     $0xe,%eax
f010bf0f:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf14:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf19:	83 e0 ef             	and    $0xffffffef,%eax
f010bf1c:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf21:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf26:	83 e0 9f             	and    $0xffffff9f,%eax
f010bf29:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf2e:	a0 85 1a 55 f0       	mov    0xf0551a85,%al
f010bf33:	83 c8 80             	or     $0xffffff80,%eax
f010bf36:	a2 85 1a 55 f0       	mov    %al,0xf0551a85
f010bf3b:	b8 7e d3 10 f0       	mov    $0xf010d37e,%eax
f010bf40:	c1 e8 10             	shr    $0x10,%eax
f010bf43:	66 a3 86 1a 55 f0    	mov    %ax,0xf0551a86
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010bf49:	b8 86 d3 10 f0       	mov    $0xf010d386,%eax
f010bf4e:	66 a3 b0 1a 55 f0    	mov    %ax,0xf0551ab0
f010bf54:	66 c7 05 b2 1a 55 f0 	movw   $0x8,0xf0551ab2
f010bf5b:	08 00 
f010bf5d:	a0 b4 1a 55 f0       	mov    0xf0551ab4,%al
f010bf62:	83 e0 e0             	and    $0xffffffe0,%eax
f010bf65:	a2 b4 1a 55 f0       	mov    %al,0xf0551ab4
f010bf6a:	a0 b4 1a 55 f0       	mov    0xf0551ab4,%al
f010bf6f:	83 e0 1f             	and    $0x1f,%eax
f010bf72:	a2 b4 1a 55 f0       	mov    %al,0xf0551ab4
f010bf77:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bf7c:	83 e0 f0             	and    $0xfffffff0,%eax
f010bf7f:	83 c8 0e             	or     $0xe,%eax
f010bf82:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bf87:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bf8c:	83 e0 ef             	and    $0xffffffef,%eax
f010bf8f:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bf94:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bf99:	83 e0 9f             	and    $0xffffff9f,%eax
f010bf9c:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bfa1:	a0 b5 1a 55 f0       	mov    0xf0551ab5,%al
f010bfa6:	83 c8 80             	or     $0xffffff80,%eax
f010bfa9:	a2 b5 1a 55 f0       	mov    %al,0xf0551ab5
f010bfae:	b8 86 d3 10 f0       	mov    $0xf010d386,%eax
f010bfb3:	c1 e8 10             	shr    $0x10,%eax
f010bfb6:	66 a3 b6 1a 55 f0    	mov    %ax,0xf0551ab6
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010bfbc:	b8 8e d3 10 f0       	mov    $0xf010d38e,%eax
f010bfc1:	66 a3 40 1b 55 f0    	mov    %ax,0xf0551b40
f010bfc7:	66 c7 05 42 1b 55 f0 	movw   $0x8,0xf0551b42
f010bfce:	08 00 
f010bfd0:	a0 44 1b 55 f0       	mov    0xf0551b44,%al
f010bfd5:	83 e0 e0             	and    $0xffffffe0,%eax
f010bfd8:	a2 44 1b 55 f0       	mov    %al,0xf0551b44
f010bfdd:	a0 44 1b 55 f0       	mov    0xf0551b44,%al
f010bfe2:	83 e0 1f             	and    $0x1f,%eax
f010bfe5:	a2 44 1b 55 f0       	mov    %al,0xf0551b44
f010bfea:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010bfef:	83 e0 f0             	and    $0xfffffff0,%eax
f010bff2:	83 c8 0e             	or     $0xe,%eax
f010bff5:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010bffa:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010bfff:	83 e0 ef             	and    $0xffffffef,%eax
f010c002:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c007:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010c00c:	83 c8 60             	or     $0x60,%eax
f010c00f:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c014:	a0 45 1b 55 f0       	mov    0xf0551b45,%al
f010c019:	83 c8 80             	or     $0xffffff80,%eax
f010c01c:	a2 45 1b 55 f0       	mov    %al,0xf0551b45
f010c021:	b8 8e d3 10 f0       	mov    $0xf010d38e,%eax
f010c026:	c1 e8 10             	shr    $0x10,%eax
f010c029:	66 a3 46 1b 55 f0    	mov    %ax,0xf0551b46
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010c02f:	b8 98 d3 10 f0       	mov    $0xf010d398,%eax
f010c034:	66 a3 48 1b 55 f0    	mov    %ax,0xf0551b48
f010c03a:	66 c7 05 4a 1b 55 f0 	movw   $0x8,0xf0551b4a
f010c041:	08 00 
f010c043:	a0 4c 1b 55 f0       	mov    0xf0551b4c,%al
f010c048:	83 e0 e0             	and    $0xffffffe0,%eax
f010c04b:	a2 4c 1b 55 f0       	mov    %al,0xf0551b4c
f010c050:	a0 4c 1b 55 f0       	mov    0xf0551b4c,%al
f010c055:	83 e0 1f             	and    $0x1f,%eax
f010c058:	a2 4c 1b 55 f0       	mov    %al,0xf0551b4c
f010c05d:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c062:	83 e0 f0             	and    $0xfffffff0,%eax
f010c065:	83 c8 0e             	or     $0xe,%eax
f010c068:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c06d:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c072:	83 e0 ef             	and    $0xffffffef,%eax
f010c075:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c07a:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c07f:	83 c8 60             	or     $0x60,%eax
f010c082:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c087:	a0 4d 1b 55 f0       	mov    0xf0551b4d,%al
f010c08c:	83 c8 80             	or     $0xffffff80,%eax
f010c08f:	a2 4d 1b 55 f0       	mov    %al,0xf0551b4d
f010c094:	b8 98 d3 10 f0       	mov    $0xf010d398,%eax
f010c099:	c1 e8 10             	shr    $0x10,%eax
f010c09c:	66 a3 4e 1b 55 f0    	mov    %ax,0xf0551b4e
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010c0a2:	b8 a2 d3 10 f0       	mov    $0xf010d3a2,%eax
f010c0a7:	66 a3 c0 1b 55 f0    	mov    %ax,0xf0551bc0
f010c0ad:	66 c7 05 c2 1b 55 f0 	movw   $0x8,0xf0551bc2
f010c0b4:	08 00 
f010c0b6:	a0 c4 1b 55 f0       	mov    0xf0551bc4,%al
f010c0bb:	83 e0 e0             	and    $0xffffffe0,%eax
f010c0be:	a2 c4 1b 55 f0       	mov    %al,0xf0551bc4
f010c0c3:	a0 c4 1b 55 f0       	mov    0xf0551bc4,%al
f010c0c8:	83 e0 1f             	and    $0x1f,%eax
f010c0cb:	a2 c4 1b 55 f0       	mov    %al,0xf0551bc4
f010c0d0:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c0d5:	83 e0 f0             	and    $0xfffffff0,%eax
f010c0d8:	83 c8 0e             	or     $0xe,%eax
f010c0db:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c0e0:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c0e5:	83 e0 ef             	and    $0xffffffef,%eax
f010c0e8:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c0ed:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c0f2:	83 c8 60             	or     $0x60,%eax
f010c0f5:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c0fa:	a0 c5 1b 55 f0       	mov    0xf0551bc5,%al
f010c0ff:	83 c8 80             	or     $0xffffff80,%eax
f010c102:	a2 c5 1b 55 f0       	mov    %al,0xf0551bc5
f010c107:	b8 a2 d3 10 f0       	mov    $0xf010d3a2,%eax
f010c10c:	c1 e8 10             	shr    $0x10,%eax
f010c10f:	66 a3 c6 1b 55 f0    	mov    %ax,0xf0551bc6

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010c115:	b8 ac d3 10 f0       	mov    $0xf010d3ac,%eax
f010c11a:	66 a3 40 1a 55 f0    	mov    %ax,0xf0551a40
f010c120:	66 c7 05 42 1a 55 f0 	movw   $0x8,0xf0551a42
f010c127:	08 00 
f010c129:	a0 44 1a 55 f0       	mov    0xf0551a44,%al
f010c12e:	83 e0 e0             	and    $0xffffffe0,%eax
f010c131:	a2 44 1a 55 f0       	mov    %al,0xf0551a44
f010c136:	a0 44 1a 55 f0       	mov    0xf0551a44,%al
f010c13b:	83 e0 1f             	and    $0x1f,%eax
f010c13e:	a2 44 1a 55 f0       	mov    %al,0xf0551a44
f010c143:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c148:	83 e0 f0             	and    $0xfffffff0,%eax
f010c14b:	83 c8 0e             	or     $0xe,%eax
f010c14e:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c153:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c158:	83 e0 ef             	and    $0xffffffef,%eax
f010c15b:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c160:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c165:	83 c8 60             	or     $0x60,%eax
f010c168:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c16d:	a0 45 1a 55 f0       	mov    0xf0551a45,%al
f010c172:	83 c8 80             	or     $0xffffff80,%eax
f010c175:	a2 45 1a 55 f0       	mov    %al,0xf0551a45
f010c17a:	b8 ac d3 10 f0       	mov    $0xf010d3ac,%eax
f010c17f:	c1 e8 10             	shr    $0x10,%eax
f010c182:	66 a3 46 1a 55 f0    	mov    %ax,0xf0551a46
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010c188:	b8 b6 d3 10 f0       	mov    $0xf010d3b6,%eax
f010c18d:	66 a3 48 1a 55 f0    	mov    %ax,0xf0551a48
f010c193:	66 c7 05 4a 1a 55 f0 	movw   $0x8,0xf0551a4a
f010c19a:	08 00 
f010c19c:	a0 4c 1a 55 f0       	mov    0xf0551a4c,%al
f010c1a1:	83 e0 e0             	and    $0xffffffe0,%eax
f010c1a4:	a2 4c 1a 55 f0       	mov    %al,0xf0551a4c
f010c1a9:	a0 4c 1a 55 f0       	mov    0xf0551a4c,%al
f010c1ae:	83 e0 1f             	and    $0x1f,%eax
f010c1b1:	a2 4c 1a 55 f0       	mov    %al,0xf0551a4c
f010c1b6:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1bb:	83 c8 0f             	or     $0xf,%eax
f010c1be:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1c3:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1c8:	83 e0 ef             	and    $0xffffffef,%eax
f010c1cb:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1d0:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1d5:	83 c8 60             	or     $0x60,%eax
f010c1d8:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1dd:	a0 4d 1a 55 f0       	mov    0xf0551a4d,%al
f010c1e2:	83 c8 80             	or     $0xffffff80,%eax
f010c1e5:	a2 4d 1a 55 f0       	mov    %al,0xf0551a4d
f010c1ea:	b8 b6 d3 10 f0       	mov    $0xf010d3b6,%eax
f010c1ef:	c1 e8 10             	shr    $0x10,%eax
f010c1f2:	66 a3 4e 1a 55 f0    	mov    %ax,0xf0551a4e
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010c1f8:	b8 c0 d3 10 f0       	mov    $0xf010d3c0,%eax
f010c1fd:	66 a3 50 1a 55 f0    	mov    %ax,0xf0551a50
f010c203:	66 c7 05 52 1a 55 f0 	movw   $0x8,0xf0551a52
f010c20a:	08 00 
f010c20c:	a0 54 1a 55 f0       	mov    0xf0551a54,%al
f010c211:	83 e0 e0             	and    $0xffffffe0,%eax
f010c214:	a2 54 1a 55 f0       	mov    %al,0xf0551a54
f010c219:	a0 54 1a 55 f0       	mov    0xf0551a54,%al
f010c21e:	83 e0 1f             	and    $0x1f,%eax
f010c221:	a2 54 1a 55 f0       	mov    %al,0xf0551a54
f010c226:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c22b:	83 e0 f0             	and    $0xfffffff0,%eax
f010c22e:	83 c8 0e             	or     $0xe,%eax
f010c231:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c236:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c23b:	83 e0 ef             	and    $0xffffffef,%eax
f010c23e:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c243:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c248:	83 c8 60             	or     $0x60,%eax
f010c24b:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c250:	a0 55 1a 55 f0       	mov    0xf0551a55,%al
f010c255:	83 c8 80             	or     $0xffffff80,%eax
f010c258:	a2 55 1a 55 f0       	mov    %al,0xf0551a55
f010c25d:	b8 c0 d3 10 f0       	mov    $0xf010d3c0,%eax
f010c262:	c1 e8 10             	shr    $0x10,%eax
f010c265:	66 a3 56 1a 55 f0    	mov    %ax,0xf0551a56
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010c26b:	b8 ca d3 10 f0       	mov    $0xf010d3ca,%eax
f010c270:	66 a3 58 1a 55 f0    	mov    %ax,0xf0551a58
f010c276:	66 c7 05 5a 1a 55 f0 	movw   $0x8,0xf0551a5a
f010c27d:	08 00 
f010c27f:	a0 5c 1a 55 f0       	mov    0xf0551a5c,%al
f010c284:	83 e0 e0             	and    $0xffffffe0,%eax
f010c287:	a2 5c 1a 55 f0       	mov    %al,0xf0551a5c
f010c28c:	a0 5c 1a 55 f0       	mov    0xf0551a5c,%al
f010c291:	83 e0 1f             	and    $0x1f,%eax
f010c294:	a2 5c 1a 55 f0       	mov    %al,0xf0551a5c
f010c299:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c29e:	83 c8 0f             	or     $0xf,%eax
f010c2a1:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2a6:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2ab:	83 e0 ef             	and    $0xffffffef,%eax
f010c2ae:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2b3:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2b8:	83 c8 60             	or     $0x60,%eax
f010c2bb:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2c0:	a0 5d 1a 55 f0       	mov    0xf0551a5d,%al
f010c2c5:	83 c8 80             	or     $0xffffff80,%eax
f010c2c8:	a2 5d 1a 55 f0       	mov    %al,0xf0551a5d
f010c2cd:	b8 ca d3 10 f0       	mov    $0xf010d3ca,%eax
f010c2d2:	c1 e8 10             	shr    $0x10,%eax
f010c2d5:	66 a3 5e 1a 55 f0    	mov    %ax,0xf0551a5e
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010c2db:	b8 d4 d3 10 f0       	mov    $0xf010d3d4,%eax
f010c2e0:	66 a3 60 1a 55 f0    	mov    %ax,0xf0551a60
f010c2e6:	66 c7 05 62 1a 55 f0 	movw   $0x8,0xf0551a62
f010c2ed:	08 00 
f010c2ef:	a0 64 1a 55 f0       	mov    0xf0551a64,%al
f010c2f4:	83 e0 e0             	and    $0xffffffe0,%eax
f010c2f7:	a2 64 1a 55 f0       	mov    %al,0xf0551a64
f010c2fc:	a0 64 1a 55 f0       	mov    0xf0551a64,%al
f010c301:	83 e0 1f             	and    $0x1f,%eax
f010c304:	a2 64 1a 55 f0       	mov    %al,0xf0551a64
f010c309:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c30e:	83 c8 0f             	or     $0xf,%eax
f010c311:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c316:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c31b:	83 e0 ef             	and    $0xffffffef,%eax
f010c31e:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c323:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c328:	83 c8 60             	or     $0x60,%eax
f010c32b:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c330:	a0 65 1a 55 f0       	mov    0xf0551a65,%al
f010c335:	83 c8 80             	or     $0xffffff80,%eax
f010c338:	a2 65 1a 55 f0       	mov    %al,0xf0551a65
f010c33d:	b8 d4 d3 10 f0       	mov    $0xf010d3d4,%eax
f010c342:	c1 e8 10             	shr    $0x10,%eax
f010c345:	66 a3 66 1a 55 f0    	mov    %ax,0xf0551a66
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010c34b:	b8 de d3 10 f0       	mov    $0xf010d3de,%eax
f010c350:	66 a3 68 1a 55 f0    	mov    %ax,0xf0551a68
f010c356:	66 c7 05 6a 1a 55 f0 	movw   $0x8,0xf0551a6a
f010c35d:	08 00 
f010c35f:	a0 6c 1a 55 f0       	mov    0xf0551a6c,%al
f010c364:	83 e0 e0             	and    $0xffffffe0,%eax
f010c367:	a2 6c 1a 55 f0       	mov    %al,0xf0551a6c
f010c36c:	a0 6c 1a 55 f0       	mov    0xf0551a6c,%al
f010c371:	83 e0 1f             	and    $0x1f,%eax
f010c374:	a2 6c 1a 55 f0       	mov    %al,0xf0551a6c
f010c379:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c37e:	83 e0 f0             	and    $0xfffffff0,%eax
f010c381:	83 c8 0e             	or     $0xe,%eax
f010c384:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c389:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c38e:	83 e0 ef             	and    $0xffffffef,%eax
f010c391:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c396:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c39b:	83 c8 60             	or     $0x60,%eax
f010c39e:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c3a3:	a0 6d 1a 55 f0       	mov    0xf0551a6d,%al
f010c3a8:	83 c8 80             	or     $0xffffff80,%eax
f010c3ab:	a2 6d 1a 55 f0       	mov    %al,0xf0551a6d
f010c3b0:	b8 de d3 10 f0       	mov    $0xf010d3de,%eax
f010c3b5:	c1 e8 10             	shr    $0x10,%eax
f010c3b8:	66 a3 6e 1a 55 f0    	mov    %ax,0xf0551a6e
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010c3be:	b8 e8 d3 10 f0       	mov    $0xf010d3e8,%eax
f010c3c3:	66 a3 70 1a 55 f0    	mov    %ax,0xf0551a70
f010c3c9:	66 c7 05 72 1a 55 f0 	movw   $0x8,0xf0551a72
f010c3d0:	08 00 
f010c3d2:	a0 74 1a 55 f0       	mov    0xf0551a74,%al
f010c3d7:	83 e0 e0             	and    $0xffffffe0,%eax
f010c3da:	a2 74 1a 55 f0       	mov    %al,0xf0551a74
f010c3df:	a0 74 1a 55 f0       	mov    0xf0551a74,%al
f010c3e4:	83 e0 1f             	and    $0x1f,%eax
f010c3e7:	a2 74 1a 55 f0       	mov    %al,0xf0551a74
f010c3ec:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c3f1:	83 e0 f0             	and    $0xfffffff0,%eax
f010c3f4:	83 c8 0e             	or     $0xe,%eax
f010c3f7:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c3fc:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c401:	83 e0 ef             	and    $0xffffffef,%eax
f010c404:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c409:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c40e:	83 c8 60             	or     $0x60,%eax
f010c411:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c416:	a0 75 1a 55 f0       	mov    0xf0551a75,%al
f010c41b:	83 c8 80             	or     $0xffffff80,%eax
f010c41e:	a2 75 1a 55 f0       	mov    %al,0xf0551a75
f010c423:	b8 e8 d3 10 f0       	mov    $0xf010d3e8,%eax
f010c428:	c1 e8 10             	shr    $0x10,%eax
f010c42b:	66 a3 76 1a 55 f0    	mov    %ax,0xf0551a76
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010c431:	b8 f2 d3 10 f0       	mov    $0xf010d3f2,%eax
f010c436:	66 a3 78 1a 55 f0    	mov    %ax,0xf0551a78
f010c43c:	66 c7 05 7a 1a 55 f0 	movw   $0x8,0xf0551a7a
f010c443:	08 00 
f010c445:	a0 7c 1a 55 f0       	mov    0xf0551a7c,%al
f010c44a:	83 e0 e0             	and    $0xffffffe0,%eax
f010c44d:	a2 7c 1a 55 f0       	mov    %al,0xf0551a7c
f010c452:	a0 7c 1a 55 f0       	mov    0xf0551a7c,%al
f010c457:	83 e0 1f             	and    $0x1f,%eax
f010c45a:	a2 7c 1a 55 f0       	mov    %al,0xf0551a7c
f010c45f:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c464:	83 e0 f0             	and    $0xfffffff0,%eax
f010c467:	83 c8 0e             	or     $0xe,%eax
f010c46a:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c46f:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c474:	83 e0 ef             	and    $0xffffffef,%eax
f010c477:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c47c:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c481:	83 c8 60             	or     $0x60,%eax
f010c484:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c489:	a0 7d 1a 55 f0       	mov    0xf0551a7d,%al
f010c48e:	83 c8 80             	or     $0xffffff80,%eax
f010c491:	a2 7d 1a 55 f0       	mov    %al,0xf0551a7d
f010c496:	b8 f2 d3 10 f0       	mov    $0xf010d3f2,%eax
f010c49b:	c1 e8 10             	shr    $0x10,%eax
f010c49e:	66 a3 7e 1a 55 f0    	mov    %ax,0xf0551a7e
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010c4a4:	b8 f8 d3 10 f0       	mov    $0xf010d3f8,%eax
f010c4a9:	66 a3 90 1a 55 f0    	mov    %ax,0xf0551a90
f010c4af:	66 c7 05 92 1a 55 f0 	movw   $0x8,0xf0551a92
f010c4b6:	08 00 
f010c4b8:	a0 94 1a 55 f0       	mov    0xf0551a94,%al
f010c4bd:	83 e0 e0             	and    $0xffffffe0,%eax
f010c4c0:	a2 94 1a 55 f0       	mov    %al,0xf0551a94
f010c4c5:	a0 94 1a 55 f0       	mov    0xf0551a94,%al
f010c4ca:	83 e0 1f             	and    $0x1f,%eax
f010c4cd:	a2 94 1a 55 f0       	mov    %al,0xf0551a94
f010c4d2:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c4d7:	83 e0 f0             	and    $0xfffffff0,%eax
f010c4da:	83 c8 0e             	or     $0xe,%eax
f010c4dd:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c4e2:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c4e7:	83 e0 ef             	and    $0xffffffef,%eax
f010c4ea:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c4ef:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c4f4:	83 c8 60             	or     $0x60,%eax
f010c4f7:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c4fc:	a0 95 1a 55 f0       	mov    0xf0551a95,%al
f010c501:	83 c8 80             	or     $0xffffff80,%eax
f010c504:	a2 95 1a 55 f0       	mov    %al,0xf0551a95
f010c509:	b8 f8 d3 10 f0       	mov    $0xf010d3f8,%eax
f010c50e:	c1 e8 10             	shr    $0x10,%eax
f010c511:	66 a3 96 1a 55 f0    	mov    %ax,0xf0551a96
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010c517:	b8 fc d3 10 f0       	mov    $0xf010d3fc,%eax
f010c51c:	66 a3 98 1a 55 f0    	mov    %ax,0xf0551a98
f010c522:	66 c7 05 9a 1a 55 f0 	movw   $0x8,0xf0551a9a
f010c529:	08 00 
f010c52b:	a0 9c 1a 55 f0       	mov    0xf0551a9c,%al
f010c530:	83 e0 e0             	and    $0xffffffe0,%eax
f010c533:	a2 9c 1a 55 f0       	mov    %al,0xf0551a9c
f010c538:	a0 9c 1a 55 f0       	mov    0xf0551a9c,%al
f010c53d:	83 e0 1f             	and    $0x1f,%eax
f010c540:	a2 9c 1a 55 f0       	mov    %al,0xf0551a9c
f010c545:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c54a:	83 e0 f0             	and    $0xfffffff0,%eax
f010c54d:	83 c8 0e             	or     $0xe,%eax
f010c550:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c555:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c55a:	83 e0 ef             	and    $0xffffffef,%eax
f010c55d:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c562:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c567:	83 c8 60             	or     $0x60,%eax
f010c56a:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c56f:	a0 9d 1a 55 f0       	mov    0xf0551a9d,%al
f010c574:	83 c8 80             	or     $0xffffff80,%eax
f010c577:	a2 9d 1a 55 f0       	mov    %al,0xf0551a9d
f010c57c:	b8 fc d3 10 f0       	mov    $0xf010d3fc,%eax
f010c581:	c1 e8 10             	shr    $0x10,%eax
f010c584:	66 a3 9e 1a 55 f0    	mov    %ax,0xf0551a9e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010c58a:	b8 00 d4 10 f0       	mov    $0xf010d400,%eax
f010c58f:	66 a3 a0 1a 55 f0    	mov    %ax,0xf0551aa0
f010c595:	66 c7 05 a2 1a 55 f0 	movw   $0x8,0xf0551aa2
f010c59c:	08 00 
f010c59e:	a0 a4 1a 55 f0       	mov    0xf0551aa4,%al
f010c5a3:	83 e0 e0             	and    $0xffffffe0,%eax
f010c5a6:	a2 a4 1a 55 f0       	mov    %al,0xf0551aa4
f010c5ab:	a0 a4 1a 55 f0       	mov    0xf0551aa4,%al
f010c5b0:	83 e0 1f             	and    $0x1f,%eax
f010c5b3:	a2 a4 1a 55 f0       	mov    %al,0xf0551aa4
f010c5b8:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5bd:	83 e0 f0             	and    $0xfffffff0,%eax
f010c5c0:	83 c8 0e             	or     $0xe,%eax
f010c5c3:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5c8:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5cd:	83 e0 ef             	and    $0xffffffef,%eax
f010c5d0:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5d5:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5da:	83 c8 60             	or     $0x60,%eax
f010c5dd:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5e2:	a0 a5 1a 55 f0       	mov    0xf0551aa5,%al
f010c5e7:	83 c8 80             	or     $0xffffff80,%eax
f010c5ea:	a2 a5 1a 55 f0       	mov    %al,0xf0551aa5
f010c5ef:	b8 00 d4 10 f0       	mov    $0xf010d400,%eax
f010c5f4:	c1 e8 10             	shr    $0x10,%eax
f010c5f7:	66 a3 a6 1a 55 f0    	mov    %ax,0xf0551aa6
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010c5fd:	b8 04 d4 10 f0       	mov    $0xf010d404,%eax
f010c602:	66 a3 a8 1a 55 f0    	mov    %ax,0xf0551aa8
f010c608:	66 c7 05 aa 1a 55 f0 	movw   $0x8,0xf0551aaa
f010c60f:	08 00 
f010c611:	a0 ac 1a 55 f0       	mov    0xf0551aac,%al
f010c616:	83 e0 e0             	and    $0xffffffe0,%eax
f010c619:	a2 ac 1a 55 f0       	mov    %al,0xf0551aac
f010c61e:	a0 ac 1a 55 f0       	mov    0xf0551aac,%al
f010c623:	83 e0 1f             	and    $0x1f,%eax
f010c626:	a2 ac 1a 55 f0       	mov    %al,0xf0551aac
f010c62b:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c630:	83 e0 f0             	and    $0xfffffff0,%eax
f010c633:	83 c8 0e             	or     $0xe,%eax
f010c636:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c63b:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c640:	83 e0 ef             	and    $0xffffffef,%eax
f010c643:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c648:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c64d:	83 c8 60             	or     $0x60,%eax
f010c650:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c655:	a0 ad 1a 55 f0       	mov    0xf0551aad,%al
f010c65a:	83 c8 80             	or     $0xffffff80,%eax
f010c65d:	a2 ad 1a 55 f0       	mov    %al,0xf0551aad
f010c662:	b8 04 d4 10 f0       	mov    $0xf010d404,%eax
f010c667:	c1 e8 10             	shr    $0x10,%eax
f010c66a:	66 a3 ae 1a 55 f0    	mov    %ax,0xf0551aae
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010c670:	b8 08 d4 10 f0       	mov    $0xf010d408,%eax
f010c675:	66 a3 c0 1a 55 f0    	mov    %ax,0xf0551ac0
f010c67b:	66 c7 05 c2 1a 55 f0 	movw   $0x8,0xf0551ac2
f010c682:	08 00 
f010c684:	a0 c4 1a 55 f0       	mov    0xf0551ac4,%al
f010c689:	83 e0 e0             	and    $0xffffffe0,%eax
f010c68c:	a2 c4 1a 55 f0       	mov    %al,0xf0551ac4
f010c691:	a0 c4 1a 55 f0       	mov    0xf0551ac4,%al
f010c696:	83 e0 1f             	and    $0x1f,%eax
f010c699:	a2 c4 1a 55 f0       	mov    %al,0xf0551ac4
f010c69e:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6a3:	83 e0 f0             	and    $0xfffffff0,%eax
f010c6a6:	83 c8 0e             	or     $0xe,%eax
f010c6a9:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6ae:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6b3:	83 e0 ef             	and    $0xffffffef,%eax
f010c6b6:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6bb:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6c0:	83 c8 60             	or     $0x60,%eax
f010c6c3:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6c8:	a0 c5 1a 55 f0       	mov    0xf0551ac5,%al
f010c6cd:	83 c8 80             	or     $0xffffff80,%eax
f010c6d0:	a2 c5 1a 55 f0       	mov    %al,0xf0551ac5
f010c6d5:	b8 08 d4 10 f0       	mov    $0xf010d408,%eax
f010c6da:	c1 e8 10             	shr    $0x10,%eax
f010c6dd:	66 a3 c6 1a 55 f0    	mov    %ax,0xf0551ac6
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010c6e3:	b8 0e d4 10 f0       	mov    $0xf010d40e,%eax
f010c6e8:	66 a3 c8 1a 55 f0    	mov    %ax,0xf0551ac8
f010c6ee:	66 c7 05 ca 1a 55 f0 	movw   $0x8,0xf0551aca
f010c6f5:	08 00 
f010c6f7:	a0 cc 1a 55 f0       	mov    0xf0551acc,%al
f010c6fc:	83 e0 e0             	and    $0xffffffe0,%eax
f010c6ff:	a2 cc 1a 55 f0       	mov    %al,0xf0551acc
f010c704:	a0 cc 1a 55 f0       	mov    0xf0551acc,%al
f010c709:	83 e0 1f             	and    $0x1f,%eax
f010c70c:	a2 cc 1a 55 f0       	mov    %al,0xf0551acc
f010c711:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c716:	83 e0 f0             	and    $0xfffffff0,%eax
f010c719:	83 c8 0e             	or     $0xe,%eax
f010c71c:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c721:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c726:	83 e0 ef             	and    $0xffffffef,%eax
f010c729:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c72e:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c733:	83 c8 60             	or     $0x60,%eax
f010c736:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c73b:	a0 cd 1a 55 f0       	mov    0xf0551acd,%al
f010c740:	83 c8 80             	or     $0xffffff80,%eax
f010c743:	a2 cd 1a 55 f0       	mov    %al,0xf0551acd
f010c748:	b8 0e d4 10 f0       	mov    $0xf010d40e,%eax
f010c74d:	c1 e8 10             	shr    $0x10,%eax
f010c750:	66 a3 ce 1a 55 f0    	mov    %ax,0xf0551ace
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010c756:	b8 12 d4 10 f0       	mov    $0xf010d412,%eax
f010c75b:	66 a3 d0 1a 55 f0    	mov    %ax,0xf0551ad0
f010c761:	66 c7 05 d2 1a 55 f0 	movw   $0x8,0xf0551ad2
f010c768:	08 00 
f010c76a:	a0 d4 1a 55 f0       	mov    0xf0551ad4,%al
f010c76f:	83 e0 e0             	and    $0xffffffe0,%eax
f010c772:	a2 d4 1a 55 f0       	mov    %al,0xf0551ad4
f010c777:	a0 d4 1a 55 f0       	mov    0xf0551ad4,%al
f010c77c:	83 e0 1f             	and    $0x1f,%eax
f010c77f:	a2 d4 1a 55 f0       	mov    %al,0xf0551ad4
f010c784:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c789:	83 e0 f0             	and    $0xfffffff0,%eax
f010c78c:	83 c8 0e             	or     $0xe,%eax
f010c78f:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c794:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c799:	83 e0 ef             	and    $0xffffffef,%eax
f010c79c:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7a1:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c7a6:	83 c8 60             	or     $0x60,%eax
f010c7a9:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7ae:	a0 d5 1a 55 f0       	mov    0xf0551ad5,%al
f010c7b3:	83 c8 80             	or     $0xffffff80,%eax
f010c7b6:	a2 d5 1a 55 f0       	mov    %al,0xf0551ad5
f010c7bb:	b8 12 d4 10 f0       	mov    $0xf010d412,%eax
f010c7c0:	c1 e8 10             	shr    $0x10,%eax
f010c7c3:	66 a3 d6 1a 55 f0    	mov    %ax,0xf0551ad6
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010c7c9:	b8 18 d4 10 f0       	mov    $0xf010d418,%eax
f010c7ce:	66 a3 d8 1a 55 f0    	mov    %ax,0xf0551ad8
f010c7d4:	66 c7 05 da 1a 55 f0 	movw   $0x8,0xf0551ada
f010c7db:	08 00 
f010c7dd:	a0 dc 1a 55 f0       	mov    0xf0551adc,%al
f010c7e2:	83 e0 e0             	and    $0xffffffe0,%eax
f010c7e5:	a2 dc 1a 55 f0       	mov    %al,0xf0551adc
f010c7ea:	a0 dc 1a 55 f0       	mov    0xf0551adc,%al
f010c7ef:	83 e0 1f             	and    $0x1f,%eax
f010c7f2:	a2 dc 1a 55 f0       	mov    %al,0xf0551adc
f010c7f7:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c7fc:	83 e0 f0             	and    $0xfffffff0,%eax
f010c7ff:	83 c8 0e             	or     $0xe,%eax
f010c802:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c807:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c80c:	83 e0 ef             	and    $0xffffffef,%eax
f010c80f:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c814:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c819:	83 c8 60             	or     $0x60,%eax
f010c81c:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c821:	a0 dd 1a 55 f0       	mov    0xf0551add,%al
f010c826:	83 c8 80             	or     $0xffffff80,%eax
f010c829:	a2 dd 1a 55 f0       	mov    %al,0xf0551add
f010c82e:	b8 18 d4 10 f0       	mov    $0xf010d418,%eax
f010c833:	c1 e8 10             	shr    $0x10,%eax
f010c836:	66 a3 de 1a 55 f0    	mov    %ax,0xf0551ade

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010c83c:	b8 1e d4 10 f0       	mov    $0xf010d41e,%eax
f010c841:	66 a3 50 1b 55 f0    	mov    %ax,0xf0551b50
f010c847:	66 c7 05 52 1b 55 f0 	movw   $0x8,0xf0551b52
f010c84e:	08 00 
f010c850:	a0 54 1b 55 f0       	mov    0xf0551b54,%al
f010c855:	83 e0 e0             	and    $0xffffffe0,%eax
f010c858:	a2 54 1b 55 f0       	mov    %al,0xf0551b54
f010c85d:	a0 54 1b 55 f0       	mov    0xf0551b54,%al
f010c862:	83 e0 1f             	and    $0x1f,%eax
f010c865:	a2 54 1b 55 f0       	mov    %al,0xf0551b54
f010c86a:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c86f:	83 e0 f0             	and    $0xfffffff0,%eax
f010c872:	83 c8 0e             	or     $0xe,%eax
f010c875:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c87a:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c87f:	83 e0 ef             	and    $0xffffffef,%eax
f010c882:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c887:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c88c:	83 c8 60             	or     $0x60,%eax
f010c88f:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c894:	a0 55 1b 55 f0       	mov    0xf0551b55,%al
f010c899:	83 c8 80             	or     $0xffffff80,%eax
f010c89c:	a2 55 1b 55 f0       	mov    %al,0xf0551b55
f010c8a1:	b8 1e d4 10 f0       	mov    $0xf010d41e,%eax
f010c8a6:	c1 e8 10             	shr    $0x10,%eax
f010c8a9:	66 a3 56 1b 55 f0    	mov    %ax,0xf0551b56
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010c8af:	b8 24 d4 10 f0       	mov    $0xf010d424,%eax
f010c8b4:	66 a3 58 1b 55 f0    	mov    %ax,0xf0551b58
f010c8ba:	66 c7 05 5a 1b 55 f0 	movw   $0x8,0xf0551b5a
f010c8c1:	08 00 
f010c8c3:	a0 5c 1b 55 f0       	mov    0xf0551b5c,%al
f010c8c8:	83 e0 e0             	and    $0xffffffe0,%eax
f010c8cb:	a2 5c 1b 55 f0       	mov    %al,0xf0551b5c
f010c8d0:	a0 5c 1b 55 f0       	mov    0xf0551b5c,%al
f010c8d5:	83 e0 1f             	and    $0x1f,%eax
f010c8d8:	a2 5c 1b 55 f0       	mov    %al,0xf0551b5c
f010c8dd:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c8e2:	83 e0 f0             	and    $0xfffffff0,%eax
f010c8e5:	83 c8 0e             	or     $0xe,%eax
f010c8e8:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c8ed:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c8f2:	83 e0 ef             	and    $0xffffffef,%eax
f010c8f5:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c8fa:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c8ff:	83 c8 60             	or     $0x60,%eax
f010c902:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c907:	a0 5d 1b 55 f0       	mov    0xf0551b5d,%al
f010c90c:	83 c8 80             	or     $0xffffff80,%eax
f010c90f:	a2 5d 1b 55 f0       	mov    %al,0xf0551b5d
f010c914:	b8 24 d4 10 f0       	mov    $0xf010d424,%eax
f010c919:	c1 e8 10             	shr    $0x10,%eax
f010c91c:	66 a3 5e 1b 55 f0    	mov    %ax,0xf0551b5e
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010c922:	b8 2a d4 10 f0       	mov    $0xf010d42a,%eax
f010c927:	66 a3 60 1b 55 f0    	mov    %ax,0xf0551b60
f010c92d:	66 c7 05 62 1b 55 f0 	movw   $0x8,0xf0551b62
f010c934:	08 00 
f010c936:	a0 64 1b 55 f0       	mov    0xf0551b64,%al
f010c93b:	83 e0 e0             	and    $0xffffffe0,%eax
f010c93e:	a2 64 1b 55 f0       	mov    %al,0xf0551b64
f010c943:	a0 64 1b 55 f0       	mov    0xf0551b64,%al
f010c948:	83 e0 1f             	and    $0x1f,%eax
f010c94b:	a2 64 1b 55 f0       	mov    %al,0xf0551b64
f010c950:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c955:	83 e0 f0             	and    $0xfffffff0,%eax
f010c958:	83 c8 0e             	or     $0xe,%eax
f010c95b:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c960:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c965:	83 e0 ef             	and    $0xffffffef,%eax
f010c968:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c96d:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c972:	83 c8 60             	or     $0x60,%eax
f010c975:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c97a:	a0 65 1b 55 f0       	mov    0xf0551b65,%al
f010c97f:	83 c8 80             	or     $0xffffff80,%eax
f010c982:	a2 65 1b 55 f0       	mov    %al,0xf0551b65
f010c987:	b8 2a d4 10 f0       	mov    $0xf010d42a,%eax
f010c98c:	c1 e8 10             	shr    $0x10,%eax
f010c98f:	66 a3 66 1b 55 f0    	mov    %ax,0xf0551b66
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010c995:	b8 30 d4 10 f0       	mov    $0xf010d430,%eax
f010c99a:	66 a3 68 1b 55 f0    	mov    %ax,0xf0551b68
f010c9a0:	66 c7 05 6a 1b 55 f0 	movw   $0x8,0xf0551b6a
f010c9a7:	08 00 
f010c9a9:	a0 6c 1b 55 f0       	mov    0xf0551b6c,%al
f010c9ae:	83 e0 e0             	and    $0xffffffe0,%eax
f010c9b1:	a2 6c 1b 55 f0       	mov    %al,0xf0551b6c
f010c9b6:	a0 6c 1b 55 f0       	mov    0xf0551b6c,%al
f010c9bb:	83 e0 1f             	and    $0x1f,%eax
f010c9be:	a2 6c 1b 55 f0       	mov    %al,0xf0551b6c
f010c9c3:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010c9c8:	83 e0 f0             	and    $0xfffffff0,%eax
f010c9cb:	83 c8 0e             	or     $0xe,%eax
f010c9ce:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010c9d3:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010c9d8:	83 e0 ef             	and    $0xffffffef,%eax
f010c9db:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010c9e0:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010c9e5:	83 c8 60             	or     $0x60,%eax
f010c9e8:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010c9ed:	a0 6d 1b 55 f0       	mov    0xf0551b6d,%al
f010c9f2:	83 c8 80             	or     $0xffffff80,%eax
f010c9f5:	a2 6d 1b 55 f0       	mov    %al,0xf0551b6d
f010c9fa:	b8 30 d4 10 f0       	mov    $0xf010d430,%eax
f010c9ff:	c1 e8 10             	shr    $0x10,%eax
f010ca02:	66 a3 6e 1b 55 f0    	mov    %ax,0xf0551b6e
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010ca08:	b8 36 d4 10 f0       	mov    $0xf010d436,%eax
f010ca0d:	66 a3 70 1b 55 f0    	mov    %ax,0xf0551b70
f010ca13:	66 c7 05 72 1b 55 f0 	movw   $0x8,0xf0551b72
f010ca1a:	08 00 
f010ca1c:	a0 74 1b 55 f0       	mov    0xf0551b74,%al
f010ca21:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca24:	a2 74 1b 55 f0       	mov    %al,0xf0551b74
f010ca29:	a0 74 1b 55 f0       	mov    0xf0551b74,%al
f010ca2e:	83 e0 1f             	and    $0x1f,%eax
f010ca31:	a2 74 1b 55 f0       	mov    %al,0xf0551b74
f010ca36:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca3b:	83 e0 f0             	and    $0xfffffff0,%eax
f010ca3e:	83 c8 0e             	or     $0xe,%eax
f010ca41:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca46:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca4b:	83 e0 ef             	and    $0xffffffef,%eax
f010ca4e:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca53:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca58:	83 c8 60             	or     $0x60,%eax
f010ca5b:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca60:	a0 75 1b 55 f0       	mov    0xf0551b75,%al
f010ca65:	83 c8 80             	or     $0xffffff80,%eax
f010ca68:	a2 75 1b 55 f0       	mov    %al,0xf0551b75
f010ca6d:	b8 36 d4 10 f0       	mov    $0xf010d436,%eax
f010ca72:	c1 e8 10             	shr    $0x10,%eax
f010ca75:	66 a3 76 1b 55 f0    	mov    %ax,0xf0551b76
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010ca7b:	b8 3c d4 10 f0       	mov    $0xf010d43c,%eax
f010ca80:	66 a3 78 1b 55 f0    	mov    %ax,0xf0551b78
f010ca86:	66 c7 05 7a 1b 55 f0 	movw   $0x8,0xf0551b7a
f010ca8d:	08 00 
f010ca8f:	a0 7c 1b 55 f0       	mov    0xf0551b7c,%al
f010ca94:	83 e0 e0             	and    $0xffffffe0,%eax
f010ca97:	a2 7c 1b 55 f0       	mov    %al,0xf0551b7c
f010ca9c:	a0 7c 1b 55 f0       	mov    0xf0551b7c,%al
f010caa1:	83 e0 1f             	and    $0x1f,%eax
f010caa4:	a2 7c 1b 55 f0       	mov    %al,0xf0551b7c
f010caa9:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010caae:	83 e0 f0             	and    $0xfffffff0,%eax
f010cab1:	83 c8 0e             	or     $0xe,%eax
f010cab4:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cab9:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010cabe:	83 e0 ef             	and    $0xffffffef,%eax
f010cac1:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cac6:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010cacb:	83 c8 60             	or     $0x60,%eax
f010cace:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cad3:	a0 7d 1b 55 f0       	mov    0xf0551b7d,%al
f010cad8:	83 c8 80             	or     $0xffffff80,%eax
f010cadb:	a2 7d 1b 55 f0       	mov    %al,0xf0551b7d
f010cae0:	b8 3c d4 10 f0       	mov    $0xf010d43c,%eax
f010cae5:	c1 e8 10             	shr    $0x10,%eax
f010cae8:	66 a3 7e 1b 55 f0    	mov    %ax,0xf0551b7e
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010caee:	b8 42 d4 10 f0       	mov    $0xf010d442,%eax
f010caf3:	66 a3 80 1b 55 f0    	mov    %ax,0xf0551b80
f010caf9:	66 c7 05 82 1b 55 f0 	movw   $0x8,0xf0551b82
f010cb00:	08 00 
f010cb02:	a0 84 1b 55 f0       	mov    0xf0551b84,%al
f010cb07:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb0a:	a2 84 1b 55 f0       	mov    %al,0xf0551b84
f010cb0f:	a0 84 1b 55 f0       	mov    0xf0551b84,%al
f010cb14:	83 e0 1f             	and    $0x1f,%eax
f010cb17:	a2 84 1b 55 f0       	mov    %al,0xf0551b84
f010cb1c:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb21:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb24:	83 c8 0e             	or     $0xe,%eax
f010cb27:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb2c:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb31:	83 e0 ef             	and    $0xffffffef,%eax
f010cb34:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb39:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb3e:	83 c8 60             	or     $0x60,%eax
f010cb41:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb46:	a0 85 1b 55 f0       	mov    0xf0551b85,%al
f010cb4b:	83 c8 80             	or     $0xffffff80,%eax
f010cb4e:	a2 85 1b 55 f0       	mov    %al,0xf0551b85
f010cb53:	b8 42 d4 10 f0       	mov    $0xf010d442,%eax
f010cb58:	c1 e8 10             	shr    $0x10,%eax
f010cb5b:	66 a3 86 1b 55 f0    	mov    %ax,0xf0551b86
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010cb61:	b8 48 d4 10 f0       	mov    $0xf010d448,%eax
f010cb66:	66 a3 88 1b 55 f0    	mov    %ax,0xf0551b88
f010cb6c:	66 c7 05 8a 1b 55 f0 	movw   $0x8,0xf0551b8a
f010cb73:	08 00 
f010cb75:	a0 8c 1b 55 f0       	mov    0xf0551b8c,%al
f010cb7a:	83 e0 e0             	and    $0xffffffe0,%eax
f010cb7d:	a2 8c 1b 55 f0       	mov    %al,0xf0551b8c
f010cb82:	a0 8c 1b 55 f0       	mov    0xf0551b8c,%al
f010cb87:	83 e0 1f             	and    $0x1f,%eax
f010cb8a:	a2 8c 1b 55 f0       	mov    %al,0xf0551b8c
f010cb8f:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cb94:	83 e0 f0             	and    $0xfffffff0,%eax
f010cb97:	83 c8 0e             	or     $0xe,%eax
f010cb9a:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cb9f:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cba4:	83 e0 ef             	and    $0xffffffef,%eax
f010cba7:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbac:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cbb1:	83 c8 60             	or     $0x60,%eax
f010cbb4:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbb9:	a0 8d 1b 55 f0       	mov    0xf0551b8d,%al
f010cbbe:	83 c8 80             	or     $0xffffff80,%eax
f010cbc1:	a2 8d 1b 55 f0       	mov    %al,0xf0551b8d
f010cbc6:	b8 48 d4 10 f0       	mov    $0xf010d448,%eax
f010cbcb:	c1 e8 10             	shr    $0x10,%eax
f010cbce:	66 a3 8e 1b 55 f0    	mov    %ax,0xf0551b8e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010cbd4:	b8 4e d4 10 f0       	mov    $0xf010d44e,%eax
f010cbd9:	66 a3 90 1b 55 f0    	mov    %ax,0xf0551b90
f010cbdf:	66 c7 05 92 1b 55 f0 	movw   $0x8,0xf0551b92
f010cbe6:	08 00 
f010cbe8:	a0 94 1b 55 f0       	mov    0xf0551b94,%al
f010cbed:	83 e0 e0             	and    $0xffffffe0,%eax
f010cbf0:	a2 94 1b 55 f0       	mov    %al,0xf0551b94
f010cbf5:	a0 94 1b 55 f0       	mov    0xf0551b94,%al
f010cbfa:	83 e0 1f             	and    $0x1f,%eax
f010cbfd:	a2 94 1b 55 f0       	mov    %al,0xf0551b94
f010cc02:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc07:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc0a:	83 c8 0e             	or     $0xe,%eax
f010cc0d:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc12:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc17:	83 e0 ef             	and    $0xffffffef,%eax
f010cc1a:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc1f:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc24:	83 c8 60             	or     $0x60,%eax
f010cc27:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc2c:	a0 95 1b 55 f0       	mov    0xf0551b95,%al
f010cc31:	83 c8 80             	or     $0xffffff80,%eax
f010cc34:	a2 95 1b 55 f0       	mov    %al,0xf0551b95
f010cc39:	b8 4e d4 10 f0       	mov    $0xf010d44e,%eax
f010cc3e:	c1 e8 10             	shr    $0x10,%eax
f010cc41:	66 a3 96 1b 55 f0    	mov    %ax,0xf0551b96
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010cc47:	b8 54 d4 10 f0       	mov    $0xf010d454,%eax
f010cc4c:	66 a3 98 1b 55 f0    	mov    %ax,0xf0551b98
f010cc52:	66 c7 05 9a 1b 55 f0 	movw   $0x8,0xf0551b9a
f010cc59:	08 00 
f010cc5b:	a0 9c 1b 55 f0       	mov    0xf0551b9c,%al
f010cc60:	83 e0 e0             	and    $0xffffffe0,%eax
f010cc63:	a2 9c 1b 55 f0       	mov    %al,0xf0551b9c
f010cc68:	a0 9c 1b 55 f0       	mov    0xf0551b9c,%al
f010cc6d:	83 e0 1f             	and    $0x1f,%eax
f010cc70:	a2 9c 1b 55 f0       	mov    %al,0xf0551b9c
f010cc75:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010cc7a:	83 e0 f0             	and    $0xfffffff0,%eax
f010cc7d:	83 c8 0e             	or     $0xe,%eax
f010cc80:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010cc85:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010cc8a:	83 e0 ef             	and    $0xffffffef,%eax
f010cc8d:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010cc92:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010cc97:	83 c8 60             	or     $0x60,%eax
f010cc9a:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010cc9f:	a0 9d 1b 55 f0       	mov    0xf0551b9d,%al
f010cca4:	83 c8 80             	or     $0xffffff80,%eax
f010cca7:	a2 9d 1b 55 f0       	mov    %al,0xf0551b9d
f010ccac:	b8 54 d4 10 f0       	mov    $0xf010d454,%eax
f010ccb1:	c1 e8 10             	shr    $0x10,%eax
f010ccb4:	66 a3 9e 1b 55 f0    	mov    %ax,0xf0551b9e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010ccba:	b8 5a d4 10 f0       	mov    $0xf010d45a,%eax
f010ccbf:	66 a3 a0 1b 55 f0    	mov    %ax,0xf0551ba0
f010ccc5:	66 c7 05 a2 1b 55 f0 	movw   $0x8,0xf0551ba2
f010cccc:	08 00 
f010ccce:	a0 a4 1b 55 f0       	mov    0xf0551ba4,%al
f010ccd3:	83 e0 e0             	and    $0xffffffe0,%eax
f010ccd6:	a2 a4 1b 55 f0       	mov    %al,0xf0551ba4
f010ccdb:	a0 a4 1b 55 f0       	mov    0xf0551ba4,%al
f010cce0:	83 e0 1f             	and    $0x1f,%eax
f010cce3:	a2 a4 1b 55 f0       	mov    %al,0xf0551ba4
f010cce8:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cced:	83 e0 f0             	and    $0xfffffff0,%eax
f010ccf0:	83 c8 0e             	or     $0xe,%eax
f010ccf3:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010ccf8:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010ccfd:	83 e0 ef             	and    $0xffffffef,%eax
f010cd00:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd05:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cd0a:	83 c8 60             	or     $0x60,%eax
f010cd0d:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd12:	a0 a5 1b 55 f0       	mov    0xf0551ba5,%al
f010cd17:	83 c8 80             	or     $0xffffff80,%eax
f010cd1a:	a2 a5 1b 55 f0       	mov    %al,0xf0551ba5
f010cd1f:	b8 5a d4 10 f0       	mov    $0xf010d45a,%eax
f010cd24:	c1 e8 10             	shr    $0x10,%eax
f010cd27:	66 a3 a6 1b 55 f0    	mov    %ax,0xf0551ba6
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010cd2d:	b8 60 d4 10 f0       	mov    $0xf010d460,%eax
f010cd32:	66 a3 a8 1b 55 f0    	mov    %ax,0xf0551ba8
f010cd38:	66 c7 05 aa 1b 55 f0 	movw   $0x8,0xf0551baa
f010cd3f:	08 00 
f010cd41:	a0 ac 1b 55 f0       	mov    0xf0551bac,%al
f010cd46:	83 e0 e0             	and    $0xffffffe0,%eax
f010cd49:	a2 ac 1b 55 f0       	mov    %al,0xf0551bac
f010cd4e:	a0 ac 1b 55 f0       	mov    0xf0551bac,%al
f010cd53:	83 e0 1f             	and    $0x1f,%eax
f010cd56:	a2 ac 1b 55 f0       	mov    %al,0xf0551bac
f010cd5b:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd60:	83 e0 f0             	and    $0xfffffff0,%eax
f010cd63:	83 c8 0e             	or     $0xe,%eax
f010cd66:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cd6b:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd70:	83 e0 ef             	and    $0xffffffef,%eax
f010cd73:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cd78:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd7d:	83 c8 60             	or     $0x60,%eax
f010cd80:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cd85:	a0 ad 1b 55 f0       	mov    0xf0551bad,%al
f010cd8a:	83 c8 80             	or     $0xffffff80,%eax
f010cd8d:	a2 ad 1b 55 f0       	mov    %al,0xf0551bad
f010cd92:	b8 60 d4 10 f0       	mov    $0xf010d460,%eax
f010cd97:	c1 e8 10             	shr    $0x10,%eax
f010cd9a:	66 a3 ae 1b 55 f0    	mov    %ax,0xf0551bae
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010cda0:	b8 66 d4 10 f0       	mov    $0xf010d466,%eax
f010cda5:	66 a3 b0 1b 55 f0    	mov    %ax,0xf0551bb0
f010cdab:	66 c7 05 b2 1b 55 f0 	movw   $0x8,0xf0551bb2
f010cdb2:	08 00 
f010cdb4:	a0 b4 1b 55 f0       	mov    0xf0551bb4,%al
f010cdb9:	83 e0 e0             	and    $0xffffffe0,%eax
f010cdbc:	a2 b4 1b 55 f0       	mov    %al,0xf0551bb4
f010cdc1:	a0 b4 1b 55 f0       	mov    0xf0551bb4,%al
f010cdc6:	83 e0 1f             	and    $0x1f,%eax
f010cdc9:	a2 b4 1b 55 f0       	mov    %al,0xf0551bb4
f010cdce:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010cdd3:	83 e0 f0             	and    $0xfffffff0,%eax
f010cdd6:	83 c8 0e             	or     $0xe,%eax
f010cdd9:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010cdde:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010cde3:	83 e0 ef             	and    $0xffffffef,%eax
f010cde6:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010cdeb:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010cdf0:	83 c8 60             	or     $0x60,%eax
f010cdf3:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010cdf8:	a0 b5 1b 55 f0       	mov    0xf0551bb5,%al
f010cdfd:	83 c8 80             	or     $0xffffff80,%eax
f010ce00:	a2 b5 1b 55 f0       	mov    %al,0xf0551bb5
f010ce05:	b8 66 d4 10 f0       	mov    $0xf010d466,%eax
f010ce0a:	c1 e8 10             	shr    $0x10,%eax
f010ce0d:	66 a3 b6 1b 55 f0    	mov    %ax,0xf0551bb6
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010ce13:	b8 6c d4 10 f0       	mov    $0xf010d46c,%eax
f010ce18:	66 a3 b8 1b 55 f0    	mov    %ax,0xf0551bb8
f010ce1e:	66 c7 05 ba 1b 55 f0 	movw   $0x8,0xf0551bba
f010ce25:	08 00 
f010ce27:	a0 bc 1b 55 f0       	mov    0xf0551bbc,%al
f010ce2c:	83 e0 e0             	and    $0xffffffe0,%eax
f010ce2f:	a2 bc 1b 55 f0       	mov    %al,0xf0551bbc
f010ce34:	a0 bc 1b 55 f0       	mov    0xf0551bbc,%al
f010ce39:	83 e0 1f             	and    $0x1f,%eax
f010ce3c:	a2 bc 1b 55 f0       	mov    %al,0xf0551bbc
f010ce41:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce46:	83 e0 f0             	and    $0xfffffff0,%eax
f010ce49:	83 c8 0e             	or     $0xe,%eax
f010ce4c:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce51:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce56:	83 e0 ef             	and    $0xffffffef,%eax
f010ce59:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce5e:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce63:	83 c8 60             	or     $0x60,%eax
f010ce66:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce6b:	a0 bd 1b 55 f0       	mov    0xf0551bbd,%al
f010ce70:	83 c8 80             	or     $0xffffff80,%eax
f010ce73:	a2 bd 1b 55 f0       	mov    %al,0xf0551bbd
f010ce78:	b8 6c d4 10 f0       	mov    $0xf010d46c,%eax
f010ce7d:	c1 e8 10             	shr    $0x10,%eax
f010ce80:	66 a3 be 1b 55 f0    	mov    %ax,0xf0551bbe
f010ce86:	c7 45 fc 40 1a 55 f0 	movl   $0xf0551a40,-0x4(%ebp)
f010ce8d:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010ce94:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010ce97:	48                   	dec    %eax
f010ce98:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010ce9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010ce9f:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010cea3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010cea6:	c1 e8 10             	shr    $0x10,%eax
f010cea9:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010cead:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010ceb0:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010ceb3:	90                   	nop
f010ceb4:	c9                   	leave  
f010ceb5:	c3                   	ret    

f010ceb6 <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010ceb6:	55                   	push   %ebp
f010ceb7:	89 e5                	mov    %esp,%ebp
f010ceb9:	53                   	push   %ebx
f010ceba:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010cebd:	83 ec 08             	sub    $0x8,%esp
f010cec0:	ff 75 08             	pushl  0x8(%ebp)
f010cec3:	68 3e 64 12 f0       	push   $0xf012643e
f010cec8:	e8 9f 40 ff ff       	call   f0100f6c <cprintf>
f010cecd:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010ced0:	8b 45 08             	mov    0x8(%ebp),%eax
f010ced3:	83 ec 0c             	sub    $0xc,%esp
f010ced6:	50                   	push   %eax
f010ced7:	e8 fd 00 00 00       	call   f010cfd9 <print_regs>
f010cedc:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010cedf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cee2:	8b 40 20             	mov    0x20(%eax),%eax
f010cee5:	0f b7 c0             	movzwl %ax,%eax
f010cee8:	83 ec 08             	sub    $0x8,%esp
f010ceeb:	50                   	push   %eax
f010ceec:	68 50 64 12 f0       	push   $0xf0126450
f010cef1:	e8 76 40 ff ff       	call   f0100f6c <cprintf>
f010cef6:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010cef9:	8b 45 08             	mov    0x8(%ebp),%eax
f010cefc:	8b 40 24             	mov    0x24(%eax),%eax
f010ceff:	0f b7 c0             	movzwl %ax,%eax
f010cf02:	83 ec 08             	sub    $0x8,%esp
f010cf05:	50                   	push   %eax
f010cf06:	68 63 64 12 f0       	push   $0xf0126463
f010cf0b:	e8 5c 40 ff ff       	call   f0100f6c <cprintf>
f010cf10:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010cf13:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf16:	8b 58 28             	mov    0x28(%eax),%ebx
f010cf19:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf1c:	8b 40 28             	mov    0x28(%eax),%eax
f010cf1f:	83 ec 0c             	sub    $0xc,%esp
f010cf22:	50                   	push   %eax
f010cf23:	e8 28 ee ff ff       	call   f010bd50 <trapname>
f010cf28:	83 c4 10             	add    $0x10,%esp
f010cf2b:	89 c2                	mov    %eax,%edx
f010cf2d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf30:	8b 40 28             	mov    0x28(%eax),%eax
f010cf33:	53                   	push   %ebx
f010cf34:	52                   	push   %edx
f010cf35:	50                   	push   %eax
f010cf36:	68 76 64 12 f0       	push   $0xf0126476
f010cf3b:	e8 2c 40 ff ff       	call   f0100f6c <cprintf>
f010cf40:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010cf43:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf46:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cf49:	83 ec 08             	sub    $0x8,%esp
f010cf4c:	50                   	push   %eax
f010cf4d:	68 8d 64 12 f0       	push   $0xf012648d
f010cf52:	e8 15 40 ff ff       	call   f0100f6c <cprintf>
f010cf57:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010cf5a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf5d:	8b 40 30             	mov    0x30(%eax),%eax
f010cf60:	83 ec 08             	sub    $0x8,%esp
f010cf63:	50                   	push   %eax
f010cf64:	68 9c 64 12 f0       	push   $0xf012649c
f010cf69:	e8 fe 3f ff ff       	call   f0100f6c <cprintf>
f010cf6e:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010cf71:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf74:	8b 40 34             	mov    0x34(%eax),%eax
f010cf77:	0f b7 c0             	movzwl %ax,%eax
f010cf7a:	83 ec 08             	sub    $0x8,%esp
f010cf7d:	50                   	push   %eax
f010cf7e:	68 ab 64 12 f0       	push   $0xf01264ab
f010cf83:	e8 e4 3f ff ff       	call   f0100f6c <cprintf>
f010cf88:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010cf8b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf8e:	8b 40 38             	mov    0x38(%eax),%eax
f010cf91:	83 ec 08             	sub    $0x8,%esp
f010cf94:	50                   	push   %eax
f010cf95:	68 be 64 12 f0       	push   $0xf01264be
f010cf9a:	e8 cd 3f ff ff       	call   f0100f6c <cprintf>
f010cf9f:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010cfa2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfa5:	8b 40 3c             	mov    0x3c(%eax),%eax
f010cfa8:	83 ec 08             	sub    $0x8,%esp
f010cfab:	50                   	push   %eax
f010cfac:	68 cd 64 12 f0       	push   $0xf01264cd
f010cfb1:	e8 b6 3f ff ff       	call   f0100f6c <cprintf>
f010cfb6:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010cfb9:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfbc:	8b 40 40             	mov    0x40(%eax),%eax
f010cfbf:	0f b7 c0             	movzwl %ax,%eax
f010cfc2:	83 ec 08             	sub    $0x8,%esp
f010cfc5:	50                   	push   %eax
f010cfc6:	68 dc 64 12 f0       	push   $0xf01264dc
f010cfcb:	e8 9c 3f ff ff       	call   f0100f6c <cprintf>
f010cfd0:	83 c4 10             	add    $0x10,%esp
}
f010cfd3:	90                   	nop
f010cfd4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010cfd7:	c9                   	leave  
f010cfd8:	c3                   	ret    

f010cfd9 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010cfd9:	55                   	push   %ebp
f010cfda:	89 e5                	mov    %esp,%ebp
f010cfdc:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010cfdf:	8b 45 08             	mov    0x8(%ebp),%eax
f010cfe2:	8b 00                	mov    (%eax),%eax
f010cfe4:	83 ec 08             	sub    $0x8,%esp
f010cfe7:	50                   	push   %eax
f010cfe8:	68 ef 64 12 f0       	push   $0xf01264ef
f010cfed:	e8 7a 3f ff ff       	call   f0100f6c <cprintf>
f010cff2:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010cff5:	8b 45 08             	mov    0x8(%ebp),%eax
f010cff8:	8b 40 04             	mov    0x4(%eax),%eax
f010cffb:	83 ec 08             	sub    $0x8,%esp
f010cffe:	50                   	push   %eax
f010cfff:	68 fe 64 12 f0       	push   $0xf01264fe
f010d004:	e8 63 3f ff ff       	call   f0100f6c <cprintf>
f010d009:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010d00c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d00f:	8b 40 08             	mov    0x8(%eax),%eax
f010d012:	83 ec 08             	sub    $0x8,%esp
f010d015:	50                   	push   %eax
f010d016:	68 0d 65 12 f0       	push   $0xf012650d
f010d01b:	e8 4c 3f ff ff       	call   f0100f6c <cprintf>
f010d020:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010d023:	8b 45 08             	mov    0x8(%ebp),%eax
f010d026:	8b 40 0c             	mov    0xc(%eax),%eax
f010d029:	83 ec 08             	sub    $0x8,%esp
f010d02c:	50                   	push   %eax
f010d02d:	68 1c 65 12 f0       	push   $0xf012651c
f010d032:	e8 35 3f ff ff       	call   f0100f6c <cprintf>
f010d037:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010d03a:	8b 45 08             	mov    0x8(%ebp),%eax
f010d03d:	8b 40 10             	mov    0x10(%eax),%eax
f010d040:	83 ec 08             	sub    $0x8,%esp
f010d043:	50                   	push   %eax
f010d044:	68 2b 65 12 f0       	push   $0xf012652b
f010d049:	e8 1e 3f ff ff       	call   f0100f6c <cprintf>
f010d04e:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010d051:	8b 45 08             	mov    0x8(%ebp),%eax
f010d054:	8b 40 14             	mov    0x14(%eax),%eax
f010d057:	83 ec 08             	sub    $0x8,%esp
f010d05a:	50                   	push   %eax
f010d05b:	68 3a 65 12 f0       	push   $0xf012653a
f010d060:	e8 07 3f ff ff       	call   f0100f6c <cprintf>
f010d065:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010d068:	8b 45 08             	mov    0x8(%ebp),%eax
f010d06b:	8b 40 18             	mov    0x18(%eax),%eax
f010d06e:	83 ec 08             	sub    $0x8,%esp
f010d071:	50                   	push   %eax
f010d072:	68 49 65 12 f0       	push   $0xf0126549
f010d077:	e8 f0 3e ff ff       	call   f0100f6c <cprintf>
f010d07c:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010d07f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d082:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d085:	83 ec 08             	sub    $0x8,%esp
f010d088:	50                   	push   %eax
f010d089:	68 58 65 12 f0       	push   $0xf0126558
f010d08e:	e8 d9 3e ff ff       	call   f0100f6c <cprintf>
f010d093:	83 c4 10             	add    $0x10,%esp
}
f010d096:	90                   	nop
f010d097:	c9                   	leave  
f010d098:	c3                   	ret    

f010d099 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010d099:	55                   	push   %ebp
f010d09a:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010d09c:	8b 45 08             	mov    0x8(%ebp),%eax
f010d09f:	8b 55 0c             	mov    0xc(%ebp),%edx
f010d0a2:	89 14 85 40 22 55 f0 	mov    %edx,-0xfaaddc0(,%eax,4)
}
f010d0a9:	90                   	nop
f010d0aa:	5d                   	pop    %ebp
f010d0ab:	c3                   	ret    

f010d0ac <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010d0ac:	55                   	push   %ebp
f010d0ad:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010d0af:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0b2:	c7 04 85 40 22 55 f0 	movl   $0x0,-0xfaaddc0(,%eax,4)
f010d0b9:	00 00 00 00 
}
f010d0bd:	90                   	nop
f010d0be:	5d                   	pop    %ebp
f010d0bf:	c3                   	ret    

f010d0c0 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010d0c0:	55                   	push   %ebp
f010d0c1:	89 e5                	mov    %esp,%ebp
f010d0c3:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010d0c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010d0c9:	8b 40 28             	mov    0x28(%eax),%eax
f010d0cc:	83 e8 20             	sub    $0x20,%eax
f010d0cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010d0d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0d5:	8b 04 85 40 22 55 f0 	mov    -0xfaaddc0(,%eax,4),%eax
f010d0dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010d0df:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d0e3:	74 0e                	je     f010d0f3 <irq_dispatch+0x33>
	{
		handler(tf);
f010d0e5:	83 ec 0c             	sub    $0xc,%esp
f010d0e8:	ff 75 08             	pushl  0x8(%ebp)
f010d0eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d0ee:	ff d0                	call   *%eax
f010d0f0:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010d0f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0f6:	0f b6 c0             	movzbl %al,%eax
f010d0f9:	83 ec 0c             	sub    $0xc,%esp
f010d0fc:	50                   	push   %eax
f010d0fd:	e8 c3 9c ff ff       	call   f0106dc5 <pic_sendEOI>
f010d102:	83 c4 10             	add    $0x10,%esp
}
f010d105:	90                   	nop
f010d106:	c9                   	leave  
f010d107:	c3                   	ret    

f010d108 <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010d108:	55                   	push   %ebp
f010d109:	89 e5                	mov    %esp,%ebp
f010d10b:	57                   	push   %edi
f010d10c:	56                   	push   %esi
f010d10d:	53                   	push   %ebx
f010d10e:	83 ec 1c             	sub    $0x1c,%esp
	if(tf->tf_trapno == T_PGFLT)
f010d111:	8b 45 08             	mov    0x8(%ebp),%eax
f010d114:	8b 40 28             	mov    0x28(%eax),%eax
f010d117:	83 f8 0e             	cmp    $0xe,%eax
f010d11a:	75 51                	jne    f010d16d <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010d11c:	a0 80 22 55 f0       	mov    0xf0552280,%al
f010d121:	84 c0                	test   %al,%al
f010d123:	74 1f                	je     f010d144 <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010d125:	8b 45 08             	mov    0x8(%ebp),%eax
f010d128:	8b 40 30             	mov    0x30(%eax),%eax
f010d12b:	89 c2                	mov    %eax,%edx
f010d12d:	a0 80 22 55 f0       	mov    0xf0552280,%al
f010d132:	0f b6 c0             	movzbl %al,%eax
f010d135:	01 d0                	add    %edx,%eax
f010d137:	89 c2                	mov    %eax,%edx
f010d139:	8b 45 08             	mov    0x8(%ebp),%eax
f010d13c:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010d13f:	e9 0c 01 00 00       	jmp    f010d250 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010d144:	83 ec 0c             	sub    $0xc,%esp
f010d147:	6a 01                	push   $0x1
f010d149:	e8 21 12 00 00       	call   f010e36f <isPageReplacmentAlgorithmLRU>
f010d14e:	83 c4 10             	add    $0x10,%esp
f010d151:	85 c0                	test   %eax,%eax
f010d153:	74 05                	je     f010d15a <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010d155:	e8 de 97 ff ff       	call   f0106938 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010d15a:	83 ec 0c             	sub    $0xc,%esp
f010d15d:	ff 75 08             	pushl  0x8(%ebp)
f010d160:	e8 ef 12 00 00       	call   f010e454 <fault_handler>
f010d165:	83 c4 10             	add    $0x10,%esp
f010d168:	e9 e3 00 00 00       	jmp    f010d250 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010d16d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d170:	8b 40 28             	mov    0x28(%eax),%eax
f010d173:	83 f8 30             	cmp    $0x30,%eax
f010d176:	75 6e                	jne    f010d1e6 <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010d178:	8b 45 08             	mov    0x8(%ebp),%eax
f010d17b:	8b 40 38             	mov    0x38(%eax),%eax
f010d17e:	25 00 02 00 00       	and    $0x200,%eax
f010d183:	85 c0                	test   %eax,%eax
f010d185:	74 06                	je     f010d18d <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010d187:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010d188:	e8 24 78 ff ff       	call   f01049b1 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010d18d:	8b 45 08             	mov    0x8(%ebp),%eax
f010d190:	8b 78 04             	mov    0x4(%eax),%edi
f010d193:	8b 45 08             	mov    0x8(%ebp),%eax
f010d196:	8b 30                	mov    (%eax),%esi
f010d198:	8b 45 08             	mov    0x8(%ebp),%eax
f010d19b:	8b 58 10             	mov    0x10(%eax),%ebx
f010d19e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1a1:	8b 48 18             	mov    0x18(%eax),%ecx
f010d1a4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1a7:	8b 50 14             	mov    0x14(%eax),%edx
f010d1aa:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1ad:	8b 40 1c             	mov    0x1c(%eax),%eax
f010d1b0:	83 ec 08             	sub    $0x8,%esp
f010d1b3:	57                   	push   %edi
f010d1b4:	56                   	push   %esi
f010d1b5:	53                   	push   %ebx
f010d1b6:	51                   	push   %ecx
f010d1b7:	52                   	push   %edx
f010d1b8:	50                   	push   %eax
f010d1b9:	e8 22 09 00 00       	call   f010dae0 <syscall>
f010d1be:	83 c4 20             	add    $0x20,%esp
f010d1c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010d1c4:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1c7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d1ca:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d1cd:	9c                   	pushf  
f010d1ce:	58                   	pop    %eax
f010d1cf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010d1d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010d1d5:	25 00 02 00 00       	and    $0x200,%eax
f010d1da:	85 c0                	test   %eax,%eax
f010d1dc:	74 72                	je     f010d250 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010d1de:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010d1df:	e8 a5 77 ff ff       	call   f0104989 <kclock_stop>
f010d1e4:	eb 6a                	jmp    f010d250 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010d1e6:	8b 45 08             	mov    0x8(%ebp),%eax
f010d1e9:	8b 40 28             	mov    0x28(%eax),%eax
f010d1ec:	83 f8 08             	cmp    $0x8,%eax
f010d1ef:	75 17                	jne    f010d208 <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010d1f1:	83 ec 04             	sub    $0x4,%esp
f010d1f4:	68 67 65 12 f0       	push   $0xf0126567
f010d1f9:	68 22 01 00 00       	push   $0x122
f010d1fe:	68 76 65 12 f0       	push   $0xf0126576
f010d203:	e8 12 31 ff ff       	call   f010031a <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010d208:	83 ec 0c             	sub    $0xc,%esp
f010d20b:	ff 75 08             	pushl  0x8(%ebp)
f010d20e:	e8 a3 fc ff ff       	call   f010ceb6 <print_trapframe>
f010d213:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010d216:	8b 45 08             	mov    0x8(%ebp),%eax
f010d219:	8b 40 34             	mov    0x34(%eax),%eax
f010d21c:	66 83 f8 08          	cmp    $0x8,%ax
f010d220:	75 17                	jne    f010d239 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010d222:	83 ec 04             	sub    $0x4,%esp
f010d225:	68 87 65 12 f0       	push   $0xf0126587
f010d22a:	68 2a 01 00 00       	push   $0x12a
f010d22f:	68 76 65 12 f0       	push   $0xf0126576
f010d234:	e8 e1 30 ff ff       	call   f010031a <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010d239:	83 ec 04             	sub    $0x4,%esp
f010d23c:	68 a0 65 12 f0       	push   $0xf01265a0
f010d241:	68 2f 01 00 00       	push   $0x12f
f010d246:	68 76 65 12 f0       	push   $0xf0126576
f010d24b:	e8 ca 30 ff ff       	call   f010031a <_panic>
		}
	}
}
f010d250:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010d253:	5b                   	pop    %ebx
f010d254:	5e                   	pop    %esi
f010d255:	5f                   	pop    %edi
f010d256:	5d                   	pop    %ebp
f010d257:	c3                   	ret    

f010d258 <trap>:

void trap(struct Trapframe *tf)
{
f010d258:	55                   	push   %ebp
f010d259:	89 e5                	mov    %esp,%ebp
f010d25b:	83 ec 28             	sub    $0x28,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010d25e:	e8 26 77 ff ff       	call   f0104989 <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d263:	9c                   	pushf  
f010d264:	58                   	pop    %eax
f010d265:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return eflags;
f010d268:	8b 45 e0             	mov    -0x20(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010d26b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (flags & FL_IF)
f010d26e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d271:	25 00 02 00 00       	and    $0x200,%eax
f010d276:	85 c0                	test   %eax,%eax
f010d278:	74 25                	je     f010d29f <trap+0x47>
	{
		print_trapframe(tf);
f010d27a:	83 ec 0c             	sub    $0xc,%esp
f010d27d:	ff 75 08             	pushl  0x8(%ebp)
f010d280:	e8 31 fc ff ff       	call   f010ceb6 <print_trapframe>
f010d285:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010d288:	83 ec 04             	sub    $0x4,%esp
f010d28b:	68 c0 65 12 f0       	push   $0xf01265c0
f010d290:	68 45 01 00 00       	push   $0x145
f010d295:	68 76 65 12 f0       	push   $0xf0126576
f010d29a:	e8 7b 30 ff ff       	call   f010031a <_panic>
	}

	int userTrap = 0;
f010d29f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010d2a6:	e8 c6 d1 ff ff       	call   f010a471 <get_cpu_proc>
f010d2ab:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010d2ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010d2b1:	8b 40 34             	mov    0x34(%eax),%eax
f010d2b4:	0f b7 c0             	movzwl %ax,%eax
f010d2b7:	83 e0 03             	and    $0x3,%eax
f010d2ba:	83 f8 03             	cmp    $0x3,%eax
f010d2bd:	75 54                	jne    f010d313 <trap+0xbb>
	{
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010d2bf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010d2c3:	74 0b                	je     f010d2d0 <trap+0x78>
f010d2c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d2c8:	8b 40 18             	mov    0x18(%eax),%eax
f010d2cb:	83 f8 02             	cmp    $0x2,%eax
f010d2ce:	74 19                	je     f010d2e9 <trap+0x91>
f010d2d0:	68 04 66 12 f0       	push   $0xf0126604
f010d2d5:	68 32 66 12 f0       	push   $0xf0126632
f010d2da:	68 4d 01 00 00       	push   $0x14d
f010d2df:	68 76 65 12 f0       	push   $0xf0126576
f010d2e4:	e8 31 30 ff ff       	call   f010031a <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
f010d2e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d2ec:	8b 00                	mov    (%eax),%eax
f010d2ee:	3b 45 08             	cmp    0x8(%ebp),%eax
f010d2f1:	74 19                	je     f010d30c <trap+0xb4>
f010d2f3:	68 47 66 12 f0       	push   $0xf0126647
f010d2f8:	68 32 66 12 f0       	push   $0xf0126632
f010d2fd:	68 4f 01 00 00       	push   $0x14f
f010d302:	68 76 65 12 f0       	push   $0xf0126576
f010d307:	e8 0e 30 ff ff       	call   f010031a <_panic>
		userTrap = 1;
f010d30c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010d313:	8b 45 08             	mov    0x8(%ebp),%eax
f010d316:	8b 40 28             	mov    0x28(%eax),%eax
f010d319:	83 f8 1f             	cmp    $0x1f,%eax
f010d31c:	76 1b                	jbe    f010d339 <trap+0xe1>
f010d31e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d321:	8b 40 28             	mov    0x28(%eax),%eax
f010d324:	83 f8 2f             	cmp    $0x2f,%eax
f010d327:	77 10                	ja     f010d339 <trap+0xe1>
	{
		irq_dispatch(tf);
f010d329:	83 ec 0c             	sub    $0xc,%esp
f010d32c:	ff 75 08             	pushl  0x8(%ebp)
f010d32f:	e8 8c fd ff ff       	call   f010d0c0 <irq_dispatch>
f010d334:	83 c4 10             	add    $0x10,%esp
f010d337:	eb 0e                	jmp    f010d347 <trap+0xef>
	}
	else
	{
		trap_dispatch(tf);
f010d339:	83 ec 0c             	sub    $0xc,%esp
f010d33c:	ff 75 08             	pushl  0x8(%ebp)
f010d33f:	e8 c4 fd ff ff       	call   f010d108 <trap_dispatch>
f010d344:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d347:	9c                   	pushf  
f010d348:	58                   	pop    %eax
f010d349:	89 45 f4             	mov    %eax,-0xc(%ebp)
        return eflags;
f010d34c:	8b 45 f4             	mov    -0xc(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010d34f:	25 00 02 00 00       	and    $0x200,%eax
f010d354:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(IEN == 0);
f010d357:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010d35b:	74 19                	je     f010d376 <trap+0x11e>
f010d35d:	68 5d 66 12 f0       	push   $0xf012665d
f010d362:	68 32 66 12 f0       	push   $0xf0126632
f010d367:	68 66 01 00 00       	push   $0x166
f010d36c:	68 76 65 12 f0       	push   $0xf0126576
f010d371:	e8 a4 2f ff ff       	call   f010031a <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010d376:	e8 36 76 ff ff       	call   f01049b1 <kclock_resume>
	//	cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010d37b:	90                   	nop
f010d37c:	c9                   	leave  
f010d37d:	c3                   	ret    

f010d37e <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010d37e:	6a 08                	push   $0x8
f010d380:	e9 ed 00 00 00       	jmp    f010d472 <_alltraps>
f010d385:	90                   	nop

f010d386 <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010d386:	6a 0e                	push   $0xe
f010d388:	e9 e5 00 00 00       	jmp    f010d472 <_alltraps>
f010d38d:	90                   	nop

f010d38e <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010d38e:	6a 00                	push   $0x0
f010d390:	6a 20                	push   $0x20
f010d392:	e9 db 00 00 00       	jmp    f010d472 <_alltraps>
f010d397:	90                   	nop

f010d398 <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010d398:	6a 00                	push   $0x0
f010d39a:	6a 21                	push   $0x21
f010d39c:	e9 d1 00 00 00       	jmp    f010d472 <_alltraps>
f010d3a1:	90                   	nop

f010d3a2 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010d3a2:	6a 00                	push   $0x0
f010d3a4:	6a 30                	push   $0x30
f010d3a6:	e9 c7 00 00 00       	jmp    f010d472 <_alltraps>
f010d3ab:	90                   	nop

f010d3ac <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010d3ac:	6a 00                	push   $0x0
f010d3ae:	6a 00                	push   $0x0
f010d3b0:	e9 bd 00 00 00       	jmp    f010d472 <_alltraps>
f010d3b5:	90                   	nop

f010d3b6 <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010d3b6:	6a 00                	push   $0x0
f010d3b8:	6a 01                	push   $0x1
f010d3ba:	e9 b3 00 00 00       	jmp    f010d472 <_alltraps>
f010d3bf:	90                   	nop

f010d3c0 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010d3c0:	6a 00                	push   $0x0
f010d3c2:	6a 02                	push   $0x2
f010d3c4:	e9 a9 00 00 00       	jmp    f010d472 <_alltraps>
f010d3c9:	90                   	nop

f010d3ca <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010d3ca:	6a 00                	push   $0x0
f010d3cc:	6a 03                	push   $0x3
f010d3ce:	e9 9f 00 00 00       	jmp    f010d472 <_alltraps>
f010d3d3:	90                   	nop

f010d3d4 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010d3d4:	6a 00                	push   $0x0
f010d3d6:	6a 04                	push   $0x4
f010d3d8:	e9 95 00 00 00       	jmp    f010d472 <_alltraps>
f010d3dd:	90                   	nop

f010d3de <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010d3de:	6a 00                	push   $0x0
f010d3e0:	6a 05                	push   $0x5
f010d3e2:	e9 8b 00 00 00       	jmp    f010d472 <_alltraps>
f010d3e7:	90                   	nop

f010d3e8 <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010d3e8:	6a 00                	push   $0x0
f010d3ea:	6a 06                	push   $0x6
f010d3ec:	e9 81 00 00 00       	jmp    f010d472 <_alltraps>
f010d3f1:	90                   	nop

f010d3f2 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010d3f2:	6a 00                	push   $0x0
f010d3f4:	6a 07                	push   $0x7
f010d3f6:	eb 7a                	jmp    f010d472 <_alltraps>

f010d3f8 <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010d3f8:	6a 0a                	push   $0xa
f010d3fa:	eb 76                	jmp    f010d472 <_alltraps>

f010d3fc <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010d3fc:	6a 0b                	push   $0xb
f010d3fe:	eb 72                	jmp    f010d472 <_alltraps>

f010d400 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010d400:	6a 0c                	push   $0xc
f010d402:	eb 6e                	jmp    f010d472 <_alltraps>

f010d404 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010d404:	6a 0d                	push   $0xd
f010d406:	eb 6a                	jmp    f010d472 <_alltraps>

f010d408 <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010d408:	6a 00                	push   $0x0
f010d40a:	6a 10                	push   $0x10
f010d40c:	eb 64                	jmp    f010d472 <_alltraps>

f010d40e <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010d40e:	6a 11                	push   $0x11
f010d410:	eb 60                	jmp    f010d472 <_alltraps>

f010d412 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010d412:	6a 00                	push   $0x0
f010d414:	6a 12                	push   $0x12
f010d416:	eb 5a                	jmp    f010d472 <_alltraps>

f010d418 <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010d418:	6a 00                	push   $0x0
f010d41a:	6a 13                	push   $0x13
f010d41c:	eb 54                	jmp    f010d472 <_alltraps>

f010d41e <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010d41e:	6a 00                	push   $0x0
f010d420:	6a 22                	push   $0x22
f010d422:	eb 4e                	jmp    f010d472 <_alltraps>

f010d424 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010d424:	6a 00                	push   $0x0
f010d426:	6a 23                	push   $0x23
f010d428:	eb 48                	jmp    f010d472 <_alltraps>

f010d42a <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010d42a:	6a 00                	push   $0x0
f010d42c:	6a 24                	push   $0x24
f010d42e:	eb 42                	jmp    f010d472 <_alltraps>

f010d430 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010d430:	6a 00                	push   $0x0
f010d432:	6a 25                	push   $0x25
f010d434:	eb 3c                	jmp    f010d472 <_alltraps>

f010d436 <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010d436:	6a 00                	push   $0x0
f010d438:	6a 26                	push   $0x26
f010d43a:	eb 36                	jmp    f010d472 <_alltraps>

f010d43c <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010d43c:	6a 00                	push   $0x0
f010d43e:	6a 27                	push   $0x27
f010d440:	eb 30                	jmp    f010d472 <_alltraps>

f010d442 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010d442:	6a 00                	push   $0x0
f010d444:	6a 28                	push   $0x28
f010d446:	eb 2a                	jmp    f010d472 <_alltraps>

f010d448 <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010d448:	6a 00                	push   $0x0
f010d44a:	6a 29                	push   $0x29
f010d44c:	eb 24                	jmp    f010d472 <_alltraps>

f010d44e <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010d44e:	6a 00                	push   $0x0
f010d450:	6a 2a                	push   $0x2a
f010d452:	eb 1e                	jmp    f010d472 <_alltraps>

f010d454 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010d454:	6a 00                	push   $0x0
f010d456:	6a 2b                	push   $0x2b
f010d458:	eb 18                	jmp    f010d472 <_alltraps>

f010d45a <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010d45a:	6a 00                	push   $0x0
f010d45c:	6a 2c                	push   $0x2c
f010d45e:	eb 12                	jmp    f010d472 <_alltraps>

f010d460 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010d460:	6a 00                	push   $0x0
f010d462:	6a 2d                	push   $0x2d
f010d464:	eb 0c                	jmp    f010d472 <_alltraps>

f010d466 <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010d466:	6a 00                	push   $0x0
f010d468:	6a 2e                	push   $0x2e
f010d46a:	eb 06                	jmp    f010d472 <_alltraps>

f010d46c <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010d46c:	6a 00                	push   $0x0
f010d46e:	6a 2f                	push   $0x2f
f010d470:	eb 00                	jmp    f010d472 <_alltraps>

f010d472 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010d472:	1e                   	push   %ds
push 	%es
f010d473:	06                   	push   %es
pushal
f010d474:	60                   	pusha  

mov 	$(GD_KD), %ax
f010d475:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010d479:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010d47b:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010d47d:	54                   	push   %esp
call 	trap
f010d47e:	e8 d5 fd ff ff       	call   f010d258 <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010d483:	59                   	pop    %ecx

f010d484 <trapret>:
.globl trapret
trapret:
popal
f010d484:	61                   	popa   
pop 	%es
f010d485:	07                   	pop    %es
pop 	%ds
f010d486:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010d487:	83 c4 08             	add    $0x8,%esp
iret
f010d48a:	cf                   	iret   

f010d48b <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f010d48b:	55                   	push   %ebp
f010d48c:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f010d48e:	8b 45 08             	mov    0x8(%ebp),%eax
f010d491:	8b 15 20 4f 55 f0    	mov    0xf0554f20,%edx
f010d497:	29 d0                	sub    %edx,%eax
f010d499:	c1 f8 03             	sar    $0x3,%eax
f010d49c:	89 c2                	mov    %eax,%edx
f010d49e:	89 d0                	mov    %edx,%eax
f010d4a0:	c1 e0 02             	shl    $0x2,%eax
f010d4a3:	01 d0                	add    %edx,%eax
f010d4a5:	c1 e0 02             	shl    $0x2,%eax
f010d4a8:	01 d0                	add    %edx,%eax
f010d4aa:	c1 e0 02             	shl    $0x2,%eax
f010d4ad:	01 d0                	add    %edx,%eax
f010d4af:	89 c1                	mov    %eax,%ecx
f010d4b1:	c1 e1 08             	shl    $0x8,%ecx
f010d4b4:	01 c8                	add    %ecx,%eax
f010d4b6:	89 c1                	mov    %eax,%ecx
f010d4b8:	c1 e1 10             	shl    $0x10,%ecx
f010d4bb:	01 c8                	add    %ecx,%eax
f010d4bd:	01 c0                	add    %eax,%eax
f010d4bf:	01 d0                	add    %edx,%eax
}
f010d4c1:	5d                   	pop    %ebp
f010d4c2:	c3                   	ret    

f010d4c3 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f010d4c3:	55                   	push   %ebp
f010d4c4:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f010d4c6:	ff 75 08             	pushl  0x8(%ebp)
f010d4c9:	e8 bd ff ff ff       	call   f010d48b <to_frame_number>
f010d4ce:	83 c4 04             	add    $0x4,%esp
f010d4d1:	c1 e0 0c             	shl    $0xc,%eax
}
f010d4d4:	c9                   	leave  
f010d4d5:	c3                   	ret    

f010d4d6 <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName)
{
f010d4d6:	55                   	push   %ebp
f010d4d7:	89 e5                	mov    %esp,%ebp
f010d4d9:	83 ec 18             	sub    $0x18,%esp
f010d4dc:	8b 45 10             	mov    0x10(%ebp),%eax
f010d4df:	88 45 f4             	mov    %al,-0xc(%ebp)
	//2024 - better to use locks instead (to support multiprocessors)
	pushcli();	//disable interrupts
f010d4e2:	e8 da 99 ff ff       	call   f0106ec1 <pushcli>
		// Destroy the environment if not.

		// LAB 3: Your code here.

		// Print the string supplied by the user.
		if (printProgName)
f010d4e7:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
f010d4eb:	74 23                	je     f010d510 <sys_cputs+0x3a>
			cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010d4ed:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d4f2:	8b 40 10             	mov    0x10(%eax),%eax
f010d4f5:	8b 15 c4 36 57 f0    	mov    0xf05736c4,%edx
f010d4fb:	83 c2 20             	add    $0x20,%edx
f010d4fe:	83 ec 04             	sub    $0x4,%esp
f010d501:	50                   	push   %eax
f010d502:	52                   	push   %edx
f010d503:	68 10 68 12 f0       	push   $0xf0126810
f010d508:	e8 5f 3a ff ff       	call   f0100f6c <cprintf>
f010d50d:	83 c4 10             	add    $0x10,%esp
		cprintf("%.*s",len, s);
f010d510:	83 ec 04             	sub    $0x4,%esp
f010d513:	ff 75 08             	pushl  0x8(%ebp)
f010d516:	ff 75 0c             	pushl  0xc(%ebp)
f010d519:	68 19 68 12 f0       	push   $0xf0126819
f010d51e:	e8 49 3a ff ff       	call   f0100f6c <cprintf>
f010d523:	83 c4 10             	add    $0x10,%esp
	}
	popcli();	//enable interrupts
f010d526:	e8 e8 99 ff ff       	call   f0106f13 <popcli>
}
f010d52b:	90                   	nop
f010d52c:	c9                   	leave  
f010d52d:	c3                   	ret    

f010d52e <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010d52e:	55                   	push   %ebp
f010d52f:	89 e5                	mov    %esp,%ebp
f010d531:	83 ec 18             	sub    $0x18,%esp
f010d534:	8b 45 08             	mov    0x8(%ebp),%eax
f010d537:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010d53a:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010d53e:	83 ec 08             	sub    $0x8,%esp
f010d541:	50                   	push   %eax
f010d542:	68 1e 68 12 f0       	push   $0xf012681e
f010d547:	e8 20 3a ff ff       	call   f0100f6c <cprintf>
f010d54c:	83 c4 10             	add    $0x10,%esp
}
f010d54f:	90                   	nop
f010d550:	c9                   	leave  
f010d551:	c3                   	ret    

f010d552 <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010d552:	55                   	push   %ebp
f010d553:	89 e5                	mov    %esp,%ebp
f010d555:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010d558:	9c                   	pushf  
f010d559:	58                   	pop    %eax
f010d55a:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010d55d:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010d560:	25 00 02 00 00       	and    $0x200,%eax
f010d565:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010d568:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010d56c:	74 10                	je     f010d57e <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010d56e:	e8 32 38 ff ff       	call   f0100da5 <cons_getc2>
f010d573:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d576:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d57a:	74 f2                	je     f010d56e <sys_cgetc+0x1c>
f010d57c:	eb 0e                	jmp    f010d58c <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010d57e:	e8 c7 37 ff ff       	call   f0100d4a <cons_getc>
f010d583:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d586:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d58a:	74 f2                	je     f010d57e <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010d58c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d58f:	c9                   	leave  
f010d590:	c3                   	ret    

f010d591 <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010d591:	55                   	push   %ebp
f010d592:	89 e5                	mov    %esp,%ebp
f010d594:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010d597:	e8 f5 38 ff ff       	call   f0100e91 <cons_lock>
}
f010d59c:	90                   	nop
f010d59d:	c9                   	leave  
f010d59e:	c3                   	ret    

f010d59f <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010d59f:	55                   	push   %ebp
f010d5a0:	89 e5                	mov    %esp,%ebp
f010d5a2:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010d5a5:	e8 2e 39 ff ff       	call   f0100ed8 <cons_unlock>
}
f010d5aa:	90                   	nop
f010d5ab:	c9                   	leave  
f010d5ac:	c3                   	ret    

f010d5ad <__sys_allocate_page>:
//	E_INVAL if va >= UTOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010d5ad:	55                   	push   %ebp
f010d5ae:	89 e5                	mov    %esp,%ebp
f010d5b0:	83 ec 28             	sub    $0x28,%esp
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	int r;
	struct Env *e = cur_env;
f010d5b3:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d5b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//if ((r = envid2env(envid, &e, 1)) < 0)
	//return r;

	struct FrameInfo *ptr_frame_info ;
	r = allocate_frame(&ptr_frame_info) ;
f010d5bb:	83 ec 0c             	sub    $0xc,%esp
f010d5be:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010d5c1:	50                   	push   %eax
f010d5c2:	e8 0a a9 ff ff       	call   f0107ed1 <allocate_frame>
f010d5c7:	83 c4 10             	add    $0x10,%esp
f010d5ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d5cd:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d5d1:	75 08                	jne    f010d5db <__sys_allocate_page+0x2e>
		return r ;
f010d5d3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d5d6:	e9 d0 00 00 00       	jmp    f010d6ab <__sys_allocate_page+0xfe>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010d5db:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5de:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010d5e3:	77 0c                	ja     f010d5f1 <__sys_allocate_page+0x44>
f010d5e5:	8b 45 08             	mov    0x8(%ebp),%eax
f010d5e8:	25 ff 0f 00 00       	and    $0xfff,%eax
f010d5ed:	85 c0                	test   %eax,%eax
f010d5ef:	74 0a                	je     f010d5fb <__sys_allocate_page+0x4e>
		return E_INVAL;
f010d5f1:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d5f6:	e9 b0 00 00 00       	jmp    f010d6ab <__sys_allocate_page+0xfe>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010d5fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010d5fe:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010d603:	83 f8 04             	cmp    $0x4,%eax
f010d606:	74 0a                	je     f010d612 <__sys_allocate_page+0x65>
		return E_INVAL;
f010d608:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010d60d:	e9 99 00 00 00       	jmp    f010d6ab <__sys_allocate_page+0xfe>


	uint32 physical_address = to_physical_address(ptr_frame_info) ;
f010d612:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d615:	83 ec 0c             	sub    $0xc,%esp
f010d618:	50                   	push   %eax
f010d619:	e8 a5 fe ff ff       	call   f010d4c3 <to_physical_address>
f010d61e:	83 c4 10             	add    $0x10,%esp
f010d621:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//return it to the original status
		ptr_frame_info->references -= 1;
	}
#else
	{
		memset(STATIC_KERNEL_VIRTUAL_ADDRESS(physical_address), 0, PAGE_SIZE);
f010d624:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010d627:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010d62a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d62d:	c1 e8 0c             	shr    $0xc,%eax
f010d630:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010d633:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f010d638:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010d63b:	72 17                	jb     f010d654 <__sys_allocate_page+0xa7>
f010d63d:	ff 75 e8             	pushl  -0x18(%ebp)
f010d640:	68 24 68 12 f0       	push   $0xf0126824
f010d645:	68 b5 00 00 00       	push   $0xb5
f010d64a:	68 53 68 12 f0       	push   $0xf0126853
f010d64f:	e8 c6 2c ff ff       	call   f010031a <_panic>
f010d654:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010d657:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010d65c:	83 ec 04             	sub    $0x4,%esp
f010d65f:	68 00 10 00 00       	push   $0x1000
f010d664:	6a 00                	push   $0x0
f010d666:	50                   	push   %eax
f010d667:	e8 b5 30 01 00       	call   f0120721 <memset>
f010d66c:	83 c4 10             	add    $0x10,%esp
	}
#endif
	r = map_frame(e->env_page_directory, ptr_frame_info, (uint32)va, perm) ;
f010d66f:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010d672:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010d675:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d678:	8b 40 64             	mov    0x64(%eax),%eax
f010d67b:	ff 75 0c             	pushl  0xc(%ebp)
f010d67e:	51                   	push   %ecx
f010d67f:	52                   	push   %edx
f010d680:	50                   	push   %eax
f010d681:	e8 61 ac ff ff       	call   f01082e7 <map_frame>
f010d686:	83 c4 10             	add    $0x10,%esp
f010d689:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (r == E_NO_MEM)
f010d68c:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010d690:	75 14                	jne    f010d6a6 <__sys_allocate_page+0xf9>
	{
		decrement_references(ptr_frame_info);
f010d692:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010d695:	83 ec 0c             	sub    $0xc,%esp
f010d698:	50                   	push   %eax
f010d699:	e8 40 aa ff ff       	call   f01080de <decrement_references>
f010d69e:	83 c4 10             	add    $0x10,%esp
		return r;
f010d6a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d6a4:	eb 05                	jmp    f010d6ab <__sys_allocate_page+0xfe>
	}
	return 0 ;
f010d6a6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010d6ab:	c9                   	leave  
f010d6ac:	c3                   	ret    

f010d6ad <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010d6ad:	55                   	push   %ebp
f010d6ae:	89 e5                	mov    %esp,%ebp
f010d6b0:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010d6b3:	83 ec 04             	sub    $0x4,%esp
f010d6b6:	68 67 68 12 f0       	push   $0xf0126867
f010d6bb:	68 dc 00 00 00       	push   $0xdc
f010d6c0:	68 53 68 12 f0       	push   $0xf0126853
f010d6c5:	e8 50 2c ff ff       	call   f010031a <_panic>

f010d6ca <__sys_unmap_frame>:
// Return 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.
static int __sys_unmap_frame(int32 envid, void *va)
{
f010d6ca:	55                   	push   %ebp
f010d6cb:	89 e5                	mov    %esp,%ebp
f010d6cd:	83 ec 08             	sub    $0x8,%esp
	// Hint: This function is a wrapper around page_remove().

	// LAB 4: Your code here.
	panic("sys_page_unmap not implemented");
f010d6d0:	83 ec 04             	sub    $0x4,%esp
f010d6d3:	68 88 68 12 f0       	push   $0xf0126888
f010d6d8:	68 ed 00 00 00       	push   $0xed
f010d6dd:	68 53 68 12 f0       	push   $0xf0126853
f010d6e2:	e8 33 2c ff ff       	call   f010031a <_panic>

f010d6e7 <sys_calculate_required_frames>:
	return 0;
}

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010d6e7:	55                   	push   %ebp
f010d6e8:	89 e5                	mov    %esp,%ebp
f010d6ea:	83 ec 08             	sub    $0x8,%esp
	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010d6ed:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d6f2:	8b 40 64             	mov    0x64(%eax),%eax
f010d6f5:	83 ec 04             	sub    $0x4,%esp
f010d6f8:	ff 75 0c             	pushl  0xc(%ebp)
f010d6fb:	ff 75 08             	pushl  0x8(%ebp)
f010d6fe:	50                   	push   %eax
f010d6ff:	e8 4f bd ff ff       	call   f0109453 <calculate_required_frames>
f010d704:	83 c4 10             	add    $0x10,%esp
}
f010d707:	c9                   	leave  
f010d708:	c3                   	ret    

f010d709 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010d709:	55                   	push   %ebp
f010d70a:	89 e5                	mov    %esp,%ebp
f010d70c:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d70f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d712:	83 ec 0c             	sub    $0xc,%esp
f010d715:	50                   	push   %eax
f010d716:	e8 84 ae ff ff       	call   f010859f <calculate_available_frames>
f010d71b:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010d71e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010d721:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d724:	01 d0                	add    %edx,%eax
}
f010d726:	c9                   	leave  
f010d727:	c3                   	ret    

f010d728 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010d728:	55                   	push   %ebp
f010d729:	89 e5                	mov    %esp,%ebp
f010d72b:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d72e:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d731:	83 ec 0c             	sub    $0xc,%esp
f010d734:	50                   	push   %eax
f010d735:	e8 65 ae ff ff       	call   f010859f <calculate_available_frames>
f010d73a:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010d73d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010d740:	c9                   	leave  
f010d741:	c3                   	ret    

f010d742 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010d742:	55                   	push   %ebp
f010d743:	89 e5                	mov    %esp,%ebp
f010d745:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010d748:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d74b:	83 ec 0c             	sub    $0xc,%esp
f010d74e:	50                   	push   %eax
f010d74f:	e8 4b ae ff ff       	call   f010859f <calculate_available_frames>
f010d754:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010d757:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010d75a:	c9                   	leave  
f010d75b:	c3                   	ret    

f010d75c <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010d75c:	55                   	push   %ebp
f010d75d:	89 e5                	mov    %esp,%ebp
f010d75f:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010d762:	83 ec 0c             	sub    $0xc,%esp
f010d765:	ff 75 08             	pushl  0x8(%ebp)
f010d768:	e8 3f 1b 01 00       	call   f011f2ac <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010d76d:	83 c4 10             	add    $0x10,%esp
}
f010d770:	c9                   	leave  
f010d771:	c3                   	ret    

f010d772 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010d772:	55                   	push   %ebp
f010d773:	89 e5                	mov    %esp,%ebp
f010d775:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010d778:	e8 5a 1a 01 00       	call   f011f1d7 <scarce_memory>
}
f010d77d:	90                   	nop
f010d77e:	c9                   	leave  
f010d77f:	c3                   	ret    

f010d780 <sys_clearFFL>:

void sys_clearFFL()
{
f010d780:	55                   	push   %ebp
f010d781:	89 e5                	mov    %esp,%ebp
f010d783:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
f010d786:	83 ec 0c             	sub    $0xc,%esp
f010d789:	68 40 25 55 f0       	push   $0xf0552540
f010d78e:	e8 ed 0f 00 00       	call   f010e780 <acquire_spinlock>
f010d793:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010d796:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f010d79b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010d79e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010d7a5:	eb 12                	jmp    f010d7b9 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010d7a7:	83 ec 0c             	sub    $0xc,%esp
f010d7aa:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010d7ad:	50                   	push   %eax
f010d7ae:	e8 1e a7 ff ff       	call   f0107ed1 <allocate_frame>
f010d7b3:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_spinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010d7b6:	ff 45 f4             	incl   -0xc(%ebp)
f010d7b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d7bc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010d7bf:	7c e6                	jl     f010d7a7 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f010d7c1:	83 ec 0c             	sub    $0xc,%esp
f010d7c4:	68 40 25 55 f0       	push   $0xf0552540
f010d7c9:	e8 39 10 00 00       	call   f010e807 <release_spinlock>
f010d7ce:	83 c4 10             	add    $0x10,%esp
}
f010d7d1:	90                   	nop
f010d7d2:	c9                   	leave  
f010d7d3:	c3                   	ret    

f010d7d4 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010d7d4:	55                   	push   %ebp
f010d7d5:	89 e5                	mov    %esp,%ebp
f010d7d7:	83 ec 08             	sub    $0x8,%esp
	return pf_calculate_allocated_pages(cur_env);
f010d7da:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d7df:	83 ec 0c             	sub    $0xc,%esp
f010d7e2:	50                   	push   %eax
f010d7e3:	e8 88 6c ff ff       	call   f0104470 <pf_calculate_allocated_pages>
f010d7e8:	83 c4 10             	add    $0x10,%esp
}
f010d7eb:	c9                   	leave  
f010d7ec:	c3                   	ret    

f010d7ed <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010d7ed:	55                   	push   %ebp
f010d7ee:	89 e5                	mov    %esp,%ebp
f010d7f0:	83 ec 08             	sub    $0x8,%esp
	if(isBufferingEnabled())
f010d7f3:	e8 3a 0c 00 00       	call   f010e432 <isBufferingEnabled>
f010d7f8:	84 c0                	test   %al,%al
f010d7fa:	74 19                	je     f010d815 <sys_free_user_mem+0x28>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010d7fc:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d801:	83 ec 04             	sub    $0x4,%esp
f010d804:	ff 75 0c             	pushl  0xc(%ebp)
f010d807:	ff 75 08             	pushl  0x8(%ebp)
f010d80a:	50                   	push   %eax
f010d80b:	e8 8e bc ff ff       	call   f010949e <__free_user_mem_with_buffering>
f010d810:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010d813:	eb 18                	jmp    f010d82d <sys_free_user_mem+0x40>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010d815:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d81a:	83 ec 04             	sub    $0x4,%esp
f010d81d:	ff 75 0c             	pushl  0xc(%ebp)
f010d820:	ff 75 08             	pushl  0x8(%ebp)
f010d823:	50                   	push   %eax
f010d824:	e8 67 bc ff ff       	call   f0109490 <free_user_mem>
f010d829:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010d82c:	90                   	nop
}
f010d82d:	c9                   	leave  
f010d82e:	c3                   	ret    

f010d82f <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010d82f:	55                   	push   %ebp
f010d830:	89 e5                	mov    %esp,%ebp
f010d832:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation

	allocate_user_mem(cur_env, virtual_address, size);
f010d835:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d83a:	83 ec 04             	sub    $0x4,%esp
f010d83d:	ff 75 0c             	pushl  0xc(%ebp)
f010d840:	ff 75 08             	pushl  0x8(%ebp)
f010d843:	50                   	push   %eax
f010d844:	e8 39 bc ff ff       	call   f0109482 <allocate_user_mem>
f010d849:	83 c4 10             	add    $0x10,%esp
	return;
f010d84c:	90                   	nop
}
f010d84d:	c9                   	leave  
f010d84e:	c3                   	ret    

f010d84f <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010d84f:	55                   	push   %ebp
f010d850:	89 e5                	mov    %esp,%ebp
f010d852:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #03] [2] SYSTEM CALLS - Params Validation

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010d855:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d85a:	8b 40 64             	mov    0x64(%eax),%eax
f010d85d:	ff 75 10             	pushl  0x10(%ebp)
f010d860:	ff 75 0c             	pushl  0xc(%ebp)
f010d863:	ff 75 08             	pushl  0x8(%ebp)
f010d866:	50                   	push   %eax
f010d867:	e8 b3 bb ff ff       	call   f010941f <allocate_chunk>
f010d86c:	83 c4 10             	add    $0x10,%esp
	return;
f010d86f:	90                   	nop
}
f010d870:	c9                   	leave  
f010d871:	c3                   	ret    

f010d872 <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010d872:	55                   	push   %ebp
f010d873:	89 e5                	mov    %esp,%ebp
f010d875:	83 ec 08             	sub    $0x8,%esp
	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010d878:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d87d:	ff 75 10             	pushl  0x10(%ebp)
f010d880:	ff 75 0c             	pushl  0xc(%ebp)
f010d883:	ff 75 08             	pushl  0x8(%ebp)
f010d886:	50                   	push   %eax
f010d887:	e8 2f bc ff ff       	call   f01094bb <move_user_mem>
f010d88c:	83 c4 10             	add    $0x10,%esp
	return;
f010d88f:	90                   	nop
}
f010d890:	c9                   	leave  
f010d891:	c3                   	ret    

f010d892 <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010d892:	55                   	push   %ebp
f010d893:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010d895:	a1 04 4f 55 f0       	mov    0xf0554f04,%eax
}
f010d89a:	5d                   	pop    %ebp
f010d89b:	c3                   	ret    

f010d89c <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010d89c:	55                   	push   %ebp
f010d89d:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010d89f:	8b 45 08             	mov    0x8(%ebp),%eax
f010d8a2:	a3 04 4f 55 f0       	mov    %eax,0xf0554f04
}
f010d8a7:	90                   	nop
f010d8a8:	5d                   	pop    %ebp
f010d8a9:	c3                   	ret    

f010d8aa <sys_createSharedObject>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_createSharedObject(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010d8aa:	55                   	push   %ebp
f010d8ab:	89 e5                	mov    %esp,%ebp
f010d8ad:	83 ec 18             	sub    $0x18,%esp
f010d8b0:	8b 45 10             	mov    0x10(%ebp),%eax
f010d8b3:	88 45 f4             	mov    %al,-0xc(%ebp)
	return createSharedObject(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010d8b6:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
f010d8ba:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d8bf:	8b 40 10             	mov    0x10(%eax),%eax
f010d8c2:	83 ec 0c             	sub    $0xc,%esp
f010d8c5:	ff 75 14             	pushl  0x14(%ebp)
f010d8c8:	52                   	push   %edx
f010d8c9:	ff 75 0c             	pushl  0xc(%ebp)
f010d8cc:	ff 75 08             	pushl  0x8(%ebp)
f010d8cf:	50                   	push   %eax
f010d8d0:	e8 35 ae ff ff       	call   f010870a <createSharedObject>
f010d8d5:	83 c4 20             	add    $0x20,%esp
}
f010d8d8:	c9                   	leave  
f010d8d9:	c3                   	ret    

f010d8da <sys_getSizeOfSharedObject>:

int sys_getSizeOfSharedObject(int32 ownerID, char* shareName)
{
f010d8da:	55                   	push   %ebp
f010d8db:	89 e5                	mov    %esp,%ebp
f010d8dd:	83 ec 08             	sub    $0x8,%esp
	return getSizeOfSharedObject(ownerID, shareName);
f010d8e0:	83 ec 08             	sub    $0x8,%esp
f010d8e3:	ff 75 0c             	pushl  0xc(%ebp)
f010d8e6:	ff 75 08             	pushl  0x8(%ebp)
f010d8e9:	e8 3c ae ff ff       	call   f010872a <getSizeOfSharedObject>
f010d8ee:	83 c4 10             	add    $0x10,%esp
}
f010d8f1:	c9                   	leave  
f010d8f2:	c3                   	ret    

f010d8f3 <sys_getSharedObject>:

int sys_getSharedObject(int32 ownerID, char* shareName, void* virtual_address)
{
f010d8f3:	55                   	push   %ebp
f010d8f4:	89 e5                	mov    %esp,%ebp
f010d8f6:	83 ec 08             	sub    $0x8,%esp
	return getSharedObject(ownerID, shareName, virtual_address);
f010d8f9:	83 ec 04             	sub    $0x4,%esp
f010d8fc:	ff 75 10             	pushl  0x10(%ebp)
f010d8ff:	ff 75 0c             	pushl  0xc(%ebp)
f010d902:	ff 75 08             	pushl  0x8(%ebp)
f010d905:	e8 4f ae ff ff       	call   f0108759 <getSharedObject>
f010d90a:	83 c4 10             	add    $0x10,%esp
}
f010d90d:	c9                   	leave  
f010d90e:	c3                   	ret    

f010d90f <sys_freeSharedObject>:

int sys_freeSharedObject(int32 sharedObjectID, void *startVA)
{
f010d90f:	55                   	push   %ebp
f010d910:	89 e5                	mov    %esp,%ebp
f010d912:	83 ec 08             	sub    $0x8,%esp
	return freeSharedObject(sharedObjectID, startVA);
f010d915:	83 ec 08             	sub    $0x8,%esp
f010d918:	ff 75 0c             	pushl  0xc(%ebp)
f010d91b:	ff 75 08             	pushl  0x8(%ebp)
f010d91e:	e8 53 ae ff ff       	call   f0108776 <freeSharedObject>
f010d923:	83 c4 10             	add    $0x10,%esp
}
f010d926:	c9                   	leave  
f010d927:	c3                   	ret    

f010d928 <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010d928:	55                   	push   %ebp
f010d929:	89 e5                	mov    %esp,%ebp
	return cur_env->env_id;
f010d92b:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d930:	8b 40 10             	mov    0x10(%eax),%eax
}
f010d933:	5d                   	pop    %ebp
f010d934:	c3                   	ret    

f010d935 <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010d935:	55                   	push   %ebp
f010d936:	89 e5                	mov    %esp,%ebp
	//return cur_env->env_id;
	return (cur_env - envs) ;
f010d938:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d93d:	89 c2                	mov    %eax,%edx
f010d93f:	a1 10 1a 55 f0       	mov    0xf0551a10,%eax
f010d944:	29 c2                	sub    %eax,%edx
f010d946:	89 d0                	mov    %edx,%eax
f010d948:	c1 f8 02             	sar    $0x2,%eax
f010d94b:	89 c2                	mov    %eax,%edx
f010d94d:	89 d0                	mov    %edx,%eax
f010d94f:	c1 e0 02             	shl    $0x2,%eax
f010d952:	01 d0                	add    %edx,%eax
f010d954:	c1 e0 02             	shl    $0x2,%eax
f010d957:	01 d0                	add    %edx,%eax
f010d959:	c1 e0 02             	shl    $0x2,%eax
f010d95c:	01 d0                	add    %edx,%eax
f010d95e:	c1 e0 02             	shl    $0x2,%eax
f010d961:	01 d0                	add    %edx,%eax
f010d963:	c1 e0 08             	shl    $0x8,%eax
f010d966:	29 d0                	sub    %edx,%eax
f010d968:	c1 e0 08             	shl    $0x8,%eax
f010d96b:	29 d0                	sub    %edx,%eax
f010d96d:	c1 e0 03             	shl    $0x3,%eax
f010d970:	01 d0                	add    %edx,%eax
f010d972:	c1 e0 03             	shl    $0x3,%eax
f010d975:	01 d0                	add    %edx,%eax
f010d977:	01 c0                	add    %eax,%eax
f010d979:	01 d0                	add    %edx,%eax
}
f010d97b:	5d                   	pop    %ebp
f010d97c:	c3                   	ret    

f010d97d <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010d97d:	55                   	push   %ebp
f010d97e:	89 e5                	mov    %esp,%ebp
	return cur_env->env_parent_id;
f010d980:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d985:	8b 40 14             	mov    0x14(%eax),%eax
}
f010d988:	5d                   	pop    %ebp
f010d989:	c3                   	ret    

f010d98a <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010d98a:	55                   	push   %ebp
f010d98b:	89 e5                	mov    %esp,%ebp
f010d98d:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Env *e;
	if (envid == 0)
f010d990:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010d994:	75 0a                	jne    f010d9a0 <sys_destroy_env+0x16>
	{
		e = cur_env ;
f010d996:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d99b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010d99e:	eb 22                	jmp    f010d9c2 <sys_destroy_env+0x38>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010d9a0:	83 ec 04             	sub    $0x4,%esp
f010d9a3:	6a 00                	push   $0x0
f010d9a5:	8d 45 f0             	lea    -0x10(%ebp),%eax
f010d9a8:	50                   	push   %eax
f010d9a9:	ff 75 08             	pushl  0x8(%ebp)
f010d9ac:	e8 10 cb ff ff       	call   f010a4c1 <envid2env>
f010d9b1:	83 c4 10             	add    $0x10,%esp
f010d9b4:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010d9b7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010d9bb:	79 05                	jns    f010d9c2 <sys_destroy_env+0x38>
	{
		return r;
f010d9bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d9c0:	eb 5e                	jmp    f010da20 <sys_destroy_env+0x96>
	}

	if (e == cur_env)
f010d9c2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010d9c5:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9ca:	39 c2                	cmp    %eax,%edx
f010d9cc:	75 1b                	jne    f010d9e9 <sys_destroy_env+0x5f>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010d9ce:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9d3:	8b 40 10             	mov    0x10(%eax),%eax
f010d9d6:	83 ec 08             	sub    $0x8,%esp
f010d9d9:	50                   	push   %eax
f010d9da:	68 a7 68 12 f0       	push   $0xf01268a7
f010d9df:	e8 88 35 ff ff       	call   f0100f6c <cprintf>
f010d9e4:	83 c4 10             	add    $0x10,%esp
f010d9e7:	eb 20                	jmp    f010da09 <sys_destroy_env+0x7f>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010d9e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010d9ec:	8b 50 10             	mov    0x10(%eax),%edx
f010d9ef:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010d9f4:	8b 40 10             	mov    0x10(%eax),%eax
f010d9f7:	83 ec 04             	sub    $0x4,%esp
f010d9fa:	52                   	push   %edx
f010d9fb:	50                   	push   %eax
f010d9fc:	68 c2 68 12 f0       	push   $0xf01268c2
f010da01:	e8 66 35 ff ff       	call   f0100f6c <cprintf>
f010da06:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010da09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da0c:	8b 40 10             	mov    0x10(%eax),%eax
f010da0f:	83 ec 0c             	sub    $0xc,%esp
f010da12:	50                   	push   %eax
f010da13:	e8 4c 7d ff ff       	call   f0105764 <sched_kill_env>
f010da18:	83 c4 10             	add    $0x10,%esp

	return 0;
f010da1b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010da20:	c9                   	leave  
f010da21:	c3                   	ret    

f010da22 <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010da22:	55                   	push   %ebp
f010da23:	89 e5                	mov    %esp,%ebp
f010da25:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010da28:	e8 02 ca ff ff       	call   f010a42f <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010da2d:	90                   	nop
f010da2e:	c9                   	leave  
f010da2f:	c3                   	ret    

f010da30 <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010da30:	55                   	push   %ebp
f010da31:	89 e5                	mov    %esp,%ebp
f010da33:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010da36:	ff 75 14             	pushl  0x14(%ebp)
f010da39:	ff 75 10             	pushl  0x10(%ebp)
f010da3c:	ff 75 0c             	pushl  0xc(%ebp)
f010da3f:	ff 75 08             	pushl  0x8(%ebp)
f010da42:	e8 2a bd ff ff       	call   f0109771 <env_create>
f010da47:	83 c4 10             	add    $0x10,%esp
f010da4a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010da4d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010da51:	75 07                	jne    f010da5a <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010da53:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010da58:	eb 14                	jmp    f010da6e <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010da5a:	83 ec 0c             	sub    $0xc,%esp
f010da5d:	ff 75 f4             	pushl  -0xc(%ebp)
f010da60:	e8 41 79 ff ff       	call   f01053a6 <sched_new_env>
f010da65:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010da68:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010da6b:	8b 40 10             	mov    0x10(%eax),%eax
}
f010da6e:	c9                   	leave  
f010da6f:	c3                   	ret    

f010da70 <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010da70:	55                   	push   %ebp
f010da71:	89 e5                	mov    %esp,%ebp
f010da73:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010da76:	8b 45 08             	mov    0x8(%ebp),%eax
f010da79:	83 ec 0c             	sub    $0xc,%esp
f010da7c:	50                   	push   %eax
f010da7d:	e8 7a 79 ff ff       	call   f01053fc <sched_run_env>
f010da82:	83 c4 10             	add    $0x10,%esp
}
f010da85:	90                   	nop
f010da86:	c9                   	leave  
f010da87:	c3                   	ret    

f010da88 <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010da88:	55                   	push   %ebp
f010da89:	89 e5                	mov    %esp,%ebp
f010da8b:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010da8e:	0f 31                	rdtsc  
f010da90:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010da93:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010da96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010da99:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010da9c:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010da9f:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010daa2:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010daa5:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010daa8:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010daab:	89 01                	mov    %eax,(%ecx)
f010daad:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010dab0:	8b 45 08             	mov    0x8(%ebp),%eax
f010dab3:	c9                   	leave  
f010dab4:	c2 04 00             	ret    $0x4

f010dab7 <sys_rcr2>:

uint32 sys_rcr2()
{
f010dab7:	55                   	push   %ebp
f010dab8:	89 e5                	mov    %esp,%ebp
f010daba:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010dabd:	0f 20 d0             	mov    %cr2,%eax
f010dac0:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010dac3:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010dac6:	90                   	nop
}
f010dac7:	c9                   	leave  
f010dac8:	c3                   	ret    

f010dac9 <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010dac9:	55                   	push   %ebp
f010daca:	89 e5                	mov    %esp,%ebp
f010dacc:	83 ec 04             	sub    $0x4,%esp
f010dacf:	8b 45 08             	mov    0x8(%ebp),%eax
f010dad2:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010dad5:	8a 45 fc             	mov    -0x4(%ebp),%al
f010dad8:	a2 80 22 55 f0       	mov    %al,0xf0552280
}
f010dadd:	90                   	nop
f010dade:	c9                   	leave  
f010dadf:	c3                   	ret    

f010dae0 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010dae0:	55                   	push   %ebp
f010dae1:	89 e5                	mov    %esp,%ebp
f010dae3:	56                   	push   %esi
f010dae4:	53                   	push   %ebx
f010dae5:	83 ec 10             	sub    $0x10,%esp
	cur_env = get_cpu_proc();
f010dae8:	e8 84 c9 ff ff       	call   f010a471 <get_cpu_proc>
f010daed:	a3 c4 36 57 f0       	mov    %eax,0xf05736c4
	assert(cur_env != NULL);
f010daf2:	a1 c4 36 57 f0       	mov    0xf05736c4,%eax
f010daf7:	85 c0                	test   %eax,%eax
f010daf9:	75 19                	jne    f010db14 <syscall+0x34>
f010dafb:	68 da 68 12 f0       	push   $0xf01268da
f010db00:	68 ea 68 12 f0       	push   $0xf01268ea
f010db05:	68 f5 01 00 00       	push   $0x1f5
f010db0a:	68 53 68 12 f0       	push   $0xf0126853
f010db0f:	e8 06 28 ff ff       	call   f010031a <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010db14:	83 7d 08 2b          	cmpl   $0x2b,0x8(%ebp)
f010db18:	0f 87 bc 03 00 00    	ja     f010deda <syscall+0x3fa>
f010db1e:	8b 45 08             	mov    0x8(%ebp),%eax
f010db21:	c1 e0 02             	shl    $0x2,%eax
f010db24:	05 00 69 12 f0       	add    $0xf0126900,%eax
f010db29:	8b 00                	mov    (%eax),%eax
f010db2b:	ff e0                	jmp    *%eax
	{
	//TODO: [PROJECT'24.MS1 - #02] [2] SYSTEM CALLS - Add suitable code here

	//======================================================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3);
f010db2d:	8b 45 14             	mov    0x14(%ebp),%eax
f010db30:	0f b6 d0             	movzbl %al,%edx
f010db33:	8b 45 0c             	mov    0xc(%ebp),%eax
f010db36:	83 ec 04             	sub    $0x4,%esp
f010db39:	52                   	push   %edx
f010db3a:	ff 75 10             	pushl  0x10(%ebp)
f010db3d:	50                   	push   %eax
f010db3e:	e8 93 f9 ff ff       	call   f010d4d6 <sys_cputs>
f010db43:	83 c4 10             	add    $0x10,%esp
		return 0;
f010db46:	b8 00 00 00 00       	mov    $0x0,%eax
f010db4b:	e9 8f 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010db50:	e8 fd f9 ff ff       	call   f010d552 <sys_cgetc>
f010db55:	e9 85 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010db5a:	e8 32 fa ff ff       	call   f010d591 <sys_lock_cons>
		return 0;
f010db5f:	b8 00 00 00 00       	mov    $0x0,%eax
f010db64:	e9 76 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010db69:	e8 31 fa ff ff       	call   f010d59f <sys_unlock_cons>
		return 0;
f010db6e:	b8 00 00 00 00       	mov    $0x0,%eax
f010db73:	e9 67 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010db78:	83 ec 08             	sub    $0x8,%esp
f010db7b:	ff 75 10             	pushl  0x10(%ebp)
f010db7e:	ff 75 0c             	pushl  0xc(%ebp)
f010db81:	e8 61 fb ff ff       	call   f010d6e7 <sys_calculate_required_frames>
f010db86:	83 c4 10             	add    $0x10,%esp
f010db89:	e9 51 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010db8e:	e8 76 fb ff ff       	call   f010d709 <sys_calculate_free_frames>
f010db93:	e9 47 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010db98:	e8 8b fb ff ff       	call   f010d728 <sys_calculate_modified_frames>
f010db9d:	e9 3d 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010dba2:	e8 9b fb ff ff       	call   f010d742 <sys_calculate_notmod_frames>
f010dba7:	e9 33 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010dbac:	e8 23 fc ff ff       	call   f010d7d4 <sys_pf_calculate_allocated_pages>
f010dbb1:	e9 29 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010dbb6:	83 ec 0c             	sub    $0xc,%esp
f010dbb9:	ff 75 0c             	pushl  0xc(%ebp)
f010dbbc:	e8 9b fb ff ff       	call   f010d75c <sys_calculate_pages_tobe_removed_ready_exit>
f010dbc1:	83 c4 10             	add    $0x10,%esp
f010dbc4:	e9 16 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010dbc9:	e8 a4 fb ff ff       	call   f010d772 <sys_scarce_memory>
		return 0;
f010dbce:	b8 00 00 00 00       	mov    $0x0,%eax
f010dbd3:	e9 07 03 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010dbd8:	83 ec 04             	sub    $0x4,%esp
f010dbdb:	ff 75 14             	pushl  0x14(%ebp)
f010dbde:	ff 75 10             	pushl  0x10(%ebp)
f010dbe1:	ff 75 0c             	pushl  0xc(%ebp)
f010dbe4:	e8 66 fc ff ff       	call   f010d84f <sys_allocate_chunk>
f010dbe9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dbec:	b8 00 00 00 00       	mov    $0x0,%eax
f010dbf1:	e9 e9 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

		//======================
	case SYS_allocate_page:
		__sys_allocate_page((void*)a1, a2);
f010dbf6:	8b 55 10             	mov    0x10(%ebp),%edx
f010dbf9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dbfc:	83 ec 08             	sub    $0x8,%esp
f010dbff:	52                   	push   %edx
f010dc00:	50                   	push   %eax
f010dc01:	e8 a7 f9 ff ff       	call   f010d5ad <__sys_allocate_page>
f010dc06:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc09:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc0e:	e9 cc 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010dc13:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010dc16:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010dc19:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dc1c:	8b 55 10             	mov    0x10(%ebp),%edx
f010dc1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc22:	83 ec 0c             	sub    $0xc,%esp
f010dc25:	56                   	push   %esi
f010dc26:	53                   	push   %ebx
f010dc27:	51                   	push   %ecx
f010dc28:	52                   	push   %edx
f010dc29:	50                   	push   %eax
f010dc2a:	e8 7e fa ff ff       	call   f010d6ad <__sys_map_frame>
f010dc2f:	83 c4 20             	add    $0x20,%esp
		return 0;
f010dc32:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc37:	e9 a3 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_unmap_frame:
		__sys_unmap_frame(a1, (void*)a2);
f010dc3c:	8b 55 10             	mov    0x10(%ebp),%edx
f010dc3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc42:	83 ec 08             	sub    $0x8,%esp
f010dc45:	52                   	push   %edx
f010dc46:	50                   	push   %eax
f010dc47:	e8 7e fa ff ff       	call   f010d6ca <__sys_unmap_frame>
f010dc4c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc4f:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc54:	e9 86 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_cputc:
		sys_cputc((const char)a1);
f010dc59:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc5c:	0f be c0             	movsbl %al,%eax
f010dc5f:	83 ec 0c             	sub    $0xc,%esp
f010dc62:	50                   	push   %eax
f010dc63:	e8 c6 f8 ff ff       	call   f010d52e <sys_cputc>
f010dc68:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc6b:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc70:	e9 6a 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010dc75:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc78:	0f be c0             	movsbl %al,%eax
f010dc7b:	83 ec 0c             	sub    $0xc,%esp
f010dc7e:	50                   	push   %eax
f010dc7f:	e8 fc fa ff ff       	call   f010d780 <sys_clearFFL>
f010dc84:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dc87:	b8 00 00 00 00       	mov    $0x0,%eax
f010dc8c:	e9 4e 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_create_shared_object:
		return sys_createSharedObject((char*)a1, a2, a3, (void*)a4);
f010dc91:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010dc94:	8b 45 14             	mov    0x14(%ebp),%eax
f010dc97:	0f b6 d0             	movzbl %al,%edx
f010dc9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dc9d:	51                   	push   %ecx
f010dc9e:	52                   	push   %edx
f010dc9f:	ff 75 10             	pushl  0x10(%ebp)
f010dca2:	50                   	push   %eax
f010dca3:	e8 02 fc ff ff       	call   f010d8aa <sys_createSharedObject>
f010dca8:	83 c4 10             	add    $0x10,%esp
f010dcab:	e9 2f 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_get_shared_object:
		return sys_getSharedObject((int32)a1, (char*)a2, (void*)a3);
f010dcb0:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010dcb3:	8b 55 10             	mov    0x10(%ebp),%edx
f010dcb6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcb9:	83 ec 04             	sub    $0x4,%esp
f010dcbc:	51                   	push   %ecx
f010dcbd:	52                   	push   %edx
f010dcbe:	50                   	push   %eax
f010dcbf:	e8 2f fc ff ff       	call   f010d8f3 <sys_getSharedObject>
f010dcc4:	83 c4 10             	add    $0x10,%esp
f010dcc7:	e9 13 02 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_free_shared_object:
		return sys_freeSharedObject((int32)a1, (void *)a2);
f010dccc:	8b 55 10             	mov    0x10(%ebp),%edx
f010dccf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcd2:	83 ec 08             	sub    $0x8,%esp
f010dcd5:	52                   	push   %edx
f010dcd6:	50                   	push   %eax
f010dcd7:	e8 33 fc ff ff       	call   f010d90f <sys_freeSharedObject>
f010dcdc:	83 c4 10             	add    $0x10,%esp
f010dcdf:	e9 fb 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_get_size_of_shared_object:
		return sys_getSizeOfSharedObject((int32)a1, (char*)a2);
f010dce4:	8b 55 10             	mov    0x10(%ebp),%edx
f010dce7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcea:	83 ec 08             	sub    $0x8,%esp
f010dced:	52                   	push   %edx
f010dcee:	50                   	push   %eax
f010dcef:	e8 e6 fb ff ff       	call   f010d8da <sys_getSizeOfSharedObject>
f010dcf4:	83 c4 10             	add    $0x10,%esp
f010dcf7:	e9 e3 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010dcfc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dcff:	ff 75 18             	pushl  0x18(%ebp)
f010dd02:	ff 75 14             	pushl  0x14(%ebp)
f010dd05:	ff 75 10             	pushl  0x10(%ebp)
f010dd08:	50                   	push   %eax
f010dd09:	e8 22 fd ff ff       	call   f010da30 <sys_create_env>
f010dd0e:	83 c4 10             	add    $0x10,%esp
f010dd11:	e9 c9 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010dd16:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd19:	83 ec 0c             	sub    $0xc,%esp
f010dd1c:	50                   	push   %eax
f010dd1d:	e8 4e fd ff ff       	call   f010da70 <sys_run_env>
f010dd22:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dd25:	b8 00 00 00 00       	mov    $0x0,%eax
f010dd2a:	e9 b0 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010dd2f:	e8 01 fc ff ff       	call   f010d935 <sys_getenvindex>
f010dd34:	e9 a6 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010dd39:	e8 ea fb ff ff       	call   f010d928 <sys_getenvid>
f010dd3e:	e9 9c 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010dd43:	e8 35 fc ff ff       	call   f010d97d <sys_getparentenvid>
f010dd48:	e9 92 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010dd4d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd50:	83 ec 0c             	sub    $0xc,%esp
f010dd53:	50                   	push   %eax
f010dd54:	e8 31 fc ff ff       	call   f010d98a <sys_destroy_env>
f010dd59:	83 c4 10             	add    $0x10,%esp
f010dd5c:	e9 7e 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010dd61:	e8 bc fc ff ff       	call   f010da22 <sys_exit_env>
		return 0;
f010dd66:	b8 00 00 00 00       	mov    $0x0,%eax
f010dd6b:	e9 6f 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010dd70:	8d 45 e8             	lea    -0x18(%ebp),%eax
f010dd73:	83 ec 0c             	sub    $0xc,%esp
f010dd76:	50                   	push   %eax
f010dd77:	e8 0c fd ff ff       	call   f010da88 <sys_get_virtual_time>
f010dd7c:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010dd7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dd82:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010dd85:	8b 45 10             	mov    0x10(%ebp),%eax
f010dd88:	89 45 f0             	mov    %eax,-0x10(%ebp)
		*ptrlow = res.low;
f010dd8b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010dd8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010dd91:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010dd93:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010dd96:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dd99:	89 10                	mov    %edx,(%eax)
		return 0;
f010dd9b:	b8 00 00 00 00       	mov    $0x0,%eax
f010dda0:	e9 3a 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010dda5:	83 ec 04             	sub    $0x4,%esp
f010dda8:	ff 75 14             	pushl  0x14(%ebp)
f010ddab:	ff 75 10             	pushl  0x10(%ebp)
f010ddae:	ff 75 0c             	pushl  0xc(%ebp)
f010ddb1:	e8 bc fa ff ff       	call   f010d872 <sys_move_user_mem>
f010ddb6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ddb9:	b8 00 00 00 00       	mov    $0x0,%eax
f010ddbe:	e9 1c 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010ddc3:	e8 ef fc ff ff       	call   f010dab7 <sys_rcr2>
f010ddc8:	e9 12 01 00 00       	jmp    f010dedf <syscall+0x3ff>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010ddcd:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ddd0:	0f b6 c0             	movzbl %al,%eax
f010ddd3:	83 ec 0c             	sub    $0xc,%esp
f010ddd6:	50                   	push   %eax
f010ddd7:	e8 ed fc ff ff       	call   f010dac9 <sys_bypassPageFault>
f010dddc:	83 c4 10             	add    $0x10,%esp
		return 0;
f010dddf:	b8 00 00 00 00       	mov    $0x0,%eax
f010dde4:	e9 f6 00 00 00       	jmp    f010dedf <syscall+0x3ff>

	case SYS_rsttst:
		rsttst();
f010dde9:	e8 f4 0c 01 00       	call   f011eae2 <rsttst>
		return 0;
f010ddee:	b8 00 00 00 00       	mov    $0x0,%eax
f010ddf3:	e9 e7 00 00 00       	jmp    f010dedf <syscall+0x3ff>
	case SYS_inctst:
		inctst();
f010ddf8:	e8 2d 0d 01 00       	call   f011eb2a <inctst>
		return 0;
f010ddfd:	b8 00 00 00 00       	mov    $0x0,%eax
f010de02:	e9 d8 00 00 00       	jmp    f010dedf <syscall+0x3ff>
	case SYS_chktst:
		chktst(a1);
f010de07:	83 ec 0c             	sub    $0xc,%esp
f010de0a:	ff 75 0c             	pushl  0xc(%ebp)
f010de0d:	e8 5a 0e 01 00       	call   f011ec6c <chktst>
f010de12:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de15:	b8 00 00 00 00       	mov    $0x0,%eax
f010de1a:	e9 c0 00 00 00       	jmp    f010dedf <syscall+0x3ff>
	case SYS_gettst:
		return gettst();
f010de1f:	e8 3a 0d 01 00       	call   f011eb5e <gettst>
f010de24:	e9 b6 00 00 00       	jmp    f010dedf <syscall+0x3ff>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010de29:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010de2c:	8b 45 18             	mov    0x18(%ebp),%eax
f010de2f:	0f be c0             	movsbl %al,%eax
f010de32:	83 ec 0c             	sub    $0xc,%esp
f010de35:	52                   	push   %edx
f010de36:	50                   	push   %eax
f010de37:	ff 75 14             	pushl  0x14(%ebp)
f010de3a:	ff 75 10             	pushl  0x10(%ebp)
f010de3d:	ff 75 0c             	pushl  0xc(%ebp)
f010de40:	e8 23 0d 01 00       	call   f011eb68 <tst>
f010de45:	83 c4 20             	add    $0x20,%esp
		return 0;
f010de48:	b8 00 00 00 00       	mov    $0x0,%eax
f010de4d:	e9 8d 00 00 00       	jmp    f010dedf <syscall+0x3ff>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010de52:	e8 3b fa ff ff       	call   f010d892 <sys_get_heap_strategy>
f010de57:	e9 83 00 00 00       	jmp    f010dedf <syscall+0x3ff>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010de5c:	83 ec 0c             	sub    $0xc,%esp
f010de5f:	ff 75 0c             	pushl  0xc(%ebp)
f010de62:	e8 35 fa ff ff       	call   f010d89c <sys_set_uheap_strategy>
f010de67:	83 c4 10             	add    $0x10,%esp
		return 0;
f010de6a:	b8 00 00 00 00       	mov    $0x0,%eax
f010de6f:	eb 6e                	jmp    f010dedf <syscall+0x3ff>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010de71:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010de74:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010de77:	8b 55 10             	mov    0x10(%ebp),%edx
f010de7a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de7d:	53                   	push   %ebx
f010de7e:	51                   	push   %ecx
f010de7f:	52                   	push   %edx
f010de80:	50                   	push   %eax
f010de81:	e8 73 31 00 00       	call   f0110ff9 <sys_check_LRU_lists>
f010de86:	83 c4 10             	add    $0x10,%esp
f010de89:	eb 54                	jmp    f010dedf <syscall+0x3ff>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010de8b:	8b 55 10             	mov    0x10(%ebp),%edx
f010de8e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010de91:	83 ec 08             	sub    $0x8,%esp
f010de94:	52                   	push   %edx
f010de95:	50                   	push   %eax
f010de96:	e8 20 33 00 00       	call   f01111bb <sys_check_LRU_lists_free>
f010de9b:	83 c4 10             	add    $0x10,%esp
f010de9e:	eb 3f                	jmp    f010dedf <syscall+0x3ff>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010dea0:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010dea3:	8b 55 10             	mov    0x10(%ebp),%edx
f010dea6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dea9:	51                   	push   %ecx
f010deaa:	ff 75 14             	pushl  0x14(%ebp)
f010dead:	52                   	push   %edx
f010deae:	50                   	push   %eax
f010deaf:	e8 94 34 00 00       	call   f0111348 <sys_check_WS_list>
f010deb4:	83 c4 10             	add    $0x10,%esp
f010deb7:	eb 26                	jmp    f010dedf <syscall+0x3ff>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010deb9:	8b 55 10             	mov    0x10(%ebp),%edx
f010debc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010debf:	83 ec 08             	sub    $0x8,%esp
f010dec2:	52                   	push   %edx
f010dec3:	50                   	push   %eax
f010dec4:	e8 a4 0f 01 00       	call   f011ee6d <sys_utilities>
f010dec9:	83 c4 10             	add    $0x10,%esp
		return 0;
f010decc:	b8 00 00 00 00       	mov    $0x0,%eax
f010ded1:	eb 0c                	jmp    f010dedf <syscall+0x3ff>

	case NSYSCALLS:
		return 	-E_INVAL;
f010ded3:	b8 03 00 00 00       	mov    $0x3,%eax
f010ded8:	eb 05                	jmp    f010dedf <syscall+0x3ff>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010deda:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010dedf:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010dee2:	5b                   	pop    %ebx
f010dee3:	5e                   	pop    %esi
f010dee4:	5d                   	pop    %ebp
f010dee5:	c3                   	ret    

f010dee6 <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010dee6:	55                   	push   %ebp
f010dee7:	89 e5                	mov    %esp,%ebp
f010dee9:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010deec:	8b 45 0c             	mov    0xc(%ebp),%eax
f010deef:	8b 00                	mov    (%eax),%eax
f010def1:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010def4:	8b 45 10             	mov    0x10(%ebp),%eax
f010def7:	8b 00                	mov    (%eax),%eax
f010def9:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010defc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010df03:	e9 ca 00 00 00       	jmp    f010dfd2 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010df08:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010df0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010df0e:	01 d0                	add    %edx,%eax
f010df10:	89 c2                	mov    %eax,%edx
f010df12:	c1 ea 1f             	shr    $0x1f,%edx
f010df15:	01 d0                	add    %edx,%eax
f010df17:	d1 f8                	sar    %eax
f010df19:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010df1c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010df1f:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010df22:	eb 03                	jmp    f010df27 <stab_binsearch+0x41>
			m--;
f010df24:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010df27:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010df2a:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010df2d:	7c 1e                	jl     f010df4d <stab_binsearch+0x67>
f010df2f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010df32:	89 d0                	mov    %edx,%eax
f010df34:	01 c0                	add    %eax,%eax
f010df36:	01 d0                	add    %edx,%eax
f010df38:	c1 e0 02             	shl    $0x2,%eax
f010df3b:	89 c2                	mov    %eax,%edx
f010df3d:	8b 45 08             	mov    0x8(%ebp),%eax
f010df40:	01 d0                	add    %edx,%eax
f010df42:	8a 40 04             	mov    0x4(%eax),%al
f010df45:	0f b6 c0             	movzbl %al,%eax
f010df48:	3b 45 14             	cmp    0x14(%ebp),%eax
f010df4b:	75 d7                	jne    f010df24 <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010df4d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010df50:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010df53:	7d 09                	jge    f010df5e <stab_binsearch+0x78>
			l = true_m + 1;
f010df55:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010df58:	40                   	inc    %eax
f010df59:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010df5c:	eb 74                	jmp    f010dfd2 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010df5e:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010df65:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010df68:	89 d0                	mov    %edx,%eax
f010df6a:	01 c0                	add    %eax,%eax
f010df6c:	01 d0                	add    %edx,%eax
f010df6e:	c1 e0 02             	shl    $0x2,%eax
f010df71:	89 c2                	mov    %eax,%edx
f010df73:	8b 45 08             	mov    0x8(%ebp),%eax
f010df76:	01 d0                	add    %edx,%eax
f010df78:	8b 40 08             	mov    0x8(%eax),%eax
f010df7b:	3b 45 18             	cmp    0x18(%ebp),%eax
f010df7e:	73 11                	jae    f010df91 <stab_binsearch+0xab>
			*region_left = m;
f010df80:	8b 45 0c             	mov    0xc(%ebp),%eax
f010df83:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010df86:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010df88:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010df8b:	40                   	inc    %eax
f010df8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010df8f:	eb 41                	jmp    f010dfd2 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010df91:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010df94:	89 d0                	mov    %edx,%eax
f010df96:	01 c0                	add    %eax,%eax
f010df98:	01 d0                	add    %edx,%eax
f010df9a:	c1 e0 02             	shl    $0x2,%eax
f010df9d:	89 c2                	mov    %eax,%edx
f010df9f:	8b 45 08             	mov    0x8(%ebp),%eax
f010dfa2:	01 d0                	add    %edx,%eax
f010dfa4:	8b 40 08             	mov    0x8(%eax),%eax
f010dfa7:	3b 45 18             	cmp    0x18(%ebp),%eax
f010dfaa:	76 14                	jbe    f010dfc0 <stab_binsearch+0xda>
			*region_right = m - 1;
f010dfac:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfaf:	8d 50 ff             	lea    -0x1(%eax),%edx
f010dfb2:	8b 45 10             	mov    0x10(%ebp),%eax
f010dfb5:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010dfb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfba:	48                   	dec    %eax
f010dfbb:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010dfbe:	eb 12                	jmp    f010dfd2 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010dfc0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfc3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010dfc6:	89 10                	mov    %edx,(%eax)
			l = m;
f010dfc8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010dfcb:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010dfce:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010dfd2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010dfd5:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010dfd8:	0f 8e 2a ff ff ff    	jle    f010df08 <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010dfde:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010dfe2:	75 0f                	jne    f010dff3 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010dfe4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010dfe7:	8b 00                	mov    (%eax),%eax
f010dfe9:	8d 50 ff             	lea    -0x1(%eax),%edx
f010dfec:	8b 45 10             	mov    0x10(%ebp),%eax
f010dfef:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010dff1:	eb 3d                	jmp    f010e030 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010dff3:	8b 45 10             	mov    0x10(%ebp),%eax
f010dff6:	8b 00                	mov    (%eax),%eax
f010dff8:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010dffb:	eb 03                	jmp    f010e000 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010dffd:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010e000:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e003:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010e005:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010e008:	7d 1e                	jge    f010e028 <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010e00a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e00d:	89 d0                	mov    %edx,%eax
f010e00f:	01 c0                	add    %eax,%eax
f010e011:	01 d0                	add    %edx,%eax
f010e013:	c1 e0 02             	shl    $0x2,%eax
f010e016:	89 c2                	mov    %eax,%edx
f010e018:	8b 45 08             	mov    0x8(%ebp),%eax
f010e01b:	01 d0                	add    %edx,%eax
f010e01d:	8a 40 04             	mov    0x4(%eax),%al
f010e020:	0f b6 c0             	movzbl %al,%eax
f010e023:	3b 45 14             	cmp    0x14(%ebp),%eax
f010e026:	75 d5                	jne    f010dffd <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010e028:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e02b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010e02e:	89 10                	mov    %edx,(%eax)
	}
}
f010e030:	90                   	nop
f010e031:	c9                   	leave  
f010e032:	c3                   	ret    

f010e033 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010e033:	55                   	push   %ebp
f010e034:	89 e5                	mov    %esp,%ebp
f010e036:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010e039:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e03c:	c7 00 b0 69 12 f0    	movl   $0xf01269b0,(%eax)
	info->eip_line = 0;
f010e042:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e045:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010e04c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e04f:	c7 40 08 b0 69 12 f0 	movl   $0xf01269b0,0x8(%eax)
	info->eip_fn_namelen = 9;
f010e056:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e059:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010e060:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e063:	8b 55 08             	mov    0x8(%ebp),%edx
f010e066:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010e069:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e06c:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010e073:	8b 45 08             	mov    0x8(%ebp),%eax
f010e076:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010e07b:	76 1e                	jbe    f010e09b <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010e07d:	c7 45 f4 18 df 12 f0 	movl   $0xf012df18,-0xc(%ebp)
		stab_end = __STAB_END__;
f010e084:	c7 45 f0 0c f1 15 f0 	movl   $0xf015f10c,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010e08b:	c7 45 ec 0d f1 15 f0 	movl   $0xf015f10d,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010e092:	c7 45 e8 51 05 17 f0 	movl   $0xf0170551,-0x18(%ebp)
f010e099:	eb 2a                	jmp    f010e0c5 <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010e09b:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010e0a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0a5:	8b 00                	mov    (%eax),%eax
f010e0a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010e0aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0ad:	8b 40 04             	mov    0x4(%eax),%eax
f010e0b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010e0b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0b6:	8b 40 08             	mov    0x8(%eax),%eax
f010e0b9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010e0bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e0bf:	8b 40 0c             	mov    0xc(%eax),%eax
f010e0c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010e0c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0c8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e0cb:	76 0a                	jbe    f010e0d7 <debuginfo_eip+0xa4>
f010e0cd:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e0d0:	48                   	dec    %eax
f010e0d1:	8a 00                	mov    (%eax),%al
f010e0d3:	84 c0                	test   %al,%al
f010e0d5:	74 0a                	je     f010e0e1 <debuginfo_eip+0xae>
		return -1;
f010e0d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e0dc:	e9 01 02 00 00       	jmp    f010e2e2 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010e0e1:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010e0e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010e0eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e0ee:	29 c2                	sub    %eax,%edx
f010e0f0:	89 d0                	mov    %edx,%eax
f010e0f2:	c1 f8 02             	sar    $0x2,%eax
f010e0f5:	89 c2                	mov    %eax,%edx
f010e0f7:	89 d0                	mov    %edx,%eax
f010e0f9:	c1 e0 02             	shl    $0x2,%eax
f010e0fc:	01 d0                	add    %edx,%eax
f010e0fe:	c1 e0 02             	shl    $0x2,%eax
f010e101:	01 d0                	add    %edx,%eax
f010e103:	c1 e0 02             	shl    $0x2,%eax
f010e106:	01 d0                	add    %edx,%eax
f010e108:	89 c1                	mov    %eax,%ecx
f010e10a:	c1 e1 08             	shl    $0x8,%ecx
f010e10d:	01 c8                	add    %ecx,%eax
f010e10f:	89 c1                	mov    %eax,%ecx
f010e111:	c1 e1 10             	shl    $0x10,%ecx
f010e114:	01 c8                	add    %ecx,%eax
f010e116:	01 c0                	add    %eax,%eax
f010e118:	01 d0                	add    %edx,%eax
f010e11a:	48                   	dec    %eax
f010e11b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010e11e:	ff 75 08             	pushl  0x8(%ebp)
f010e121:	6a 64                	push   $0x64
f010e123:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010e126:	50                   	push   %eax
f010e127:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010e12a:	50                   	push   %eax
f010e12b:	ff 75 f4             	pushl  -0xc(%ebp)
f010e12e:	e8 b3 fd ff ff       	call   f010dee6 <stab_binsearch>
f010e133:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010e136:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e139:	85 c0                	test   %eax,%eax
f010e13b:	75 0a                	jne    f010e147 <debuginfo_eip+0x114>
		return -1;
f010e13d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010e142:	e9 9b 01 00 00       	jmp    f010e2e2 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010e147:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e14a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010e14d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e150:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010e153:	ff 75 08             	pushl  0x8(%ebp)
f010e156:	6a 24                	push   $0x24
f010e158:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010e15b:	50                   	push   %eax
f010e15c:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010e15f:	50                   	push   %eax
f010e160:	ff 75 f4             	pushl  -0xc(%ebp)
f010e163:	e8 7e fd ff ff       	call   f010dee6 <stab_binsearch>
f010e168:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010e16b:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010e16e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e171:	39 c2                	cmp    %eax,%edx
f010e173:	0f 8f 86 00 00 00    	jg     f010e1ff <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010e179:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e17c:	89 c2                	mov    %eax,%edx
f010e17e:	89 d0                	mov    %edx,%eax
f010e180:	01 c0                	add    %eax,%eax
f010e182:	01 d0                	add    %edx,%eax
f010e184:	c1 e0 02             	shl    $0x2,%eax
f010e187:	89 c2                	mov    %eax,%edx
f010e189:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e18c:	01 d0                	add    %edx,%eax
f010e18e:	8b 00                	mov    (%eax),%eax
f010e190:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e193:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e196:	29 d1                	sub    %edx,%ecx
f010e198:	89 ca                	mov    %ecx,%edx
f010e19a:	39 d0                	cmp    %edx,%eax
f010e19c:	73 22                	jae    f010e1c0 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010e19e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e1a1:	89 c2                	mov    %eax,%edx
f010e1a3:	89 d0                	mov    %edx,%eax
f010e1a5:	01 c0                	add    %eax,%eax
f010e1a7:	01 d0                	add    %edx,%eax
f010e1a9:	c1 e0 02             	shl    $0x2,%eax
f010e1ac:	89 c2                	mov    %eax,%edx
f010e1ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1b1:	01 d0                	add    %edx,%eax
f010e1b3:	8b 10                	mov    (%eax),%edx
f010e1b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e1b8:	01 c2                	add    %eax,%edx
f010e1ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1bd:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010e1c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e1c3:	89 c2                	mov    %eax,%edx
f010e1c5:	89 d0                	mov    %edx,%eax
f010e1c7:	01 c0                	add    %eax,%eax
f010e1c9:	01 d0                	add    %edx,%eax
f010e1cb:	c1 e0 02             	shl    $0x2,%eax
f010e1ce:	89 c2                	mov    %eax,%edx
f010e1d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e1d3:	01 d0                	add    %edx,%eax
f010e1d5:	8b 50 08             	mov    0x8(%eax),%edx
f010e1d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1db:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010e1de:	8b 55 08             	mov    0x8(%ebp),%edx
f010e1e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e1e4:	8b 40 10             	mov    0x10(%eax),%eax
f010e1e7:	29 c2                	sub    %eax,%edx
f010e1e9:	89 d0                	mov    %edx,%eax
f010e1eb:	c1 f8 02             	sar    $0x2,%eax
f010e1ee:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010e1f1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010e1f4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010e1f7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010e1fa:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010e1fd:	eb 15                	jmp    f010e214 <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010e1ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e202:	8b 55 08             	mov    0x8(%ebp),%edx
f010e205:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010e208:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e20b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010e20e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010e211:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010e214:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e217:	8b 40 08             	mov    0x8(%eax),%eax
f010e21a:	83 ec 08             	sub    $0x8,%esp
f010e21d:	6a 3a                	push   $0x3a
f010e21f:	50                   	push   %eax
f010e220:	e8 d0 24 01 00       	call   f01206f5 <strfind>
f010e225:	83 c4 10             	add    $0x10,%esp
f010e228:	89 c2                	mov    %eax,%edx
f010e22a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e22d:	8b 40 08             	mov    0x8(%eax),%eax
f010e230:	29 c2                	sub    %eax,%edx
f010e232:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e235:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e238:	eb 03                	jmp    f010e23d <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010e23a:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010e23d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e240:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e243:	7c 4e                	jl     f010e293 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010e245:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e248:	89 d0                	mov    %edx,%eax
f010e24a:	01 c0                	add    %eax,%eax
f010e24c:	01 d0                	add    %edx,%eax
f010e24e:	c1 e0 02             	shl    $0x2,%eax
f010e251:	89 c2                	mov    %eax,%edx
f010e253:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e256:	01 d0                	add    %edx,%eax
f010e258:	8a 40 04             	mov    0x4(%eax),%al
f010e25b:	3c 84                	cmp    $0x84,%al
f010e25d:	74 34                	je     f010e293 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010e25f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e262:	89 d0                	mov    %edx,%eax
f010e264:	01 c0                	add    %eax,%eax
f010e266:	01 d0                	add    %edx,%eax
f010e268:	c1 e0 02             	shl    $0x2,%eax
f010e26b:	89 c2                	mov    %eax,%edx
f010e26d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e270:	01 d0                	add    %edx,%eax
f010e272:	8a 40 04             	mov    0x4(%eax),%al
f010e275:	3c 64                	cmp    $0x64,%al
f010e277:	75 c1                	jne    f010e23a <debuginfo_eip+0x207>
f010e279:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e27c:	89 d0                	mov    %edx,%eax
f010e27e:	01 c0                	add    %eax,%eax
f010e280:	01 d0                	add    %edx,%eax
f010e282:	c1 e0 02             	shl    $0x2,%eax
f010e285:	89 c2                	mov    %eax,%edx
f010e287:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e28a:	01 d0                	add    %edx,%eax
f010e28c:	8b 40 08             	mov    0x8(%eax),%eax
f010e28f:	85 c0                	test   %eax,%eax
f010e291:	74 a7                	je     f010e23a <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010e293:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e296:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010e299:	7c 42                	jl     f010e2dd <debuginfo_eip+0x2aa>
f010e29b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e29e:	89 d0                	mov    %edx,%eax
f010e2a0:	01 c0                	add    %eax,%eax
f010e2a2:	01 d0                	add    %edx,%eax
f010e2a4:	c1 e0 02             	shl    $0x2,%eax
f010e2a7:	89 c2                	mov    %eax,%edx
f010e2a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2ac:	01 d0                	add    %edx,%eax
f010e2ae:	8b 00                	mov    (%eax),%eax
f010e2b0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010e2b3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e2b6:	29 d1                	sub    %edx,%ecx
f010e2b8:	89 ca                	mov    %ecx,%edx
f010e2ba:	39 d0                	cmp    %edx,%eax
f010e2bc:	73 1f                	jae    f010e2dd <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010e2be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010e2c1:	89 d0                	mov    %edx,%eax
f010e2c3:	01 c0                	add    %eax,%eax
f010e2c5:	01 d0                	add    %edx,%eax
f010e2c7:	c1 e0 02             	shl    $0x2,%eax
f010e2ca:	89 c2                	mov    %eax,%edx
f010e2cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2cf:	01 d0                	add    %edx,%eax
f010e2d1:	8b 10                	mov    (%eax),%edx
f010e2d3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e2d6:	01 c2                	add    %eax,%edx
f010e2d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e2db:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010e2dd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e2e2:	c9                   	leave  
f010e2e3:	c3                   	ret    

f010e2e4 <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010e2e4:	55                   	push   %ebp
f010e2e5:	89 e5                	mov    %esp,%ebp
f010e2e7:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010e2ea:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010e2ee:	74 1c                	je     f010e30c <setPageReplacmentAlgorithmLRU+0x28>
f010e2f0:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010e2f4:	74 16                	je     f010e30c <setPageReplacmentAlgorithmLRU+0x28>
f010e2f6:	68 bc 69 12 f0       	push   $0xf01269bc
f010e2fb:	68 06 6a 12 f0       	push   $0xf0126a06
f010e300:	6a 19                	push   $0x19
f010e302:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e307:	e8 0e 20 ff ff       	call   f010031a <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010e30c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e30f:	a3 68 51 55 f0       	mov    %eax,0xf0555168
}
f010e314:	90                   	nop
f010e315:	c9                   	leave  
f010e316:	c3                   	ret    

f010e317 <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010e317:	55                   	push   %ebp
f010e318:	89 e5                	mov    %esp,%ebp
f010e31a:	c7 05 68 51 55 f0 03 	movl   $0x3,0xf0555168
f010e321:	00 00 00 
f010e324:	90                   	nop
f010e325:	5d                   	pop    %ebp
f010e326:	c3                   	ret    

f010e327 <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010e327:	55                   	push   %ebp
f010e328:	89 e5                	mov    %esp,%ebp
f010e32a:	c7 05 68 51 55 f0 04 	movl   $0x4,0xf0555168
f010e331:	00 00 00 
f010e334:	90                   	nop
f010e335:	5d                   	pop    %ebp
f010e336:	c3                   	ret    

f010e337 <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010e337:	55                   	push   %ebp
f010e338:	89 e5                	mov    %esp,%ebp
f010e33a:	c7 05 68 51 55 f0 05 	movl   $0x5,0xf0555168
f010e341:	00 00 00 
f010e344:	90                   	nop
f010e345:	5d                   	pop    %ebp
f010e346:	c3                   	ret    

f010e347 <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010e347:	55                   	push   %ebp
f010e348:	89 e5                	mov    %esp,%ebp
f010e34a:	c7 05 68 51 55 f0 07 	movl   $0x7,0xf0555168
f010e351:	00 00 00 
f010e354:	90                   	nop
f010e355:	5d                   	pop    %ebp
f010e356:	c3                   	ret    

f010e357 <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010e357:	55                   	push   %ebp
f010e358:	89 e5                	mov    %esp,%ebp
f010e35a:	c7 05 68 51 55 f0 06 	movl   $0x6,0xf0555168
f010e361:	00 00 00 
f010e364:	8b 45 08             	mov    0x8(%ebp),%eax
f010e367:	a3 00 25 55 f0       	mov    %eax,0xf0552500
f010e36c:	90                   	nop
f010e36d:	5d                   	pop    %ebp
f010e36e:	c3                   	ret    

f010e36f <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010e36f:	55                   	push   %ebp
f010e370:	89 e5                	mov    %esp,%ebp
f010e372:	8b 15 68 51 55 f0    	mov    0xf0555168,%edx
f010e378:	8b 45 08             	mov    0x8(%ebp),%eax
f010e37b:	39 c2                	cmp    %eax,%edx
f010e37d:	0f 94 c0             	sete   %al
f010e380:	0f b6 c0             	movzbl %al,%eax
f010e383:	5d                   	pop    %ebp
f010e384:	c3                   	ret    

f010e385 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010e385:	55                   	push   %ebp
f010e386:	89 e5                	mov    %esp,%ebp
f010e388:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e38d:	83 f8 03             	cmp    $0x3,%eax
f010e390:	75 07                	jne    f010e399 <isPageReplacmentAlgorithmCLOCK+0x14>
f010e392:	b8 01 00 00 00       	mov    $0x1,%eax
f010e397:	eb 05                	jmp    f010e39e <isPageReplacmentAlgorithmCLOCK+0x19>
f010e399:	b8 00 00 00 00       	mov    $0x0,%eax
f010e39e:	5d                   	pop    %ebp
f010e39f:	c3                   	ret    

f010e3a0 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010e3a0:	55                   	push   %ebp
f010e3a1:	89 e5                	mov    %esp,%ebp
f010e3a3:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3a8:	83 f8 04             	cmp    $0x4,%eax
f010e3ab:	75 07                	jne    f010e3b4 <isPageReplacmentAlgorithmFIFO+0x14>
f010e3ad:	b8 01 00 00 00       	mov    $0x1,%eax
f010e3b2:	eb 05                	jmp    f010e3b9 <isPageReplacmentAlgorithmFIFO+0x19>
f010e3b4:	b8 00 00 00 00       	mov    $0x0,%eax
f010e3b9:	5d                   	pop    %ebp
f010e3ba:	c3                   	ret    

f010e3bb <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010e3bb:	55                   	push   %ebp
f010e3bc:	89 e5                	mov    %esp,%ebp
f010e3be:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3c3:	83 f8 05             	cmp    $0x5,%eax
f010e3c6:	75 07                	jne    f010e3cf <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010e3c8:	b8 01 00 00 00       	mov    $0x1,%eax
f010e3cd:	eb 05                	jmp    f010e3d4 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010e3cf:	b8 00 00 00 00       	mov    $0x0,%eax
f010e3d4:	5d                   	pop    %ebp
f010e3d5:	c3                   	ret    

f010e3d6 <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010e3d6:	55                   	push   %ebp
f010e3d7:	89 e5                	mov    %esp,%ebp
f010e3d9:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3de:	83 f8 07             	cmp    $0x7,%eax
f010e3e1:	75 07                	jne    f010e3ea <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010e3e3:	b8 01 00 00 00       	mov    $0x1,%eax
f010e3e8:	eb 05                	jmp    f010e3ef <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010e3ea:	b8 00 00 00 00       	mov    $0x0,%eax
f010e3ef:	5d                   	pop    %ebp
f010e3f0:	c3                   	ret    

f010e3f1 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010e3f1:	55                   	push   %ebp
f010e3f2:	89 e5                	mov    %esp,%ebp
f010e3f4:	a1 68 51 55 f0       	mov    0xf0555168,%eax
f010e3f9:	83 f8 06             	cmp    $0x6,%eax
f010e3fc:	75 07                	jne    f010e405 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010e3fe:	b8 01 00 00 00       	mov    $0x1,%eax
f010e403:	eb 05                	jmp    f010e40a <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010e405:	b8 00 00 00 00       	mov    $0x0,%eax
f010e40a:	5d                   	pop    %ebp
f010e40b:	c3                   	ret    

f010e40c <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010e40c:	55                   	push   %ebp
f010e40d:	89 e5                	mov    %esp,%ebp
f010e40f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e412:	a3 18 4f 55 f0       	mov    %eax,0xf0554f18
f010e417:	90                   	nop
f010e418:	5d                   	pop    %ebp
f010e419:	c3                   	ret    

f010e41a <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010e41a:	55                   	push   %ebp
f010e41b:	89 e5                	mov    %esp,%ebp
f010e41d:	a1 18 4f 55 f0       	mov    0xf0554f18,%eax
f010e422:	5d                   	pop    %ebp
f010e423:	c3                   	ret    

f010e424 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010e424:	55                   	push   %ebp
f010e425:	89 e5                	mov    %esp,%ebp
f010e427:	8b 45 08             	mov    0x8(%ebp),%eax
f010e42a:	a3 d4 51 55 f0       	mov    %eax,0xf05551d4
f010e42f:	90                   	nop
f010e430:	5d                   	pop    %ebp
f010e431:	c3                   	ret    

f010e432 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010e432:	55                   	push   %ebp
f010e433:	89 e5                	mov    %esp,%ebp
f010e435:	a1 d4 51 55 f0       	mov    0xf05551d4,%eax
f010e43a:	5d                   	pop    %ebp
f010e43b:	c3                   	ret    

f010e43c <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010e43c:	55                   	push   %ebp
f010e43d:	89 e5                	mov    %esp,%ebp
f010e43f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e442:	a3 70 52 55 f0       	mov    %eax,0xf0555270
f010e447:	90                   	nop
f010e448:	5d                   	pop    %ebp
f010e449:	c3                   	ret    

f010e44a <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010e44a:	55                   	push   %ebp
f010e44b:	89 e5                	mov    %esp,%ebp
f010e44d:	a1 70 52 55 f0       	mov    0xf0555270,%eax
f010e452:	5d                   	pop    %ebp
f010e453:	c3                   	ret    

f010e454 <fault_handler>:
uint32 before_last_fault_va = 0;
int8 num_repeated_fault  = 0;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010e454:	55                   	push   %ebp
f010e455:	89 e5                	mov    %esp,%ebp
f010e457:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e45a:	0f 20 d0             	mov    %cr2,%eax
f010e45d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010e460:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010e463:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010e466:	e8 06 c0 ff ff       	call   f010a471 <get_cpu_proc>
f010e46b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010e46e:	a1 8c 22 55 f0       	mov    0xf055228c,%eax
f010e473:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e476:	75 50                	jne    f010e4c8 <fault_handler+0x74>
f010e478:	a1 98 22 55 f0       	mov    0xf0552298,%eax
f010e47d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010e480:	75 46                	jne    f010e4c8 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010e482:	a0 94 22 55 f0       	mov    0xf0552294,%al
f010e487:	40                   	inc    %eax
f010e488:	a2 94 22 55 f0       	mov    %al,0xf0552294
		if (num_repeated_fault == 3)
f010e48d:	a0 94 22 55 f0       	mov    0xf0552294,%al
f010e492:	3c 03                	cmp    $0x3,%al
f010e494:	75 4d                	jne    f010e4e3 <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010e496:	83 ec 0c             	sub    $0xc,%esp
f010e499:	ff 75 08             	pushl  0x8(%ebp)
f010e49c:	e8 15 ea ff ff       	call   f010ceb6 <print_trapframe>
f010e4a1:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010e4a4:	8b 15 88 22 55 f0    	mov    0xf0552288,%edx
f010e4aa:	a1 90 22 55 f0       	mov    0xf0552290,%eax
f010e4af:	83 ec 08             	sub    $0x8,%esp
f010e4b2:	ff 75 ec             	pushl  -0x14(%ebp)
f010e4b5:	52                   	push   %edx
f010e4b6:	50                   	push   %eax
f010e4b7:	68 38 6a 12 f0       	push   $0xf0126a38
f010e4bc:	6a 57                	push   $0x57
f010e4be:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e4c3:	e8 52 1e ff ff       	call   f010031a <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010e4c8:	a1 8c 22 55 f0       	mov    0xf055228c,%eax
f010e4cd:	a3 90 22 55 f0       	mov    %eax,0xf0552290
		before_last_eip = last_eip;
f010e4d2:	a1 84 22 55 f0       	mov    0xf0552284,%eax
f010e4d7:	a3 88 22 55 f0       	mov    %eax,0xf0552288
		num_repeated_fault = 0;
f010e4dc:	c6 05 94 22 55 f0 00 	movb   $0x0,0xf0552294
	}
	last_eip = (uint32)tf->tf_eip;
f010e4e3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4e6:	8b 40 30             	mov    0x30(%eax),%eax
f010e4e9:	a3 84 22 55 f0       	mov    %eax,0xf0552284
	last_fault_va = fault_va ;
f010e4ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e4f1:	a3 8c 22 55 f0       	mov    %eax,0xf055228c
	last_faulted_env = cur_env;
f010e4f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e4f9:	a3 98 22 55 f0       	mov    %eax,0xf0552298
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010e4fe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010e505:	8b 45 08             	mov    0x8(%ebp),%eax
f010e508:	8b 40 34             	mov    0x34(%eax),%eax
f010e50b:	0f b7 c0             	movzwl %ax,%eax
f010e50e:	83 e0 03             	and    $0x3,%eax
f010e511:	83 f8 03             	cmp    $0x3,%eax
f010e514:	75 07                	jne    f010e51d <fault_handler+0xc9>
		userTrap = 1;
f010e516:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010e51d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e521:	0f 85 a9 00 00 00    	jne    f010e5d0 <fault_handler+0x17c>
	{
		struct cpu* c = mycpu();
f010e527:	e8 d2 88 ff ff       	call   f0106dfe <mycpu>
f010e52c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010e52f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010e533:	74 2f                	je     f010e564 <fault_handler+0x110>
f010e535:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e538:	8b 40 70             	mov    0x70(%eax),%eax
f010e53b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e53e:	77 24                	ja     f010e564 <fault_handler+0x110>
f010e540:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e543:	8b 40 70             	mov    0x70(%eax),%eax
f010e546:	05 00 10 00 00       	add    $0x1000,%eax
f010e54b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e54e:	76 14                	jbe    f010e564 <fault_handler+0x110>
			panic("User Kernel Stack: overflow exception!");
f010e550:	83 ec 04             	sub    $0x4,%esp
f010e553:	68 a8 6a 12 f0       	push   $0xf0126aa8
f010e558:	6a 6e                	push   $0x6e
f010e55a:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e55f:	e8 b6 1d ff ff       	call   f010031a <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010e564:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e567:	8b 40 08             	mov    0x8(%eax),%eax
f010e56a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e56d:	0f 87 83 00 00 00    	ja     f010e5f6 <fault_handler+0x1a2>
f010e573:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e576:	8b 40 08             	mov    0x8(%eax),%eax
f010e579:	05 00 10 00 00       	add    $0x1000,%eax
f010e57e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010e581:	76 73                	jbe    f010e5f6 <fault_handler+0x1a2>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010e583:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010e586:	ba 00 4c 55 f0       	mov    $0xf0554c00,%edx
f010e58b:	29 d0                	sub    %edx,%eax
f010e58d:	c1 f8 03             	sar    $0x3,%eax
f010e590:	89 c2                	mov    %eax,%edx
f010e592:	89 d0                	mov    %edx,%eax
f010e594:	c1 e0 02             	shl    $0x2,%eax
f010e597:	01 d0                	add    %edx,%eax
f010e599:	01 c0                	add    %eax,%eax
f010e59b:	01 d0                	add    %edx,%eax
f010e59d:	c1 e0 03             	shl    $0x3,%eax
f010e5a0:	01 d0                	add    %edx,%eax
f010e5a2:	89 c1                	mov    %eax,%ecx
f010e5a4:	c1 e1 0b             	shl    $0xb,%ecx
f010e5a7:	01 c8                	add    %ecx,%eax
f010e5a9:	c1 e0 05             	shl    $0x5,%eax
f010e5ac:	01 d0                	add    %edx,%eax
f010e5ae:	c1 e0 02             	shl    $0x2,%eax
f010e5b1:	01 d0                	add    %edx,%eax
f010e5b3:	01 c0                	add    %eax,%eax
f010e5b5:	01 d0                	add    %edx,%eax
f010e5b7:	c1 e0 03             	shl    $0x3,%eax
f010e5ba:	01 d0                	add    %edx,%eax
f010e5bc:	f7 d8                	neg    %eax
f010e5be:	50                   	push   %eax
f010e5bf:	68 d0 6a 12 f0       	push   $0xf0126ad0
f010e5c4:	6a 70                	push   $0x70
f010e5c6:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e5cb:	e8 4a 1d ff ff       	call   f010031a <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010e5d0:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010e5d7:	76 1d                	jbe    f010e5f6 <fault_handler+0x1a2>
f010e5d9:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010e5e0:	77 14                	ja     f010e5f6 <fault_handler+0x1a2>
			panic("User: stack underflow exception!");
f010e5e2:	83 ec 04             	sub    $0x4,%esp
f010e5e5:	68 04 6b 12 f0       	push   $0xf0126b04
f010e5ea:	6a 7b                	push   $0x7b
f010e5ec:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e5f1:	e8 24 1d ff ff       	call   f010031a <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010e5f6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e5f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010e5fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010e600:	75 25                	jne    f010e627 <fault_handler+0x1d3>
	{
		print_trapframe(tf);
f010e602:	83 ec 0c             	sub    $0xc,%esp
f010e605:	ff 75 08             	pushl  0x8(%ebp)
f010e608:	e8 a9 e8 ff ff       	call   f010ceb6 <print_trapframe>
f010e60d:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010e610:	83 ec 04             	sub    $0x4,%esp
f010e613:	68 25 6b 12 f0       	push   $0xf0126b25
f010e618:	68 84 00 00 00       	push   $0x84
f010e61d:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e622:	e8 f3 1c ff ff       	call   f010031a <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010e627:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e62a:	8b 40 64             	mov    0x64(%eax),%eax
f010e62d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e630:	c1 ea 16             	shr    $0x16,%edx
f010e633:	c1 e2 02             	shl    $0x2,%edx
f010e636:	01 d0                	add    %edx,%eax
f010e638:	8b 00                	mov    (%eax),%eax
f010e63a:	83 e0 01             	and    $0x1,%eax
f010e63d:	85 c0                	test   %eax,%eax
f010e63f:	75 28                	jne    f010e669 <fault_handler+0x215>
	{
		// we have a table fault =============================================================
		//		cprintf("[%s] user TABLE fault va %08x\n", curenv->prog_name, fault_va);
		//		print_trapframe(tf);

		faulted_env->tableFaultsCounter ++ ;
f010e641:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e644:	8b 80 44 da 01 00    	mov    0x1da44(%eax),%eax
f010e64a:	8d 50 01             	lea    0x1(%eax),%edx
f010e64d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e650:	89 90 44 da 01 00    	mov    %edx,0x1da44(%eax)

		table_fault_handler(faulted_env, fault_va);
f010e656:	83 ec 08             	sub    $0x8,%esp
f010e659:	ff 75 ec             	pushl  -0x14(%ebp)
f010e65c:	ff 75 e0             	pushl  -0x20(%ebp)
f010e65f:	e8 8f 00 00 00       	call   f010e6f3 <table_fault_handler>
f010e664:	83 c4 10             	add    $0x10,%esp
f010e667:	eb 7b                	jmp    f010e6e4 <fault_handler+0x290>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010e669:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e66c:	8b 40 64             	mov    0x64(%eax),%eax
f010e66f:	83 ec 08             	sub    $0x8,%esp
f010e672:	ff 75 ec             	pushl  -0x14(%ebp)
f010e675:	50                   	push   %eax
f010e676:	e8 72 a2 ff ff       	call   f01088ed <pt_get_page_permissions>
f010e67b:	83 c4 10             	add    $0x10,%esp
f010e67e:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010e681:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010e684:	83 e0 01             	and    $0x1,%eax
f010e687:	85 c0                	test   %eax,%eax
f010e689:	74 17                	je     f010e6a2 <fault_handler+0x24e>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010e68b:	ff 75 ec             	pushl  -0x14(%ebp)
f010e68e:	68 3c 6b 12 f0       	push   $0xf0126b3c
f010e693:	68 a1 00 00 00       	push   $0xa1
f010e698:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e69d:	e8 78 1c ff ff       	call   f010031a <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010e6a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6a5:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f010e6ab:	8d 50 01             	lea    0x1(%eax),%edx
f010e6ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e6b1:	89 90 40 da 01 00    	mov    %edx,0x1da40(%eax)

		//		cprintf("[%08s] user PAGE fault va %08x\n", curenv->prog_name, fault_va);
		//		cprintf("\nPage working set BEFORE fault handler...\n");
		//		env_page_ws_print(curenv);

		if(isBufferingEnabled())
f010e6b7:	e8 76 fd ff ff       	call   f010e432 <isBufferingEnabled>
f010e6bc:	84 c0                	test   %al,%al
f010e6be:	74 13                	je     f010e6d3 <fault_handler+0x27f>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010e6c0:	83 ec 08             	sub    $0x8,%esp
f010e6c3:	ff 75 ec             	pushl  -0x14(%ebp)
f010e6c6:	ff 75 e0             	pushl  -0x20(%ebp)
f010e6c9:	e8 64 00 00 00       	call   f010e732 <__page_fault_handler_with_buffering>
f010e6ce:	83 c4 10             	add    $0x10,%esp
f010e6d1:	eb 11                	jmp    f010e6e4 <fault_handler+0x290>
		}
		else
		{
			//page_fault_handler(faulted_env, fault_va);
			page_fault_handler(faulted_env, fault_va);
f010e6d3:	83 ec 08             	sub    $0x8,%esp
f010e6d6:	ff 75 ec             	pushl  -0x14(%ebp)
f010e6d9:	ff 75 e0             	pushl  -0x20(%ebp)
f010e6dc:	e8 34 00 00 00       	call   f010e715 <page_fault_handler>
f010e6e1:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010e6e4:	0f 20 d8             	mov    %cr3,%eax
f010e6e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010e6ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e6ed:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010e6f0:	90                   	nop
f010e6f1:	c9                   	leave  
f010e6f2:	c3                   	ret    

f010e6f3 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010e6f3:	55                   	push   %ebp
f010e6f4:	89 e5                	mov    %esp,%ebp
f010e6f6:	83 ec 18             	sub    $0x18,%esp
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
	}
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
f010e6f9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e6fc:	8b 40 64             	mov    0x64(%eax),%eax
f010e6ff:	83 ec 04             	sub    $0x4,%esp
f010e702:	8d 55 f4             	lea    -0xc(%ebp),%edx
f010e705:	52                   	push   %edx
f010e706:	ff 75 0c             	pushl  0xc(%ebp)
f010e709:	50                   	push   %eax
f010e70a:	e8 25 9b ff ff       	call   f0108234 <__static_cpt>
f010e70f:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f010e712:	90                   	nop
f010e713:	c9                   	leave  
f010e714:	c3                   	ret    

f010e715 <page_fault_handler>:

//=========================
// [3] PAGE FAULT HANDLER:
//=========================
void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010e715:	55                   	push   %ebp
f010e716:	89 e5                	mov    %esp,%ebp
f010e718:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24] [3] PAGE FAULT HANDLER
	// Write your code here, remove the panic and write your code
	panic("page_fault_handler() is not implemented yet...!!");
f010e71b:	83 ec 04             	sub    $0x4,%esp
f010e71e:	68 80 6b 12 f0       	push   $0xf0126b80
f010e723:	68 db 00 00 00       	push   $0xdb
f010e728:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e72d:	e8 e8 1b ff ff       	call   f010031a <_panic>

f010e732 <__page_fault_handler_with_buffering>:
		panic("page_fault_handler() Replacement is not implemented yet...!!");
	}
}

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010e732:	55                   	push   %ebp
f010e733:	89 e5                	mov    %esp,%ebp
f010e735:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT] PAGE FAULT HANDLER WITH BUFFERING
	// your code is here, remove the panic and write your code
	panic("__page_fault_handler_with_buffering() is not implemented yet...!!");
f010e738:	83 ec 04             	sub    $0x4,%esp
f010e73b:	68 b4 6b 12 f0       	push   $0xf0126bb4
f010e740:	68 fc 00 00 00       	push   $0xfc
f010e745:	68 1b 6a 12 f0       	push   $0xf0126a1b
f010e74a:	e8 cb 1b ff ff       	call   f010031a <_panic>

f010e74f <init_spinlock>:
#include "spinlock.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_spinlock(struct spinlock *lk, char *name)
{
f010e74f:	55                   	push   %ebp
f010e750:	89 e5                	mov    %esp,%ebp
f010e752:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010e755:	8b 45 08             	mov    0x8(%ebp),%eax
f010e758:	83 c0 04             	add    $0x4,%eax
f010e75b:	83 ec 08             	sub    $0x8,%esp
f010e75e:	ff 75 0c             	pushl  0xc(%ebp)
f010e761:	50                   	push   %eax
f010e762:	e8 1b 1e 01 00       	call   f0120582 <strcpy>
f010e767:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010e76a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e76d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010e773:	8b 45 08             	mov    0x8(%ebp),%eax
f010e776:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010e77d:	90                   	nop
f010e77e:	c9                   	leave  
f010e77f:	c3                   	ret    

f010e780 <acquire_spinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_spinlock(struct spinlock *lk)
{
f010e780:	55                   	push   %ebp
f010e781:	89 e5                	mov    %esp,%ebp
f010e783:	53                   	push   %ebx
f010e784:	83 ec 14             	sub    $0x14,%esp
	if(holding_spinlock(lk))
f010e787:	8b 45 08             	mov    0x8(%ebp),%eax
f010e78a:	83 ec 0c             	sub    $0xc,%esp
f010e78d:	50                   	push   %eax
f010e78e:	e8 06 02 00 00       	call   f010e999 <holding_spinlock>
f010e793:	83 c4 10             	add    $0x10,%esp
f010e796:	85 c0                	test   %eax,%eax
f010e798:	74 18                	je     f010e7b2 <acquire_spinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010e79a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e79d:	83 c0 04             	add    $0x4,%eax
f010e7a0:	50                   	push   %eax
f010e7a1:	68 f8 6b 12 f0       	push   $0xf0126bf8
f010e7a6:	6a 1f                	push   $0x1f
f010e7a8:	68 35 6c 12 f0       	push   $0xf0126c35
f010e7ad:	e8 68 1b ff ff       	call   f010031a <_panic>

	pushcli(); // disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler) just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
f010e7b2:	e8 0a 87 ff ff       	call   f0106ec1 <pushcli>

	//cprintf("\nAttempt to acquire SPIN lock [%s] by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010e7b7:	90                   	nop
f010e7b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e7be:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010e7c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e7c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e7cb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010e7ce:	f0 87 02             	lock xchg %eax,(%edx)
f010e7d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010e7d4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e7d7:	85 c0                	test   %eax,%eax
f010e7d9:	75 dd                	jne    f010e7b8 <acquire_spinlock+0x38>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, myproc() != NULL? myproc()->env_id : 0);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010e7db:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010e7e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010e7e3:	e8 16 86 ff ff       	call   f0106dfe <mycpu>
f010e7e8:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010e7eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e7ee:	83 c0 48             	add    $0x48,%eax
f010e7f1:	83 ec 08             	sub    $0x8,%esp
f010e7f4:	50                   	push   %eax
f010e7f5:	8d 45 08             	lea    0x8(%ebp),%eax
f010e7f8:	50                   	push   %eax
f010e7f9:	e8 74 00 00 00       	call   f010e872 <getcallerpcs>
f010e7fe:	83 c4 10             	add    $0x10,%esp

}
f010e801:	90                   	nop
f010e802:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e805:	c9                   	leave  
f010e806:	c3                   	ret    

f010e807 <release_spinlock>:

// Release the lock.
void release_spinlock(struct spinlock *lk)
{
f010e807:	55                   	push   %ebp
f010e808:	89 e5                	mov    %esp,%ebp
f010e80a:	83 ec 08             	sub    $0x8,%esp
	if(!holding_spinlock(lk))
f010e80d:	83 ec 0c             	sub    $0xc,%esp
f010e810:	ff 75 08             	pushl  0x8(%ebp)
f010e813:	e8 81 01 00 00       	call   f010e999 <holding_spinlock>
f010e818:	83 c4 10             	add    $0x10,%esp
f010e81b:	85 c0                	test   %eax,%eax
f010e81d:	75 26                	jne    f010e845 <release_spinlock+0x3e>
	{
		printcallstack(lk);
f010e81f:	83 ec 0c             	sub    $0xc,%esp
f010e822:	ff 75 08             	pushl  0x8(%ebp)
f010e825:	e8 08 01 00 00       	call   f010e932 <printcallstack>
f010e82a:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010e82d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e830:	83 c0 04             	add    $0x4,%eax
f010e833:	50                   	push   %eax
f010e834:	68 4c 6c 12 f0       	push   $0xf0126c4c
f010e839:	6a 3b                	push   $0x3b
f010e83b:	68 35 6c 12 f0       	push   $0xf0126c35
f010e840:	e8 d5 1a ff ff       	call   f010031a <_panic>
	}
	lk->pcs[0] = 0;
f010e845:	8b 45 08             	mov    0x8(%ebp),%eax
f010e848:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010e84f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e852:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010e859:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010e85e:	8b 45 08             	mov    0x8(%ebp),%eax
f010e861:	8b 55 08             	mov    0x8(%ebp),%edx
f010e864:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	popcli();
f010e86a:	e8 a4 86 ff ff       	call   f0106f13 <popcli>
}
f010e86f:	90                   	nop
f010e870:	c9                   	leave  
f010e871:	c3                   	ret    

f010e872 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010e872:	55                   	push   %ebp
f010e873:	89 e5                	mov    %esp,%ebp
f010e875:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010e878:	e8 f4 bb ff ff       	call   f010a471 <get_cpu_proc>
f010e87d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010e880:	e8 79 85 ff ff       	call   f0106dfe <mycpu>
f010e885:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010e888:	8b 45 08             	mov    0x8(%ebp),%eax
f010e88b:	83 e8 08             	sub    $0x8,%eax
f010e88e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010e891:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010e898:	eb 67                	jmp    f010e901 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010e89a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e89e:	74 67                	je     f010e907 <getcallerpcs+0x95>
f010e8a0:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010e8a7:	76 5e                	jbe    f010e907 <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010e8a9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8ac:	8b 40 08             	mov    0x8(%eax),%eax
f010e8af:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010e8b4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e8b7:	77 10                	ja     f010e8c9 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010e8b9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010e8bc:	8b 40 08             	mov    0x8(%eax),%eax
f010e8bf:	05 00 90 00 00       	add    $0x9000,%eax
f010e8c4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e8c7:	77 3e                	ja     f010e907 <getcallerpcs+0x95>
f010e8c9:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010e8cd:	74 10                	je     f010e8df <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f010e8cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010e8d2:	8b 40 70             	mov    0x70(%eax),%eax
f010e8d5:	05 00 80 00 00       	add    $0x8000,%eax
f010e8da:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010e8dd:	76 28                	jbe    f010e907 <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f010e8df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8e2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010e8e9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8ec:	01 c2                	add    %eax,%edx
f010e8ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8f1:	8b 40 04             	mov    0x4(%eax),%eax
f010e8f4:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f010e8f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8f9:	8b 00                	mov    (%eax),%eax
f010e8fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f010e8fe:	ff 45 f0             	incl   -0x10(%ebp)
f010e901:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010e905:	7e 93                	jle    f010e89a <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f010e907:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e90a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f010e90d:	eb 18                	jmp    f010e927 <getcallerpcs+0xb5>
		pcs[i] = 0;
f010e90f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e912:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010e919:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e91c:	01 d0                	add    %edx,%eax
f010e91e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f010e924:	ff 45 f0             	incl   -0x10(%ebp)
f010e927:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f010e92b:	7e e2                	jle    f010e90f <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f010e92d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f010e930:	c9                   	leave  
f010e931:	c3                   	ret    

f010e932 <printcallstack>:

void printcallstack(struct spinlock *lk)
{
f010e932:	55                   	push   %ebp
f010e933:	89 e5                	mov    %esp,%ebp
f010e935:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f010e938:	83 ec 0c             	sub    $0xc,%esp
f010e93b:	68 8a 6c 12 f0       	push   $0xf0126c8a
f010e940:	e8 27 26 ff ff       	call   f0100f6c <cprintf>
f010e945:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f010e948:	8b 45 08             	mov    0x8(%ebp),%eax
f010e94b:	83 c0 48             	add    $0x48,%eax
f010e94e:	83 ec 08             	sub    $0x8,%esp
f010e951:	50                   	push   %eax
f010e952:	8d 45 08             	lea    0x8(%ebp),%eax
f010e955:	50                   	push   %eax
f010e956:	e8 17 ff ff ff       	call   f010e872 <getcallerpcs>
f010e95b:	83 c4 10             	add    $0x10,%esp
f010e95e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f010e961:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010e968:	eb 24                	jmp    f010e98e <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f010e96a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e96d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e970:	83 c2 10             	add    $0x10,%edx
f010e973:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f010e977:	83 ec 04             	sub    $0x4,%esp
f010e97a:	50                   	push   %eax
f010e97b:	ff 75 f4             	pushl  -0xc(%ebp)
f010e97e:	68 9a 6c 12 f0       	push   $0xf0126c9a
f010e983:	e8 e4 25 ff ff       	call   f0100f6c <cprintf>
f010e988:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct spinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f010e98b:	ff 45 f4             	incl   -0xc(%ebp)
f010e98e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e991:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010e994:	7c d4                	jl     f010e96a <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f010e996:	90                   	nop
f010e997:	c9                   	leave  
f010e998:	c3                   	ret    

f010e999 <holding_spinlock>:
// Check whether this cpu is holding the lock.
int holding_spinlock(struct spinlock *lock)
{
f010e999:	55                   	push   %ebp
f010e99a:	89 e5                	mov    %esp,%ebp
f010e99c:	53                   	push   %ebx
f010e99d:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f010e9a0:	e8 1c 85 ff ff       	call   f0106ec1 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f010e9a5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9a8:	8b 00                	mov    (%eax),%eax
f010e9aa:	85 c0                	test   %eax,%eax
f010e9ac:	74 16                	je     f010e9c4 <holding_spinlock+0x2b>
f010e9ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9b1:	8b 58 44             	mov    0x44(%eax),%ebx
f010e9b4:	e8 45 84 ff ff       	call   f0106dfe <mycpu>
f010e9b9:	39 c3                	cmp    %eax,%ebx
f010e9bb:	75 07                	jne    f010e9c4 <holding_spinlock+0x2b>
f010e9bd:	b8 01 00 00 00       	mov    $0x1,%eax
f010e9c2:	eb 05                	jmp    f010e9c9 <holding_spinlock+0x30>
f010e9c4:	b8 00 00 00 00       	mov    $0x0,%eax
f010e9c9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f010e9cc:	e8 42 85 ff ff       	call   f0106f13 <popcli>
	return r;
f010e9d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e9d4:	83 c4 14             	add    $0x14,%esp
f010e9d7:	5b                   	pop    %ebx
f010e9d8:	5d                   	pop    %ebp
f010e9d9:	c3                   	ret    

f010e9da <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f010e9da:	55                   	push   %ebp
f010e9db:	89 e5                	mov    %esp,%ebp
f010e9dd:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f010e9e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9e3:	83 c0 74             	add    $0x74,%eax
f010e9e6:	83 ec 08             	sub    $0x8,%esp
f010e9e9:	68 ac 6c 12 f0       	push   $0xf0126cac
f010e9ee:	50                   	push   %eax
f010e9ef:	e8 de 00 00 00       	call   f010ead2 <init_channel>
f010e9f4:	83 c4 10             	add    $0x10,%esp
	init_spinlock(&(lk->lk), "lock of sleep lock");
f010e9f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e9fa:	83 c0 04             	add    $0x4,%eax
f010e9fd:	83 ec 08             	sub    $0x8,%esp
f010ea00:	68 bf 6c 12 f0       	push   $0xf0126cbf
f010ea05:	50                   	push   %eax
f010ea06:	e8 44 fd ff ff       	call   f010e74f <init_spinlock>
f010ea0b:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f010ea0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea11:	05 c4 00 00 00       	add    $0xc4,%eax
f010ea16:	83 ec 08             	sub    $0x8,%esp
f010ea19:	ff 75 0c             	pushl  0xc(%ebp)
f010ea1c:	50                   	push   %eax
f010ea1d:	e8 60 1b 01 00       	call   f0120582 <strcpy>
f010ea22:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010ea25:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea28:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f010ea2e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea31:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f010ea38:	00 00 00 
}
f010ea3b:	90                   	nop
f010ea3c:	c9                   	leave  
f010ea3d:	c3                   	ret    

f010ea3e <holding_sleeplock>:
int holding_sleeplock(struct sleeplock *lk)
{
f010ea3e:	55                   	push   %ebp
f010ea3f:	89 e5                	mov    %esp,%ebp
f010ea41:	53                   	push   %ebx
f010ea42:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_spinlock(&(lk->lk));
f010ea45:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea48:	83 c0 04             	add    $0x4,%eax
f010ea4b:	83 ec 0c             	sub    $0xc,%esp
f010ea4e:	50                   	push   %eax
f010ea4f:	e8 2c fd ff ff       	call   f010e780 <acquire_spinlock>
f010ea54:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f010ea57:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea5a:	8b 00                	mov    (%eax),%eax
f010ea5c:	85 c0                	test   %eax,%eax
f010ea5e:	74 1c                	je     f010ea7c <holding_sleeplock+0x3e>
f010ea60:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea63:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f010ea69:	e8 03 ba ff ff       	call   f010a471 <get_cpu_proc>
f010ea6e:	8b 40 10             	mov    0x10(%eax),%eax
f010ea71:	39 c3                	cmp    %eax,%ebx
f010ea73:	75 07                	jne    f010ea7c <holding_sleeplock+0x3e>
f010ea75:	b8 01 00 00 00       	mov    $0x1,%eax
f010ea7a:	eb 05                	jmp    f010ea81 <holding_sleeplock+0x43>
f010ea7c:	b8 00 00 00 00       	mov    $0x0,%eax
f010ea81:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_spinlock(&(lk->lk));
f010ea84:	8b 45 08             	mov    0x8(%ebp),%eax
f010ea87:	83 c0 04             	add    $0x4,%eax
f010ea8a:	83 ec 0c             	sub    $0xc,%esp
f010ea8d:	50                   	push   %eax
f010ea8e:	e8 74 fd ff ff       	call   f010e807 <release_spinlock>
f010ea93:	83 c4 10             	add    $0x10,%esp
	return r;
f010ea96:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010ea99:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ea9c:	c9                   	leave  
f010ea9d:	c3                   	ret    

f010ea9e <acquire_sleeplock>:
//==========================================================================

void acquire_sleeplock(struct sleeplock *lk)
{
f010ea9e:	55                   	push   %ebp
f010ea9f:	89 e5                	mov    %esp,%ebp
f010eaa1:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #13] [4] LOCKS - acquire_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("acquire_sleeplock is not implemented yet");
f010eaa4:	83 ec 04             	sub    $0x4,%esp
f010eaa7:	68 d4 6c 12 f0       	push   $0xf0126cd4
f010eaac:	6a 25                	push   $0x25
f010eaae:	68 fd 6c 12 f0       	push   $0xf0126cfd
f010eab3:	e8 62 18 ff ff       	call   f010031a <_panic>

f010eab8 <release_sleeplock>:
	//Your Code is Here...

}

void release_sleeplock(struct sleeplock *lk)
{
f010eab8:	55                   	push   %ebp
f010eab9:	89 e5                	mov    %esp,%ebp
f010eabb:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #14] [4] LOCKS - release_sleeplock
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("release_sleeplock is not implemented yet");
f010eabe:	83 ec 04             	sub    $0x4,%esp
f010eac1:	68 14 6d 12 f0       	push   $0xf0126d14
f010eac6:	6a 2e                	push   $0x2e
f010eac8:	68 fd 6c 12 f0       	push   $0xf0126cfd
f010eacd:	e8 48 18 ff ff       	call   f010031a <_panic>

f010ead2 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f010ead2:	55                   	push   %ebp
f010ead3:	89 e5                	mov    %esp,%ebp
f010ead5:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f010ead8:	8b 45 08             	mov    0x8(%ebp),%eax
f010eadb:	83 c0 10             	add    $0x10,%eax
f010eade:	83 ec 08             	sub    $0x8,%esp
f010eae1:	ff 75 0c             	pushl  0xc(%ebp)
f010eae4:	50                   	push   %eax
f010eae5:	e8 98 1a 01 00       	call   f0120582 <strcpy>
f010eaea:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f010eaed:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaf0:	83 ec 0c             	sub    $0xc,%esp
f010eaf3:	50                   	push   %eax
f010eaf4:	e8 3f 61 ff ff       	call   f0104c38 <init_queue>
f010eaf9:	83 c4 10             	add    $0x10,%esp
}
f010eafc:	90                   	nop
f010eafd:	c9                   	leave  
f010eafe:	c3                   	ret    

f010eaff <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct spinlock* lk)
{
f010eaff:	55                   	push   %ebp
f010eb00:	89 e5                	mov    %esp,%ebp
f010eb02:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #10] [4] LOCKS - sleep
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("sleep is not implemented yet");
f010eb05:	83 ec 04             	sub    $0x4,%esp
f010eb08:	68 40 6d 12 f0       	push   $0xf0126d40
f010eb0d:	6a 21                	push   $0x21
f010eb0f:	68 5d 6d 12 f0       	push   $0xf0126d5d
f010eb14:	e8 01 18 ff ff       	call   f010031a <_panic>

f010eb19 <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f010eb19:	55                   	push   %ebp
f010eb1a:	89 e5                	mov    %esp,%ebp
f010eb1c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #11] [4] LOCKS - wakeup_one
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wakeup_one is not implemented yet");
f010eb1f:	83 ec 04             	sub    $0x4,%esp
f010eb22:	68 74 6d 12 f0       	push   $0xf0126d74
f010eb27:	6a 31                	push   $0x31
f010eb29:	68 5d 6d 12 f0       	push   $0xf0126d5d
f010eb2e:	e8 e7 17 ff ff       	call   f010031a <_panic>

f010eb33 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f010eb33:	55                   	push   %ebp
f010eb34:	89 e5                	mov    %esp,%ebp
f010eb36:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #12] [4] LOCKS - wakeup_all
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wakeup_all is not implemented yet");
f010eb39:	83 ec 04             	sub    $0x4,%esp
f010eb3c:	68 98 6d 12 f0       	push   $0xf0126d98
f010eb41:	6a 41                	push   $0x41
f010eb43:	68 5d 6d 12 f0       	push   $0xf0126d5d
f010eb48:	e8 cd 17 ff ff       	call   f010031a <_panic>

f010eb4d <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f010eb4d:	55                   	push   %ebp
f010eb4e:	89 e5                	mov    %esp,%ebp
f010eb50:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("init_ksemaphore is not implemented yet");
f010eb53:	83 ec 04             	sub    $0x4,%esp
f010eb56:	68 bc 6d 12 f0       	push   $0xf0126dbc
f010eb5b:	6a 13                	push   $0x13
f010eb5d:	68 e3 6d 12 f0       	push   $0xf0126de3
f010eb62:	e8 b3 17 ff ff       	call   f010031a <_panic>

f010eb67 <wait_ksemaphore>:
	//Your Code is Here...
}

void wait_ksemaphore(struct ksemaphore *ksem)
{
f010eb67:	55                   	push   %ebp
f010eb68:	89 e5                	mov    %esp,%ebp
f010eb6a:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("wait_ksemaphore is not implemented yet");
f010eb6d:	83 ec 04             	sub    $0x4,%esp
f010eb70:	68 fc 6d 12 f0       	push   $0xf0126dfc
f010eb75:	6a 1b                	push   $0x1b
f010eb77:	68 e3 6d 12 f0       	push   $0xf0126de3
f010eb7c:	e8 99 17 ff ff       	call   f010031a <_panic>

f010eb81 <signal_ksemaphore>:
	//Your Code is Here...

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f010eb81:	55                   	push   %ebp
f010eb82:	89 e5                	mov    %esp,%ebp
f010eb84:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT'24.MS3]
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("signal_ksemaphore is not implemented yet");
f010eb87:	83 ec 04             	sub    $0x4,%esp
f010eb8a:	68 24 6e 12 f0       	push   $0xf0126e24
f010eb8f:	6a 24                	push   $0x24
f010eb91:	68 e3 6d 12 f0       	push   $0xf0126de3
f010eb96:	e8 7f 17 ff ff       	call   f010031a <_panic>

f010eb9b <setKHeapPlacementStrategyFIRSTFIT>:
#define KHP_PLACE_BESTFIT 	0x2
#define KHP_PLACE_NEXTFIT 	0x3
#define KHP_PLACE_WORSTFIT 	0x4

static inline void setKHeapPlacementStrategyCONTALLOC(){_KHeapPlacementStrategy = KHP_PLACE_CONTALLOC;}
static inline void setKHeapPlacementStrategyFIRSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_FIRSTFIT;}
f010eb9b:	55                   	push   %ebp
f010eb9c:	89 e5                	mov    %esp,%ebp
f010eb9e:	c7 05 b0 4f 55 f0 01 	movl   $0x1,0xf0554fb0
f010eba5:	00 00 00 
f010eba8:	90                   	nop
f010eba9:	5d                   	pop    %ebp
f010ebaa:	c3                   	ret    

f010ebab <setKHeapPlacementStrategyBESTFIT>:
static inline void setKHeapPlacementStrategyBESTFIT(){_KHeapPlacementStrategy = KHP_PLACE_BESTFIT;}
f010ebab:	55                   	push   %ebp
f010ebac:	89 e5                	mov    %esp,%ebp
f010ebae:	c7 05 b0 4f 55 f0 02 	movl   $0x2,0xf0554fb0
f010ebb5:	00 00 00 
f010ebb8:	90                   	nop
f010ebb9:	5d                   	pop    %ebp
f010ebba:	c3                   	ret    

f010ebbb <setKHeapPlacementStrategyNEXTFIT>:
static inline void setKHeapPlacementStrategyNEXTFIT(){_KHeapPlacementStrategy = KHP_PLACE_NEXTFIT;}
f010ebbb:	55                   	push   %ebp
f010ebbc:	89 e5                	mov    %esp,%ebp
f010ebbe:	c7 05 b0 4f 55 f0 03 	movl   $0x3,0xf0554fb0
f010ebc5:	00 00 00 
f010ebc8:	90                   	nop
f010ebc9:	5d                   	pop    %ebp
f010ebca:	c3                   	ret    

f010ebcb <isKHeapPlacementStrategyFIRSTFIT>:
static inline void setKHeapPlacementStrategyWORSTFIT(){_KHeapPlacementStrategy = KHP_PLACE_WORSTFIT;}

static inline uint8 isKHeapPlacementStrategyCONTALLOC(){if(_KHeapPlacementStrategy == KHP_PLACE_CONTALLOC) return 1; return 0;}
static inline uint8 isKHeapPlacementStrategyFIRSTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_FIRSTFIT) return 1; return 0;}
f010ebcb:	55                   	push   %ebp
f010ebcc:	89 e5                	mov    %esp,%ebp
f010ebce:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010ebd3:	83 f8 01             	cmp    $0x1,%eax
f010ebd6:	75 04                	jne    f010ebdc <isKHeapPlacementStrategyFIRSTFIT+0x11>
f010ebd8:	b0 01                	mov    $0x1,%al
f010ebda:	eb 02                	jmp    f010ebde <isKHeapPlacementStrategyFIRSTFIT+0x13>
f010ebdc:	b0 00                	mov    $0x0,%al
f010ebde:	5d                   	pop    %ebp
f010ebdf:	c3                   	ret    

f010ebe0 <isKHeapPlacementStrategyBESTFIT>:
static inline uint8 isKHeapPlacementStrategyBESTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_BESTFIT) return 1; return 0;}
f010ebe0:	55                   	push   %ebp
f010ebe1:	89 e5                	mov    %esp,%ebp
f010ebe3:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010ebe8:	83 f8 02             	cmp    $0x2,%eax
f010ebeb:	75 04                	jne    f010ebf1 <isKHeapPlacementStrategyBESTFIT+0x11>
f010ebed:	b0 01                	mov    $0x1,%al
f010ebef:	eb 02                	jmp    f010ebf3 <isKHeapPlacementStrategyBESTFIT+0x13>
f010ebf1:	b0 00                	mov    $0x0,%al
f010ebf3:	5d                   	pop    %ebp
f010ebf4:	c3                   	ret    

f010ebf5 <isKHeapPlacementStrategyNEXTFIT>:
static inline uint8 isKHeapPlacementStrategyNEXTFIT(){if(_KHeapPlacementStrategy == KHP_PLACE_NEXTFIT) return 1; return 0;}
f010ebf5:	55                   	push   %ebp
f010ebf6:	89 e5                	mov    %esp,%ebp
f010ebf8:	a1 b0 4f 55 f0       	mov    0xf0554fb0,%eax
f010ebfd:	83 f8 03             	cmp    $0x3,%eax
f010ec00:	75 04                	jne    f010ec06 <isKHeapPlacementStrategyNEXTFIT+0x11>
f010ec02:	b0 01                	mov    $0x1,%al
f010ec04:	eb 02                	jmp    f010ec08 <isKHeapPlacementStrategyNEXTFIT+0x13>
f010ec06:	b0 00                	mov    $0x0,%al
f010ec08:	5d                   	pop    %ebp
f010ec09:	c3                   	ret    

f010ec0a <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f010ec0a:	55                   	push   %ebp
f010ec0b:	89 e5                	mov    %esp,%ebp
f010ec0d:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ec10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ec17:	eb 26                	jmp    f010ec3f <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f010ec19:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec1c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010ec23:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec26:	01 c2                	add    %eax,%edx
f010ec28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec2b:	40                   	inc    %eax
f010ec2c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f010ec33:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec36:	01 c8                	add    %ecx,%eax
f010ec38:	8b 00                	mov    (%eax),%eax
f010ec3a:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f010ec3c:	ff 45 f4             	incl   -0xc(%ebp)
f010ec3f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec42:	48                   	dec    %eax
f010ec43:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ec46:	7f d1                	jg     f010ec19 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f010ec48:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f010ec4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010ec52:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010ec59:	eb 35                	jmp    f010ec90 <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f010ec5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ec5e:	89 d0                	mov    %edx,%eax
f010ec60:	01 c0                	add    %eax,%eax
f010ec62:	01 d0                	add    %edx,%eax
f010ec64:	c1 e0 02             	shl    $0x2,%eax
f010ec67:	05 c0 9c 17 f0       	add    $0xf0179cc0,%eax
f010ec6c:	8b 10                	mov    (%eax),%edx
f010ec6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ec71:	8b 00                	mov    (%eax),%eax
f010ec73:	83 ec 08             	sub    $0x8,%esp
f010ec76:	52                   	push   %edx
f010ec77:	50                   	push   %eax
f010ec78:	e8 c2 19 01 00       	call   f012063f <strcmp>
f010ec7d:	83 c4 10             	add    $0x10,%esp
f010ec80:	85 c0                	test   %eax,%eax
f010ec82:	75 09                	jne    f010ec8d <tst_handler+0x83>
		{
			test_found = 1;
f010ec84:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f010ec8b:	eb 0f                	jmp    f010ec9c <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f010ec8d:	ff 45 ec             	incl   -0x14(%ebp)
f010ec90:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010ec93:	a1 74 9d 17 f0       	mov    0xf0179d74,%eax
f010ec98:	39 c2                	cmp    %eax,%edx
f010ec9a:	72 bf                	jb     f010ec5b <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f010ec9c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010eca0:	74 29                	je     f010eccb <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f010eca2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010eca5:	89 d0                	mov    %edx,%eax
f010eca7:	01 c0                	add    %eax,%eax
f010eca9:	01 d0                	add    %edx,%eax
f010ecab:	c1 e0 02             	shl    $0x2,%eax
f010ecae:	05 c8 9c 17 f0       	add    $0xf0179cc8,%eax
f010ecb3:	8b 00                	mov    (%eax),%eax
f010ecb5:	83 ec 08             	sub    $0x8,%esp
f010ecb8:	ff 75 0c             	pushl  0xc(%ebp)
f010ecbb:	ff 75 08             	pushl  0x8(%ebp)
f010ecbe:	ff d0                	call   *%eax
f010ecc0:	83 c4 10             	add    $0x10,%esp
f010ecc3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f010ecc6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ecc9:	eb 1b                	jmp    f010ece6 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f010eccb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ecce:	8b 00                	mov    (%eax),%eax
f010ecd0:	83 ec 08             	sub    $0x8,%esp
f010ecd3:	50                   	push   %eax
f010ecd4:	68 64 71 12 f0       	push   $0xf0127164
f010ecd9:	e8 8e 22 ff ff       	call   f0100f6c <cprintf>
f010ecde:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ece1:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f010ece6:	c9                   	leave  
f010ece7:	c3                   	ret    

f010ece8 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f010ece8:	55                   	push   %ebp
f010ece9:	89 e5                	mov    %esp,%ebp
f010eceb:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f010ecee:	e8 0f f1 00 00       	call   f011de02 <test_three_creation_functions>
	return 0;
f010ecf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ecf8:	c9                   	leave  
f010ecf9:	c3                   	ret    

f010ecfa <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f010ecfa:	55                   	push   %ebp
f010ecfb:	89 e5                	mov    %esp,%ebp
f010ecfd:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f010ed00:	e8 51 80 00 00       	call   f0116d56 <test_priority_normal_and_higher>
	return 0;
f010ed05:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed0a:	c9                   	leave  
f010ed0b:	c3                   	ret    

f010ed0c <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f010ed0c:	55                   	push   %ebp
f010ed0d:	89 e5                	mov    %esp,%ebp
f010ed0f:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f010ed12:	e8 a9 8a 00 00       	call   f01177c0 <test_priority_normal_and_lower>
	return 0;
f010ed17:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed1c:	c9                   	leave  
f010ed1d:	c3                   	ret    

f010ed1e <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f010ed1e:	55                   	push   %ebp
f010ed1f:	89 e5                	mov    %esp,%ebp
f010ed21:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f010ed24:	e8 91 f2 00 00       	call   f011dfba <test_kfreeall>
	return 0;
f010ed29:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed2e:	c9                   	leave  
f010ed2f:	c3                   	ret    

f010ed30 <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f010ed30:	55                   	push   %ebp
f010ed31:	89 e5                	mov    %esp,%ebp
f010ed33:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f010ed36:	e8 9c f2 00 00       	call   f011dfd7 <test_kexpand>
	return 0;
f010ed3b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed40:	c9                   	leave  
f010ed41:	c3                   	ret    

f010ed42 <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f010ed42:	55                   	push   %ebp
f010ed43:	89 e5                	mov    %esp,%ebp
f010ed45:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f010ed48:	e8 a7 f2 00 00       	call   f011dff4 <test_kshrink>
	return 0;
f010ed4d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed52:	c9                   	leave  
f010ed53:	c3                   	ret    

f010ed54 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f010ed54:	55                   	push   %ebp
f010ed55:	89 e5                	mov    %esp,%ebp
f010ed57:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f010ed5a:	e8 b2 f2 00 00       	call   f011e011 <test_kfreelast>
	return 0;
f010ed5f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ed64:	c9                   	leave  
f010ed65:	c3                   	ret    

f010ed66 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f010ed66:	55                   	push   %ebp
f010ed67:	89 e5                	mov    %esp,%ebp
f010ed69:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f010ed6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ed6f:	83 c0 04             	add    $0x4,%eax
f010ed72:	8b 00                	mov    (%eax),%eax
f010ed74:	83 ec 04             	sub    $0x4,%esp
f010ed77:	6a 0a                	push   $0xa
f010ed79:	6a 00                	push   $0x0
f010ed7b:	50                   	push   %eax
f010ed7c:	e8 12 1b 01 00       	call   f0120893 <strtol>
f010ed81:	83 c4 10             	add    $0x10,%esp
f010ed84:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f010ed87:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f010ed8e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
f010ed95:	83 ec 0c             	sub    $0xc,%esp
f010ed98:	68 60 24 55 f0       	push   $0xf0552460
f010ed9d:	e8 de f9 ff ff       	call   f010e780 <acquire_spinlock>
f010eda2:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010eda5:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f010edaa:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010edad:	eb 3b                	jmp    f010edea <tst_sc_MLFQ+0x84>
			{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f010edaf:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010edb2:	83 c0 20             	add    $0x20,%eax
f010edb5:	83 ec 08             	sub    $0x8,%esp
f010edb8:	68 77 71 12 f0       	push   $0xf0127177
f010edbd:	50                   	push   %eax
f010edbe:	e8 7c 18 01 00       	call   f012063f <strcmp>
f010edc3:	83 c4 10             	add    $0x10,%esp
f010edc6:	85 c0                	test   %eax,%eax
f010edc8:	75 12                	jne    f010eddc <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f010edca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010edce:	74 07                	je     f010edd7 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f010edd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f010edd7:	ff 45 f4             	incl   -0xc(%ebp)
f010edda:	eb 06                	jmp    f010ede2 <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f010eddc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ede0:	74 31                	je     f010ee13 <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f010ede2:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f010ede7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010edea:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010edee:	74 08                	je     f010edf8 <tst_sc_MLFQ+0x92>
f010edf0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010edf3:	8b 40 08             	mov    0x8(%eax),%eax
f010edf6:	eb 05                	jmp    f010edfd <tst_sc_MLFQ+0x97>
f010edf8:	b8 00 00 00 00       	mov    $0x0,%eax
f010edfd:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f010ee02:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f010ee07:	85 c0                	test   %eax,%eax
f010ee09:	75 a4                	jne    f010edaf <tst_sc_MLFQ+0x49>
f010ee0b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ee0f:	75 9e                	jne    f010edaf <tst_sc_MLFQ+0x49>
f010ee11:	eb 01                	jmp    f010ee14 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f010ee13:	90                   	nop
			}
		if(cnt == numOfSlave2)
f010ee14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee17:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010ee1a:	75 12                	jne    f010ee2e <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f010ee1c:	83 ec 0c             	sub    $0xc,%esp
f010ee1f:	68 80 71 12 f0       	push   $0xf0127180
f010ee24:	e8 43 21 ff ff       	call   f0100f6c <cprintf>
f010ee29:	83 c4 10             	add    $0x10,%esp
f010ee2c:	eb 17                	jmp    f010ee45 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f010ee2e:	83 ec 04             	sub    $0x4,%esp
f010ee31:	68 b9 71 12 f0       	push   $0xf01271b9
f010ee36:	68 9b 00 00 00       	push   $0x9b
f010ee3b:	68 cf 71 12 f0       	push   $0xf01271cf
f010ee40:	e8 d5 14 ff ff       	call   f010031a <_panic>
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f010ee45:	83 ec 0c             	sub    $0xc,%esp
f010ee48:	68 60 24 55 f0       	push   $0xf0552460
f010ee4d:	e8 b5 f9 ff ff       	call   f010e807 <release_spinlock>
f010ee52:	83 c4 10             	add    $0x10,%esp
	return 0;
f010ee55:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ee5a:	c9                   	leave  
f010ee5b:	c3                   	ret    

f010ee5c <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f010ee5c:	55                   	push   %ebp
f010ee5d:	89 e5                	mov    %esp,%ebp
f010ee5f:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f010ee62:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ee66:	74 17                	je     f010ee7f <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f010ee68:	83 ec 0c             	sub    $0xc,%esp
f010ee6b:	68 e8 71 12 f0       	push   $0xf01271e8
f010ee70:	e8 f7 20 ff ff       	call   f0100f6c <cprintf>
f010ee75:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ee78:	b8 00 00 00 00       	mov    $0x0,%eax
f010ee7d:	eb 45                	jmp    f010eec4 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f010ee7f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ee82:	83 c0 04             	add    $0x4,%eax
f010ee85:	8b 00                	mov    (%eax),%eax
f010ee87:	83 ec 04             	sub    $0x4,%esp
f010ee8a:	6a 0a                	push   $0xa
f010ee8c:	6a 00                	push   $0x0
f010ee8e:	50                   	push   %eax
f010ee8f:	e8 ff 19 01 00       	call   f0120893 <strtol>
f010ee94:	83 c4 10             	add    $0x10,%esp
f010ee97:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f010ee9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee9d:	83 f8 01             	cmp    $0x1,%eax
f010eea0:	74 10                	je     f010eeb2 <tst_bsd_nice+0x56>
f010eea2:	83 f8 02             	cmp    $0x2,%eax
f010eea5:	74 12                	je     f010eeb9 <tst_bsd_nice+0x5d>
f010eea7:	85 c0                	test   %eax,%eax
f010eea9:	75 14                	jne    f010eebf <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f010eeab:	e8 54 f4 00 00       	call   f011e304 <test_bsd_nice_0>
		break;
f010eeb0:	eb 0d                	jmp    f010eebf <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f010eeb2:	e8 d7 f6 00 00       	call   f011e58e <test_bsd_nice_1>
		break;
f010eeb7:	eb 06                	jmp    f010eebf <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f010eeb9:	e8 e4 f8 00 00       	call   f011e7a2 <test_bsd_nice_2>
		break;
f010eebe:	90                   	nop
	}
	return 0;
f010eebf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010eec4:	c9                   	leave  
f010eec5:	c3                   	ret    

f010eec6 <tst_str2lower>:

int tst_str2lower(int number_of_arguments, char **arguments)
{
f010eec6:	55                   	push   %ebp
f010eec7:	89 e5                	mov    %esp,%ebp
f010eec9:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f010eecc:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010eed0:	74 17                	je     f010eee9 <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f010eed2:	83 ec 0c             	sub    $0xc,%esp
f010eed5:	68 28 72 12 f0       	push   $0xf0127228
f010eeda:	e8 8d 20 ff ff       	call   f0100f6c <cprintf>
f010eedf:	83 c4 10             	add    $0x10,%esp
		return 0;
f010eee2:	b8 00 00 00 00       	mov    $0x0,%eax
f010eee7:	eb 0a                	jmp    f010eef3 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f010eee9:	e8 42 29 00 00       	call   f0111830 <test_str2lower_function>
	return 0;
f010eeee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010eef3:	c9                   	leave  
f010eef4:	c3                   	ret    

f010eef5 <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f010eef5:	55                   	push   %ebp
f010eef6:	89 e5                	mov    %esp,%ebp
f010eef8:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f010eefb:	e8 66 25 00 00       	call   f0111466 <TestAutoCompleteCommand>
f010ef00:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f010ef03:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010ef08:	c9                   	leave  
f010ef09:	c3                   	ret    

f010ef0a <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f010ef0a:	55                   	push   %ebp
f010ef0b:	89 e5                	mov    %esp,%ebp
f010ef0d:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010ef10:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010ef14:	74 1a                	je     f010ef30 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f010ef16:	83 ec 0c             	sub    $0xc,%esp
f010ef19:	68 5c 72 12 f0       	push   $0xf012725c
f010ef1e:	e8 49 20 ff ff       	call   f0100f6c <cprintf>
f010ef23:	83 c4 10             	add    $0x10,%esp
		return 0;
f010ef26:	b8 00 00 00 00       	mov    $0x0,%eax
f010ef2b:	e9 2f 01 00 00       	jmp    f010f05f <tst_dyn_alloc+0x155>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f010ef30:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef33:	83 c0 04             	add    $0x4,%eax
f010ef36:	8b 00                	mov    (%eax),%eax
f010ef38:	83 ec 08             	sub    $0x8,%esp
f010ef3b:	68 99 72 12 f0       	push   $0xf0127299
f010ef40:	50                   	push   %eax
f010ef41:	e8 f9 16 01 00       	call   f012063f <strcmp>
f010ef46:	83 c4 10             	add    $0x10,%esp
f010ef49:	85 c0                	test   %eax,%eax
f010ef4b:	75 0a                	jne    f010ef57 <tst_dyn_alloc+0x4d>
	{
		test_initialize_dynamic_allocator();
f010ef4d:	e8 35 07 00 00       	call   f010f687 <test_initialize_dynamic_allocator>
f010ef52:	e9 03 01 00 00       	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 2 Example for alloc_block_FF: tstdynalloc allocFF
	else if(strcmp(arguments[1], "allocff") == 0)
f010ef57:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef5a:	83 c0 04             	add    $0x4,%eax
f010ef5d:	8b 00                	mov    (%eax),%eax
f010ef5f:	83 ec 08             	sub    $0x8,%esp
f010ef62:	68 9e 72 12 f0       	push   $0xf012729e
f010ef67:	50                   	push   %eax
f010ef68:	e8 d2 16 01 00       	call   f012063f <strcmp>
f010ef6d:	83 c4 10             	add    $0x10,%esp
f010ef70:	85 c0                	test   %eax,%eax
f010ef72:	75 0a                	jne    f010ef7e <tst_dyn_alloc+0x74>
	{
		test_alloc_block_FF();
f010ef74:	e8 c7 0b 00 00       	call   f010fb40 <test_alloc_block_FF>
f010ef79:	e9 dc 00 00 00       	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 3 Example for alloc_block_BF: tstdynalloc allocBF
	else if(strcmp(arguments[1], "allocbf") == 0)
f010ef7e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ef81:	83 c0 04             	add    $0x4,%eax
f010ef84:	8b 00                	mov    (%eax),%eax
f010ef86:	83 ec 08             	sub    $0x8,%esp
f010ef89:	68 a6 72 12 f0       	push   $0xf01272a6
f010ef8e:	50                   	push   %eax
f010ef8f:	e8 ab 16 01 00       	call   f012063f <strcmp>
f010ef94:	83 c4 10             	add    $0x10,%esp
f010ef97:	85 c0                	test   %eax,%eax
f010ef99:	75 0a                	jne    f010efa5 <tst_dyn_alloc+0x9b>
	{
		test_alloc_block_BF();
f010ef9b:	e8 1a 10 00 00       	call   f010ffba <test_alloc_block_BF>
f010efa0:	e9 b5 00 00 00       	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 4 Example for alloc_block_NF: tstdynalloc allocNF
	else if(strcmp(arguments[1], "allocnf") == 0)
f010efa5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efa8:	83 c0 04             	add    $0x4,%eax
f010efab:	8b 00                	mov    (%eax),%eax
f010efad:	83 ec 08             	sub    $0x8,%esp
f010efb0:	68 ae 72 12 f0       	push   $0xf01272ae
f010efb5:	50                   	push   %eax
f010efb6:	e8 84 16 01 00       	call   f012063f <strcmp>
f010efbb:	83 c4 10             	add    $0x10,%esp
f010efbe:	85 c0                	test   %eax,%eax
f010efc0:	75 0a                	jne    f010efcc <tst_dyn_alloc+0xc2>
	{
		test_alloc_block_NF();
f010efc2:	e8 10 10 00 00       	call   f010ffd7 <test_alloc_block_NF>
f010efc7:	e9 8e 00 00 00       	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 5 Example for free_block: tstdynalloc freeFF
	else if(strcmp(arguments[1], "freeff") == 0)
f010efcc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010efcf:	83 c0 04             	add    $0x4,%eax
f010efd2:	8b 00                	mov    (%eax),%eax
f010efd4:	83 ec 08             	sub    $0x8,%esp
f010efd7:	68 b6 72 12 f0       	push   $0xf01272b6
f010efdc:	50                   	push   %eax
f010efdd:	e8 5d 16 01 00       	call   f012063f <strcmp>
f010efe2:	83 c4 10             	add    $0x10,%esp
f010efe5:	85 c0                	test   %eax,%eax
f010efe7:	75 07                	jne    f010eff0 <tst_dyn_alloc+0xe6>
	{
		test_free_block_FF();
f010efe9:	e8 ef 0f 00 00       	call   f010ffdd <test_free_block_FF>
f010efee:	eb 6a                	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 6 Example for free_block: tstdynalloc freeBF
	else if(strcmp(arguments[1], "freebf") == 0)
f010eff0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eff3:	83 c0 04             	add    $0x4,%eax
f010eff6:	8b 00                	mov    (%eax),%eax
f010eff8:	83 ec 08             	sub    $0x8,%esp
f010effb:	68 bd 72 12 f0       	push   $0xf01272bd
f010f000:	50                   	push   %eax
f010f001:	e8 39 16 01 00       	call   f012063f <strcmp>
f010f006:	83 c4 10             	add    $0x10,%esp
f010f009:	85 c0                	test   %eax,%eax
f010f00b:	75 07                	jne    f010f014 <tst_dyn_alloc+0x10a>
	{
		test_free_block_BF();
f010f00d:	e8 03 1f 00 00       	call   f0110f15 <test_free_block_BF>
f010f012:	eb 46                	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 7 Example for free_block: tstdynalloc freeNF
	else if(strcmp(arguments[1], "freenf") == 0)
f010f014:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f017:	83 c0 04             	add    $0x4,%eax
f010f01a:	8b 00                	mov    (%eax),%eax
f010f01c:	83 ec 08             	sub    $0x8,%esp
f010f01f:	68 c4 72 12 f0       	push   $0xf01272c4
f010f024:	50                   	push   %eax
f010f025:	e8 15 16 01 00       	call   f012063f <strcmp>
f010f02a:	83 c4 10             	add    $0x10,%esp
f010f02d:	85 c0                	test   %eax,%eax
f010f02f:	75 07                	jne    f010f038 <tst_dyn_alloc+0x12e>
	{
		test_free_block_NF();
f010f031:	e8 2c 1f 00 00       	call   f0110f62 <test_free_block_NF>
f010f036:	eb 22                	jmp    f010f05a <tst_dyn_alloc+0x150>
	}
	// Test 8 Example for realloc_block_ff: tstdynalloc reallocFF
	else if(strcmp(arguments[1], "reallocff") == 0)
f010f038:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f03b:	83 c0 04             	add    $0x4,%eax
f010f03e:	8b 00                	mov    (%eax),%eax
f010f040:	83 ec 08             	sub    $0x8,%esp
f010f043:	68 cb 72 12 f0       	push   $0xf01272cb
f010f048:	50                   	push   %eax
f010f049:	e8 f1 15 01 00       	call   f012063f <strcmp>
f010f04e:	83 c4 10             	add    $0x10,%esp
f010f051:	85 c0                	test   %eax,%eax
f010f053:	75 05                	jne    f010f05a <tst_dyn_alloc+0x150>
	{
		test_realloc_block_FF();
f010f055:	e8 25 1f 00 00       	call   f0110f7f <test_realloc_block_FF>
		//test_realloc_block_FF_COMPLETE();
	}
	return 0;
f010f05a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f05f:	c9                   	leave  
f010f060:	c3                   	ret    

f010f061 <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f010f061:	55                   	push   %ebp
f010f062:	89 e5                	mov    %esp,%ebp
f010f064:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f067:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f06b:	74 1a                	je     f010f087 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstchunk <testname>\n") ;
f010f06d:	83 ec 0c             	sub    $0xc,%esp
f010f070:	68 d8 72 12 f0       	push   $0xf01272d8
f010f075:	e8 f2 1e ff ff       	call   f0100f6c <cprintf>
f010f07a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f07d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f082:	e9 e1 00 00 00       	jmp    f010f168 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f010f087:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f08a:	83 c0 04             	add    $0x4,%eax
f010f08d:	8b 00                	mov    (%eax),%eax
f010f08f:	83 ec 08             	sub    $0x8,%esp
f010f092:	68 11 73 12 f0       	push   $0xf0127311
f010f097:	50                   	push   %eax
f010f098:	e8 a2 15 01 00       	call   f012063f <strcmp>
f010f09d:	83 c4 10             	add    $0x10,%esp
f010f0a0:	85 c0                	test   %eax,%eax
f010f0a2:	75 0a                	jne    f010f0ae <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f010f0a4:	e8 9a 30 00 00       	call   f0112143 <test_cut_paste_pages>
f010f0a9:	e9 b5 00 00 00       	jmp    f010f163 <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f010f0ae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0b1:	83 c0 04             	add    $0x4,%eax
f010f0b4:	8b 00                	mov    (%eax),%eax
f010f0b6:	83 ec 08             	sub    $0x8,%esp
f010f0b9:	68 1a 73 12 f0       	push   $0xf012731a
f010f0be:	50                   	push   %eax
f010f0bf:	e8 7b 15 01 00       	call   f012063f <strcmp>
f010f0c4:	83 c4 10             	add    $0x10,%esp
f010f0c7:	85 c0                	test   %eax,%eax
f010f0c9:	75 0a                	jne    f010f0d5 <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f010f0cb:	e8 be 3a 00 00       	call   f0112b8e <test_copy_paste_chunk>
f010f0d0:	e9 8e 00 00 00       	jmp    f010f163 <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f010f0d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0d8:	83 c0 04             	add    $0x4,%eax
f010f0db:	8b 00                	mov    (%eax),%eax
f010f0dd:	83 ec 08             	sub    $0x8,%esp
f010f0e0:	68 24 73 12 f0       	push   $0xf0127324
f010f0e5:	50                   	push   %eax
f010f0e6:	e8 54 15 01 00       	call   f012063f <strcmp>
f010f0eb:	83 c4 10             	add    $0x10,%esp
f010f0ee:	85 c0                	test   %eax,%eax
f010f0f0:	75 07                	jne    f010f0f9 <tst_chunks+0x98>
	{
		test_share_chunk();
f010f0f2:	e8 95 4b 00 00       	call   f0113c8c <test_share_chunk>
f010f0f7:	eb 6a                	jmp    f010f163 <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f010f0f9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0fc:	83 c0 04             	add    $0x4,%eax
f010f0ff:	8b 00                	mov    (%eax),%eax
f010f101:	83 ec 08             	sub    $0x8,%esp
f010f104:	68 2a 73 12 f0       	push   $0xf012732a
f010f109:	50                   	push   %eax
f010f10a:	e8 30 15 01 00       	call   f012063f <strcmp>
f010f10f:	83 c4 10             	add    $0x10,%esp
f010f112:	85 c0                	test   %eax,%eax
f010f114:	75 07                	jne    f010f11d <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f010f116:	e8 99 55 00 00       	call   f01146b4 <test_allocate_chunk>
f010f11b:	eb 46                	jmp    f010f163 <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f010f11d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f120:	83 c0 04             	add    $0x4,%eax
f010f123:	8b 00                	mov    (%eax),%eax
f010f125:	83 ec 08             	sub    $0x8,%esp
f010f128:	68 33 73 12 f0       	push   $0xf0127333
f010f12d:	50                   	push   %eax
f010f12e:	e8 0c 15 01 00       	call   f012063f <strcmp>
f010f133:	83 c4 10             	add    $0x10,%esp
f010f136:	85 c0                	test   %eax,%eax
f010f138:	75 07                	jne    f010f141 <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f010f13a:	e8 7c 5e 00 00       	call   f0114fbb <test_calculate_required_frames>
f010f13f:	eb 22                	jmp    f010f163 <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f010f141:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f144:	83 c0 04             	add    $0x4,%eax
f010f147:	8b 00                	mov    (%eax),%eax
f010f149:	83 ec 08             	sub    $0x8,%esp
f010f14c:	68 42 73 12 f0       	push   $0xf0127342
f010f151:	50                   	push   %eax
f010f152:	e8 e8 14 01 00       	call   f012063f <strcmp>
f010f157:	83 c4 10             	add    $0x10,%esp
f010f15a:	85 c0                	test   %eax,%eax
f010f15c:	75 05                	jne    f010f163 <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f010f15e:	e8 cc 66 00 00       	call   f011582f <test_calculate_allocated_space>
	}
	return 0;
f010f163:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f168:	c9                   	leave  
f010f169:	c3                   	ret    

f010f16a <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f010f16a:	55                   	push   %ebp
f010f16b:	89 e5                	mov    %esp,%ebp
f010f16d:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f010f170:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f174:	74 1a                	je     f010f190 <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tstpg <testname>\n") ;
f010f176:	83 ec 0c             	sub    $0xc,%esp
f010f179:	68 54 73 12 f0       	push   $0xf0127354
f010f17e:	e8 e9 1d ff ff       	call   f0100f6c <cprintf>
f010f183:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f186:	b8 00 00 00 00       	mov    $0x0,%eax
f010f18b:	e9 ba 00 00 00       	jmp    f010f24a <tst_paging_manipulation+0xe0>
	}
	// Test 1.1-Set/Clear permissions: tstpg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f010f190:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f193:	83 c0 04             	add    $0x4,%eax
f010f196:	8b 00                	mov    (%eax),%eax
f010f198:	83 ec 08             	sub    $0x8,%esp
f010f19b:	68 8a 73 12 f0       	push   $0xf012738a
f010f1a0:	50                   	push   %eax
f010f1a1:	e8 99 14 01 00       	call   f012063f <strcmp>
f010f1a6:	83 c4 10             	add    $0x10,%esp
f010f1a9:	85 c0                	test   %eax,%eax
f010f1ab:	75 0a                	jne    f010f1b7 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f010f1ad:	e8 04 2a 00 00       	call   f0111bb6 <test_pt_set_page_permissions>
f010f1b2:	e9 8e 00 00 00       	jmp    f010f245 <tst_paging_manipulation+0xdb>
	}
	// Test 1.2-Set/Clear permissions: tstpg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f010f1b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1ba:	83 c0 04             	add    $0x4,%eax
f010f1bd:	8b 00                	mov    (%eax),%eax
f010f1bf:	83 ec 08             	sub    $0x8,%esp
f010f1c2:	68 92 73 12 f0       	push   $0xf0127392
f010f1c7:	50                   	push   %eax
f010f1c8:	e8 72 14 01 00       	call   f012063f <strcmp>
f010f1cd:	83 c4 10             	add    $0x10,%esp
f010f1d0:	85 c0                	test   %eax,%eax
f010f1d2:	75 07                	jne    f010f1db <tst_paging_manipulation+0x71>
	{
		test_pt_set_page_permissions_invalid_va();
f010f1d4:	e8 4c 2c 00 00       	call   f0111e25 <test_pt_set_page_permissions_invalid_va>
f010f1d9:	eb 6a                	jmp    f010f245 <tst_paging_manipulation+0xdb>
	}
	// Test 2-Get permissions: tstpg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f010f1db:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1de:	83 c0 04             	add    $0x4,%eax
f010f1e1:	8b 00                	mov    (%eax),%eax
f010f1e3:	83 ec 08             	sub    $0x8,%esp
f010f1e6:	68 9a 73 12 f0       	push   $0xf012739a
f010f1eb:	50                   	push   %eax
f010f1ec:	e8 4e 14 01 00       	call   f012063f <strcmp>
f010f1f1:	83 c4 10             	add    $0x10,%esp
f010f1f4:	85 c0                	test   %eax,%eax
f010f1f6:	75 07                	jne    f010f1ff <tst_paging_manipulation+0x95>
	{
		test_pt_get_page_permissions();
f010f1f8:	e8 71 2c 00 00       	call   f0111e6e <test_pt_get_page_permissions>
f010f1fd:	eb 46                	jmp    f010f245 <tst_paging_manipulation+0xdb>
	}
	// Test 3.1-Clear entry: tstpg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f010f1ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f202:	83 c0 04             	add    $0x4,%eax
f010f205:	8b 00                	mov    (%eax),%eax
f010f207:	83 ec 08             	sub    $0x8,%esp
f010f20a:	68 a2 73 12 f0       	push   $0xf01273a2
f010f20f:	50                   	push   %eax
f010f210:	e8 2a 14 01 00       	call   f012063f <strcmp>
f010f215:	83 c4 10             	add    $0x10,%esp
f010f218:	85 c0                	test   %eax,%eax
f010f21a:	75 07                	jne    f010f223 <tst_paging_manipulation+0xb9>
	{
		test_pt_clear_page_table_entry();
f010f21c:	e8 91 2d 00 00       	call   f0111fb2 <test_pt_clear_page_table_entry>
f010f221:	eb 22                	jmp    f010f245 <tst_paging_manipulation+0xdb>
	}
	// Test 3.2-Clear entry: tstpg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f010f223:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f226:	83 c0 04             	add    $0x4,%eax
f010f229:	8b 00                	mov    (%eax),%eax
f010f22b:	83 ec 08             	sub    $0x8,%esp
f010f22e:	68 a9 73 12 f0       	push   $0xf01273a9
f010f233:	50                   	push   %eax
f010f234:	e8 06 14 01 00       	call   f012063f <strcmp>
f010f239:	83 c4 10             	add    $0x10,%esp
f010f23c:	85 c0                	test   %eax,%eax
f010f23e:	75 05                	jne    f010f245 <tst_paging_manipulation+0xdb>
	{
		test_pt_clear_page_table_entry_invalid_va();
f010f240:	e8 c6 2e 00 00       	call   f011210b <test_pt_clear_page_table_entry_invalid_va>
	// Test 4-Convert virtual to physical: tstpg v2p
//	else if(strcmp(arguments[1], "v2p") == 0)
//	{
//		test_virtual_to_physical();
//	}
	return 0;
f010f245:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f24a:	c9                   	leave  
f010f24b:	c3                   	ret    

f010f24c <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f010f24c:	55                   	push   %ebp
f010f24d:	89 e5                	mov    %esp,%ebp
f010f24f:	83 ec 18             	sub    $0x18,%esp
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f010f252:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f255:	83 c0 08             	add    $0x8,%eax
f010f258:	8b 00                	mov    (%eax),%eax
f010f25a:	83 ec 08             	sub    $0x8,%esp
f010f25d:	68 b0 73 12 f0       	push   $0xf01273b0
f010f262:	50                   	push   %eax
f010f263:	e8 d7 13 01 00       	call   f012063f <strcmp>
f010f268:	83 c4 10             	add    $0x10,%esp
f010f26b:	85 c0                	test   %eax,%eax
f010f26d:	75 20                	jne    f010f28f <tst_kheap+0x43>
f010f26f:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010f273:	74 1a                	je     f010f28f <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <1 or 2 or 3>\n") ;
f010f275:	83 ec 0c             	sub    $0xc,%esp
f010f278:	68 b8 73 12 f0       	push   $0xf01273b8
f010f27d:	e8 ea 1c ff ff       	call   f0100f6c <cprintf>
f010f282:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f285:	b8 00 00 00 00       	mov    $0x0,%eax
f010f28a:	e9 f6 03 00 00       	jmp    f010f685 <tst_kheap+0x439>
	}
	if (strcmp(arguments[2], "kmalloc") != 0 && number_of_arguments != 3)
f010f28f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f292:	83 c0 08             	add    $0x8,%eax
f010f295:	8b 00                	mov    (%eax),%eax
f010f297:	83 ec 08             	sub    $0x8,%esp
f010f29a:	68 b0 73 12 f0       	push   $0xf01273b0
f010f29f:	50                   	push   %eax
f010f2a0:	e8 9a 13 01 00       	call   f012063f <strcmp>
f010f2a5:	83 c4 10             	add    $0x10,%esp
f010f2a8:	85 c0                	test   %eax,%eax
f010f2aa:	74 43                	je     f010f2ef <tst_kheap+0xa3>
f010f2ac:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010f2b0:	74 3d                	je     f010f2ef <tst_kheap+0xa3>
	{
		if (strcmp(arguments[2], "krealloc") != 0 && number_of_arguments != 5)
f010f2b2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2b5:	83 c0 08             	add    $0x8,%eax
f010f2b8:	8b 00                	mov    (%eax),%eax
f010f2ba:	83 ec 08             	sub    $0x8,%esp
f010f2bd:	68 08 74 12 f0       	push   $0xf0127408
f010f2c2:	50                   	push   %eax
f010f2c3:	e8 77 13 01 00       	call   f012063f <strcmp>
f010f2c8:	83 c4 10             	add    $0x10,%esp
f010f2cb:	85 c0                	test   %eax,%eax
f010f2cd:	74 20                	je     f010f2ef <tst_kheap+0xa3>
f010f2cf:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
f010f2d3:	74 1a                	je     f010f2ef <tst_kheap+0xa3>
		{
			cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> <testname>\n") ;
f010f2d5:	83 ec 0c             	sub    $0xc,%esp
f010f2d8:	68 14 74 12 f0       	push   $0xf0127414
f010f2dd:	e8 8a 1c ff ff       	call   f0100f6c <cprintf>
f010f2e2:	83 c4 10             	add    $0x10,%esp
			return 0;
f010f2e5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2ea:	e9 96 03 00 00       	jmp    f010f685 <tst_kheap+0x439>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f010f2ef:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2f2:	83 c0 04             	add    $0x4,%eax
f010f2f5:	8b 00                	mov    (%eax),%eax
f010f2f7:	83 ec 08             	sub    $0x8,%esp
f010f2fa:	68 59 74 12 f0       	push   $0xf0127459
f010f2ff:	50                   	push   %eax
f010f300:	e8 3a 13 01 00       	call   f012063f <strcmp>
f010f305:	83 c4 10             	add    $0x10,%esp
f010f308:	85 c0                	test   %eax,%eax
f010f30a:	74 1d                	je     f010f329 <tst_kheap+0xdd>
f010f30c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f30f:	83 c0 04             	add    $0x4,%eax
f010f312:	8b 00                	mov    (%eax),%eax
f010f314:	83 ec 08             	sub    $0x8,%esp
f010f317:	68 5c 74 12 f0       	push   $0xf012745c
f010f31c:	50                   	push   %eax
f010f31d:	e8 1d 13 01 00       	call   f012063f <strcmp>
f010f322:	83 c4 10             	add    $0x10,%esp
f010f325:	85 c0                	test   %eax,%eax
f010f327:	75 1a                	jne    f010f343 <tst_kheap+0xf7>
	{
		setKHeapPlacementStrategyFIRSTFIT();
f010f329:	e8 6d f8 ff ff       	call   f010eb9b <setKHeapPlacementStrategyFIRSTFIT>
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f010f32e:	83 ec 0c             	sub    $0xc,%esp
f010f331:	68 60 74 12 f0       	push   $0xf0127460
f010f336:	e8 31 1c ff ff       	call   f0100f6c <cprintf>
f010f33b:	83 c4 10             	add    $0x10,%esp
f010f33e:	e9 a0 00 00 00       	jmp    f010f3e3 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f010f343:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f346:	83 c0 04             	add    $0x4,%eax
f010f349:	8b 00                	mov    (%eax),%eax
f010f34b:	83 ec 08             	sub    $0x8,%esp
f010f34e:	68 8d 74 12 f0       	push   $0xf012748d
f010f353:	50                   	push   %eax
f010f354:	e8 e6 12 01 00       	call   f012063f <strcmp>
f010f359:	83 c4 10             	add    $0x10,%esp
f010f35c:	85 c0                	test   %eax,%eax
f010f35e:	74 1d                	je     f010f37d <tst_kheap+0x131>
f010f360:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f363:	83 c0 04             	add    $0x4,%eax
f010f366:	8b 00                	mov    (%eax),%eax
f010f368:	83 ec 08             	sub    $0x8,%esp
f010f36b:	68 90 74 12 f0       	push   $0xf0127490
f010f370:	50                   	push   %eax
f010f371:	e8 c9 12 01 00       	call   f012063f <strcmp>
f010f376:	83 c4 10             	add    $0x10,%esp
f010f379:	85 c0                	test   %eax,%eax
f010f37b:	75 17                	jne    f010f394 <tst_kheap+0x148>
	{
		setKHeapPlacementStrategyBESTFIT();
f010f37d:	e8 29 f8 ff ff       	call   f010ebab <setKHeapPlacementStrategyBESTFIT>
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f010f382:	83 ec 0c             	sub    $0xc,%esp
f010f385:	68 94 74 12 f0       	push   $0xf0127494
f010f38a:	e8 dd 1b ff ff       	call   f0100f6c <cprintf>
f010f38f:	83 c4 10             	add    $0x10,%esp
f010f392:	eb 4f                	jmp    f010f3e3 <tst_kheap+0x197>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f010f394:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f397:	83 c0 04             	add    $0x4,%eax
f010f39a:	8b 00                	mov    (%eax),%eax
f010f39c:	83 ec 08             	sub    $0x8,%esp
f010f39f:	68 c0 74 12 f0       	push   $0xf01274c0
f010f3a4:	50                   	push   %eax
f010f3a5:	e8 95 12 01 00       	call   f012063f <strcmp>
f010f3aa:	83 c4 10             	add    $0x10,%esp
f010f3ad:	85 c0                	test   %eax,%eax
f010f3af:	74 1d                	je     f010f3ce <tst_kheap+0x182>
f010f3b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3b4:	83 c0 04             	add    $0x4,%eax
f010f3b7:	8b 00                	mov    (%eax),%eax
f010f3b9:	83 ec 08             	sub    $0x8,%esp
f010f3bc:	68 c3 74 12 f0       	push   $0xf01274c3
f010f3c1:	50                   	push   %eax
f010f3c2:	e8 78 12 01 00       	call   f012063f <strcmp>
f010f3c7:	83 c4 10             	add    $0x10,%esp
f010f3ca:	85 c0                	test   %eax,%eax
f010f3cc:	75 15                	jne    f010f3e3 <tst_kheap+0x197>
	{
		setKHeapPlacementStrategyNEXTFIT();
f010f3ce:	e8 e8 f7 ff ff       	call   f010ebbb <setKHeapPlacementStrategyNEXTFIT>
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f010f3d3:	83 ec 0c             	sub    $0xc,%esp
f010f3d6:	68 c8 74 12 f0       	push   $0xf01274c8
f010f3db:	e8 8c 1b ff ff       	call   f0100f6c <cprintf>
f010f3e0:	83 c4 10             	add    $0x10,%esp
	}

	// Test 1-kmalloc: tst kheap FF kmalloc 1
	if(strcmp(arguments[2], "kmalloc") == 0)
f010f3e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f3e6:	83 c0 08             	add    $0x8,%eax
f010f3e9:	8b 00                	mov    (%eax),%eax
f010f3eb:	83 ec 08             	sub    $0x8,%esp
f010f3ee:	68 b0 73 12 f0       	push   $0xf01273b0
f010f3f3:	50                   	push   %eax
f010f3f4:	e8 46 12 01 00       	call   f012063f <strcmp>
f010f3f9:	83 c4 10             	add    $0x10,%esp
f010f3fc:	85 c0                	test   %eax,%eax
f010f3fe:	0f 85 13 01 00 00    	jne    f010f517 <tst_kheap+0x2cb>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f404:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f407:	83 c0 0c             	add    $0xc,%eax
f010f40a:	8b 00                	mov    (%eax),%eax
f010f40c:	83 ec 04             	sub    $0x4,%esp
f010f40f:	6a 0a                	push   $0xa
f010f411:	6a 00                	push   $0x0
f010f413:	50                   	push   %eax
f010f414:	e8 7a 14 01 00       	call   f0120893 <strtol>
f010f419:	83 c4 10             	add    $0x10,%esp
f010f41c:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f41f:	e8 a7 f7 ff ff       	call   f010ebcb <isKHeapPlacementStrategyFIRSTFIT>
f010f424:	84 c0                	test   %al,%al
f010f426:	74 54                	je     f010f47c <tst_kheap+0x230>
		{
			if (testNum == 0)
f010f428:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f42c:	75 1a                	jne    f010f448 <tst_kheap+0x1fc>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f42e:	83 ec 0c             	sub    $0xc,%esp
f010f431:	68 f4 74 12 f0       	push   $0xf01274f4
f010f436:	e8 31 1b ff ff       	call   f0100f6c <cprintf>
f010f43b:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f43e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f443:	e9 3d 02 00 00       	jmp    f010f685 <tst_kheap+0x439>
			}
			//Test FIRST FIT allocation
			if (testNum == 1)
f010f448:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f44c:	75 0a                	jne    f010f458 <tst_kheap+0x20c>
				test_kmalloc();
f010f44e:	e8 ba 8d 00 00       	call   f011820d <test_kmalloc>
f010f453:	e9 b5 00 00 00       	jmp    f010f50d <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f458:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f45c:	75 0a                	jne    f010f468 <tst_kheap+0x21c>
				test_kmalloc_firstfit1();
f010f45e:	e8 c4 98 00 00       	call   f0118d27 <test_kmalloc_firstfit1>
f010f463:	e9 a5 00 00 00       	jmp    f010f50d <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f468:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f46c:	0f 85 9b 00 00 00    	jne    f010f50d <tst_kheap+0x2c1>
				test_kmalloc_firstfit2();
f010f472:	e8 44 a3 00 00       	call   f01197bb <test_kmalloc_firstfit2>
f010f477:	e9 91 00 00 00       	jmp    f010f50d <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyBESTFIT())
f010f47c:	e8 5f f7 ff ff       	call   f010ebe0 <isKHeapPlacementStrategyBESTFIT>
f010f481:	84 c0                	test   %al,%al
f010f483:	74 47                	je     f010f4cc <tst_kheap+0x280>
		{
			if (testNum == 0)
f010f485:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f489:	75 1a                	jne    f010f4a5 <tst_kheap+0x259>
			{
				cprintf("Error: [Kernel.BestFit] must specify the test number (1, 2, 3) as an argument\n");
f010f48b:	83 ec 0c             	sub    $0xc,%esp
f010f48e:	68 44 75 12 f0       	push   $0xf0127544
f010f493:	e8 d4 1a ff ff       	call   f0100f6c <cprintf>
f010f498:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f49b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4a0:	e9 e0 01 00 00       	jmp    f010f685 <tst_kheap+0x439>
			}
			if (testNum == 1)
f010f4a5:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f4a9:	75 07                	jne    f010f4b2 <tst_kheap+0x266>
				test_kmalloc();
f010f4ab:	e8 5d 8d 00 00       	call   f011820d <test_kmalloc>
f010f4b0:	eb 5b                	jmp    f010f50d <tst_kheap+0x2c1>
			else if (testNum == 2)
f010f4b2:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f4b6:	75 07                	jne    f010f4bf <tst_kheap+0x273>
				test_kmalloc_bestfit1();
f010f4b8:	e8 cb e8 00 00       	call   f011dd88 <test_kmalloc_bestfit1>
f010f4bd:	eb 4e                	jmp    f010f50d <tst_kheap+0x2c1>
			else if (testNum == 3)
f010f4bf:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f010f4c3:	75 48                	jne    f010f50d <tst_kheap+0x2c1>
				test_kmalloc_bestfit2();
f010f4c5:	e8 db e8 00 00       	call   f011dda5 <test_kmalloc_bestfit2>
f010f4ca:	eb 41                	jmp    f010f50d <tst_kheap+0x2c1>
		}
		else if(isKHeapPlacementStrategyNEXTFIT())
f010f4cc:	e8 24 f7 ff ff       	call   f010ebf5 <isKHeapPlacementStrategyNEXTFIT>
f010f4d1:	84 c0                	test   %al,%al
f010f4d3:	74 38                	je     f010f50d <tst_kheap+0x2c1>
		{
			if (testNum == 0)
f010f4d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f4d9:	75 1a                	jne    f010f4f5 <tst_kheap+0x2a9>
			{
				cprintf("Error: [Kernel.NextFit] must specify the test number (1 or 2) as an argument\n");
f010f4db:	83 ec 0c             	sub    $0xc,%esp
f010f4de:	68 94 75 12 f0       	push   $0xf0127594
f010f4e3:	e8 84 1a ff ff       	call   f0100f6c <cprintf>
f010f4e8:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f4eb:	b8 00 00 00 00       	mov    $0x0,%eax
f010f4f0:	e9 90 01 00 00       	jmp    f010f685 <tst_kheap+0x439>
			}
			//Test cont. allocation
			if (testNum == 1)
f010f4f5:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010f4f9:	75 07                	jne    f010f502 <tst_kheap+0x2b6>
				test_kmalloc();
f010f4fb:	e8 0d 8d 00 00       	call   f011820d <test_kmalloc>
f010f500:	eb 0b                	jmp    f010f50d <tst_kheap+0x2c1>
			//Test nextfit strategy
			else if (testNum == 2)
f010f502:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010f506:	75 05                	jne    f010f50d <tst_kheap+0x2c1>
				test_kmalloc_nextfit();
f010f508:	e8 5b e8 00 00       	call   f011dd68 <test_kmalloc_nextfit>
		}
		return 0;
f010f50d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f512:	e9 6e 01 00 00       	jmp    f010f685 <tst_kheap+0x439>
	}
	// Test 2-kfree: tst kheap FF kfree
	else if(strcmp(arguments[2], "kfree") == 0)
f010f517:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f51a:	83 c0 08             	add    $0x8,%eax
f010f51d:	8b 00                	mov    (%eax),%eax
f010f51f:	83 ec 08             	sub    $0x8,%esp
f010f522:	68 e2 75 12 f0       	push   $0xf01275e2
f010f527:	50                   	push   %eax
f010f528:	e8 12 11 01 00       	call   f012063f <strcmp>
f010f52d:	83 c4 10             	add    $0x10,%esp
f010f530:	85 c0                	test   %eax,%eax
f010f532:	75 28                	jne    f010f55c <tst_kheap+0x310>
	{
		if (isKHeapPlacementStrategyBESTFIT() || isKHeapPlacementStrategyFIRSTFIT())
f010f534:	e8 a7 f6 ff ff       	call   f010ebe0 <isKHeapPlacementStrategyBESTFIT>
f010f539:	84 c0                	test   %al,%al
f010f53b:	75 09                	jne    f010f546 <tst_kheap+0x2fa>
f010f53d:	e8 89 f6 ff ff       	call   f010ebcb <isKHeapPlacementStrategyFIRSTFIT>
f010f542:	84 c0                	test   %al,%al
f010f544:	74 07                	je     f010f54d <tst_kheap+0x301>
		{
			test_kfree_bestfirstfit();
f010f546:	e8 29 ad 00 00       	call   f011a274 <test_kfree_bestfirstfit>
f010f54b:	eb 05                	jmp    f010f552 <tst_kheap+0x306>
		}
		else //NEXT & CONT
		{
			test_kfree();
f010f54d:	e8 90 e8 00 00       	call   f011dde2 <test_kfree>
		}
		return 0;
f010f552:	b8 00 00 00 00       	mov    $0x0,%eax
f010f557:	e9 29 01 00 00       	jmp    f010f685 <tst_kheap+0x439>
	}
	// Test 3-kphysaddr: tst kheap FF kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f010f55c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f55f:	83 c0 08             	add    $0x8,%eax
f010f562:	8b 00                	mov    (%eax),%eax
f010f564:	83 ec 08             	sub    $0x8,%esp
f010f567:	68 e8 75 12 f0       	push   $0xf01275e8
f010f56c:	50                   	push   %eax
f010f56d:	e8 cd 10 01 00       	call   f012063f <strcmp>
f010f572:	83 c4 10             	add    $0x10,%esp
f010f575:	85 c0                	test   %eax,%eax
f010f577:	75 0f                	jne    f010f588 <tst_kheap+0x33c>
	{
		test_kheap_phys_addr();
f010f579:	e8 01 c3 00 00       	call   f011b87f <test_kheap_phys_addr>
		return 0;
f010f57e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f583:	e9 fd 00 00 00       	jmp    f010f685 <tst_kheap+0x439>
	}
	// Test 4-kvirtaddr: tst kheap FF kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f010f588:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f58b:	83 c0 08             	add    $0x8,%eax
f010f58e:	8b 00                	mov    (%eax),%eax
f010f590:	83 ec 08             	sub    $0x8,%esp
f010f593:	68 f2 75 12 f0       	push   $0xf01275f2
f010f598:	50                   	push   %eax
f010f599:	e8 a1 10 01 00       	call   f012063f <strcmp>
f010f59e:	83 c4 10             	add    $0x10,%esp
f010f5a1:	85 c0                	test   %eax,%eax
f010f5a3:	75 0f                	jne    f010f5b4 <tst_kheap+0x368>
	{
		test_kheap_virt_addr();
f010f5a5:	e8 4f d0 00 00       	call   f011c5f9 <test_kheap_virt_addr>
		return 0;
f010f5aa:	b8 00 00 00 00       	mov    $0x0,%eax
f010f5af:	e9 d1 00 00 00       	jmp    f010f685 <tst_kheap+0x439>
	}
	// Test 5-krealloc: tst kheap BF krealloc
	else if(strcmp(arguments[2], "krealloc") == 0)
f010f5b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5b7:	83 c0 08             	add    $0x8,%eax
f010f5ba:	8b 00                	mov    (%eax),%eax
f010f5bc:	83 ec 08             	sub    $0x8,%esp
f010f5bf:	68 08 74 12 f0       	push   $0xf0127408
f010f5c4:	50                   	push   %eax
f010f5c5:	e8 75 10 01 00       	call   f012063f <strcmp>
f010f5ca:	83 c4 10             	add    $0x10,%esp
f010f5cd:	85 c0                	test   %eax,%eax
f010f5cf:	0f 85 89 00 00 00    	jne    f010f65e <tst_kheap+0x412>
	{
		uint32 testNum = strtol(arguments[3], NULL, 10);
f010f5d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d8:	83 c0 0c             	add    $0xc,%eax
f010f5db:	8b 00                	mov    (%eax),%eax
f010f5dd:	83 ec 04             	sub    $0x4,%esp
f010f5e0:	6a 0a                	push   $0xa
f010f5e2:	6a 00                	push   $0x0
f010f5e4:	50                   	push   %eax
f010f5e5:	e8 a9 12 01 00       	call   f0120893 <strtol>
f010f5ea:	83 c4 10             	add    $0x10,%esp
f010f5ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(isKHeapPlacementStrategyFIRSTFIT())
f010f5f0:	e8 d6 f5 ff ff       	call   f010ebcb <isKHeapPlacementStrategyFIRSTFIT>
f010f5f5:	84 c0                	test   %al,%al
f010f5f7:	74 42                	je     f010f63b <tst_kheap+0x3ef>
		{
			if (testNum == 0)
f010f5f9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f5fd:	75 17                	jne    f010f616 <tst_kheap+0x3ca>
			{
				cprintf("Error: [Kernel.FirstFit] must specify the test number (1 or 2) as an argument\n");
f010f5ff:	83 ec 0c             	sub    $0xc,%esp
f010f602:	68 f4 74 12 f0       	push   $0xf01274f4
f010f607:	e8 60 19 ff ff       	call   f0100f6c <cprintf>
f010f60c:	83 c4 10             	add    $0x10,%esp
				return 0;
f010f60f:	b8 00 00 00 00       	mov    $0x0,%eax
f010f614:	eb 6f                	jmp    f010f685 <tst_kheap+0x439>
			}
			if (testNum==1)
f010f616:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f010f61a:	75 07                	jne    f010f623 <tst_kheap+0x3d7>
				test_krealloc_FF1();
f010f61c:	e8 a7 ea 00 00       	call   f011e0c8 <test_krealloc_FF1>
f010f621:	eb 18                	jmp    f010f63b <tst_kheap+0x3ef>
			else if (testNum==2)
f010f623:	83 7d f0 02          	cmpl   $0x2,-0x10(%ebp)
f010f627:	75 07                	jne    f010f630 <tst_kheap+0x3e4>
				test_krealloc_FF2();
f010f629:	e8 e7 ea 00 00       	call   f011e115 <test_krealloc_FF2>
f010f62e:	eb 0b                	jmp    f010f63b <tst_kheap+0x3ef>
			else if (testNum==3)
f010f630:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f010f634:	75 05                	jne    f010f63b <tst_kheap+0x3ef>
				test_krealloc_FF3();
f010f636:	e8 27 eb 00 00       	call   f011e162 <test_krealloc_FF3>
		}
		if (isKHeapPlacementStrategyNEXTFIT())
f010f63b:	e8 b5 f5 ff ff       	call   f010ebf5 <isKHeapPlacementStrategyNEXTFIT>
f010f640:	84 c0                	test   %al,%al
f010f642:	74 05                	je     f010f649 <tst_kheap+0x3fd>
		{
			test_krealloc();
f010f644:	e8 e5 e9 00 00       	call   f011e02e <test_krealloc>
		}
		if (isKHeapPlacementStrategyBESTFIT())
f010f649:	e8 92 f5 ff ff       	call   f010ebe0 <isKHeapPlacementStrategyBESTFIT>
f010f64e:	84 c0                	test   %al,%al
f010f650:	74 05                	je     f010f657 <tst_kheap+0x40b>
		{
			test_krealloc_BF();
f010f652:	e8 24 ea 00 00       	call   f011e07b <test_krealloc_BF>
		}
		return 0;
f010f657:	b8 00 00 00 00       	mov    $0x0,%eax
f010f65c:	eb 27                	jmp    f010f685 <tst_kheap+0x439>
	}
	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
f010f65e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f661:	83 c0 08             	add    $0x8,%eax
f010f664:	8b 00                	mov    (%eax),%eax
f010f666:	83 ec 08             	sub    $0x8,%esp
f010f669:	68 fc 75 12 f0       	push   $0xf01275fc
f010f66e:	50                   	push   %eax
f010f66f:	e8 cb 0f 01 00       	call   f012063f <strcmp>
f010f674:	83 c4 10             	add    $0x10,%esp
f010f677:	85 c0                	test   %eax,%eax
f010f679:	75 05                	jne    f010f680 <tst_kheap+0x434>
	{
		test_ksbrk();
f010f67b:	e8 13 dc 00 00       	call   f011d293 <test_ksbrk>
	}
	return 0;
f010f680:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f685:	c9                   	leave  
f010f686:	c3                   	ret    

f010f687 <test_initialize_dynamic_allocator>:

#define Mega  (1024*1024)
#define kilo (1024)

void test_initialize_dynamic_allocator()
{
f010f687:	55                   	push   %ebp
f010f688:	89 e5                	mov    %esp,%ebp
f010f68a:	83 ec 28             	sub    $0x28,%esp
	panic("test_initialize_dynamic_allocator: the kernel heap should be diabled. make sure USE_KHEAP = 0");
	return;
#endif

	//write initial data at the start (for checking)
	int* tmp_ptr = (int*)KERNEL_HEAP_START;
f010f68d:	c7 45 f4 00 00 00 f6 	movl   $0xf6000000,-0xc(%ebp)
	*tmp_ptr = -1 ;
f010f694:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f697:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	*(tmp_ptr+1) = 1 ;
f010f69d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f6a0:	83 c0 04             	add    $0x4,%eax
f010f6a3:	c7 00 01 00 00 00    	movl   $0x1,(%eax)

	uint32 initAllocatedSpace = 2*Mega;
f010f6a9:	c7 45 f0 00 00 20 00 	movl   $0x200000,-0x10(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010f6b0:	83 ec 08             	sub    $0x8,%esp
f010f6b3:	ff 75 f0             	pushl  -0x10(%ebp)
f010f6b6:	68 00 00 00 f6       	push   $0xf6000000
f010f6bb:	e8 42 1a 01 00       	call   f0121102 <initialize_dynamic_allocator>
f010f6c0:	83 c4 10             	add    $0x10,%esp


	//Check#1: Metadata
	uint32* daBeg = (uint32*) KERNEL_HEAP_START ;
f010f6c3:	c7 45 ec 00 00 00 f6 	movl   $0xf6000000,-0x14(%ebp)
	uint32* daEnd = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - sizeof(int));
f010f6ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f6cd:	2d 04 00 00 0a       	sub    $0xa000004,%eax
f010f6d2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32* blkHeader = (uint32*) (KERNEL_HEAP_START + sizeof(int));
f010f6d5:	c7 45 e4 04 00 00 f6 	movl   $0xf6000004,-0x1c(%ebp)
	uint32* blkFooter = (uint32*) (KERNEL_HEAP_START +  initAllocatedSpace - 2*sizeof(int));
f010f6dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f6df:	2d 08 00 00 0a       	sub    $0xa000008,%eax
f010f6e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (*daBeg != 1 || *daEnd != 1 || (*blkHeader != initAllocatedSpace - 2*sizeof(int))|| (*blkFooter != initAllocatedSpace - 2*sizeof(int)))
f010f6e7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f6ea:	8b 00                	mov    (%eax),%eax
f010f6ec:	83 f8 01             	cmp    $0x1,%eax
f010f6ef:	75 28                	jne    f010f719 <test_initialize_dynamic_allocator+0x92>
f010f6f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f6f4:	8b 00                	mov    (%eax),%eax
f010f6f6:	83 f8 01             	cmp    $0x1,%eax
f010f6f9:	75 1e                	jne    f010f719 <test_initialize_dynamic_allocator+0x92>
f010f6fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f6fe:	8b 00                	mov    (%eax),%eax
f010f700:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f703:	83 ea 08             	sub    $0x8,%edx
f010f706:	39 d0                	cmp    %edx,%eax
f010f708:	75 0f                	jne    f010f719 <test_initialize_dynamic_allocator+0x92>
f010f70a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f70d:	8b 00                	mov    (%eax),%eax
f010f70f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f712:	83 ea 08             	sub    $0x8,%edx
f010f715:	39 d0                	cmp    %edx,%eax
f010f717:	74 14                	je     f010f72d <test_initialize_dynamic_allocator+0xa6>
	{
		panic("Content of header/footer and/or DA begin/end are not set correctly");
f010f719:	83 ec 04             	sub    $0x4,%esp
f010f71c:	68 04 76 12 f0       	push   $0xf0127604
f010f721:	6a 2b                	push   $0x2b
f010f723:	68 48 76 12 f0       	push   $0xf0127648
f010f728:	e8 ed 0b ff ff       	call   f010031a <_panic>
	}
	if (LIST_SIZE(&freeBlocksList) != 1 || (uint32)LIST_FIRST(&freeBlocksList) != KERNEL_HEAP_START + 2*sizeof(int))
f010f72d:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010f732:	83 f8 01             	cmp    $0x1,%eax
f010f735:	75 0c                	jne    f010f743 <test_initialize_dynamic_allocator+0xbc>
f010f737:	a1 b0 25 55 f0       	mov    0xf05525b0,%eax
f010f73c:	3d 08 00 00 f6       	cmp    $0xf6000008,%eax
f010f741:	74 14                	je     f010f757 <test_initialize_dynamic_allocator+0xd0>
	{
		panic("free block is not added correctly");
f010f743:	83 ec 04             	sub    $0x4,%esp
f010f746:	68 6c 76 12 f0       	push   $0xf012766c
f010f74b:	6a 2f                	push   $0x2f
f010f74d:	68 48 76 12 f0       	push   $0xf0127648
f010f752:	e8 c3 0b ff ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test initialize_dynamic_allocator completed successfully.\n");
f010f757:	83 ec 0c             	sub    $0xc,%esp
f010f75a:	68 90 76 12 f0       	push   $0xf0127690
f010f75f:	e8 08 18 ff ff       	call   f0100f6c <cprintf>
f010f764:	83 c4 10             	add    $0x10,%esp
}
f010f767:	90                   	nop
f010f768:	c9                   	leave  
f010f769:	c3                   	ret    

f010f76a <test_initial_alloc>:
short* startVAs[numOfAllocs*allocCntPerSize+1] ;
short* midVAs[numOfAllocs*allocCntPerSize+1] ;
short* endVAs[numOfAllocs*allocCntPerSize+1] ;

int test_initial_alloc(int ALLOC_STRATEGY)
{
f010f76a:	55                   	push   %ebp
f010f76b:	89 e5                	mov    %esp,%ebp
f010f76d:	83 ec 48             	sub    $0x48,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return 0;
#endif

	int eval = 0;
f010f770:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct = 1;
f010f777:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int initAllocatedSpace = 3*Mega;
f010f77e:	c7 45 d0 00 00 30 00 	movl   $0x300000,-0x30(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f010f785:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f788:	83 ec 08             	sub    $0x8,%esp
f010f78b:	50                   	push   %eax
f010f78c:	68 00 00 00 f6       	push   $0xf6000000
f010f791:	e8 6c 19 01 00       	call   f0121102 <initialize_dynamic_allocator>
f010f796:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/*INITIAL ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f010f799:	83 ec 0c             	sub    $0xc,%esp
f010f79c:	68 e0 76 12 f0       	push   $0xf01276e0
f010f7a1:	e8 c6 17 ff ff       	call   f0100f6c <cprintf>
f010f7a6:	83 c4 10             	add    $0x10,%esp

	is_correct = 1;
f010f7a9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	va = alloc_block(3*initAllocatedSpace, ALLOC_STRATEGY);
f010f7b0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f7b3:	89 c2                	mov    %eax,%edx
f010f7b5:	01 d2                	add    %edx,%edx
f010f7b7:	01 d0                	add    %edx,%eax
f010f7b9:	83 ec 08             	sub    $0x8,%esp
f010f7bc:	ff 75 08             	pushl  0x8(%ebp)
f010f7bf:	50                   	push   %eax
f010f7c0:	e8 10 18 01 00       	call   f0120fd5 <alloc_block>
f010f7c5:	83 c4 10             	add    $0x10,%esp
f010f7c8:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010f7cb:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010f7cf:	74 17                	je     f010f7e8 <test_initial_alloc+0x7e>
	{
		is_correct = 0;
f010f7d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #1: should not be allocated.\n");
f010f7d8:	83 ec 0c             	sub    $0xc,%esp
f010f7db:	68 1c 77 12 f0       	push   $0xf012771c
f010f7e0:	e8 87 17 ff ff       	call   f0100f6c <cprintf>
f010f7e5:	83 c4 10             	add    $0x10,%esp
	}
	va = alloc_block(initAllocatedSpace, ALLOC_STRATEGY);
f010f7e8:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f7eb:	83 ec 08             	sub    $0x8,%esp
f010f7ee:	ff 75 08             	pushl  0x8(%ebp)
f010f7f1:	50                   	push   %eax
f010f7f2:	e8 de 17 01 00       	call   f0120fd5 <alloc_block>
f010f7f7:	83 c4 10             	add    $0x10,%esp
f010f7fa:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//Check returned va
	if(va != NULL)
f010f7fd:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010f801:	74 17                	je     f010f81a <test_initial_alloc+0xb0>
	{
		is_correct = 0;
f010f803:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #2: should not be allocated.\n");
f010f80a:	83 ec 0c             	sub    $0xc,%esp
f010f80d:	68 4c 77 12 f0       	push   $0xf012774c
f010f812:	e8 55 17 ff ff       	call   f0100f6c <cprintf>
f010f817:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f010f81a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f81e:	74 04                	je     f010f824 <test_initial_alloc+0xba>
	{
		eval += 5;
f010f820:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 2: Try to allocate set of blocks with different sizes*/
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
f010f824:	83 ec 0c             	sub    $0xc,%esp
f010f827:	68 7c 77 12 f0       	push   $0xf012777c
f010f82c:	e8 3b 17 ff ff       	call   f0100f6c <cprintf>
f010f831:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010f834:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	int totalSizes = 0;
f010f83b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f010f842:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f010f849:	eb 2a                	jmp    f010f875 <test_initial_alloc+0x10b>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f010f84b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f84e:	8b 14 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%edx
f010f855:	89 d0                	mov    %edx,%eax
f010f857:	c1 e0 02             	shl    $0x2,%eax
f010f85a:	01 d0                	add    %edx,%eax
f010f85c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010f863:	01 d0                	add    %edx,%eax
f010f865:	c1 e0 03             	shl    $0x3,%eax
f010f868:	89 c2                	mov    %eax,%edx
f010f86a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f86d:	01 d0                	add    %edx,%eax
f010f86f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	/*INITIAL ALLOC Scenario 2: Try to allocate set of blocks with different sizes*/
	cprintf("	2: Try to allocate set of blocks with different sizes [all should fit]\n\n") ;
	is_correct = 1;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f010f872:	ff 45 e8             	incl   -0x18(%ebp)
f010f875:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f010f879:	7e d0                	jle    f010f84b <test_initial_alloc+0xe1>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f010f87b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f87e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f010f881:	83 e8 08             	sub    $0x8,%eax
f010f884:	89 45 c8             	mov    %eax,-0x38(%ebp)
	//cprintf("\n********* Remaining size = %d\n", remainSize);
	if (remainSize <= 0)
f010f887:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010f88b:	7f 17                	jg     f010f8a4 <test_initial_alloc+0x13a>
	{
		is_correct = 0;
f010f88d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
f010f894:	83 ec 0c             	sub    $0xc,%esp
f010f897:	68 c8 77 12 f0       	push   $0xf01277c8
f010f89c:	e8 cb 16 ff ff       	call   f0100f6c <cprintf>
f010f8a1:	83 c4 10             	add    $0x10,%esp
	}
	int idx = 0;
f010f8a4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f010f8ab:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010f8b2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010f8b9:	e9 fc 00 00 00       	jmp    f010f9ba <test_initial_alloc+0x250>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010f8be:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010f8c5:	e9 e0 00 00 00       	jmp    f010f9aa <test_initial_alloc+0x240>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f010f8ca:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f8cd:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010f8d4:	83 e8 08             	sub    $0x8,%eax
f010f8d7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010f8da:	83 ec 08             	sub    $0x8,%esp
f010f8dd:	ff 75 08             	pushl  0x8(%ebp)
f010f8e0:	ff 75 c4             	pushl  -0x3c(%ebp)
f010f8e3:	e8 ed 16 01 00       	call   f0120fd5 <alloc_block>
f010f8e8:	83 c4 10             	add    $0x10,%esp
f010f8eb:	89 c2                	mov    %eax,%edx
f010f8ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f8f0:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f010f8f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f8fa:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010f901:	89 45 cc             	mov    %eax,-0x34(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f010f904:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010f907:	d1 e8                	shr    %eax
f010f909:	89 c2                	mov    %eax,%edx
f010f90b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f90e:	01 c2                	add    %eax,%edx
f010f910:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f913:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f010f91a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010f91d:	8d 50 fe             	lea    -0x2(%eax),%edx
f010f920:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f923:	01 c2                	add    %eax,%edx
f010f925:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f928:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
			//Check returned va
			if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f010f92f:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010f933:	74 0b                	je     f010f940 <test_initial_alloc+0x1d6>
f010f935:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f938:	83 c0 04             	add    $0x4,%eax
f010f93b:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010f93e:	74 27                	je     f010f967 <test_initial_alloc+0x1fd>
			{
				if (is_correct)
f010f940:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f944:	74 21                	je     f010f967 <test_initial_alloc+0x1fd>
				{
					is_correct = 0;
f010f946:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
					cprintf("alloc_block_xx #3.%d: WRONG ALLOC - alloc_block_xx return wrong address. Expected %x, Actual %x\n", idx, curVA + sizeOfMetaData ,va);
f010f94d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f950:	83 c0 08             	add    $0x8,%eax
f010f953:	ff 75 cc             	pushl  -0x34(%ebp)
f010f956:	50                   	push   %eax
f010f957:	ff 75 e4             	pushl  -0x1c(%ebp)
f010f95a:	68 44 78 12 f0       	push   $0xf0127844
f010f95f:	e8 08 16 ff ff       	call   f0100f6c <cprintf>
f010f964:	83 c4 10             	add    $0x10,%esp
				}
			}
			curVA += allocSizes[i] ;
f010f967:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010f96a:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010f971:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f010f974:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f977:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f010f97e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f981:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f010f984:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f987:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f010f98e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f991:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f010f994:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f997:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f010f99e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010f9a1:	66 89 02             	mov    %ax,(%edx)
			idx++;
f010f9a4:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f010f9a7:	ff 45 d8             	incl   -0x28(%ebp)
f010f9aa:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f010f9b1:	0f 8e 13 ff ff ff    	jle    f010f8ca <test_initial_alloc+0x160>
		cprintf("alloc_block_xx test is not configured correctly. Consider updating the initial allocated space OR the required allocations\n");
	}
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f010f9b7:	ff 45 dc             	incl   -0x24(%ebp)
f010f9ba:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f010f9be:	0f 8e fa fe ff ff    	jle    f010f8be <test_initial_alloc+0x154>
			idx++;
		}
		//if (is_correct == 0)
		//break;
	}
	if (is_correct)
f010f9c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010f9c8:	74 04                	je     f010f9ce <test_initial_alloc+0x264>
	{
		eval += 20;
f010f9ca:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f010f9ce:	83 ec 0c             	sub    $0xc,%esp
f010f9d1:	68 a8 78 12 f0       	push   $0xf01278a8
f010f9d6:	e8 91 15 ff ff       	call   f0100f6c <cprintf>
f010f9db:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010f9de:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	actualSize = remainSize - sizeOfMetaData;
f010f9e5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010f9e8:	83 e8 08             	sub    $0x8,%eax
f010f9eb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, ALLOC_STRATEGY);
f010f9ee:	83 ec 08             	sub    $0x8,%esp
f010f9f1:	ff 75 08             	pushl  0x8(%ebp)
f010f9f4:	ff 75 c4             	pushl  -0x3c(%ebp)
f010f9f7:	e8 d9 15 01 00       	call   f0120fd5 <alloc_block>
f010f9fc:	83 c4 10             	add    $0x10,%esp
f010f9ff:	89 c2                	mov    %eax,%edx
f010fa01:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa04:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f010fa0b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa0e:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010fa15:	89 45 cc             	mov    %eax,-0x34(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f010fa18:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fa1b:	d1 e8                	shr    %eax
f010fa1d:	89 c2                	mov    %eax,%edx
f010fa1f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fa22:	01 c2                	add    %eax,%edx
f010fa24:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa27:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f010fa2e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fa31:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fa34:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010fa37:	01 c2                	add    %eax,%edx
f010fa39:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa3c:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
	//Check returned va
	if(va == NULL || (va != (curVA + sizeOfMetaData/2)) || LIST_SIZE(&freeBlocksList) != 0)
f010fa43:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010fa47:	74 14                	je     f010fa5d <test_initial_alloc+0x2f3>
f010fa49:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fa4c:	83 c0 04             	add    $0x4,%eax
f010fa4f:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f010fa52:	75 09                	jne    f010fa5d <test_initial_alloc+0x2f3>
f010fa54:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fa59:	85 c0                	test   %eax,%eax
f010fa5b:	74 17                	je     f010fa74 <test_initial_alloc+0x30a>
	{
		is_correct = 0;
f010fa5d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("alloc_block_xx #4: WRONG ALLOC.\n");
f010fa64:	83 ec 0c             	sub    $0xc,%esp
f010fa67:	68 f4 78 12 f0       	push   $0xf01278f4
f010fa6c:	e8 fb 14 ff ff       	call   f0100f6c <cprintf>
f010fa71:	83 c4 10             	add    $0x10,%esp
	}
	*(startVAs[idx]) = idx ;
f010fa74:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa77:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f010fa7e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa81:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f010fa84:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa87:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f010fa8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa91:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f010fa94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fa97:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f010fa9e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010faa1:	66 89 02             	mov    %ax,(%edx)
	if (is_correct)
f010faa4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010faa8:	74 04                	je     f010faae <test_initial_alloc+0x344>
	{
		eval += 5;
f010faaa:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)
	}
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
f010faae:	83 ec 0c             	sub    $0xc,%esp
f010fab1:	68 18 79 12 f0       	push   $0xf0127918
f010fab6:	e8 b1 14 ff ff       	call   f0100f6c <cprintf>
f010fabb:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fabe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f010fac5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010facc:	eb 5b                	jmp    f010fb29 <test_initial_alloc+0x3bf>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f010face:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fad1:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010fad8:	66 8b 00             	mov    (%eax),%ax
f010fadb:	98                   	cwtl   
f010fadc:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010fadf:	75 26                	jne    f010fb07 <test_initial_alloc+0x39d>
f010fae1:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fae4:	8b 04 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%eax
f010faeb:	66 8b 00             	mov    (%eax),%ax
f010faee:	98                   	cwtl   
f010faef:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010faf2:	75 13                	jne    f010fb07 <test_initial_alloc+0x39d>
f010faf4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010faf7:	8b 04 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%eax
f010fafe:	66 8b 00             	mov    (%eax),%ax
f010fb01:	98                   	cwtl   
f010fb02:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010fb05:	74 1f                	je     f010fb26 <test_initial_alloc+0x3bc>
		{
			is_correct = 0;
f010fb07:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f010fb0e:	83 ec 04             	sub    $0x4,%esp
f010fb11:	ff 75 d4             	pushl  -0x2c(%ebp)
f010fb14:	ff 75 d4             	pushl  -0x2c(%ebp)
f010fb17:	68 4c 79 12 f0       	push   $0xf012794c
f010fb1c:	e8 4b 14 ff ff       	call   f0100f6c <cprintf>
f010fb21:	83 c4 10             	add    $0x10,%esp
			break;
f010fb24:	eb 0b                	jmp    f010fb31 <test_initial_alloc+0x3c7>
	//====================================================================//
	/*INITIAL ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f010fb26:	ff 45 d4             	incl   -0x2c(%ebp)
f010fb29:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fb2c:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f010fb2f:	7c 9d                	jl     f010face <test_initial_alloc+0x364>
			is_correct = 0;
			cprintf("alloc_block_xx #4.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
			break;
		}
	}
	if (is_correct)
f010fb31:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fb35:	74 04                	je     f010fb3b <test_initial_alloc+0x3d1>
	{
		eval += 10;
f010fb37:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}
	return eval;
f010fb3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010fb3e:	c9                   	leave  
f010fb3f:	c3                   	ret    

f010fb40 <test_alloc_block_FF>:

void test_alloc_block_FF()
{
f010fb40:	55                   	push   %ebp
f010fb41:	89 e5                	mov    %esp,%ebp
f010fb43:	57                   	push   %edi
f010fb44:	56                   	push   %esi
f010fb45:	53                   	push   %ebx
f010fb46:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
#if USE_KHEAP
	panic("test_alloc_block_FF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	int eval = 0;
f010fb4c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_correct;
	void* va = NULL;
f010fb53:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 actualSize = 0;
f010fb5a:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)

	cprintf("=======================================================\n") ;
f010fb61:	83 ec 0c             	sub    $0xc,%esp
f010fb64:	68 9c 79 12 f0       	push   $0xf012799c
f010fb69:	e8 fe 13 ff ff       	call   f0100f6c <cprintf>
f010fb6e:	83 c4 10             	add    $0x10,%esp
	cprintf("FIRST: Tests depend on the Allocate Function ONLY [40%]\n") ;
f010fb71:	83 ec 0c             	sub    $0xc,%esp
f010fb74:	68 d8 79 12 f0       	push   $0xf01279d8
f010fb79:	e8 ee 13 ff ff       	call   f0100f6c <cprintf>
f010fb7e:	83 c4 10             	add    $0x10,%esp
	cprintf("=======================================================\n") ;
f010fb81:	83 ec 0c             	sub    $0xc,%esp
f010fb84:	68 9c 79 12 f0       	push   $0xf012799c
f010fb89:	e8 de 13 ff ff       	call   f0100f6c <cprintf>
f010fb8e:	83 c4 10             	add    $0x10,%esp
	eval = test_initial_alloc(DA_FF);
f010fb91:	83 ec 0c             	sub    $0xc,%esp
f010fb94:	6a 01                	push   $0x1
f010fb96:	e8 cf fb ff ff       	call   f010f76a <test_initial_alloc>
f010fb9b:	83 c4 10             	add    $0x10,%esp
f010fb9e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	cprintf("====================================================\n") ;
f010fba1:	83 ec 0c             	sub    $0xc,%esp
f010fba4:	68 14 7a 12 f0       	push   $0xf0127a14
f010fba9:	e8 be 13 ff ff       	call   f0100f6c <cprintf>
f010fbae:	83 c4 10             	add    $0x10,%esp
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
f010fbb1:	83 ec 0c             	sub    $0xc,%esp
f010fbb4:	68 4c 7a 12 f0       	push   $0xf0127a4c
f010fbb9:	e8 ae 13 ff ff       	call   f0100f6c <cprintf>
f010fbbe:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
f010fbc1:	83 ec 0c             	sub    $0xc,%esp
f010fbc4:	68 14 7a 12 f0       	push   $0xf0127a14
f010fbc9:	e8 9e 13 ff ff       	call   f0100f6c <cprintf>
f010fbce:	83 c4 10             	add    $0x10,%esp

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f010fbd1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f010fbd8:	eb 2c                	jmp    f010fc06 <test_alloc_block_FF+0xc6>
	{
		free_block(startVAs[i*allocCntPerSize]);
f010fbda:	8b 55 dc             	mov    -0x24(%ebp),%edx
f010fbdd:	89 d0                	mov    %edx,%eax
f010fbdf:	c1 e0 02             	shl    $0x2,%eax
f010fbe2:	01 d0                	add    %edx,%eax
f010fbe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010fbeb:	01 d0                	add    %edx,%eax
f010fbed:	c1 e0 03             	shl    $0x3,%eax
f010fbf0:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f010fbf7:	83 ec 0c             	sub    $0xc,%esp
f010fbfa:	50                   	push   %eax
f010fbfb:	e8 16 16 01 00       	call   f0121216 <free_block>
f010fc00:	83 c4 10             	add    $0x10,%esp
	cprintf("====================================================\n") ;
	cprintf("SECOND: Tests depend on BOTH Allocate and Free [60%] \n") ;
	cprintf("====================================================\n") ;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f010fc03:	ff 45 dc             	incl   -0x24(%ebp)
f010fc06:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f010fc0a:	7e ce                	jle    f010fbda <test_alloc_block_FF+0x9a>
	{
		free_block(startVAs[i*allocCntPerSize]);
	}
	is_correct = 1;
f010fc0c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//Check number of freed blocks
	if(LIST_SIZE(&freeBlocksList) != numOfAllocs)
f010fc13:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fc18:	83 f8 07             	cmp    $0x7,%eax
f010fc1b:	74 17                	je     f010fc34 <test_alloc_block_FF+0xf4>
	{
		is_correct = 0;
f010fc1d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #5: WRONG FREE. unexpected number of freed blocks\n");
f010fc24:	83 ec 0c             	sub    $0xc,%esp
f010fc27:	68 84 7a 12 f0       	push   $0xf0127a84
f010fc2c:	e8 3b 13 ff ff       	call   f0100f6c <cprintf>
f010fc31:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f010fc34:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fc38:	74 04                	je     f010fc3e <test_alloc_block_FF+0xfe>
	{
		eval += 10;
f010fc3a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
f010fc3e:	83 ec 0c             	sub    $0xc,%esp
f010fc41:	68 e0 76 12 f0       	push   $0xf01276e0
f010fc46:	e8 21 13 ff ff       	call   f0100f6c <cprintf>
f010fc4b:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fc4e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	uint32 maxSize = 0 ;
f010fc55:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f010fc5c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f010fc63:	eb 1f                	jmp    f010fc84 <test_alloc_block_FF+0x144>
	{
		if (allocSizes[i] > maxSize)
f010fc65:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fc68:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010fc6f:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f010fc72:	76 0d                	jbe    f010fc81 <test_alloc_block_FF+0x141>
			maxSize = allocSizes[i] ;
f010fc74:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010fc77:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f010fc7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
	/*FF ALLOC Scenario 1: Try to allocate a block with a size greater than the size of any existing free block*/
	cprintf("	1: Try to allocate large block [not fit in any space]\n\n") ;
	is_correct = 1;

	uint32 maxSize = 0 ;
	for (int i = 0; i < numOfAllocs; ++i)
f010fc81:	ff 45 d4             	incl   -0x2c(%ebp)
f010fc84:	83 7d d4 06          	cmpl   $0x6,-0x2c(%ebp)
f010fc88:	7e db                	jle    f010fc65 <test_alloc_block_FF+0x125>
	{
		if (allocSizes[i] > maxSize)
			maxSize = allocSizes[i] ;
	}
	va = alloc_block(maxSize, DA_FF);
f010fc8a:	83 ec 08             	sub    $0x8,%esp
f010fc8d:	6a 01                	push   $0x1
f010fc8f:	ff 75 d8             	pushl  -0x28(%ebp)
f010fc92:	e8 3e 13 01 00       	call   f0120fd5 <alloc_block>
f010fc97:	83 c4 10             	add    $0x10,%esp
f010fc9a:	89 45 c8             	mov    %eax,-0x38(%ebp)

	//Check returned va
	if(va != NULL)
f010fc9d:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010fca1:	74 17                	je     f010fcba <test_alloc_block_FF+0x17a>
	{
		is_correct = 0;
f010fca3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #5: WRONG FF ALLOC - alloc_block_FF find a block instead no existing free blocks with the given size.\n");
f010fcaa:	83 ec 0c             	sub    $0xc,%esp
f010fcad:	68 c8 7a 12 f0       	push   $0xf0127ac8
f010fcb2:	e8 b5 12 ff ff       	call   f0100f6c <cprintf>
f010fcb7:	83 c4 10             	add    $0x10,%esp
	}

	if (is_correct)
f010fcba:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fcbe:	74 04                	je     f010fcc4 <test_alloc_block_FF+0x184>
	{
		eval += 5;
f010fcc0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 2: Try to allocate blocks with sizes smaller than existing free blocks*/
	cprintf("	2: Try to allocate set of blocks with different sizes smaller than existing free blocks\n\n") ;
f010fcc4:	83 ec 0c             	sub    $0xc,%esp
f010fcc7:	68 40 7b 12 f0       	push   $0xf0127b40
f010fccc:	e8 9b 12 ff ff       	call   f0100f6c <cprintf>
f010fcd1:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fcd4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

#define numOfFFTests 3
	uint32 startVA = KERNEL_HEAP_START + sizeof(int); //just after the DA Begin block
f010fcdb:	c7 45 c0 04 00 00 f6 	movl   $0xf6000004,-0x40(%ebp)
	uint32 testSizes[numOfFFTests] = {1*kilo + kilo/2, 3*kilo, kilo/2} ;
f010fce2:	8d 45 ac             	lea    -0x54(%ebp),%eax
f010fce5:	bb 60 7d 12 f0       	mov    $0xf0127d60,%ebx
f010fcea:	ba 03 00 00 00       	mov    $0x3,%edx
f010fcef:	89 c7                	mov    %eax,%edi
f010fcf1:	89 de                	mov    %ebx,%esi
f010fcf3:	89 d1                	mov    %edx,%ecx
f010fcf5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
f010fcf7:	a1 a0 49 57 f0       	mov    0xf05749a0,%eax
f010fcfc:	89 45 bc             	mov    %eax,-0x44(%ebp)
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
f010fcff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010fd02:	83 c0 04             	add    $0x4,%eax
f010fd05:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010fd08:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010fd0b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f010fd0e:	8b 55 ac             	mov    -0x54(%ebp),%edx
f010fd11:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010fd14:	01 d0                	add    %edx,%eax
f010fd16:	83 c0 04             	add    $0x4,%eax
f010fd19:	89 45 a8             	mov    %eax,-0x58(%ebp)
	short* tstStartVAs[numOfFFTests+1] ;
	short* tstMidVAs[numOfFFTests+1] ;
	short* tstEndVAs[numOfFFTests+1] ;
	for (int i = 0; i < numOfFFTests; ++i)
f010fd1c:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010fd23:	e9 c6 00 00 00       	jmp    f010fdee <test_alloc_block_FF+0x2ae>
	{
		actualSize = testSizes[i] - sizeOfMetaData;
f010fd28:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd2b:	8b 44 85 ac          	mov    -0x54(%ebp,%eax,4),%eax
f010fd2f:	83 e8 08             	sub    $0x8,%eax
f010fd32:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		va = tstStartVAs[i] = alloc_block(actualSize, DA_FF);
f010fd35:	83 ec 08             	sub    $0x8,%esp
f010fd38:	6a 01                	push   $0x1
f010fd3a:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fd3d:	e8 93 12 01 00       	call   f0120fd5 <alloc_block>
f010fd42:	83 c4 10             	add    $0x10,%esp
f010fd45:	89 c2                	mov    %eax,%edx
f010fd47:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd4a:	89 54 85 90          	mov    %edx,-0x70(%ebp,%eax,4)
f010fd4e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd51:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010fd55:	89 45 c8             	mov    %eax,-0x38(%ebp)
		tstMidVAs[i] = va + actualSize/2 ;
f010fd58:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fd5b:	d1 e8                	shr    %eax
f010fd5d:	89 c2                	mov    %eax,%edx
f010fd5f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fd62:	01 c2                	add    %eax,%edx
f010fd64:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd67:	89 54 85 80          	mov    %edx,-0x80(%ebp,%eax,4)
		tstEndVAs[i] = va + actualSize - sizeof(short);
f010fd6b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fd6e:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fd71:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fd74:	01 c2                	add    %eax,%edx
f010fd76:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd79:	89 94 85 70 ff ff ff 	mov    %edx,-0x90(%ebp,%eax,4)
		//Check returned va
		if(tstStartVAs[i] == NULL || (tstStartVAs[i] != (short*)expectedVAs[i]))
f010fd80:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd83:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010fd87:	85 c0                	test   %eax,%eax
f010fd89:	74 12                	je     f010fd9d <test_alloc_block_FF+0x25d>
f010fd8b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd8e:	8b 54 85 90          	mov    -0x70(%ebp,%eax,4),%edx
f010fd92:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fd95:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f010fd99:	39 c2                	cmp    %eax,%edx
f010fd9b:	74 27                	je     f010fdc4 <test_alloc_block_FF+0x284>
		{
			is_correct = 0;
f010fd9d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_FF #6.%d: WRONG FF ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", i, expectedVAs[i] ,tstStartVAs[i]);
f010fda4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fda7:	8b 54 85 90          	mov    -0x70(%ebp,%eax,4),%edx
f010fdab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdae:	8b 44 85 a0          	mov    -0x60(%ebp,%eax,4),%eax
f010fdb2:	52                   	push   %edx
f010fdb3:	50                   	push   %eax
f010fdb4:	ff 75 d0             	pushl  -0x30(%ebp)
f010fdb7:	68 9c 7b 12 f0       	push   $0xf0127b9c
f010fdbc:	e8 ab 11 ff ff       	call   f0100f6c <cprintf>
f010fdc1:	83 c4 10             	add    $0x10,%esp
			//break;
		}
		*(tstStartVAs[i]) = 353;
f010fdc4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdc7:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010fdcb:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstMidVAs[i]) = 353;
f010fdd0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fdd3:	8b 44 85 80          	mov    -0x80(%ebp,%eax,4),%eax
f010fdd7:	66 c7 00 61 01       	movw   $0x161,(%eax)
		*(tstEndVAs[i]) = 353;
f010fddc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010fddf:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010fde6:	66 c7 00 61 01       	movw   $0x161,(%eax)
	uint32 startOf1st7KB = (uint32)startVAs[6*allocCntPerSize];
	uint32 expectedVAs[numOfFFTests] = {startVA + sizeOfMetaData/2, startOf1st7KB, startVA + testSizes[0] + sizeOfMetaData/2};
	short* tstStartVAs[numOfFFTests+1] ;
	short* tstMidVAs[numOfFFTests+1] ;
	short* tstEndVAs[numOfFFTests+1] ;
	for (int i = 0; i < numOfFFTests; ++i)
f010fdeb:	ff 45 d0             	incl   -0x30(%ebp)
f010fdee:	83 7d d0 02          	cmpl   $0x2,-0x30(%ebp)
f010fdf2:	0f 8e 30 ff ff ff    	jle    f010fd28 <test_alloc_block_FF+0x1e8>
		}
		*(tstStartVAs[i]) = 353;
		*(tstMidVAs[i]) = 353;
		*(tstEndVAs[i]) = 353;
	}
	if (is_correct)
f010fdf8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fdfc:	74 04                	je     f010fe02 <test_alloc_block_FF+0x2c2>
	{
		eval += 15;
f010fdfe:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 3: Try to allocate a block with a size equal to the size of the first existing free block*/
	cprintf("	3: Try to allocate a block with equal to the first existing free block\n\n") ;
f010fe02:	83 ec 0c             	sub    $0xc,%esp
f010fe05:	68 a8 78 12 f0       	push   $0xf01278a8
f010fe0a:	e8 5d 11 ff ff       	call   f0100f6c <cprintf>
f010fe0f:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fe12:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	actualSize = 2*kilo - sizeOfMetaData;
f010fe19:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	va = tstStartVAs[numOfFFTests] = alloc_block(actualSize, DA_FF);
f010fe20:	83 ec 08             	sub    $0x8,%esp
f010fe23:	6a 01                	push   $0x1
f010fe25:	ff 75 c4             	pushl  -0x3c(%ebp)
f010fe28:	e8 a8 11 01 00       	call   f0120fd5 <alloc_block>
f010fe2d:	83 c4 10             	add    $0x10,%esp
f010fe30:	89 45 9c             	mov    %eax,-0x64(%ebp)
f010fe33:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010fe36:	89 45 c8             	mov    %eax,-0x38(%ebp)
	tstMidVAs[numOfFFTests] = va + actualSize/2 ;
f010fe39:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fe3c:	d1 e8                	shr    %eax
f010fe3e:	89 c2                	mov    %eax,%edx
f010fe40:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe43:	01 d0                	add    %edx,%eax
f010fe45:	89 45 8c             	mov    %eax,-0x74(%ebp)
	tstEndVAs[numOfFFTests] = va + actualSize - sizeof(short);
f010fe48:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010fe4b:	8d 50 fe             	lea    -0x2(%eax),%edx
f010fe4e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe51:	01 d0                	add    %edx,%eax
f010fe53:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
	//Check returned va
	void* expected = (void*)(startVA + testSizes[0] + testSizes[2] + sizeOfMetaData/2) ;
f010fe59:	8b 55 ac             	mov    -0x54(%ebp),%edx
f010fe5c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010fe5f:	01 c2                	add    %eax,%edx
f010fe61:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010fe64:	01 d0                	add    %edx,%eax
f010fe66:	83 c0 04             	add    $0x4,%eax
f010fe69:	89 45 b8             	mov    %eax,-0x48(%ebp)
	if(va == NULL || (va != expected))
f010fe6c:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f010fe70:	74 08                	je     f010fe7a <test_alloc_block_FF+0x33a>
f010fe72:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010fe75:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f010fe78:	74 1d                	je     f010fe97 <test_alloc_block_FF+0x357>
	{
		is_correct = 0;
f010fe7a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #7: WRONG FF ALLOC - alloc_block_FF return wrong address.expected %x, actual %x\n", expected, va);
f010fe81:	83 ec 04             	sub    $0x4,%esp
f010fe84:	ff 75 c8             	pushl  -0x38(%ebp)
f010fe87:	ff 75 b8             	pushl  -0x48(%ebp)
f010fe8a:	68 00 7c 12 f0       	push   $0xf0127c00
f010fe8f:	e8 d8 10 ff ff       	call   f0100f6c <cprintf>
f010fe94:	83 c4 10             	add    $0x10,%esp
	}
	if(LIST_SIZE(&freeBlocksList) != numOfAllocs - 1)
f010fe97:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fe9c:	83 f8 06             	cmp    $0x6,%eax
f010fe9f:	74 1f                	je     f010fec0 <test_alloc_block_FF+0x380>
	{
		is_correct = 0;
f010fea1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		cprintf("alloc_block_FF #7: WRONG FF ALLOC - unexpected number of free blocks. expected %d, actual %d\n", numOfAllocs-1, LIST_SIZE(&freeBlocksList));
f010fea8:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f010fead:	83 ec 04             	sub    $0x4,%esp
f010feb0:	50                   	push   %eax
f010feb1:	6a 06                	push   $0x6
f010feb3:	68 60 7c 12 f0       	push   $0xf0127c60
f010feb8:	e8 af 10 ff ff       	call   f0100f6c <cprintf>
f010febd:	83 c4 10             	add    $0x10,%esp
	}

	*(tstStartVAs[numOfFFTests]) = 353 ;
f010fec0:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010fec3:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstMidVAs[numOfFFTests]) = 353 ;
f010fec8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010fecb:	66 c7 00 61 01       	movw   $0x161,(%eax)
	*(tstEndVAs[numOfFFTests]) = 353 ;
f010fed0:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010fed6:	66 c7 00 61 01       	movw   $0x161,(%eax)

	if (is_correct)
f010fedb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fedf:	74 04                	je     f010fee5 <test_alloc_block_FF+0x3a5>
	{
		eval += 15;
f010fee1:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	//====================================================================//
	/*FF ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
f010fee5:	83 ec 0c             	sub    $0xc,%esp
f010fee8:	68 18 79 12 f0       	push   $0xf0127918
f010feed:	e8 7a 10 ff ff       	call   f0100f6c <cprintf>
f010fef2:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f010fef5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	for (int i = 0; i <= numOfFFTests; ++i)
f010fefc:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010ff03:	e9 82 00 00 00       	jmp    f010ff8a <test_alloc_block_FF+0x44a>
	{
		//cprintf("startVA = %x, mid = %x, last = %x\n", tstStartVAs[i], tstMidVAs[i], tstEndVAs[i]);
		if (*(tstStartVAs[i]) != 353 || *(tstMidVAs[i]) != 353 || *(tstEndVAs[i]) != 353)
f010ff08:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff0b:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010ff0f:	66 8b 00             	mov    (%eax),%ax
f010ff12:	66 3d 61 01          	cmp    $0x161,%ax
f010ff16:	75 23                	jne    f010ff3b <test_alloc_block_FF+0x3fb>
f010ff18:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff1b:	8b 44 85 80          	mov    -0x80(%ebp,%eax,4),%eax
f010ff1f:	66 8b 00             	mov    (%eax),%ax
f010ff22:	66 3d 61 01          	cmp    $0x161,%ax
f010ff26:	75 13                	jne    f010ff3b <test_alloc_block_FF+0x3fb>
f010ff28:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff2b:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010ff32:	66 8b 00             	mov    (%eax),%ax
f010ff35:	66 3d 61 01          	cmp    $0x161,%ax
f010ff39:	74 4c                	je     f010ff87 <test_alloc_block_FF+0x447>
		{
			is_correct = 0;
f010ff3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
f010ff42:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff45:	8b 84 85 70 ff ff ff 	mov    -0x90(%ebp,%eax,4),%eax
f010ff4c:	66 8b 00             	mov    (%eax),%ax
f010ff4f:	0f bf c8             	movswl %ax,%ecx
f010ff52:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff55:	8b 44 85 80          	mov    -0x80(%ebp,%eax,4),%eax
f010ff59:	66 8b 00             	mov    (%eax),%ax
f010ff5c:	0f bf d0             	movswl %ax,%edx
f010ff5f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010ff62:	8b 44 85 90          	mov    -0x70(%ebp,%eax,4),%eax
f010ff66:	66 8b 00             	mov    (%eax),%ax
f010ff69:	98                   	cwtl   
f010ff6a:	83 ec 08             	sub    $0x8,%esp
f010ff6d:	51                   	push   %ecx
f010ff6e:	52                   	push   %edx
f010ff6f:	50                   	push   %eax
f010ff70:	68 61 01 00 00       	push   $0x161
f010ff75:	ff 75 cc             	pushl  -0x34(%ebp)
f010ff78:	68 c0 7c 12 f0       	push   $0xf0127cc0
f010ff7d:	e8 ea 0f ff ff       	call   f0100f6c <cprintf>
f010ff82:	83 c4 20             	add    $0x20,%esp
			break;
f010ff85:	eb 0d                	jmp    f010ff94 <test_alloc_block_FF+0x454>
	//====================================================================//
	/*FF ALLOC Scenario 4: Check stored data inside each allocated block*/
	cprintf("	4: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i <= numOfFFTests; ++i)
f010ff87:	ff 45 cc             	incl   -0x34(%ebp)
f010ff8a:	83 7d cc 03          	cmpl   $0x3,-0x34(%ebp)
f010ff8e:	0f 8e 74 ff ff ff    	jle    f010ff08 <test_alloc_block_FF+0x3c8>
			cprintf("alloc_block_FF #8.%d: WRONG! content of the block is not correct. Expected=%d, val1=%d, val2=%d, val3=%d\n",i, 353, *(tstStartVAs[i]), *(tstMidVAs[i]), *(tstEndVAs[i]));
			break;
		}
	}

	if (is_correct)
f010ff94:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010ff98:	74 04                	je     f010ff9e <test_alloc_block_FF+0x45e>
	{
		eval += 15;
f010ff9a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("test alloc_block_FF completed. Evaluation = %d%\n", eval);
f010ff9e:	83 ec 08             	sub    $0x8,%esp
f010ffa1:	ff 75 e4             	pushl  -0x1c(%ebp)
f010ffa4:	68 2c 7d 12 f0       	push   $0xf0127d2c
f010ffa9:	e8 be 0f ff ff       	call   f0100f6c <cprintf>
f010ffae:	83 c4 10             	add    $0x10,%esp
}
f010ffb1:	90                   	nop
f010ffb2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ffb5:	5b                   	pop    %ebx
f010ffb6:	5e                   	pop    %esi
f010ffb7:	5f                   	pop    %edi
f010ffb8:	5d                   	pop    %ebp
f010ffb9:	c3                   	ret    

f010ffba <test_alloc_block_BF>:

void test_alloc_block_BF()
{
f010ffba:	55                   	push   %ebp
f010ffbb:	89 e5                	mov    %esp,%ebp
f010ffbd:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_alloc_block_BF: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	panic("Test is under construction! will be announced later isA");
f010ffc0:	83 ec 04             	sub    $0x4,%esp
f010ffc3:	68 6c 7d 12 f0       	push   $0xf0127d6c
f010ffc8:	68 5e 01 00 00       	push   $0x15e
f010ffcd:	68 48 76 12 f0       	push   $0xf0127648
f010ffd2:	e8 43 03 ff ff       	call   f010031a <_panic>

f010ffd7 <test_alloc_block_NF>:
}

void test_alloc_block_NF()
{
f010ffd7:	55                   	push   %ebp
f010ffd8:	89 e5                	mov    %esp,%ebp
	//====================================================================//
	/*NF ALLOC Scenario 7: Try to allocate a block with a size smaller than the existing blocks .. To try to update head not to remove it*/

	//cprintf("Congratulations!! test alloc_block_NF completed successfully.\n");

}
f010ffda:	90                   	nop
f010ffdb:	5d                   	pop    %ebp
f010ffdc:	c3                   	ret    

f010ffdd <test_free_block_FF>:

void test_free_block_FF()
{
f010ffdd:	55                   	push   %ebp
f010ffde:	89 e5                	mov    %esp,%ebp
f010ffe0:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f010ffe3:	83 ec 0c             	sub    $0xc,%esp
f010ffe6:	68 a4 7d 12 f0       	push   $0xf0127da4
f010ffeb:	e8 7c 0f ff ff       	call   f0100f6c <cprintf>
f010fff0:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f010fff3:	83 ec 0c             	sub    $0xc,%esp
f010fff6:	68 e4 7d 12 f0       	push   $0xf0127de4
f010fffb:	e8 6c 0f ff ff       	call   f0100f6c <cprintf>
f0110000:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0110003:	83 ec 0c             	sub    $0xc,%esp
f0110006:	68 a4 7d 12 f0       	push   $0xf0127da4
f011000b:	e8 5c 0f ff ff       	call   f0100f6c <cprintf>
f0110010:	83 c4 10             	add    $0x10,%esp

	int eval = 0;
f0110013:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool is_correct;
	int initAllocatedSpace = 3*Mega;
f011001a:	c7 45 cc 00 00 30 00 	movl   $0x300000,-0x34(%ebp)
	initialize_dynamic_allocator(KERNEL_HEAP_START, initAllocatedSpace);
f0110021:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110024:	83 ec 08             	sub    $0x8,%esp
f0110027:	50                   	push   %eax
f0110028:	68 00 00 00 f6       	push   $0xf6000000
f011002d:	e8 d0 10 01 00       	call   f0121102 <initialize_dynamic_allocator>
f0110032:	83 c4 10             	add    $0x10,%esp

	void * va ;
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;
f0110035:	83 ec 0c             	sub    $0xc,%esp
f0110038:	68 24 7e 12 f0       	push   $0xf0127e24
f011003d:	e8 2a 0f ff ff       	call   f0100f6c <cprintf>
f0110042:	83 c4 10             	add    $0x10,%esp

	int totalSizes = 0;
f0110045:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfAllocs; ++i)
f011004c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110053:	eb 2a                	jmp    f011007f <test_free_block_FF+0xa2>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
f0110055:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110058:	8b 14 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%edx
f011005f:	89 d0                	mov    %edx,%eax
f0110061:	c1 e0 02             	shl    $0x2,%eax
f0110064:	01 d0                	add    %edx,%eax
f0110066:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011006d:	01 d0                	add    %edx,%eax
f011006f:	c1 e0 03             	shl    $0x3,%eax
f0110072:	89 c2                	mov    %eax,%edx
f0110074:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110077:	01 d0                	add    %edx,%eax
f0110079:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//====================================================================//
	/* Try to allocate set of blocks with different sizes*/
	cprintf("	1: Try to allocate set of blocks with different sizes to fill-up the allocated space\n\n") ;

	int totalSizes = 0;
	for (int i = 0; i < numOfAllocs; ++i)
f011007c:	ff 45 e8             	incl   -0x18(%ebp)
f011007f:	83 7d e8 06          	cmpl   $0x6,-0x18(%ebp)
f0110083:	7e d0                	jle    f0110055 <test_free_block_FF+0x78>
	{
		totalSizes += allocSizes[i] * allocCntPerSize ;
	}
	int remainSize = initAllocatedSpace - totalSizes - 2*sizeof(int) ; //exclude size of "DA Begin & End" blocks
f0110085:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0110088:	2b 45 ec             	sub    -0x14(%ebp),%eax
f011008b:	83 e8 08             	sub    $0x8,%eax
f011008e:	89 45 c8             	mov    %eax,-0x38(%ebp)
	if (remainSize <= 0)
f0110091:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f0110095:	7f 17                	jg     f01100ae <test_free_block_FF+0xd1>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");
f0110097:	83 ec 04             	sub    $0x4,%esp
f011009a:	68 7c 7e 12 f0       	push   $0xf0127e7c
f011009f:	68 9a 01 00 00       	push   $0x19a
f01100a4:	68 48 76 12 f0       	push   $0xf0127648
f01100a9:	e8 6c 02 ff ff       	call   f010031a <_panic>

	int idx = 0;
f01100ae:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
f01100b5:	c7 45 e0 04 00 00 f6 	movl   $0xf6000004,-0x20(%ebp)
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01100bc:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01100c3:	e9 f8 00 00 00       	jmp    f01101c0 <test_free_block_FF+0x1e3>
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01100c8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01100cf:	e9 dc 00 00 00       	jmp    f01101b0 <test_free_block_FF+0x1d3>
		{
			actualSize = allocSizes[i] - sizeOfMetaData;
f01100d4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01100d7:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f01100de:	83 e8 08             	sub    $0x8,%eax
f01100e1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f01100e4:	83 ec 08             	sub    $0x8,%esp
f01100e7:	6a 01                	push   $0x1
f01100e9:	ff 75 c4             	pushl  -0x3c(%ebp)
f01100ec:	e8 e4 0e 01 00       	call   f0120fd5 <alloc_block>
f01100f1:	83 c4 10             	add    $0x10,%esp
f01100f4:	89 c2                	mov    %eax,%edx
f01100f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01100f9:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f0110100:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110103:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011010a:	89 45 c0             	mov    %eax,-0x40(%ebp)
			midVAs[idx] = va + actualSize/2 ;
f011010d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110110:	d1 e8                	shr    %eax
f0110112:	89 c2                	mov    %eax,%edx
f0110114:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110117:	01 c2                	add    %eax,%edx
f0110119:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011011c:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
			endVAs[idx] = va + actualSize - sizeof(short);
f0110123:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110126:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110129:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011012c:	01 c2                	add    %eax,%edx
f011012e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110131:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
			//Check returned va
			if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f0110138:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011013c:	74 0b                	je     f0110149 <test_free_block_FF+0x16c>
f011013e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110141:	83 c0 04             	add    $0x4,%eax
f0110144:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0110147:	74 24                	je     f011016d <test_free_block_FF+0x190>
				panic("test_free_block #1.%d: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x", idx, curVA + sizeOfMetaData ,va);
f0110149:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011014c:	83 c0 08             	add    $0x8,%eax
f011014f:	83 ec 08             	sub    $0x8,%esp
f0110152:	ff 75 c0             	pushl  -0x40(%ebp)
f0110155:	50                   	push   %eax
f0110156:	ff 75 e4             	pushl  -0x1c(%ebp)
f0110159:	68 f4 7e 12 f0       	push   $0xf0127ef4
f011015e:	68 a9 01 00 00       	push   $0x1a9
f0110163:	68 48 76 12 f0       	push   $0xf0127648
f0110168:	e8 ad 01 ff ff       	call   f010031a <_panic>
			curVA += allocSizes[i] ;
f011016d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0110170:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f0110177:	01 45 e0             	add    %eax,-0x20(%ebp)
			*(startVAs[idx]) = idx ;
f011017a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011017d:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f0110184:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110187:	66 89 02             	mov    %ax,(%edx)
			*(midVAs[idx]) = idx ;
f011018a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011018d:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f0110194:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110197:	66 89 02             	mov    %ax,(%edx)
			*(endVAs[idx]) = idx ;
f011019a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011019d:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f01101a4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101a7:	66 89 02             	mov    %ax,(%edx)
			idx++;
f01101aa:	ff 45 e4             	incl   -0x1c(%ebp)
	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
	{
		for (int j = 0; j < allocCntPerSize; ++j)
f01101ad:	ff 45 d8             	incl   -0x28(%ebp)
f01101b0:	81 7d d8 c7 00 00 00 	cmpl   $0xc7,-0x28(%ebp)
f01101b7:	0f 8e 17 ff ff ff    	jle    f01100d4 <test_free_block_FF+0xf7>
		panic("test_free_block is not configured correctly. Consider updating the initial allocated space OR the required allocations");

	int idx = 0;
	void* curVA = (void*) KERNEL_HEAP_START + sizeof(int) ; //just after the "DA Begin" block
	uint32 actualSize;
	for (int i = 0; i < numOfAllocs; ++i)
f01101bd:	ff 45 dc             	incl   -0x24(%ebp)
f01101c0:	83 7d dc 06          	cmpl   $0x6,-0x24(%ebp)
f01101c4:	0f 8e fe fe ff ff    	jle    f01100c8 <test_free_block_FF+0xeb>
		}
	}

	//====================================================================//
	/* Try to allocate a block with a size equal to the size of the first existing free block*/
	actualSize = remainSize - sizeOfMetaData;
f01101ca:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01101cd:	83 e8 08             	sub    $0x8,%eax
f01101d0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = startVAs[idx] = alloc_block(actualSize, DA_FF);
f01101d3:	83 ec 08             	sub    $0x8,%esp
f01101d6:	6a 01                	push   $0x1
f01101d8:	ff 75 c4             	pushl  -0x3c(%ebp)
f01101db:	e8 f5 0d 01 00       	call   f0120fd5 <alloc_block>
f01101e0:	83 c4 10             	add    $0x10,%esp
f01101e3:	89 c2                	mov    %eax,%edx
f01101e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101e8:	89 14 85 e0 36 57 f0 	mov    %edx,-0xfa8c920(,%eax,4)
f01101ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01101f2:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01101f9:	89 45 c0             	mov    %eax,-0x40(%ebp)
	midVAs[idx] = va + actualSize/2 ;
f01101fc:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01101ff:	d1 e8                	shr    %eax
f0110201:	89 c2                	mov    %eax,%edx
f0110203:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110206:	01 c2                	add    %eax,%edx
f0110208:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011020b:	89 14 85 e0 62 57 f0 	mov    %edx,-0xfa89d20(,%eax,4)
	endVAs[idx] = va + actualSize - sizeof(short);
f0110212:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110215:	8d 50 fe             	lea    -0x2(%eax),%edx
f0110218:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011021b:	01 c2                	add    %eax,%edx
f011021d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110220:	89 14 85 e0 4c 57 f0 	mov    %edx,-0xfa8b320(,%eax,4)
	//Check returned va
	if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f0110227:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f011022b:	74 0b                	je     f0110238 <test_free_block_FF+0x25b>
f011022d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0110230:	83 c0 04             	add    $0x4,%eax
f0110233:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0110236:	74 17                	je     f011024f <test_free_block_FF+0x272>
		panic("test_free_block #2: WRONG ALLOC - alloc_block_FF return wrong address.");
f0110238:	83 ec 04             	sub    $0x4,%esp
f011023b:	68 58 7f 12 f0       	push   $0xf0127f58
f0110240:	68 ba 01 00 00       	push   $0x1ba
f0110245:	68 48 76 12 f0       	push   $0xf0127648
f011024a:	e8 cb 00 ff ff       	call   f010031a <_panic>
	*(startVAs[idx]) = idx ;
f011024f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110252:	8b 14 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%edx
f0110259:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011025c:	66 89 02             	mov    %ax,(%edx)
	*(midVAs[idx]) = idx ;
f011025f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110262:	8b 14 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%edx
f0110269:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011026c:	66 89 02             	mov    %ax,(%edx)
	*(endVAs[idx]) = idx ;
f011026f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0110272:	8b 14 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%edx
f0110279:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011027c:	66 89 02             	mov    %ax,(%edx)

	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
f011027f:	83 ec 0c             	sub    $0xc,%esp
f0110282:	68 a0 7f 12 f0       	push   $0xf0127fa0
f0110287:	e8 e0 0c ff ff       	call   f0100f6c <cprintf>
f011028c:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f011028f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	for (int i = 0; i < idx; ++i)
f0110296:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f011029d:	eb 5b                	jmp    f01102fa <test_free_block_FF+0x31d>
	{
		if (*(startVAs[i]) != i || *(midVAs[i]) != i ||	*(endVAs[i]) != i)
f011029f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102a2:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01102a9:	66 8b 00             	mov    (%eax),%ax
f01102ac:	98                   	cwtl   
f01102ad:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01102b0:	75 26                	jne    f01102d8 <test_free_block_FF+0x2fb>
f01102b2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102b5:	8b 04 85 e0 62 57 f0 	mov    -0xfa89d20(,%eax,4),%eax
f01102bc:	66 8b 00             	mov    (%eax),%ax
f01102bf:	98                   	cwtl   
f01102c0:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01102c3:	75 13                	jne    f01102d8 <test_free_block_FF+0x2fb>
f01102c5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102c8:	8b 04 85 e0 4c 57 f0 	mov    -0xfa8b320(,%eax,4),%eax
f01102cf:	66 8b 00             	mov    (%eax),%ax
f01102d2:	98                   	cwtl   
f01102d3:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f01102d6:	74 1f                	je     f01102f7 <test_free_block_FF+0x31a>
		{
			is_correct = 0;
f01102d8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			cprintf("test_free_block #3.%d: WRONG! content of the block is not correct. Expected %d\n",i, i);
f01102df:	83 ec 04             	sub    $0x4,%esp
f01102e2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01102e5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01102e8:	68 d4 7f 12 f0       	push   $0xf0127fd4
f01102ed:	e8 7a 0c ff ff       	call   f0100f6c <cprintf>
f01102f2:	83 c4 10             	add    $0x10,%esp
			break;
f01102f5:	eb 0b                	jmp    f0110302 <test_free_block_FF+0x325>
	//====================================================================//
	/* Check stored data inside each allocated block*/
	cprintf("	2: Check stored data inside each allocated block\n\n") ;
	is_correct = 1;

	for (int i = 0; i < idx; ++i)
f01102f7:	ff 45 d4             	incl   -0x2c(%ebp)
f01102fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01102fd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0110300:	7c 9d                	jl     f011029f <test_free_block_FF+0x2c2>
		}
	}

	//====================================================================//
	/* free_block Scenario 1: Free some allocated blocks [no coalesce]*/
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
f0110302:	83 ec 0c             	sub    $0xc,%esp
f0110305:	68 24 80 12 f0       	push   $0xf0128024
f011030a:	e8 5d 0c ff ff       	call   f0100f6c <cprintf>
f011030f:	83 c4 10             	add    $0x10,%esp
	uint32 block_size, expected_size, *blk_header, *blk_footer;
	is_correct = 1;
f0110312:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110319:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0110320:	e9 e4 00 00 00       	jmp    f0110409 <test_free_block_FF+0x42c>
	{
		free_block(startVAs[i*allocCntPerSize]);
f0110325:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110328:	89 d0                	mov    %edx,%eax
f011032a:	c1 e0 02             	shl    $0x2,%eax
f011032d:	01 d0                	add    %edx,%eax
f011032f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110336:	01 d0                	add    %edx,%eax
f0110338:	c1 e0 03             	shl    $0x3,%eax
f011033b:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110342:	83 ec 0c             	sub    $0xc,%esp
f0110345:	50                   	push   %eax
f0110346:	e8 cb 0e 01 00       	call   f0121216 <free_block>
f011034b:	83 c4 10             	add    $0x10,%esp
		uint32 block_size = get_block_size(startVAs[i*allocCntPerSize]) ;
f011034e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0110351:	89 d0                	mov    %edx,%eax
f0110353:	c1 e0 02             	shl    $0x2,%eax
f0110356:	01 d0                	add    %edx,%eax
f0110358:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011035f:	01 d0                	add    %edx,%eax
f0110361:	c1 e0 03             	shl    $0x3,%eax
f0110364:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011036b:	83 ec 0c             	sub    $0xc,%esp
f011036e:	50                   	push   %eax
f011036f:	e8 2a 0c 01 00       	call   f0120f9e <get_block_size>
f0110374:	83 c4 10             	add    $0x10,%esp
f0110377:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if (block_size != allocSizes[i])
f011037a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011037d:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f0110384:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0110387:	74 2b                	je     f01103b4 <test_free_block_FF+0x3d7>
		{
			if (is_correct)
f0110389:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011038d:	74 25                	je     f01103b4 <test_free_block_FF+0x3d7>
			{
				is_correct = 0;
f011038f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf("test_free_block #4.%d: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",i, allocSizes[i],block_size);
f0110396:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0110399:	8b 04 85 78 9d 17 f0 	mov    -0xfe86288(,%eax,4),%eax
f01103a0:	ff 75 bc             	pushl  -0x44(%ebp)
f01103a3:	50                   	push   %eax
f01103a4:	ff 75 d0             	pushl  -0x30(%ebp)
f01103a7:	68 54 80 12 f0       	push   $0xf0128054
f01103ac:	e8 bb 0b ff ff       	call   f0100f6c <cprintf>
f01103b1:	83 c4 10             	add    $0x10,%esp
			}
		}
		int8 block_status = is_free_block(startVAs[i*allocCntPerSize]) ;
f01103b4:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01103b7:	89 d0                	mov    %edx,%eax
f01103b9:	c1 e0 02             	shl    $0x2,%eax
f01103bc:	01 d0                	add    %edx,%eax
f01103be:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01103c5:	01 d0                	add    %edx,%eax
f01103c7:	c1 e0 03             	shl    $0x3,%eax
f01103ca:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01103d1:	83 ec 0c             	sub    $0xc,%esp
f01103d4:	50                   	push   %eax
f01103d5:	e8 dd 0b 01 00       	call   f0120fb7 <is_free_block>
f01103da:	83 c4 10             	add    $0x10,%esp
f01103dd:	88 45 bb             	mov    %al,-0x45(%ebp)
		if (block_status != 1)
f01103e0:	80 7d bb 01          	cmpb   $0x1,-0x45(%ebp)
f01103e4:	74 20                	je     f0110406 <test_free_block_FF+0x429>
		{
			if (is_correct)
f01103e6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103ea:	74 1a                	je     f0110406 <test_free_block_FF+0x429>
			{
				is_correct = 0;
f01103ec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cprintf("test_free_block #5.%d: WRONG FREE! block status not marked as free.\n", i);
f01103f3:	83 ec 08             	sub    $0x8,%esp
f01103f6:	ff 75 d0             	pushl  -0x30(%ebp)
f01103f9:	68 b8 80 12 f0       	push   $0xf01280b8
f01103fe:	e8 69 0b ff ff       	call   f0100f6c <cprintf>
f0110403:	83 c4 10             	add    $0x10,%esp
	cprintf("	3: Free some allocated block [no coalesce]\n\n") ;
	uint32 block_size, expected_size, *blk_header, *blk_footer;
	is_correct = 1;

	//Free set of blocks with different sizes (first block of each size)
	for (int i = 0; i < numOfAllocs; ++i)
f0110406:	ff 45 d0             	incl   -0x30(%ebp)
f0110409:	83 7d d0 06          	cmpl   $0x6,-0x30(%ebp)
f011040d:	0f 8e 12 ff ff ff    	jle    f0110325 <test_free_block_FF+0x348>
				is_correct = 0;
				cprintf("test_free_block #5.%d: WRONG FREE! block status not marked as free.\n", i);
			}
		}
	}
	uint32 expectedNumOfFreeBlks = numOfAllocs;
f0110413:	c7 45 b4 07 00 00 00 	movl   $0x7,-0x4c(%ebp)
	is_correct = 1;
f011041a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f0110421:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110426:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110429:	74 17                	je     f0110442 <test_free_block_FF+0x465>
	{
		is_correct = 0;
f011042b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #5.oo: WRONG number of freed blocks in the freeBlockList.\n");
f0110432:	83 ec 0c             	sub    $0xc,%esp
f0110435:	68 00 81 12 f0       	push   $0xf0128100
f011043a:	e8 2d 0b ff ff       	call   f0100f6c <cprintf>
f011043f:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110442:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110446:	74 04                	je     f011044c <test_free_block_FF+0x46f>
	{
		eval += 10;
f0110448:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	is_correct = 1;
f011044c:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block
	free_block(startVAs[numOfAllocs*allocCntPerSize]);
f0110453:	a1 c0 4c 57 f0       	mov    0xf0574cc0,%eax
f0110458:	83 ec 0c             	sub    $0xc,%esp
f011045b:	50                   	push   %eax
f011045c:	e8 b5 0d 01 00       	call   f0121216 <free_block>
f0110461:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[numOfAllocs*allocCntPerSize]) ;
f0110464:	a1 c0 4c 57 f0       	mov    0xf0574cc0,%eax
f0110469:	83 ec 0c             	sub    $0xc,%esp
f011046c:	50                   	push   %eax
f011046d:	e8 2c 0b 01 00       	call   f0120f9e <get_block_size>
f0110472:	83 c4 10             	add    $0x10,%esp
f0110475:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (block_size != remainSize)
f0110478:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011047b:	39 45 b0             	cmp    %eax,-0x50(%ebp)
f011047e:	74 1d                	je     f011049d <test_free_block_FF+0x4c0>
	{
		is_correct = 0;
f0110480:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",remainSize,block_size);
f0110487:	83 ec 04             	sub    $0x4,%esp
f011048a:	ff 75 b0             	pushl  -0x50(%ebp)
f011048d:	ff 75 c8             	pushl  -0x38(%ebp)
f0110490:	68 4c 81 12 f0       	push   $0xf012814c
f0110495:	e8 d2 0a ff ff       	call   f0100f6c <cprintf>
f011049a:	83 c4 10             	add    $0x10,%esp
	}
	int8 block_status = is_free_block(startVAs[numOfAllocs*allocCntPerSize]) ;
f011049d:	a1 c0 4c 57 f0       	mov    0xf0574cc0,%eax
f01104a2:	83 ec 0c             	sub    $0xc,%esp
f01104a5:	50                   	push   %eax
f01104a6:	e8 0c 0b 01 00       	call   f0120fb7 <is_free_block>
f01104ab:	83 c4 10             	add    $0x10,%esp
f01104ae:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f01104b1:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f01104b5:	74 17                	je     f01104ce <test_free_block_FF+0x4f1>
	{
		is_correct = 0;
f01104b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.2: WRONG FREE! WRONG FREE! block status not marked as free.\n");
f01104be:	83 ec 0c             	sub    $0xc,%esp
f01104c1:	68 ac 81 12 f0       	push   $0xf01281ac
f01104c6:	e8 a1 0a ff ff       	call   f0100f6c <cprintf>
f01104cb:	83 c4 10             	add    $0x10,%esp
	}

	//Reallocate last block
	actualSize = remainSize - sizeOfMetaData;
f01104ce:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01104d1:	83 e8 08             	sub    $0x8,%eax
f01104d4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f01104d7:	83 ec 08             	sub    $0x8,%esp
f01104da:	6a 01                	push   $0x1
f01104dc:	ff 75 c4             	pushl  -0x3c(%ebp)
f01104df:	e8 f1 0a 01 00       	call   f0120fd5 <alloc_block>
f01104e4:	83 c4 10             	add    $0x10,%esp
f01104e7:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	if(va == NULL || (va != (curVA + sizeOfMetaData/2)))
f01104ea:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f01104ee:	74 0b                	je     f01104fb <test_free_block_FF+0x51e>
f01104f0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01104f3:	83 c0 04             	add    $0x4,%eax
f01104f6:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f01104f9:	74 17                	je     f0110512 <test_free_block_FF+0x535>
	{
		is_correct = 0;
f01104fb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.3: WRONG ALLOC - alloc_block_FF return wrong address.\n");
f0110502:	83 ec 0c             	sub    $0xc,%esp
f0110505:	68 fc 81 12 f0       	push   $0xf01281fc
f011050a:	e8 5d 0a ff ff       	call   f0100f6c <cprintf>
f011050f:	83 c4 10             	add    $0x10,%esp
	}

	//Free block before last
	free_block(startVAs[numOfAllocs*allocCntPerSize - 1]);
f0110512:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110517:	83 ec 0c             	sub    $0xc,%esp
f011051a:	50                   	push   %eax
f011051b:	e8 f6 0c 01 00       	call   f0121216 <free_block>
f0110520:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[numOfAllocs*allocCntPerSize - 1]) ;
f0110523:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110528:	83 ec 0c             	sub    $0xc,%esp
f011052b:	50                   	push   %eax
f011052c:	e8 6d 0a 01 00       	call   f0120f9e <get_block_size>
f0110531:	83 c4 10             	add    $0x10,%esp
f0110534:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (block_size != allocSizes[numOfAllocs-1])
f0110537:	a1 90 9d 17 f0       	mov    0xf0179d90,%eax
f011053c:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011053f:	74 20                	je     f0110561 <test_free_block_FF+0x584>
	{
		is_correct = 0;
f0110541:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.4: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[numOfAllocs-1],block_size);
f0110548:	a1 90 9d 17 f0       	mov    0xf0179d90,%eax
f011054d:	83 ec 04             	sub    $0x4,%esp
f0110550:	ff 75 b0             	pushl  -0x50(%ebp)
f0110553:	50                   	push   %eax
f0110554:	68 48 82 12 f0       	push   $0xf0128248
f0110559:	e8 0e 0a ff ff       	call   f0100f6c <cprintf>
f011055e:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[numOfAllocs*allocCntPerSize-1]) ;
f0110561:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110566:	83 ec 0c             	sub    $0xc,%esp
f0110569:	50                   	push   %eax
f011056a:	e8 48 0a 01 00       	call   f0120fb7 <is_free_block>
f011056f:	83 c4 10             	add    $0x10,%esp
f0110572:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110575:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110579:	74 17                	je     f0110592 <test_free_block_FF+0x5b5>
	{
		is_correct = 0;
f011057b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #6.5: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110582:	83 ec 0c             	sub    $0xc,%esp
f0110585:	68 a8 82 12 f0       	push   $0xf01282a8
f011058a:	e8 dd 09 ff ff       	call   f0100f6c <cprintf>
f011058f:	83 c4 10             	add    $0x10,%esp
	}

	//Reallocate first block
	actualSize = allocSizes[0] - sizeOfMetaData;
f0110592:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f0110597:	83 e8 08             	sub    $0x8,%eax
f011059a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f011059d:	83 ec 08             	sub    $0x8,%esp
f01105a0:	6a 01                	push   $0x1
f01105a2:	ff 75 c4             	pushl  -0x3c(%ebp)
f01105a5:	e8 2b 0a 01 00       	call   f0120fd5 <alloc_block>
f01105aa:	83 c4 10             	add    $0x10,%esp
f01105ad:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	if(va == NULL || (va != (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2)))
f01105b0:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f01105b4:	74 09                	je     f01105bf <test_free_block_FF+0x5e2>
f01105b6:	81 7d c0 08 00 00 f6 	cmpl   $0xf6000008,-0x40(%ebp)
f01105bd:	74 17                	je     f01105d6 <test_free_block_FF+0x5f9>
	{
		is_correct = 0;
f01105bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.1: WRONG ALLOC - alloc_block_FF return wrong address.\n");
f01105c6:	83 ec 0c             	sub    $0xc,%esp
f01105c9:	68 00 83 12 f0       	push   $0xf0128300
f01105ce:	e8 99 09 ff ff       	call   f0100f6c <cprintf>
f01105d3:	83 c4 10             	add    $0x10,%esp
	}

	//Free 2nd block
	free_block(startVAs[1]);
f01105d6:	a1 e4 36 57 f0       	mov    0xf05736e4,%eax
f01105db:	83 ec 0c             	sub    $0xc,%esp
f01105de:	50                   	push   %eax
f01105df:	e8 32 0c 01 00       	call   f0121216 <free_block>
f01105e4:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[1]) ;
f01105e7:	a1 e4 36 57 f0       	mov    0xf05736e4,%eax
f01105ec:	83 ec 0c             	sub    $0xc,%esp
f01105ef:	50                   	push   %eax
f01105f0:	e8 a9 09 01 00       	call   f0120f9e <get_block_size>
f01105f5:	83 c4 10             	add    $0x10,%esp
f01105f8:	89 45 b0             	mov    %eax,-0x50(%ebp)
	if (block_size != allocSizes[0])
f01105fb:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f0110600:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0110603:	74 20                	je     f0110625 <test_free_block_FF+0x648>
	{
		is_correct = 0;
f0110605:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.2: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[0],block_size);
f011060c:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f0110611:	83 ec 04             	sub    $0x4,%esp
f0110614:	ff 75 b0             	pushl  -0x50(%ebp)
f0110617:	50                   	push   %eax
f0110618:	68 4c 83 12 f0       	push   $0xf012834c
f011061d:	e8 4a 09 ff ff       	call   f0100f6c <cprintf>
f0110622:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[1]) ;
f0110625:	a1 e4 36 57 f0       	mov    0xf05736e4,%eax
f011062a:	83 ec 0c             	sub    $0xc,%esp
f011062d:	50                   	push   %eax
f011062e:	e8 84 09 01 00       	call   f0120fb7 <is_free_block>
f0110633:	83 c4 10             	add    $0x10,%esp
f0110636:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110639:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f011063d:	74 17                	je     f0110656 <test_free_block_FF+0x679>
	{
		is_correct = 0;
f011063f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.3: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110646:	83 ec 0c             	sub    $0xc,%esp
f0110649:	68 ac 83 12 f0       	push   $0xf01283ac
f011064e:	e8 19 09 ff ff       	call   f0100f6c <cprintf>
f0110653:	83 c4 10             	add    $0x10,%esp
	}
	is_correct = 1;
f0110656:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	expectedNumOfFreeBlks++ ;
f011065d:	ff 45 b4             	incl   -0x4c(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f0110660:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110665:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110668:	74 17                	je     f0110681 <test_free_block_FF+0x6a4>
	{
		is_correct = 0;
f011066a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #7.4: WRONG number of freed blocks in the freeBlockList.\n");
f0110671:	83 ec 0c             	sub    $0xc,%esp
f0110674:	68 04 84 12 f0       	push   $0xf0128404
f0110679:	e8 ee 08 ff ff       	call   f0100f6c <cprintf>
f011067e:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110681:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110685:	74 04                	je     f011068b <test_free_block_FF+0x6ae>
	{
		eval += 10;
f0110687:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 2: Merge with previous ONLY (AT the tail)*/
	cprintf("	4: Free some allocated blocks [Merge with previous ONLY]\n\n") ;
f011068b:	83 ec 0c             	sub    $0xc,%esp
f011068e:	68 50 84 12 f0       	push   $0xf0128450
f0110693:	e8 d4 08 ff ff       	call   f0100f6c <cprintf>
f0110698:	83 c4 10             	add    $0x10,%esp
	cprintf("		4.1: at the tail\n\n") ;
f011069b:	83 ec 0c             	sub    $0xc,%esp
f011069e:	68 8c 84 12 f0       	push   $0xf012848c
f01106a3:	e8 c4 08 ff ff       	call   f0100f6c <cprintf>
f01106a8:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f01106ab:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Free last block (coalesce with previous)
	uint32 blockIndex = numOfAllocs*allocCntPerSize;
f01106b2:	c7 45 a8 78 05 00 00 	movl   $0x578,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f01106b9:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01106bc:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01106c3:	83 ec 0c             	sub    $0xc,%esp
f01106c6:	50                   	push   %eax
f01106c7:	e8 4a 0b 01 00       	call   f0121216 <free_block>
f01106cc:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex-1]) ;
f01106cf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01106d2:	48                   	dec    %eax
f01106d3:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01106da:	83 ec 0c             	sub    $0xc,%esp
f01106dd:	50                   	push   %eax
f01106de:	e8 bb 08 01 00       	call   f0120f9e <get_block_size>
f01106e3:	83 c4 10             	add    $0x10,%esp
f01106e6:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = remainSize + allocSizes[numOfAllocs-1];
f01106e9:	8b 15 90 9d 17 f0    	mov    0xf0179d90,%edx
f01106ef:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01106f2:	01 d0                	add    %edx,%eax
f01106f4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f01106f7:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01106fa:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f01106fd:	74 26                	je     f0110725 <test_free_block_FF+0x748>
	{
		is_correct = 0;
f01106ff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #8.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",remainSize + allocSizes[numOfAllocs-1],block_size);
f0110706:	8b 15 90 9d 17 f0    	mov    0xf0179d90,%edx
f011070c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011070f:	01 d0                	add    %edx,%eax
f0110711:	83 ec 04             	sub    $0x4,%esp
f0110714:	ff 75 b0             	pushl  -0x50(%ebp)
f0110717:	50                   	push   %eax
f0110718:	68 a4 84 12 f0       	push   $0xf01284a4
f011071d:	e8 4a 08 ff ff       	call   f0100f6c <cprintf>
f0110722:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex-1]) ;
f0110725:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110728:	48                   	dec    %eax
f0110729:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110730:	83 ec 0c             	sub    $0xc,%esp
f0110733:	50                   	push   %eax
f0110734:	e8 7e 08 01 00       	call   f0120fb7 <is_free_block>
f0110739:	83 c4 10             	add    $0x10,%esp
f011073c:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f011073f:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110743:	74 17                	je     f011075c <test_free_block_FF+0x77f>
	{
		is_correct = 0;
f0110745:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #8.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f011074c:	83 ec 0c             	sub    $0xc,%esp
f011074f:	68 04 85 12 f0       	push   $0xf0128504
f0110754:	e8 13 08 ff ff       	call   f0100f6c <cprintf>
f0110759:	83 c4 10             	add    $0x10,%esp
	}

	blk_header = (uint32*)((uint32)startVAs[blockIndex-1] - sizeof(int));
f011075c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011075f:	48                   	dec    %eax
f0110760:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110767:	83 e8 04             	sub    $0x4,%eax
f011076a:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex-1]+expected_size-2*sizeof(int));
f011076d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110770:	48                   	dec    %eax
f0110771:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110778:	89 c2                	mov    %eax,%edx
f011077a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011077d:	01 d0                	add    %edx,%eax
f011077f:	83 e8 08             	sub    $0x8,%eax
f0110782:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110785:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110788:	8b 10                	mov    (%eax),%edx
f011078a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011078d:	8b 00                	mov    (%eax),%eax
f011078f:	39 c2                	cmp    %eax,%edx
f0110791:	74 17                	je     f01107aa <test_free_block_FF+0x7cd>
	{
		is_correct = 0;
f0110793:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #8.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f011079a:	83 ec 0c             	sub    $0xc,%esp
f011079d:	68 5c 85 12 f0       	push   $0xf012855c
f01107a2:	e8 c5 07 ff ff       	call   f0100f6c <cprintf>
f01107a7:	83 c4 10             	add    $0x10,%esp
	}

	//====================================================================//
	/*free_block Scenario 3: Merge with previous ONLY (between 2 blocks)*/
	cprintf("		4.2: between 2 blocks\n\n") ;
f01107aa:	83 ec 0c             	sub    $0xc,%esp
f01107ad:	68 be 85 12 f0       	push   $0xf01285be
f01107b2:	e8 b5 07 ff ff       	call   f0100f6c <cprintf>
f01107b7:	83 c4 10             	add    $0x10,%esp
	blockIndex = 2*allocCntPerSize+1 ;
f01107ba:	c7 45 a8 91 01 00 00 	movl   $0x191,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f01107c1:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01107c4:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01107cb:	83 ec 0c             	sub    $0xc,%esp
f01107ce:	50                   	push   %eax
f01107cf:	e8 42 0a 01 00       	call   f0121216 <free_block>
f01107d4:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex-1]) ;
f01107d7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01107da:	48                   	dec    %eax
f01107db:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01107e2:	83 ec 0c             	sub    $0xc,%esp
f01107e5:	50                   	push   %eax
f01107e6:	e8 b3 07 01 00       	call   f0120f9e <get_block_size>
f01107eb:	83 c4 10             	add    $0x10,%esp
f01107ee:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[2]+allocSizes[2];
f01107f1:	8b 15 80 9d 17 f0    	mov    0xf0179d80,%edx
f01107f7:	a1 80 9d 17 f0       	mov    0xf0179d80,%eax
f01107fc:	01 d0                	add    %edx,%eax
f01107fe:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110801:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110804:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110807:	74 28                	je     f0110831 <test_free_block_FF+0x854>
	{
		is_correct = 0;
f0110809:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf	("test_free_block #9.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[2] + allocSizes[2],block_size);
f0110810:	8b 15 80 9d 17 f0    	mov    0xf0179d80,%edx
f0110816:	a1 80 9d 17 f0       	mov    0xf0179d80,%eax
f011081b:	01 d0                	add    %edx,%eax
f011081d:	83 ec 04             	sub    $0x4,%esp
f0110820:	ff 75 b0             	pushl  -0x50(%ebp)
f0110823:	50                   	push   %eax
f0110824:	68 d8 85 12 f0       	push   $0xf01285d8
f0110829:	e8 3e 07 ff ff       	call   f0100f6c <cprintf>
f011082e:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex-1]) ;
f0110831:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110834:	48                   	dec    %eax
f0110835:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011083c:	83 ec 0c             	sub    $0xc,%esp
f011083f:	50                   	push   %eax
f0110840:	e8 72 07 01 00       	call   f0120fb7 <is_free_block>
f0110845:	83 c4 10             	add    $0x10,%esp
f0110848:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f011084b:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f011084f:	74 17                	je     f0110868 <test_free_block_FF+0x88b>
	{
		is_correct = 0;
f0110851:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #9.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110858:	83 ec 0c             	sub    $0xc,%esp
f011085b:	68 38 86 12 f0       	push   $0xf0128638
f0110860:	e8 07 07 ff ff       	call   f0100f6c <cprintf>
f0110865:	83 c4 10             	add    $0x10,%esp
	}

	blk_header = (uint32*)((uint32)startVAs[blockIndex-1] - sizeof(int));
f0110868:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011086b:	48                   	dec    %eax
f011086c:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110873:	83 e8 04             	sub    $0x4,%eax
f0110876:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex-1]+expected_size-2*sizeof(int));
f0110879:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011087c:	48                   	dec    %eax
f011087d:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110884:	89 c2                	mov    %eax,%edx
f0110886:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110889:	01 d0                	add    %edx,%eax
f011088b:	83 e8 08             	sub    $0x8,%eax
f011088e:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110891:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110894:	8b 10                	mov    (%eax),%edx
f0110896:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110899:	8b 00                	mov    (%eax),%eax
f011089b:	39 c2                	cmp    %eax,%edx
f011089d:	74 17                	je     f01108b6 <test_free_block_FF+0x8d9>
	{
		is_correct = 0;
f011089f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #9.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f01108a6:	83 ec 0c             	sub    $0xc,%esp
f01108a9:	68 90 86 12 f0       	push   $0xf0128690
f01108ae:	e8 b9 06 ff ff       	call   f0100f6c <cprintf>
f01108b3:	83 c4 10             	add    $0x10,%esp
	}
	is_correct = 1;
f01108b6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f01108bd:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f01108c2:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01108c5:	74 17                	je     f01108de <test_free_block_FF+0x901>
	{
		is_correct = 0;
f01108c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #9.4: WRONG number of freed blocks in the freeBlockList.\n");
f01108ce:	83 ec 0c             	sub    $0xc,%esp
f01108d1:	68 f4 86 12 f0       	push   $0xf01286f4
f01108d6:	e8 91 06 ff ff       	call   f0100f6c <cprintf>
f01108db:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f01108de:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01108e2:	74 04                	je     f01108e8 <test_free_block_FF+0x90b>
	{
		eval += 15;
f01108e4:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 4: Merge with next ONLY (AT the head)*/
	cprintf("	5: Free some allocated blocks [Merge with next ONLY]\n\n") ;
f01108e8:	83 ec 0c             	sub    $0xc,%esp
f01108eb:	68 40 87 12 f0       	push   $0xf0128740
f01108f0:	e8 77 06 ff ff       	call   f0100f6c <cprintf>
f01108f5:	83 c4 10             	add    $0x10,%esp
	cprintf("		5.1: at the head\n\n") ;
f01108f8:	83 ec 0c             	sub    $0xc,%esp
f01108fb:	68 78 87 12 f0       	push   $0xf0128778
f0110900:	e8 67 06 ff ff       	call   f0100f6c <cprintf>
f0110905:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110908:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 0 ;
f011090f:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f0110916:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110919:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110920:	83 ec 0c             	sub    $0xc,%esp
f0110923:	50                   	push   %eax
f0110924:	e8 ed 08 01 00       	call   f0121216 <free_block>
f0110929:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex]) ;
f011092c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011092f:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110936:	83 ec 0c             	sub    $0xc,%esp
f0110939:	50                   	push   %eax
f011093a:	e8 5f 06 01 00       	call   f0120f9e <get_block_size>
f011093f:	83 c4 10             	add    $0x10,%esp
f0110942:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[0]+allocSizes[0];
f0110945:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f011094b:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f0110950:	01 d0                	add    %edx,%eax
f0110952:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110955:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110958:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011095b:	74 28                	je     f0110985 <test_free_block_FF+0x9a8>
	{
		is_correct = 0;
f011095d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #10.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[0] + allocSizes[0],block_size);
f0110964:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f011096a:	a1 78 9d 17 f0       	mov    0xf0179d78,%eax
f011096f:	01 d0                	add    %edx,%eax
f0110971:	83 ec 04             	sub    $0x4,%esp
f0110974:	ff 75 b0             	pushl  -0x50(%ebp)
f0110977:	50                   	push   %eax
f0110978:	68 90 87 12 f0       	push   $0xf0128790
f011097d:	e8 ea 05 ff ff       	call   f0100f6c <cprintf>
f0110982:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex]) ;
f0110985:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110988:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f011098f:	83 ec 0c             	sub    $0xc,%esp
f0110992:	50                   	push   %eax
f0110993:	e8 1f 06 01 00       	call   f0120fb7 <is_free_block>
f0110998:	83 c4 10             	add    $0x10,%esp
f011099b:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f011099e:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f01109a2:	74 17                	je     f01109bb <test_free_block_FF+0x9de>
	{
		is_correct = 0;
f01109a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #10.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f01109ab:	83 ec 0c             	sub    $0xc,%esp
f01109ae:	68 f4 87 12 f0       	push   $0xf01287f4
f01109b3:	e8 b4 05 ff ff       	call   f0100f6c <cprintf>
f01109b8:	83 c4 10             	add    $0x10,%esp
	}
	blk_header = (uint32*)((uint32)startVAs[blockIndex] - sizeof(int));
f01109bb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01109be:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01109c5:	83 e8 04             	sub    $0x4,%eax
f01109c8:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex]+expected_size-2*sizeof(int));
f01109cb:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01109ce:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f01109d5:	89 c2                	mov    %eax,%edx
f01109d7:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01109da:	01 d0                	add    %edx,%eax
f01109dc:	83 e8 08             	sub    $0x8,%eax
f01109df:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f01109e2:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01109e5:	8b 10                	mov    (%eax),%edx
f01109e7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01109ea:	8b 00                	mov    (%eax),%eax
f01109ec:	39 c2                	cmp    %eax,%edx
f01109ee:	74 17                	je     f0110a07 <test_free_block_FF+0xa2a>
	{
		is_correct = 0;
f01109f0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #10.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f01109f7:	83 ec 0c             	sub    $0xc,%esp
f01109fa:	68 4c 88 12 f0       	push   $0xf012884c
f01109ff:	e8 68 05 ff ff       	call   f0100f6c <cprintf>
f0110a04:	83 c4 10             	add    $0x10,%esp
	}


	//====================================================================//
	/*free_block Scenario 5: Merge with next ONLY (between 2 blocks)*/
	cprintf("		5.2: between 2 blocks\n\n") ;
f0110a07:	83 ec 0c             	sub    $0xc,%esp
f0110a0a:	68 af 88 12 f0       	push   $0xf01288af
f0110a0f:	e8 58 05 ff ff       	call   f0100f6c <cprintf>
f0110a14:	83 c4 10             	add    $0x10,%esp
	blockIndex = 1*allocCntPerSize - 1 ;
f0110a17:	c7 45 a8 c7 00 00 00 	movl   $0xc7,-0x58(%ebp)
	free_block(startVAs[blockIndex]);
f0110a1e:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110a21:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110a28:	83 ec 0c             	sub    $0xc,%esp
f0110a2b:	50                   	push   %eax
f0110a2c:	e8 e5 07 01 00       	call   f0121216 <free_block>
f0110a31:	83 c4 10             	add    $0x10,%esp
	block_size = get_block_size(startVAs[blockIndex]) ;
f0110a34:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110a37:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110a3e:	83 ec 0c             	sub    $0xc,%esp
f0110a41:	50                   	push   %eax
f0110a42:	e8 57 05 01 00       	call   f0120f9e <get_block_size>
f0110a47:	83 c4 10             	add    $0x10,%esp
f0110a4a:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[0]+allocSizes[1];
f0110a4d:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f0110a53:	a1 7c 9d 17 f0       	mov    0xf0179d7c,%eax
f0110a58:	01 d0                	add    %edx,%eax
f0110a5a:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110a5d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110a60:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110a63:	74 28                	je     f0110a8d <test_free_block_FF+0xab0>
	{
		is_correct = 0;
f0110a65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[0] + allocSizes[1],block_size);
f0110a6c:	8b 15 78 9d 17 f0    	mov    0xf0179d78,%edx
f0110a72:	a1 7c 9d 17 f0       	mov    0xf0179d7c,%eax
f0110a77:	01 d0                	add    %edx,%eax
f0110a79:	83 ec 04             	sub    $0x4,%esp
f0110a7c:	ff 75 b0             	pushl  -0x50(%ebp)
f0110a7f:	50                   	push   %eax
f0110a80:	68 cc 88 12 f0       	push   $0xf01288cc
f0110a85:	e8 e2 04 ff ff       	call   f0100f6c <cprintf>
f0110a8a:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex]) ;
f0110a8d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110a90:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110a97:	83 ec 0c             	sub    $0xc,%esp
f0110a9a:	50                   	push   %eax
f0110a9b:	e8 17 05 01 00       	call   f0120fb7 <is_free_block>
f0110aa0:	83 c4 10             	add    $0x10,%esp
f0110aa3:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110aa6:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110aaa:	74 17                	je     f0110ac3 <test_free_block_FF+0xae6>
	{
		is_correct = 0;
f0110aac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110ab3:	83 ec 0c             	sub    $0xc,%esp
f0110ab6:	68 30 89 12 f0       	push   $0xf0128930
f0110abb:	e8 ac 04 ff ff       	call   f0100f6c <cprintf>
f0110ac0:	83 c4 10             	add    $0x10,%esp
	}
	blk_header = (uint32*)((uint32)startVAs[blockIndex] - sizeof(int));
f0110ac3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110ac6:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110acd:	83 e8 04             	sub    $0x4,%eax
f0110ad0:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex]+expected_size-2*sizeof(int));
f0110ad3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110ad6:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110add:	89 c2                	mov    %eax,%edx
f0110adf:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110ae2:	01 d0                	add    %edx,%eax
f0110ae4:	83 e8 08             	sub    $0x8,%eax
f0110ae7:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110aea:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110aed:	8b 10                	mov    (%eax),%edx
f0110aef:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110af2:	8b 00                	mov    (%eax),%eax
f0110af4:	39 c2                	cmp    %eax,%edx
f0110af6:	74 17                	je     f0110b0f <test_free_block_FF+0xb32>
	{
		is_correct = 0;
f0110af8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f0110aff:	83 ec 0c             	sub    $0xc,%esp
f0110b02:	68 88 89 12 f0       	push   $0xf0128988
f0110b07:	e8 60 04 ff ff       	call   f0100f6c <cprintf>
f0110b0c:	83 c4 10             	add    $0x10,%esp
	}

	is_correct = 1;
f0110b0f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f0110b16:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110b1b:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110b1e:	74 17                	je     f0110b37 <test_free_block_FF+0xb5a>
	{
		is_correct = 0;
f0110b20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #11.4: WRONG number of freed blocks in the freeBlockList.\n");
f0110b27:	83 ec 0c             	sub    $0xc,%esp
f0110b2a:	68 ec 89 12 f0       	push   $0xf01289ec
f0110b2f:	e8 38 04 ff ff       	call   f0100f6c <cprintf>
f0110b34:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110b37:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110b3b:	74 04                	je     f0110b41 <test_free_block_FF+0xb64>
	{
		eval += 15;
f0110b3d:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)
	}

	//====================================================================//
	/*free_block Scenario 6: Merge with prev & next */
	cprintf("	6: Free some allocated blocks [Merge with previous & next]\n\n") ;
f0110b41:	83 ec 0c             	sub    $0xc,%esp
f0110b44:	68 38 8a 12 f0       	push   $0xf0128a38
f0110b49:	e8 1e 04 ff ff       	call   f0100f6c <cprintf>
f0110b4e:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110b51:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	blockIndex = 4*allocCntPerSize - 2 ;
f0110b58:	c7 45 a8 1e 03 00 00 	movl   $0x31e,-0x58(%ebp)
	free_block(startVAs[blockIndex]);	//no merge
f0110b5f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110b62:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110b69:	83 ec 0c             	sub    $0xc,%esp
f0110b6c:	50                   	push   %eax
f0110b6d:	e8 a4 06 01 00       	call   f0121216 <free_block>
f0110b72:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks++;
f0110b75:	ff 45 b4             	incl   -0x4c(%ebp)

	blockIndex = 4*allocCntPerSize - 1 ;
f0110b78:	c7 45 a8 1f 03 00 00 	movl   $0x31f,-0x58(%ebp)
	free_block(startVAs[blockIndex]);	//merge with prev & next
f0110b7f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110b82:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110b89:	83 ec 0c             	sub    $0xc,%esp
f0110b8c:	50                   	push   %eax
f0110b8d:	e8 84 06 01 00       	call   f0121216 <free_block>
f0110b92:	83 c4 10             	add    $0x10,%esp
	expectedNumOfFreeBlks--;
f0110b95:	ff 4d b4             	decl   -0x4c(%ebp)

	block_size = get_block_size(startVAs[blockIndex-1]) ;
f0110b98:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110b9b:	48                   	dec    %eax
f0110b9c:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110ba3:	83 ec 0c             	sub    $0xc,%esp
f0110ba6:	50                   	push   %eax
f0110ba7:	e8 f2 03 01 00       	call   f0120f9e <get_block_size>
f0110bac:	83 c4 10             	add    $0x10,%esp
f0110baf:	89 45 b0             	mov    %eax,-0x50(%ebp)
	expected_size = allocSizes[3]+allocSizes[3]+allocSizes[4];
f0110bb2:	8b 15 84 9d 17 f0    	mov    0xf0179d84,%edx
f0110bb8:	a1 84 9d 17 f0       	mov    0xf0179d84,%eax
f0110bbd:	01 c2                	add    %eax,%edx
f0110bbf:	a1 88 9d 17 f0       	mov    0xf0179d88,%eax
f0110bc4:	01 d0                	add    %edx,%eax
f0110bc6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	if (block_size != expected_size)
f0110bc9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0110bcc:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f0110bcf:	74 2f                	je     f0110c00 <test_free_block_FF+0xc23>
	{
		is_correct = 0;
f0110bd1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.1: WRONG FREE! block size after free is not correct. Expected %d, Actual %d\n",allocSizes[3]+allocSizes[3]+allocSizes[4],block_size);
f0110bd8:	8b 15 84 9d 17 f0    	mov    0xf0179d84,%edx
f0110bde:	a1 84 9d 17 f0       	mov    0xf0179d84,%eax
f0110be3:	01 c2                	add    %eax,%edx
f0110be5:	a1 88 9d 17 f0       	mov    0xf0179d88,%eax
f0110bea:	01 d0                	add    %edx,%eax
f0110bec:	83 ec 04             	sub    $0x4,%esp
f0110bef:	ff 75 b0             	pushl  -0x50(%ebp)
f0110bf2:	50                   	push   %eax
f0110bf3:	68 78 8a 12 f0       	push   $0xf0128a78
f0110bf8:	e8 6f 03 ff ff       	call   f0100f6c <cprintf>
f0110bfd:	83 c4 10             	add    $0x10,%esp
	}
	block_status = is_free_block(startVAs[blockIndex-1]) ;
f0110c00:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110c03:	48                   	dec    %eax
f0110c04:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110c0b:	83 ec 0c             	sub    $0xc,%esp
f0110c0e:	50                   	push   %eax
f0110c0f:	e8 a3 03 01 00       	call   f0120fb7 <is_free_block>
f0110c14:	83 c4 10             	add    $0x10,%esp
f0110c17:	88 45 af             	mov    %al,-0x51(%ebp)
	if (block_status != 1)
f0110c1a:	80 7d af 01          	cmpb   $0x1,-0x51(%ebp)
f0110c1e:	74 17                	je     f0110c37 <test_free_block_FF+0xc5a>
	{
		is_correct = 0;
f0110c20:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.2: WRONG FREE! block status (is_free) not equal 1 after freeing.\n");
f0110c27:	83 ec 0c             	sub    $0xc,%esp
f0110c2a:	68 dc 8a 12 f0       	push   $0xf0128adc
f0110c2f:	e8 38 03 ff ff       	call   f0100f6c <cprintf>
f0110c34:	83 c4 10             	add    $0x10,%esp
	}
	blk_header = (uint32*)((uint32)startVAs[blockIndex-1] - sizeof(int));
f0110c37:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110c3a:	48                   	dec    %eax
f0110c3b:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110c42:	83 e8 04             	sub    $0x4,%eax
f0110c45:	89 45 a0             	mov    %eax,-0x60(%ebp)
	blk_footer = (uint32*)((uint32)startVAs[blockIndex-1]+expected_size-2*sizeof(int));
f0110c48:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0110c4b:	48                   	dec    %eax
f0110c4c:	8b 04 85 e0 36 57 f0 	mov    -0xfa8c920(,%eax,4),%eax
f0110c53:	89 c2                	mov    %eax,%edx
f0110c55:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0110c58:	01 d0                	add    %edx,%eax
f0110c5a:	83 e8 08             	sub    $0x8,%eax
f0110c5d:	89 45 9c             	mov    %eax,-0x64(%ebp)
	if (*(blk_header) != *(blk_footer))
f0110c60:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0110c63:	8b 10                	mov    (%eax),%edx
f0110c65:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0110c68:	8b 00                	mov    (%eax),%eax
f0110c6a:	39 c2                	cmp    %eax,%edx
f0110c6c:	74 17                	je     f0110c85 <test_free_block_FF+0xca8>
	{
		is_correct = 0;
f0110c6e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.3: WRONG FREE! make sure to set block header and footer with the same values.\n");
f0110c75:	83 ec 0c             	sub    $0xc,%esp
f0110c78:	68 34 8b 12 f0       	push   $0xf0128b34
f0110c7d:	e8 ea 02 ff ff       	call   f0100f6c <cprintf>
f0110c82:	83 c4 10             	add    $0x10,%esp
	}

	is_correct = 1;
f0110c85:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	if (LIST_SIZE(&freeBlocksList) != expectedNumOfFreeBlks)
f0110c8c:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110c91:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0110c94:	74 20                	je     f0110cb6 <test_free_block_FF+0xcd9>
	{
		is_correct = 0;
f0110c96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #12.4: WRONG number of freed blocks in the freeBlockList. expected = %d, actual = %d\n", expectedNumOfFreeBlks, LIST_SIZE(&freeBlocksList));
f0110c9d:	a1 bc 25 55 f0       	mov    0xf05525bc,%eax
f0110ca2:	83 ec 04             	sub    $0x4,%esp
f0110ca5:	50                   	push   %eax
f0110ca6:	ff 75 b4             	pushl  -0x4c(%ebp)
f0110ca9:	68 98 8b 12 f0       	push   $0xf0128b98
f0110cae:	e8 b9 02 ff ff       	call   f0100f6c <cprintf>
f0110cb3:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110cb6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110cba:	74 04                	je     f0110cc0 <test_free_block_FF+0xce3>
	{
		eval += 20;
f0110cbc:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)
	}

	//====================================================================//
	/*Allocate After Free Scenarios */
	cprintf("	7: Allocate After Free [should be placed in coalesced blocks]\n\n") ;
f0110cc0:	83 ec 0c             	sub    $0xc,%esp
f0110cc3:	68 00 8c 12 f0       	push   $0xf0128c00
f0110cc8:	e8 9f 02 ff ff       	call   f0100f6c <cprintf>
f0110ccd:	83 c4 10             	add    $0x10,%esp

	cprintf("		7.1: in block coalesces with NEXT\n\n") ;
f0110cd0:	83 ec 0c             	sub    $0xc,%esp
f0110cd3:	68 44 8c 12 f0       	push   $0xf0128c44
f0110cd8:	e8 8f 02 ff ff       	call   f0100f6c <cprintf>
f0110cdd:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110ce0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 5*kilo - sizeOfMetaData;
f0110ce7:	c7 45 c4 f8 13 00 00 	movl   $0x13f8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110cee:	83 ec 08             	sub    $0x8,%esp
f0110cf1:	6a 01                	push   $0x1
f0110cf3:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110cf6:	e8 da 02 01 00       	call   f0120fd5 <alloc_block>
f0110cfb:	83 c4 10             	add    $0x10,%esp
f0110cfe:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	void* expected = (void*)(KERNEL_HEAP_START + sizeof(int) + sizeOfMetaData/2);
f0110d01:	c7 45 98 08 00 00 f6 	movl   $0xf6000008,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110d08:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110d0c:	74 08                	je     f0110d16 <test_free_block_FF+0xd39>
f0110d0e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110d11:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110d14:	74 1d                	je     f0110d33 <test_free_block_FF+0xd56>
	{
		is_correct = 0;
f0110d16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.1: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110d1d:	83 ec 04             	sub    $0x4,%esp
f0110d20:	ff 75 c0             	pushl  -0x40(%ebp)
f0110d23:	ff 75 98             	pushl  -0x68(%ebp)
f0110d26:	68 6c 8c 12 f0       	push   $0xf0128c6c
f0110d2b:	e8 3c 02 ff ff       	call   f0100f6c <cprintf>
f0110d30:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 3*kilo - sizeOfMetaData;
f0110d33:	c7 45 c4 f8 0b 00 00 	movl   $0xbf8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110d3a:	83 ec 08             	sub    $0x8,%esp
f0110d3d:	6a 01                	push   $0x1
f0110d3f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110d42:	e8 8e 02 01 00       	call   f0120fd5 <alloc_block>
f0110d47:	83 c4 10             	add    $0x10,%esp
f0110d4a:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = (void*)(KERNEL_HEAP_START + sizeof(int) + 5*kilo + sizeOfMetaData/2);
f0110d4d:	c7 45 98 08 14 00 f6 	movl   $0xf6001408,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110d54:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110d58:	74 08                	je     f0110d62 <test_free_block_FF+0xd85>
f0110d5a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110d5d:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110d60:	74 1d                	je     f0110d7f <test_free_block_FF+0xda2>
	{
		is_correct = 0;
f0110d62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.2: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110d69:	83 ec 04             	sub    $0x4,%esp
f0110d6c:	ff 75 c0             	pushl  -0x40(%ebp)
f0110d6f:	ff 75 98             	pushl  -0x68(%ebp)
f0110d72:	68 d0 8c 12 f0       	push   $0xf0128cd0
f0110d77:	e8 f0 01 ff ff       	call   f0100f6c <cprintf>
f0110d7c:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 4*kilo + 10;
f0110d7f:	c7 45 c4 0a 10 00 00 	movl   $0x100a,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110d86:	83 ec 08             	sub    $0x8,%esp
f0110d89:	6a 01                	push   $0x1
f0110d8b:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110d8e:	e8 42 02 01 00       	call   f0120fd5 <alloc_block>
f0110d93:	83 c4 10             	add    $0x10,%esp
f0110d96:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[1*allocCntPerSize - 1];
f0110d99:	a1 fc 39 57 f0       	mov    0xf05739fc,%eax
f0110d9e:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110da1:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110da5:	74 08                	je     f0110daf <test_free_block_FF+0xdd2>
f0110da7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110daa:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110dad:	74 1d                	je     f0110dcc <test_free_block_FF+0xdef>
	{
		is_correct = 0;
f0110daf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.3: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110db6:	83 ec 04             	sub    $0x4,%esp
f0110db9:	ff 75 c0             	pushl  -0x40(%ebp)
f0110dbc:	ff 75 98             	pushl  -0x68(%ebp)
f0110dbf:	68 34 8d 12 f0       	push   $0xf0128d34
f0110dc4:	e8 a3 01 ff ff       	call   f0100f6c <cprintf>
f0110dc9:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110dcc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110dd0:	74 04                	je     f0110dd6 <test_free_block_FF+0xdf9>
	{
		eval += 10;
f0110dd2:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("		7.2: in block coalesces with PREV & NEXT\n\n") ;
f0110dd6:	83 ec 0c             	sub    $0xc,%esp
f0110dd9:	68 98 8d 12 f0       	push   $0xf0128d98
f0110dde:	e8 89 01 ff ff       	call   f0100f6c <cprintf>
f0110de3:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110de6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo + 1;
f0110ded:	c7 45 c4 01 08 00 00 	movl   $0x801,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110df4:	83 ec 08             	sub    $0x8,%esp
f0110df7:	6a 01                	push   $0x1
f0110df9:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110dfc:	e8 d4 01 01 00       	call   f0120fd5 <alloc_block>
f0110e01:	83 c4 10             	add    $0x10,%esp
f0110e04:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[4*allocCntPerSize - 2];
f0110e07:	a1 58 43 57 f0       	mov    0xf0574358,%eax
f0110e0c:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110e0f:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110e13:	74 08                	je     f0110e1d <test_free_block_FF+0xe40>
f0110e15:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110e18:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110e1b:	74 1d                	je     f0110e3a <test_free_block_FF+0xe5d>
	{
		is_correct = 0;
f0110e1d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.4: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110e24:	83 ec 04             	sub    $0x4,%esp
f0110e27:	ff 75 c0             	pushl  -0x40(%ebp)
f0110e2a:	ff 75 98             	pushl  -0x68(%ebp)
f0110e2d:	68 c8 8d 12 f0       	push   $0xf0128dc8
f0110e32:	e8 35 01 ff ff       	call   f0100f6c <cprintf>
f0110e37:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110e3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110e3e:	74 04                	je     f0110e44 <test_free_block_FF+0xe67>
	{
		eval += 10;
f0110e40:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("		7.3: in block coalesces with PREV\n\n") ;
f0110e44:	83 ec 0c             	sub    $0xc,%esp
f0110e47:	68 2c 8e 12 f0       	push   $0xf0128e2c
f0110e4c:	e8 1b 01 ff ff       	call   f0100f6c <cprintf>
f0110e51:	83 c4 10             	add    $0x10,%esp
	is_correct = 1;
f0110e54:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	actualSize = 2*kilo - sizeOfMetaData;
f0110e5b:	c7 45 c4 f8 07 00 00 	movl   $0x7f8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110e62:	83 ec 08             	sub    $0x8,%esp
f0110e65:	6a 01                	push   $0x1
f0110e67:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110e6a:	e8 66 01 01 00       	call   f0120fd5 <alloc_block>
f0110e6f:	83 c4 10             	add    $0x10,%esp
f0110e72:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[2*allocCntPerSize];
f0110e75:	a1 20 3d 57 f0       	mov    0xf0573d20,%eax
f0110e7a:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110e7d:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110e81:	74 08                	je     f0110e8b <test_free_block_FF+0xeae>
f0110e83:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110e86:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110e89:	74 1d                	je     f0110ea8 <test_free_block_FF+0xecb>
	{
		is_correct = 0;
f0110e8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.5: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110e92:	83 ec 04             	sub    $0x4,%esp
f0110e95:	ff 75 c0             	pushl  -0x40(%ebp)
f0110e98:	ff 75 98             	pushl  -0x68(%ebp)
f0110e9b:	68 54 8e 12 f0       	push   $0xf0128e54
f0110ea0:	e8 c7 00 ff ff       	call   f0100f6c <cprintf>
f0110ea5:	83 c4 10             	add    $0x10,%esp
	}
	actualSize = 8*kilo - sizeOfMetaData;
f0110ea8:	c7 45 c4 f8 1f 00 00 	movl   $0x1ff8,-0x3c(%ebp)
	va = alloc_block(actualSize, DA_FF);
f0110eaf:	83 ec 08             	sub    $0x8,%esp
f0110eb2:	6a 01                	push   $0x1
f0110eb4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0110eb7:	e8 19 01 01 00       	call   f0120fd5 <alloc_block>
f0110ebc:	83 c4 10             	add    $0x10,%esp
f0110ebf:	89 45 c0             	mov    %eax,-0x40(%ebp)
	//Check returned va
	expected = startVAs[numOfAllocs*allocCntPerSize-1];
f0110ec2:	a1 bc 4c 57 f0       	mov    0xf0574cbc,%eax
f0110ec7:	89 45 98             	mov    %eax,-0x68(%ebp)
	if(va == NULL || (va != expected))
f0110eca:	83 7d c0 00          	cmpl   $0x0,-0x40(%ebp)
f0110ece:	74 08                	je     f0110ed8 <test_free_block_FF+0xefb>
f0110ed0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0110ed3:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0110ed6:	74 1d                	je     f0110ef5 <test_free_block_FF+0xf18>
	{
		is_correct = 0;
f0110ed8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		cprintf("test_free_block #13.6: WRONG ALLOC - alloc_block_FF return wrong address. Expected %x, Actual %x\n", expected, va);
f0110edf:	83 ec 04             	sub    $0x4,%esp
f0110ee2:	ff 75 c0             	pushl  -0x40(%ebp)
f0110ee5:	ff 75 98             	pushl  -0x68(%ebp)
f0110ee8:	68 b8 8e 12 f0       	push   $0xf0128eb8
f0110eed:	e8 7a 00 ff ff       	call   f0100f6c <cprintf>
f0110ef2:	83 c4 10             	add    $0x10,%esp
	}
	if (is_correct)
f0110ef5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0110ef9:	74 04                	je     f0110eff <test_free_block_FF+0xf22>
	{
		eval += 10;
f0110efb:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)
	}

	cprintf("test free_block with FIRST FIT completed. Evaluation = %d%\n", eval);
f0110eff:	83 ec 08             	sub    $0x8,%esp
f0110f02:	ff 75 f4             	pushl  -0xc(%ebp)
f0110f05:	68 1c 8f 12 f0       	push   $0xf0128f1c
f0110f0a:	e8 5d 00 ff ff       	call   f0100f6c <cprintf>
f0110f0f:	83 c4 10             	add    $0x10,%esp

}
f0110f12:	90                   	nop
f0110f13:	c9                   	leave  
f0110f14:	c3                   	ret    

f0110f15 <test_free_block_BF>:

void test_free_block_BF()
{
f0110f15:	55                   	push   %ebp
f0110f16:	89 e5                	mov    %esp,%ebp
f0110f18:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===========================================================\n") ;
f0110f1b:	83 ec 0c             	sub    $0xc,%esp
f0110f1e:	68 a4 7d 12 f0       	push   $0xf0127da4
f0110f23:	e8 44 00 ff ff       	call   f0100f6c <cprintf>
f0110f28:	83 c4 10             	add    $0x10,%esp
	cprintf("NOTE: THIS TEST IS DEPEND ON BOTH ALLOCATE & FREE FUNCTIONS\n") ;
f0110f2b:	83 ec 0c             	sub    $0xc,%esp
f0110f2e:	68 e4 7d 12 f0       	push   $0xf0127de4
f0110f33:	e8 34 00 ff ff       	call   f0100f6c <cprintf>
f0110f38:	83 c4 10             	add    $0x10,%esp
	cprintf("===========================================================\n") ;
f0110f3b:	83 ec 0c             	sub    $0xc,%esp
f0110f3e:	68 a4 7d 12 f0       	push   $0xf0127da4
f0110f43:	e8 24 00 ff ff       	call   f0100f6c <cprintf>
f0110f48:	83 c4 10             	add    $0x10,%esp

	panic("Test is under construction! will be announced later isA");
f0110f4b:	83 ec 04             	sub    $0x4,%esp
f0110f4e:	68 6c 7d 12 f0       	push   $0xf0127d6c
f0110f53:	68 53 03 00 00       	push   $0x353
f0110f58:	68 48 76 12 f0       	push   $0xf0127648
f0110f5d:	e8 b8 f3 fe ff       	call   f010031a <_panic>

f0110f62 <test_free_block_NF>:

}

void test_free_block_NF()
{
f0110f62:	55                   	push   %ebp
f0110f63:	89 e5                	mov    %esp,%ebp
f0110f65:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented");
f0110f68:	83 ec 04             	sub    $0x4,%esp
f0110f6b:	68 58 8f 12 f0       	push   $0xf0128f58
f0110f70:	68 59 03 00 00       	push   $0x359
f0110f75:	68 48 76 12 f0       	push   $0xf0127648
f0110f7a:	e8 9b f3 fe ff       	call   f010031a <_panic>

f0110f7f <test_realloc_block_FF>:
}

void test_realloc_block_FF()
{
f0110f7f:	55                   	push   %ebp
f0110f80:	89 e5                	mov    %esp,%ebp
f0110f82:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	cprintf("===================================================\n");
f0110f85:	83 ec 0c             	sub    $0xc,%esp
f0110f88:	68 68 8f 12 f0       	push   $0xf0128f68
f0110f8d:	e8 da ff fe ff       	call   f0100f6c <cprintf>
f0110f92:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A PARTIAL TEST FOR REALLOC******\n") ;
f0110f95:	83 ec 0c             	sub    $0xc,%esp
f0110f98:	68 a0 8f 12 f0       	push   $0xf0128fa0
f0110f9d:	e8 ca ff fe ff       	call   f0100f6c <cprintf>
f0110fa2:	83 c4 10             	add    $0x10,%esp
	cprintf("You need to pick-up the missing tests and test them\n") ;
f0110fa5:	83 ec 0c             	sub    $0xc,%esp
f0110fa8:	68 d8 8f 12 f0       	push   $0xf0128fd8
f0110fad:	e8 ba ff fe ff       	call   f0100f6c <cprintf>
f0110fb2:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f0110fb5:	83 ec 0c             	sub    $0xc,%esp
f0110fb8:	68 68 8f 12 f0       	push   $0xf0128f68
f0110fbd:	e8 aa ff fe ff       	call   f0100f6c <cprintf>
f0110fc2:	83 c4 10             	add    $0x10,%esp

	//TODO: [PROJECT'24.MS1 - #09] [3] DYNAMIC ALLOCATOR - test_realloc_block_FF()
	//CHECK MISSING CASES AND TRY TO TEST THEM !

	panic("Test is under construction! will be announced later isA");
f0110fc5:	83 ec 04             	sub    $0x4,%esp
f0110fc8:	68 6c 7d 12 f0       	push   $0xf0127d6c
f0110fcd:	68 6b 03 00 00       	push   $0x36b
f0110fd2:	68 48 76 12 f0       	push   $0xf0127648
f0110fd7:	e8 3e f3 fe ff       	call   f010031a <_panic>

f0110fdc <test_realloc_block_FF_COMPLETE>:

}


void test_realloc_block_FF_COMPLETE()
{
f0110fdc:	55                   	push   %ebp
f0110fdd:	89 e5                	mov    %esp,%ebp
f0110fdf:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_free_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
	return;
#endif

	panic("this is unseen test");
f0110fe2:	83 ec 04             	sub    $0x4,%esp
f0110fe5:	68 0d 90 12 f0       	push   $0xf012900d
f0110fea:	68 77 03 00 00       	push   $0x377
f0110fef:	68 48 76 12 f0       	push   $0xf0127648
f0110ff4:	e8 21 f3 fe ff       	call   f010031a <_panic>

f0110ff9 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0110ff9:	55                   	push   %ebp
f0110ffa:	89 e5                	mov    %esp,%ebp
f0110ffc:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f0110fff:	e8 6d 94 ff ff       	call   f010a471 <get_cpu_proc>
f0111004:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111007:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011100b:	75 16                	jne    f0111023 <sys_check_LRU_lists+0x2a>
f011100d:	68 24 90 12 f0       	push   $0xf0129024
f0111012:	68 34 90 12 f0       	push   $0xf0129034
f0111017:	6a 10                	push   $0x10
f0111019:	68 49 90 12 f0       	push   $0xf0129049
f011101e:	e8 f7 f2 fe ff       	call   f010031a <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f0111023:	83 ec 0c             	sub    $0xc,%esp
f0111026:	68 68 90 12 f0       	push   $0xf0129068
f011102b:	e8 3c ff fe ff       	call   f0100f6c <cprintf>
f0111030:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f0111033:	83 ec 0c             	sub    $0xc,%esp
f0111036:	ff 75 e0             	pushl  -0x20(%ebp)
f0111039:	e8 cb 7c ff ff       	call   f0108d09 <env_page_ws_print>
f011103e:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f0111041:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111044:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f0111047:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f011104e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f0111055:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0111059:	0f 84 a5 00 00 00    	je     f0111104 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f011105f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111066:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111069:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f011106f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111072:	eb 4a                	jmp    f01110be <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f0111074:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111077:	8b 00                	mov    (%eax),%eax
f0111079:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011107c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011107f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111084:	89 c2                	mov    %eax,%edx
f0111086:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111089:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111090:	8b 45 08             	mov    0x8(%ebp),%eax
f0111093:	01 c8                	add    %ecx,%eax
f0111095:	8b 00                	mov    (%eax),%eax
f0111097:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011109a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011109d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01110a2:	39 c2                	cmp    %eax,%edx
f01110a4:	74 09                	je     f01110af <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f01110a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f01110ad:	eb 3e                	jmp    f01110ed <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f01110af:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01110b2:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110b5:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f01110bb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01110be:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01110c2:	74 08                	je     f01110cc <sys_check_LRU_lists+0xd3>
f01110c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01110c7:	8b 40 10             	mov    0x10(%eax),%eax
f01110ca:	eb 05                	jmp    f01110d1 <sys_check_LRU_lists+0xd8>
f01110cc:	b8 00 00 00 00       	mov    $0x0,%eax
f01110d1:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01110d4:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f01110da:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110dd:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f01110e3:	85 c0                	test   %eax,%eax
f01110e5:	75 8d                	jne    f0111074 <sys_check_LRU_lists+0x7b>
f01110e7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01110eb:	75 87                	jne    f0111074 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f01110ed:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01110f0:	8b 90 1c da 01 00    	mov    0x1da1c(%eax),%edx
f01110f6:	8b 45 10             	mov    0x10(%ebp),%eax
f01110f9:	39 c2                	cmp    %eax,%edx
f01110fb:	74 07                	je     f0111104 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f01110fd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111104:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111108:	0f 84 a5 00 00 00    	je     f01111b3 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f011110e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111115:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111118:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f011111e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0111121:	eb 4a                	jmp    f011116d <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f0111123:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111126:	8b 00                	mov    (%eax),%eax
f0111128:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011112b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011112e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111133:	89 c2                	mov    %eax,%edx
f0111135:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111138:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011113f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111142:	01 c8                	add    %ecx,%eax
f0111144:	8b 00                	mov    (%eax),%eax
f0111146:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0111149:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011114c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111151:	39 c2                	cmp    %eax,%edx
f0111153:	74 09                	je     f011115e <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f0111155:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f011115c:	eb 3e                	jmp    f011119c <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f011115e:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111161:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111164:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f011116a:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011116d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111171:	74 08                	je     f011117b <sys_check_LRU_lists+0x182>
f0111173:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111176:	8b 40 10             	mov    0x10(%eax),%eax
f0111179:	eb 05                	jmp    f0111180 <sys_check_LRU_lists+0x187>
f011117b:	b8 00 00 00 00       	mov    $0x0,%eax
f0111180:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111183:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f0111189:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011118c:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0111192:	85 c0                	test   %eax,%eax
f0111194:	75 8d                	jne    f0111123 <sys_check_LRU_lists+0x12a>
f0111196:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011119a:	75 87                	jne    f0111123 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f011119c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011119f:	8b 90 2c da 01 00    	mov    0x1da2c(%eax),%edx
f01111a5:	8b 45 14             	mov    0x14(%ebp),%eax
f01111a8:	39 c2                	cmp    %eax,%edx
f01111aa:	74 07                	je     f01111b3 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f01111ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f01111b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01111b6:	23 45 f0             	and    -0x10(%ebp),%eax
}
f01111b9:	c9                   	leave  
f01111ba:	c3                   	ret    

f01111bb <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f01111bb:	55                   	push   %ebp
f01111bc:	89 e5                	mov    %esp,%ebp
f01111be:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f01111c1:	e8 ab 92 ff ff       	call   f010a471 <get_cpu_proc>
f01111c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f01111c9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01111cd:	75 16                	jne    f01111e5 <sys_check_LRU_lists_free+0x2a>
f01111cf:	68 24 90 12 f0       	push   $0xf0129024
f01111d4:	68 34 90 12 f0       	push   $0xf0129034
f01111d9:	6a 45                	push   $0x45
f01111db:	68 49 90 12 f0       	push   $0xf0129049
f01111e0:	e8 35 f1 fe ff       	call   f010031a <_panic>
	struct Env* env = cur_env;
f01111e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01111e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f01111eb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01111f2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111f5:	8b 80 10 da 01 00    	mov    0x1da10(%eax),%eax
f01111fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01111fe:	eb 65                	jmp    f0111265 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f0111200:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111207:	eb 3a                	jmp    f0111243 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111209:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011120c:	8b 00                	mov    (%eax),%eax
f011120e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111211:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111214:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111219:	89 c2                	mov    %eax,%edx
f011121b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011121e:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111225:	8b 45 08             	mov    0x8(%ebp),%eax
f0111228:	01 c8                	add    %ecx,%eax
f011122a:	8b 00                	mov    (%eax),%eax
f011122c:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011122f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111232:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111237:	39 c2                	cmp    %eax,%edx
f0111239:	75 05                	jne    f0111240 <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f011123b:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f011123e:	eb 0b                	jmp    f011124b <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f0111240:	ff 45 ec             	incl   -0x14(%ebp)
f0111243:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111246:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111249:	7c be                	jl     f0111209 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f011124b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011124f:	7e 08                	jle    f0111259 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f0111251:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111254:	e9 ed 00 00 00       	jmp    f0111346 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111259:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011125c:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f0111262:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111265:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111269:	74 08                	je     f0111273 <sys_check_LRU_lists_free+0xb8>
f011126b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011126e:	8b 40 10             	mov    0x10(%eax),%eax
f0111271:	eb 05                	jmp    f0111278 <sys_check_LRU_lists_free+0xbd>
f0111273:	b8 00 00 00 00       	mov    $0x0,%eax
f0111278:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011127b:	89 82 18 da 01 00    	mov    %eax,0x1da18(%edx)
f0111281:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111284:	8b 80 18 da 01 00    	mov    0x1da18(%eax),%eax
f011128a:	85 c0                	test   %eax,%eax
f011128c:	0f 85 6e ff ff ff    	jne    f0111200 <sys_check_LRU_lists_free+0x45>
f0111292:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111296:	0f 85 64 ff ff ff    	jne    f0111200 <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011129c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011129f:	8b 80 20 da 01 00    	mov    0x1da20(%eax),%eax
f01112a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01112a8:	eb 62                	jmp    f011130c <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f01112aa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01112b1:	eb 3a                	jmp    f01112ed <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f01112b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01112b6:	8b 00                	mov    (%eax),%eax
f01112b8:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01112bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01112be:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112c3:	89 c2                	mov    %eax,%edx
f01112c5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112c8:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01112d2:	01 c8                	add    %ecx,%eax
f01112d4:	8b 00                	mov    (%eax),%eax
f01112d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01112d9:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01112dc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112e1:	39 c2                	cmp    %eax,%edx
f01112e3:	75 05                	jne    f01112ea <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f01112e5:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01112e8:	eb 0b                	jmp    f01112f5 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f01112ea:	ff 45 e8             	incl   -0x18(%ebp)
f01112ed:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01112f0:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01112f3:	7c be                	jl     f01112b3 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01112f5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01112f9:	7e 05                	jle    f0111300 <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f01112fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01112fe:	eb 46                	jmp    f0111346 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111300:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111303:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0111309:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011130c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111310:	74 08                	je     f011131a <sys_check_LRU_lists_free+0x15f>
f0111312:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111315:	8b 40 10             	mov    0x10(%eax),%eax
f0111318:	eb 05                	jmp    f011131f <sys_check_LRU_lists_free+0x164>
f011131a:	b8 00 00 00 00       	mov    $0x0,%eax
f011131f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0111322:	89 82 28 da 01 00    	mov    %eax,0x1da28(%edx)
f0111328:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011132b:	8b 80 28 da 01 00    	mov    0x1da28(%eax),%eax
f0111331:	85 c0                	test   %eax,%eax
f0111333:	0f 85 71 ff ff ff    	jne    f01112aa <sys_check_LRU_lists_free+0xef>
f0111339:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011133d:	0f 85 67 ff ff ff    	jne    f01112aa <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f0111343:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0111346:	c9                   	leave  
f0111347:	c3                   	ret    

f0111348 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f0111348:	55                   	push   %ebp
f0111349:	89 e5                	mov    %esp,%ebp
f011134b:	83 ec 08             	sub    $0x8,%esp
		}
	}

	return WS_list_validation;
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
f011134e:	83 ec 04             	sub    $0x4,%esp
f0111351:	68 90 90 12 f0       	push   $0xf0129090
f0111356:	68 ea 00 00 00       	push   $0xea
f011135b:	68 49 90 12 f0       	push   $0xf0129049
f0111360:	e8 b5 ef fe ff       	call   f010031a <_panic>

f0111365 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111365:	55                   	push   %ebp
f0111366:	89 e5                	mov    %esp,%ebp
f0111368:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011136b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111372:	8b 15 78 51 55 f0    	mov    0xf0555178,%edx
f0111378:	8b 45 0c             	mov    0xc(%ebp),%eax
f011137b:	39 c2                	cmp    %eax,%edx
f011137d:	74 0a                	je     f0111389 <hasExpectedCommands+0x24>
		return 0;
f011137f:	b8 00 00 00 00       	mov    $0x0,%eax
f0111384:	e9 8b 00 00 00       	jmp    f0111414 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f0111389:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f011138e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111391:	eb 55                	jmp    f01113e8 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111393:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011139a:	eb 2a                	jmp    f01113c6 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011139c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011139f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01113a6:	8b 45 08             	mov    0x8(%ebp),%eax
f01113a9:	01 d0                	add    %edx,%eax
f01113ab:	8b 10                	mov    (%eax),%edx
f01113ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113b0:	8b 00                	mov    (%eax),%eax
f01113b2:	83 ec 08             	sub    $0x8,%esp
f01113b5:	52                   	push   %edx
f01113b6:	50                   	push   %eax
f01113b7:	e8 83 f2 00 00       	call   f012063f <strcmp>
f01113bc:	83 c4 10             	add    $0x10,%esp
f01113bf:	85 c0                	test   %eax,%eax
f01113c1:	74 0d                	je     f01113d0 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f01113c3:	ff 45 f0             	incl   -0x10(%ebp)
f01113c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113c9:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113cc:	7c ce                	jl     f011139c <hasExpectedCommands+0x37>
f01113ce:	eb 01                	jmp    f01113d1 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f01113d0:	90                   	nop
		if (i == commandsCount)
f01113d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113d4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113d7:	75 07                	jne    f01113e0 <hasExpectedCommands+0x7b>
			return 0;
f01113d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01113de:	eb 34                	jmp    f0111414 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f01113e0:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f01113e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01113e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01113ec:	74 08                	je     f01113f6 <hasExpectedCommands+0x91>
f01113ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113f1:	8b 40 10             	mov    0x10(%eax),%eax
f01113f4:	eb 05                	jmp    f01113fb <hasExpectedCommands+0x96>
f01113f6:	b8 00 00 00 00       	mov    $0x0,%eax
f01113fb:	a3 74 51 55 f0       	mov    %eax,0xf0555174
f0111400:	a1 74 51 55 f0       	mov    0xf0555174,%eax
f0111405:	85 c0                	test   %eax,%eax
f0111407:	75 8a                	jne    f0111393 <hasExpectedCommands+0x2e>
f0111409:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011140d:	75 84                	jne    f0111393 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f011140f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0111414:	c9                   	leave  
f0111415:	c3                   	ret    

f0111416 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f0111416:	55                   	push   %ebp
f0111417:	89 e5                	mov    %esp,%ebp
f0111419:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f011141c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111423:	eb 2e                	jmp    f0111453 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f0111425:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111428:	89 d0                	mov    %edx,%eax
f011142a:	01 c0                	add    %eax,%eax
f011142c:	01 d0                	add    %edx,%eax
f011142e:	c1 e0 03             	shl    $0x3,%eax
f0111431:	05 40 95 17 f0       	add    $0xf0179540,%eax
f0111436:	8b 00                	mov    (%eax),%eax
f0111438:	83 ec 08             	sub    $0x8,%esp
f011143b:	ff 75 08             	pushl  0x8(%ebp)
f011143e:	50                   	push   %eax
f011143f:	e8 fb f1 00 00       	call   f012063f <strcmp>
f0111444:	83 c4 10             	add    $0x10,%esp
f0111447:	85 c0                	test   %eax,%eax
f0111449:	75 05                	jne    f0111450 <getIndexOfCommand+0x3a>
			return i;
f011144b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011144e:	eb 14                	jmp    f0111464 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111450:	ff 45 f4             	incl   -0xc(%ebp)
f0111453:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111456:	a1 48 99 17 f0       	mov    0xf0179948,%eax
f011145b:	39 c2                	cmp    %eax,%edx
f011145d:	72 c6                	jb     f0111425 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f011145f:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111464:	c9                   	leave  
f0111465:	c3                   	ret    

f0111466 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111466:	55                   	push   %ebp
f0111467:	89 e5                	mov    %esp,%ebp
f0111469:	57                   	push   %edi
f011146a:	56                   	push   %esi
f011146b:	53                   	push   %ebx
f011146c:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111472:	83 ec 0c             	sub    $0xc,%esp
f0111475:	68 e0 90 12 f0       	push   $0xf01290e0
f011147a:	e8 ed fa fe ff       	call   f0100f6c <cprintf>
f011147f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111482:	83 ec 0c             	sub    $0xc,%esp
f0111485:	68 04 91 12 f0       	push   $0xf0129104
f011148a:	e8 dd fa fe ff       	call   f0100f6c <cprintf>
f011148f:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111492:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f0111499:	c7 45 8c 1f 91 12 f0 	movl   $0xf012911f,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f01114a0:	83 ec 08             	sub    $0x8,%esp
f01114a3:	8d 45 8c             	lea    -0x74(%ebp),%eax
f01114a6:	50                   	push   %eax
f01114a7:	6a 01                	push   $0x1
f01114a9:	e8 03 0d ff ff       	call   f01021b1 <process_command>
f01114ae:	83 c4 10             	add    $0x10,%esp
f01114b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f01114b4:	83 ec 0c             	sub    $0xc,%esp
f01114b7:	68 2c 91 12 f0       	push   $0xf012912c
f01114bc:	e8 ab fa fe ff       	call   f0100f6c <cprintf>
f01114c1:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f01114c4:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01114c7:	83 ec 0c             	sub    $0xc,%esp
f01114ca:	50                   	push   %eax
f01114cb:	e8 46 ff ff ff       	call   f0111416 <getIndexOfCommand>
f01114d0:	83 c4 10             	add    $0x10,%esp
f01114d3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01114d6:	75 0f                	jne    f01114e7 <TestAutoCompleteCommand+0x81>
f01114d8:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f01114dd:	85 c0                	test   %eax,%eax
f01114df:	75 06                	jne    f01114e7 <TestAutoCompleteCommand+0x81>
		eval += 15;
f01114e1:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01114e5:	eb 10                	jmp    f01114f7 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01114e7:	83 ec 0c             	sub    $0xc,%esp
f01114ea:	68 5c 91 12 f0       	push   $0xf012915c
f01114ef:	e8 78 fa fe ff       	call   f0100f6c <cprintf>
f01114f4:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01114f7:	83 ec 0c             	sub    $0xc,%esp
f01114fa:	68 ac 91 12 f0       	push   $0xf01291ac
f01114ff:	e8 68 fa fe ff       	call   f0100f6c <cprintf>
f0111504:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f0111507:	c7 45 88 d2 91 12 f0 	movl   $0xf01291d2,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f011150e:	83 ec 08             	sub    $0x8,%esp
f0111511:	8d 45 88             	lea    -0x78(%ebp),%eax
f0111514:	50                   	push   %eax
f0111515:	6a 01                	push   $0x1
f0111517:	e8 95 0c ff ff       	call   f01021b1 <process_command>
f011151c:	83 c4 10             	add    $0x10,%esp
f011151f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f0111522:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111526:	75 30                	jne    f0111558 <TestAutoCompleteCommand+0xf2>
f0111528:	8d 45 90             	lea    -0x70(%ebp),%eax
f011152b:	bb b0 95 12 f0       	mov    $0xf01295b0,%ebx
f0111530:	ba 03 00 00 00       	mov    $0x3,%edx
f0111535:	89 c7                	mov    %eax,%edi
f0111537:	89 de                	mov    %ebx,%esi
f0111539:	89 d1                	mov    %edx,%ecx
f011153b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f011153d:	83 ec 08             	sub    $0x8,%esp
f0111540:	6a 03                	push   $0x3
f0111542:	8d 45 90             	lea    -0x70(%ebp),%eax
f0111545:	50                   	push   %eax
f0111546:	e8 1a fe ff ff       	call   f0111365 <hasExpectedCommands>
f011154b:	83 c4 10             	add    $0x10,%esp
f011154e:	85 c0                	test   %eax,%eax
f0111550:	74 06                	je     f0111558 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111552:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111556:	eb 10                	jmp    f0111568 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111558:	83 ec 0c             	sub    $0xc,%esp
f011155b:	68 d8 91 12 f0       	push   $0xf01291d8
f0111560:	e8 07 fa fe ff       	call   f0100f6c <cprintf>
f0111565:	83 c4 10             	add    $0x10,%esp

	// CASE3: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111568:	83 ec 0c             	sub    $0xc,%esp
f011156b:	68 28 92 12 f0       	push   $0xf0129228
f0111570:	e8 f7 f9 fe ff       	call   f0100f6c <cprintf>
f0111575:	83 c4 10             	add    $0x10,%esp
	char *args3[] = {"wm"};
f0111578:	c7 45 84 4d 92 12 f0 	movl   $0xf012924d,-0x7c(%ebp)
	cprintf("va of args3 = %x, *args3 = %x\n", args3, *args3);
f011157f:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0111582:	83 ec 04             	sub    $0x4,%esp
f0111585:	50                   	push   %eax
f0111586:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111589:	50                   	push   %eax
f011158a:	68 50 92 12 f0       	push   $0xf0129250
f011158f:	e8 d8 f9 fe ff       	call   f0100f6c <cprintf>
f0111594:	83 c4 10             	add    $0x10,%esp
	ret = process_command(ARRAY_LENGTH(args3), args3);
f0111597:	83 ec 08             	sub    $0x8,%esp
f011159a:	8d 45 84             	lea    -0x7c(%ebp),%eax
f011159d:	50                   	push   %eax
f011159e:	6a 01                	push   $0x1
f01115a0:	e8 0c 0c ff ff       	call   f01021b1 <process_command>
f01115a5:	83 c4 10             	add    $0x10,%esp
f01115a8:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3, 1))
f01115ab:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f01115af:	75 1b                	jne    f01115cc <TestAutoCompleteCommand+0x166>
f01115b1:	83 ec 08             	sub    $0x8,%esp
f01115b4:	6a 01                	push   $0x1
f01115b6:	8d 45 84             	lea    -0x7c(%ebp),%eax
f01115b9:	50                   	push   %eax
f01115ba:	e8 a6 fd ff ff       	call   f0111365 <hasExpectedCommands>
f01115bf:	83 c4 10             	add    $0x10,%esp
f01115c2:	85 c0                	test   %eax,%eax
f01115c4:	74 06                	je     f01115cc <TestAutoCompleteCommand+0x166>
		eval += 15;
f01115c6:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f01115ca:	eb 10                	jmp    f01115dc <TestAutoCompleteCommand+0x176>
	else
		cprintf("#3: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f01115cc:	83 ec 0c             	sub    $0xc,%esp
f01115cf:	68 70 92 12 f0       	push   $0xf0129270
f01115d4:	e8 93 f9 fe ff       	call   f0100f6c <cprintf>
f01115d9:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f01115dc:	83 ec 0c             	sub    $0xc,%esp
f01115df:	68 c8 92 12 f0       	push   $0xf01292c8
f01115e4:	e8 83 f9 fe ff       	call   f0100f6c <cprintf>
f01115e9:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f01115ec:	c7 45 80 ee 92 12 f0 	movl   $0xf01292ee,-0x80(%ebp)
	ret = process_command(ARRAY_LENGTH(args4), args4);
f01115f3:	83 ec 08             	sub    $0x8,%esp
f01115f6:	8d 45 80             	lea    -0x80(%ebp),%eax
f01115f9:	50                   	push   %eax
f01115fa:	6a 01                	push   $0x1
f01115fc:	e8 b0 0b ff ff       	call   f01021b1 <process_command>
f0111601:	83 c4 10             	add    $0x10,%esp
f0111604:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111607:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f011160b:	75 0f                	jne    f011161c <TestAutoCompleteCommand+0x1b6>
f011160d:	a1 78 51 55 f0       	mov    0xf0555178,%eax
f0111612:	85 c0                	test   %eax,%eax
f0111614:	75 06                	jne    f011161c <TestAutoCompleteCommand+0x1b6>
		eval += 15;
f0111616:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f011161a:	eb 10                	jmp    f011162c <TestAutoCompleteCommand+0x1c6>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011161c:	83 ec 0c             	sub    $0xc,%esp
f011161f:	68 f4 92 12 f0       	push   $0xf01292f4
f0111624:	e8 43 f9 fe ff       	call   f0100f6c <cprintf>
f0111629:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that start with he ---> Shall print (help)
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f011162c:	83 ec 0c             	sub    $0xc,%esp
f011162f:	68 44 93 12 f0       	push   $0xf0129344
f0111634:	e8 33 f9 fe ff       	call   f0100f6c <cprintf>
f0111639:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f011163c:	c7 85 7c ff ff ff 69 	movl   $0xf0129369,-0x84(%ebp)
f0111643:	93 12 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111646:	83 ec 08             	sub    $0x8,%esp
f0111649:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011164f:	50                   	push   %eax
f0111650:	6a 01                	push   $0x1
f0111652:	e8 5a 0b ff ff       	call   f01021b1 <process_command>
f0111657:	83 c4 10             	add    $0x10,%esp
f011165a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f011165d:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111661:	75 30                	jne    f0111693 <TestAutoCompleteCommand+0x22d>
f0111663:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111666:	bb 40 96 12 f0       	mov    $0xf0129640,%ebx
f011166b:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111670:	89 c7                	mov    %eax,%edi
f0111672:	89 de                	mov    %ebx,%esi
f0111674:	89 d1                	mov    %edx,%ecx
f0111676:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111678:	83 ec 08             	sub    $0x8,%esp
f011167b:	6a 0c                	push   $0xc
f011167d:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111680:	50                   	push   %eax
f0111681:	e8 df fc ff ff       	call   f0111365 <hasExpectedCommands>
f0111686:	83 c4 10             	add    $0x10,%esp
f0111689:	85 c0                	test   %eax,%eax
f011168b:	74 06                	je     f0111693 <TestAutoCompleteCommand+0x22d>
		eval += 10;
f011168d:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111691:	eb 10                	jmp    f01116a3 <TestAutoCompleteCommand+0x23d>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111693:	83 ec 0c             	sub    $0xc,%esp
f0111696:	68 6c 93 12 f0       	push   $0xf012936c
f011169b:	e8 cc f8 fe ff       	call   f0100f6c <cprintf>
f01116a0:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that start with ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f01116a3:	83 ec 0c             	sub    $0xc,%esp
f01116a6:	68 c4 93 12 f0       	push   $0xf01293c4
f01116ab:	e8 bc f8 fe ff       	call   f0100f6c <cprintf>
f01116b0:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f01116b3:	c7 85 78 ff ff ff e9 	movl   $0xf01293e9,-0x88(%ebp)
f01116ba:	93 12 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f01116bd:	83 ec 08             	sub    $0x8,%esp
f01116c0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01116c6:	50                   	push   %eax
f01116c7:	6a 01                	push   $0x1
f01116c9:	e8 e3 0a ff ff       	call   f01021b1 <process_command>
f01116ce:	83 c4 10             	add    $0x10,%esp
f01116d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f01116d4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01116d8:	75 30                	jne    f011170a <TestAutoCompleteCommand+0x2a4>
f01116da:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01116dd:	bb 88 96 12 f0       	mov    $0xf0129688,%ebx
f01116e2:	ba 05 00 00 00       	mov    $0x5,%edx
f01116e7:	89 c7                	mov    %eax,%edi
f01116e9:	89 de                	mov    %ebx,%esi
f01116eb:	89 d1                	mov    %edx,%ecx
f01116ed:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01116ef:	83 ec 08             	sub    $0x8,%esp
f01116f2:	6a 05                	push   $0x5
f01116f4:	8d 45 cc             	lea    -0x34(%ebp),%eax
f01116f7:	50                   	push   %eax
f01116f8:	e8 68 fc ff ff       	call   f0111365 <hasExpectedCommands>
f01116fd:	83 c4 10             	add    $0x10,%esp
f0111700:	85 c0                	test   %eax,%eax
f0111702:	74 06                	je     f011170a <TestAutoCompleteCommand+0x2a4>
		eval += 10;
f0111704:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111708:	eb 10                	jmp    f011171a <TestAutoCompleteCommand+0x2b4>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f011170a:	83 ec 0c             	sub    $0xc,%esp
f011170d:	68 ec 93 12 f0       	push   $0xf01293ec
f0111712:	e8 55 f8 fe ff       	call   f0100f6c <cprintf>
f0111717:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f011171a:	83 ec 0c             	sub    $0xc,%esp
f011171d:	68 44 94 12 f0       	push   $0xf0129444
f0111722:	e8 45 f8 fe ff       	call   f0100f6c <cprintf>
f0111727:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f011172a:	c7 85 70 ff ff ff 70 	movl   $0xf0129470,-0x90(%ebp)
f0111731:	94 12 f0 
f0111734:	c7 85 74 ff ff ff 75 	movl   $0xf0129475,-0x8c(%ebp)
f011173b:	94 12 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f011173e:	83 ec 08             	sub    $0x8,%esp
f0111741:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111747:	50                   	push   %eax
f0111748:	6a 02                	push   $0x2
f011174a:	e8 62 0a ff ff       	call   f01021b1 <process_command>
f011174f:	83 c4 10             	add    $0x10,%esp
f0111752:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111755:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011175b:	83 ec 0c             	sub    $0xc,%esp
f011175e:	50                   	push   %eax
f011175f:	e8 b2 fc ff ff       	call   f0111416 <getIndexOfCommand>
f0111764:	83 c4 10             	add    $0x10,%esp
f0111767:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011176a:	75 0f                	jne    f011177b <TestAutoCompleteCommand+0x315>
f011176c:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f0111771:	85 c0                	test   %eax,%eax
f0111773:	75 06                	jne    f011177b <TestAutoCompleteCommand+0x315>
		eval += 10;
f0111775:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111779:	eb 10                	jmp    f011178b <TestAutoCompleteCommand+0x325>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f011177b:	83 ec 0c             	sub    $0xc,%esp
f011177e:	68 7c 94 12 f0       	push   $0xf012947c
f0111783:	e8 e4 f7 fe ff       	call   f0100f6c <cprintf>
f0111788:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f011178b:	83 ec 0c             	sub    $0xc,%esp
f011178e:	68 cc 94 12 f0       	push   $0xf01294cc
f0111793:	e8 d4 f7 fe ff       	call   f0100f6c <cprintf>
f0111798:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f011179b:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01117a1:	bb b0 96 12 f0       	mov    $0xf01296b0,%ebx
f01117a6:	ba 03 00 00 00       	mov    $0x3,%edx
f01117ab:	89 c7                	mov    %eax,%edi
f01117ad:	89 de                	mov    %ebx,%esi
f01117af:	89 d1                	mov    %edx,%ecx
f01117b1:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f01117b3:	83 ec 08             	sub    $0x8,%esp
f01117b6:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f01117bc:	50                   	push   %eax
f01117bd:	6a 03                	push   $0x3
f01117bf:	e8 ed 09 ff ff       	call   f01021b1 <process_command>
f01117c4:	83 c4 10             	add    $0x10,%esp
f01117c7:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f01117ca:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f01117d0:	83 ec 0c             	sub    $0xc,%esp
f01117d3:	50                   	push   %eax
f01117d4:	e8 3d fc ff ff       	call   f0111416 <getIndexOfCommand>
f01117d9:	83 c4 10             	add    $0x10,%esp
f01117dc:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01117df:	75 0f                	jne    f01117f0 <TestAutoCompleteCommand+0x38a>
f01117e1:	a1 6c 51 55 f0       	mov    0xf055516c,%eax
f01117e6:	85 c0                	test   %eax,%eax
f01117e8:	75 06                	jne    f01117f0 <TestAutoCompleteCommand+0x38a>
		eval += 10;
f01117ea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f01117ee:	eb 10                	jmp    f0111800 <TestAutoCompleteCommand+0x39a>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f01117f0:	83 ec 0c             	sub    $0xc,%esp
f01117f3:	68 00 95 12 f0       	push   $0xf0129500
f01117f8:	e8 6f f7 fe ff       	call   f0100f6c <cprintf>
f01117fd:	83 c4 10             	add    $0x10,%esp

	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
f0111800:	83 ec 08             	sub    $0x8,%esp
f0111803:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111806:	68 50 95 12 f0       	push   $0xf0129550
f011180b:	e8 5c f7 fe ff       	call   f0100f6c <cprintf>
f0111810:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111813:	83 ec 0c             	sub    $0xc,%esp
f0111816:	68 80 95 12 f0       	push   $0xf0129580
f011181b:	e8 4c f7 fe ff       	call   f0100f6c <cprintf>
f0111820:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111823:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111828:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011182b:	5b                   	pop    %ebx
f011182c:	5e                   	pop    %esi
f011182d:	5f                   	pop    %edi
f011182e:	5d                   	pop    %ebp
f011182f:	c3                   	ret    

f0111830 <test_str2lower_function>:

int test_str2lower_function()
{
f0111830:	55                   	push   %ebp
f0111831:	89 e5                	mov    %esp,%ebp
f0111833:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111839:	83 ec 0c             	sub    $0xc,%esp
f011183c:	68 bc 96 12 f0       	push   $0xf01296bc
f0111841:	e8 26 f7 fe ff       	call   f0100f6c <cprintf>
f0111846:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111849:	83 ec 0c             	sub    $0xc,%esp
f011184c:	68 dd 96 12 f0       	push   $0xf01296dd
f0111851:	e8 16 f7 fe ff       	call   f0100f6c <cprintf>
f0111856:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111859:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111860:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111867:	c7 45 ec f7 96 12 f0 	movl   $0xf01296f7,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f011186e:	83 ec 08             	sub    $0x8,%esp
f0111871:	ff 75 ec             	pushl  -0x14(%ebp)
f0111874:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f011187a:	50                   	push   %eax
f011187b:	e8 9c f3 00 00       	call   f0120c1c <str2lower>
f0111880:	83 c4 10             	add    $0x10,%esp
f0111883:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111886:	83 ec 0c             	sub    $0xc,%esp
f0111889:	ff 75 e8             	pushl  -0x18(%ebp)
f011188c:	e8 a2 ec 00 00       	call   f0120533 <strlen>
f0111891:	83 c4 10             	add    $0x10,%esp
f0111894:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111897:	83 ec 08             	sub    $0x8,%esp
f011189a:	68 02 97 12 f0       	push   $0xf0129702
f011189f:	ff 75 e8             	pushl  -0x18(%ebp)
f01118a2:	e8 98 ed 00 00       	call   f012063f <strcmp>
f01118a7:	83 c4 10             	add    $0x10,%esp
f01118aa:	85 c0                	test   %eax,%eax
f01118ac:	75 13                	jne    f01118c1 <test_str2lower_function+0x91>
f01118ae:	83 ec 0c             	sub    $0xc,%esp
f01118b1:	ff 75 ec             	pushl  -0x14(%ebp)
f01118b4:	e8 7a ec 00 00       	call   f0120533 <strlen>
f01118b9:	83 c4 10             	add    $0x10,%esp
f01118bc:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01118bf:	74 15                	je     f01118d6 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f01118c1:	83 ec 08             	sub    $0x8,%esp
f01118c4:	ff 75 e8             	pushl  -0x18(%ebp)
f01118c7:	68 10 97 12 f0       	push   $0xf0129710
f01118cc:	e8 9b f6 fe ff       	call   f0100f6c <cprintf>
f01118d1:	83 c4 10             	add    $0x10,%esp
f01118d4:	eb 04                	jmp    f01118da <test_str2lower_function+0xaa>
	else
		eval += 10;
f01118d6:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f01118da:	c7 45 e0 72 97 12 f0 	movl   $0xf0129772,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f01118e1:	83 ec 08             	sub    $0x8,%esp
f01118e4:	ff 75 e0             	pushl  -0x20(%ebp)
f01118e7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01118ed:	50                   	push   %eax
f01118ee:	e8 29 f3 00 00       	call   f0120c1c <str2lower>
f01118f3:	83 c4 10             	add    $0x10,%esp
f01118f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01118f9:	83 ec 0c             	sub    $0xc,%esp
f01118fc:	ff 75 e8             	pushl  -0x18(%ebp)
f01118ff:	e8 2f ec 00 00       	call   f0120533 <strlen>
f0111904:	83 c4 10             	add    $0x10,%esp
f0111907:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f011190a:	83 ec 08             	sub    $0x8,%esp
f011190d:	68 72 97 12 f0       	push   $0xf0129772
f0111912:	ff 75 e8             	pushl  -0x18(%ebp)
f0111915:	e8 25 ed 00 00       	call   f012063f <strcmp>
f011191a:	83 c4 10             	add    $0x10,%esp
f011191d:	85 c0                	test   %eax,%eax
f011191f:	75 13                	jne    f0111934 <test_str2lower_function+0x104>
f0111921:	83 ec 0c             	sub    $0xc,%esp
f0111924:	ff 75 e0             	pushl  -0x20(%ebp)
f0111927:	e8 07 ec 00 00       	call   f0120533 <strlen>
f011192c:	83 c4 10             	add    $0x10,%esp
f011192f:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111932:	74 15                	je     f0111949 <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111934:	83 ec 08             	sub    $0x8,%esp
f0111937:	ff 75 e8             	pushl  -0x18(%ebp)
f011193a:	68 74 97 12 f0       	push   $0xf0129774
f011193f:	e8 28 f6 fe ff       	call   f0100f6c <cprintf>
f0111944:	83 c4 10             	add    $0x10,%esp
f0111947:	eb 04                	jmp    f011194d <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111949:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f011194d:	c7 45 dc cc 97 12 f0 	movl   $0xf01297cc,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111954:	83 ec 08             	sub    $0x8,%esp
f0111957:	ff 75 dc             	pushl  -0x24(%ebp)
f011195a:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111960:	50                   	push   %eax
f0111961:	e8 b6 f2 00 00       	call   f0120c1c <str2lower>
f0111966:	83 c4 10             	add    $0x10,%esp
f0111969:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011196c:	83 ec 0c             	sub    $0xc,%esp
f011196f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111972:	e8 bc eb 00 00       	call   f0120533 <strlen>
f0111977:	83 c4 10             	add    $0x10,%esp
f011197a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f011197d:	83 ec 08             	sub    $0x8,%esp
f0111980:	68 cc 97 12 f0       	push   $0xf01297cc
f0111985:	ff 75 e8             	pushl  -0x18(%ebp)
f0111988:	e8 b2 ec 00 00       	call   f012063f <strcmp>
f011198d:	83 c4 10             	add    $0x10,%esp
f0111990:	85 c0                	test   %eax,%eax
f0111992:	75 13                	jne    f01119a7 <test_str2lower_function+0x177>
f0111994:	83 ec 0c             	sub    $0xc,%esp
f0111997:	ff 75 dc             	pushl  -0x24(%ebp)
f011199a:	e8 94 eb 00 00       	call   f0120533 <strlen>
f011199f:	83 c4 10             	add    $0x10,%esp
f01119a2:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f01119a5:	74 15                	je     f01119bc <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f01119a7:	83 ec 08             	sub    $0x8,%esp
f01119aa:	ff 75 e8             	pushl  -0x18(%ebp)
f01119ad:	68 d8 97 12 f0       	push   $0xf01297d8
f01119b2:	e8 b5 f5 fe ff       	call   f0100f6c <cprintf>
f01119b7:	83 c4 10             	add    $0x10,%esp
f01119ba:	eb 04                	jmp    f01119c0 <test_str2lower_function+0x190>
	else
		eval += 15;
f01119bc:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f01119c0:	c7 45 d8 3b 98 12 f0 	movl   $0xf012983b,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f01119c7:	83 ec 08             	sub    $0x8,%esp
f01119ca:	ff 75 d8             	pushl  -0x28(%ebp)
f01119cd:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f01119d3:	50                   	push   %eax
f01119d4:	e8 43 f2 00 00       	call   f0120c1c <str2lower>
f01119d9:	83 c4 10             	add    $0x10,%esp
f01119dc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f01119df:	83 ec 0c             	sub    $0xc,%esp
f01119e2:	ff 75 e8             	pushl  -0x18(%ebp)
f01119e5:	e8 49 eb 00 00       	call   f0120533 <strlen>
f01119ea:	83 c4 10             	add    $0x10,%esp
f01119ed:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f01119f0:	83 ec 08             	sub    $0x8,%esp
f01119f3:	68 3b 98 12 f0       	push   $0xf012983b
f01119f8:	ff 75 e8             	pushl  -0x18(%ebp)
f01119fb:	e8 3f ec 00 00       	call   f012063f <strcmp>
f0111a00:	83 c4 10             	add    $0x10,%esp
f0111a03:	85 c0                	test   %eax,%eax
f0111a05:	75 13                	jne    f0111a1a <test_str2lower_function+0x1ea>
f0111a07:	83 ec 0c             	sub    $0xc,%esp
f0111a0a:	ff 75 d8             	pushl  -0x28(%ebp)
f0111a0d:	e8 21 eb 00 00       	call   f0120533 <strlen>
f0111a12:	83 c4 10             	add    $0x10,%esp
f0111a15:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111a18:	74 15                	je     f0111a2f <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111a1a:	83 ec 08             	sub    $0x8,%esp
f0111a1d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a20:	68 48 98 12 f0       	push   $0xf0129848
f0111a25:	e8 42 f5 fe ff       	call   f0100f6c <cprintf>
f0111a2a:	83 c4 10             	add    $0x10,%esp
f0111a2d:	eb 04                	jmp    f0111a33 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111a2f:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111a33:	c7 45 d4 aa 98 12 f0 	movl   $0xf01298aa,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111a3a:	83 ec 08             	sub    $0x8,%esp
f0111a3d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111a40:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111a46:	50                   	push   %eax
f0111a47:	e8 d0 f1 00 00       	call   f0120c1c <str2lower>
f0111a4c:	83 c4 10             	add    $0x10,%esp
f0111a4f:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111a52:	83 ec 0c             	sub    $0xc,%esp
f0111a55:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a58:	e8 d6 ea 00 00       	call   f0120533 <strlen>
f0111a5d:	83 c4 10             	add    $0x10,%esp
f0111a60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111a63:	83 ec 08             	sub    $0x8,%esp
f0111a66:	68 c0 98 12 f0       	push   $0xf01298c0
f0111a6b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a6e:	e8 cc eb 00 00       	call   f012063f <strcmp>
f0111a73:	83 c4 10             	add    $0x10,%esp
f0111a76:	85 c0                	test   %eax,%eax
f0111a78:	75 13                	jne    f0111a8d <test_str2lower_function+0x25d>
f0111a7a:	83 ec 0c             	sub    $0xc,%esp
f0111a7d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111a80:	e8 ae ea 00 00       	call   f0120533 <strlen>
f0111a85:	83 c4 10             	add    $0x10,%esp
f0111a88:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111a8b:	74 15                	je     f0111aa2 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111a8d:	83 ec 08             	sub    $0x8,%esp
f0111a90:	ff 75 e8             	pushl  -0x18(%ebp)
f0111a93:	68 d8 98 12 f0       	push   $0xf01298d8
f0111a98:	e8 cf f4 fe ff       	call   f0100f6c <cprintf>
f0111a9d:	83 c4 10             	add    $0x10,%esp
f0111aa0:	eb 04                	jmp    f0111aa6 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111aa2:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111aa6:	c7 45 d0 45 99 12 f0 	movl   $0xf0129945,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111aad:	83 ec 08             	sub    $0x8,%esp
f0111ab0:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ab3:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111ab9:	50                   	push   %eax
f0111aba:	e8 5d f1 00 00       	call   f0120c1c <str2lower>
f0111abf:	83 c4 10             	add    $0x10,%esp
f0111ac2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ac5:	83 ec 0c             	sub    $0xc,%esp
f0111ac8:	ff 75 e8             	pushl  -0x18(%ebp)
f0111acb:	e8 63 ea 00 00       	call   f0120533 <strlen>
f0111ad0:	83 c4 10             	add    $0x10,%esp
f0111ad3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111ad6:	83 ec 08             	sub    $0x8,%esp
f0111ad9:	68 51 99 12 f0       	push   $0xf0129951
f0111ade:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ae1:	e8 59 eb 00 00       	call   f012063f <strcmp>
f0111ae6:	83 c4 10             	add    $0x10,%esp
f0111ae9:	85 c0                	test   %eax,%eax
f0111aeb:	75 13                	jne    f0111b00 <test_str2lower_function+0x2d0>
f0111aed:	83 ec 0c             	sub    $0xc,%esp
f0111af0:	ff 75 d0             	pushl  -0x30(%ebp)
f0111af3:	e8 3b ea 00 00       	call   f0120533 <strlen>
f0111af8:	83 c4 10             	add    $0x10,%esp
f0111afb:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111afe:	74 15                	je     f0111b15 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0111b00:	83 ec 08             	sub    $0x8,%esp
f0111b03:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b06:	68 60 99 12 f0       	push   $0xf0129960
f0111b0b:	e8 5c f4 fe ff       	call   f0100f6c <cprintf>
f0111b10:	83 c4 10             	add    $0x10,%esp
f0111b13:	eb 04                	jmp    f0111b19 <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0111b15:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f0111b19:	c7 45 cc c3 99 12 f0 	movl   $0xf01299c3,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0111b20:	83 ec 08             	sub    $0x8,%esp
f0111b23:	ff 75 cc             	pushl  -0x34(%ebp)
f0111b26:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f0111b2c:	50                   	push   %eax
f0111b2d:	e8 ea f0 00 00       	call   f0120c1c <str2lower>
f0111b32:	83 c4 10             	add    $0x10,%esp
f0111b35:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111b38:	83 ec 0c             	sub    $0xc,%esp
f0111b3b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b3e:	e8 f0 e9 00 00       	call   f0120533 <strlen>
f0111b43:	83 c4 10             	add    $0x10,%esp
f0111b46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f0111b49:	83 ec 08             	sub    $0x8,%esp
f0111b4c:	68 de 99 12 f0       	push   $0xf01299de
f0111b51:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b54:	e8 e6 ea 00 00       	call   f012063f <strcmp>
f0111b59:	83 c4 10             	add    $0x10,%esp
f0111b5c:	85 c0                	test   %eax,%eax
f0111b5e:	75 13                	jne    f0111b73 <test_str2lower_function+0x343>
f0111b60:	83 ec 0c             	sub    $0xc,%esp
f0111b63:	ff 75 cc             	pushl  -0x34(%ebp)
f0111b66:	e8 c8 e9 00 00       	call   f0120533 <strlen>
f0111b6b:	83 c4 10             	add    $0x10,%esp
f0111b6e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111b71:	74 15                	je     f0111b88 <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0111b73:	83 ec 08             	sub    $0x8,%esp
f0111b76:	ff 75 e8             	pushl  -0x18(%ebp)
f0111b79:	68 fc 99 12 f0       	push   $0xf01299fc
f0111b7e:	e8 e9 f3 fe ff       	call   f0100f6c <cprintf>
f0111b83:	83 c4 10             	add    $0x10,%esp
f0111b86:	eb 04                	jmp    f0111b8c <test_str2lower_function+0x35c>
	else
		eval += 20;
f0111b88:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f0111b8c:	83 ec 08             	sub    $0x8,%esp
f0111b8f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111b92:	68 70 9a 12 f0       	push   $0xf0129a70
f0111b97:	e8 d0 f3 fe ff       	call   f0100f6c <cprintf>
f0111b9c:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f0111b9f:	83 ec 0c             	sub    $0xc,%esp
f0111ba2:	68 80 95 12 f0       	push   $0xf0129580
f0111ba7:	e8 c0 f3 fe ff       	call   f0100f6c <cprintf>
f0111bac:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111baf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111bb4:	c9                   	leave  
f0111bb5:	c3                   	ret    

f0111bb6 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f0111bb6:	55                   	push   %ebp
f0111bb7:	89 e5                	mov    %esp,%ebp
f0111bb9:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f0111bbc:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111bc3:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111bca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111bd1:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111bd6:	ff 75 ec             	pushl  -0x14(%ebp)
f0111bd9:	ff 75 f0             	pushl  -0x10(%ebp)
f0111bdc:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bdf:	50                   	push   %eax
f0111be0:	e8 44 6c ff ff       	call   f0108829 <pt_set_page_permissions>
f0111be5:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111be8:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111bed:	ff 75 ec             	pushl  -0x14(%ebp)
f0111bf0:	ff 75 f0             	pushl  -0x10(%ebp)
f0111bf3:	ff 75 f4             	pushl  -0xc(%ebp)
f0111bf6:	50                   	push   %eax
f0111bf7:	e8 a0 4d 00 00       	call   f011699c <CP>
f0111bfc:	83 c4 10             	add    $0x10,%esp
f0111bff:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111c02:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111c06:	74 17                	je     f0111c1f <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f0111c08:	83 ec 04             	sub    $0x4,%esp
f0111c0b:	68 a0 9a 12 f0       	push   $0xf0129aa0
f0111c10:	68 23 01 00 00       	push   $0x123
f0111c15:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111c1a:	e8 fb e6 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0111c1f:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0111c26:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f0111c2d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111c34:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111c39:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c3c:	ff 75 f0             	pushl  -0x10(%ebp)
f0111c3f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c42:	50                   	push   %eax
f0111c43:	e8 e1 6b ff ff       	call   f0108829 <pt_set_page_permissions>
f0111c48:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111c4b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111c50:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c53:	ff 75 f0             	pushl  -0x10(%ebp)
f0111c56:	ff 75 f4             	pushl  -0xc(%ebp)
f0111c59:	50                   	push   %eax
f0111c5a:	e8 3d 4d 00 00       	call   f011699c <CP>
f0111c5f:	83 c4 10             	add    $0x10,%esp
f0111c62:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111c65:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111c69:	74 17                	je     f0111c82 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f0111c6b:	83 ec 04             	sub    $0x4,%esp
f0111c6e:	68 e0 9a 12 f0       	push   $0xf0129ae0
f0111c73:	68 2f 01 00 00       	push   $0x12f
f0111c78:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111c7d:	e8 98 e6 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0111c82:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f0111c89:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0111c90:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111c97:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111c9c:	ff 75 ec             	pushl  -0x14(%ebp)
f0111c9f:	ff 75 f0             	pushl  -0x10(%ebp)
f0111ca2:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ca5:	50                   	push   %eax
f0111ca6:	e8 7e 6b ff ff       	call   f0108829 <pt_set_page_permissions>
f0111cab:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111cae:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111cb3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111cb6:	ff 75 f0             	pushl  -0x10(%ebp)
f0111cb9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111cbc:	50                   	push   %eax
f0111cbd:	e8 da 4c 00 00       	call   f011699c <CP>
f0111cc2:	83 c4 10             	add    $0x10,%esp
f0111cc5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111cc8:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111ccc:	74 17                	je     f0111ce5 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f0111cce:	83 ec 04             	sub    $0x4,%esp
f0111cd1:	68 04 9b 12 f0       	push   $0xf0129b04
f0111cd6:	68 3a 01 00 00       	push   $0x13a
f0111cdb:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111ce0:	e8 35 e6 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f0111ce5:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f0111cec:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f0111cf3:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111cfa:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111cff:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d02:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d05:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d08:	50                   	push   %eax
f0111d09:	e8 1b 6b ff ff       	call   f0108829 <pt_set_page_permissions>
f0111d0e:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d11:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d16:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d19:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d1c:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d1f:	50                   	push   %eax
f0111d20:	e8 77 4c 00 00       	call   f011699c <CP>
f0111d25:	83 c4 10             	add    $0x10,%esp
f0111d28:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111d2b:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111d2f:	74 17                	je     f0111d48 <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0111d31:	83 ec 04             	sub    $0x4,%esp
f0111d34:	68 28 9b 12 f0       	push   $0xf0129b28
f0111d39:	68 46 01 00 00       	push   $0x146
f0111d3e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111d43:	e8 d2 e5 fe ff       	call   f010031a <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f0111d48:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0111d4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0111d56:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d5d:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d62:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d65:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d68:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d6b:	50                   	push   %eax
f0111d6c:	e8 b8 6a ff ff       	call   f0108829 <pt_set_page_permissions>
f0111d71:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111d74:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111d79:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d7c:	ff 75 f0             	pushl  -0x10(%ebp)
f0111d7f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111d82:	50                   	push   %eax
f0111d83:	e8 14 4c 00 00       	call   f011699c <CP>
f0111d88:	83 c4 10             	add    $0x10,%esp
f0111d8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111d8e:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111d92:	74 17                	je     f0111dab <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0111d94:	83 ec 04             	sub    $0x4,%esp
f0111d97:	68 4c 9b 12 f0       	push   $0xf0129b4c
f0111d9c:	68 52 01 00 00       	push   $0x152
f0111da1:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111da6:	e8 6f e5 fe ff       	call   f010031a <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f0111dab:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f0111db2:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f0111db9:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111dc0:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111dc5:	ff 75 ec             	pushl  -0x14(%ebp)
f0111dc8:	ff 75 f0             	pushl  -0x10(%ebp)
f0111dcb:	ff 75 f4             	pushl  -0xc(%ebp)
f0111dce:	50                   	push   %eax
f0111dcf:	e8 55 6a ff ff       	call   f0108829 <pt_set_page_permissions>
f0111dd4:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111dd7:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111ddc:	ff 75 ec             	pushl  -0x14(%ebp)
f0111ddf:	ff 75 f0             	pushl  -0x10(%ebp)
f0111de2:	ff 75 f4             	pushl  -0xc(%ebp)
f0111de5:	50                   	push   %eax
f0111de6:	e8 b1 4b 00 00       	call   f011699c <CP>
f0111deb:	83 c4 10             	add    $0x10,%esp
f0111dee:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0111df1:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0111df5:	74 17                	je     f0111e0e <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f0111df7:	83 ec 04             	sub    $0x4,%esp
f0111dfa:	68 70 9b 12 f0       	push   $0xf0129b70
f0111dff:	68 5e 01 00 00       	push   $0x15e
f0111e04:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111e09:	e8 0c e5 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0111e0e:	83 ec 0c             	sub    $0xc,%esp
f0111e11:	68 9c 9b 12 f0       	push   $0xf0129b9c
f0111e16:	e8 51 f1 fe ff       	call   f0100f6c <cprintf>
f0111e1b:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111e1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111e23:	c9                   	leave  
f0111e24:	c3                   	ret    

f0111e25 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0111e25:	55                   	push   %ebp
f0111e26:	89 e5                	mov    %esp,%ebp
f0111e28:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f0111e2b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0111e32:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f0111e39:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0111e40:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111e45:	ff 75 ec             	pushl  -0x14(%ebp)
f0111e48:	ff 75 f0             	pushl  -0x10(%ebp)
f0111e4b:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e4e:	50                   	push   %eax
f0111e4f:	e8 d5 69 ff ff       	call   f0108829 <pt_set_page_permissions>
f0111e54:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0111e57:	83 ec 04             	sub    $0x4,%esp
f0111e5a:	68 ec 9b 12 f0       	push   $0xf0129bec
f0111e5f:	68 6b 01 00 00       	push   $0x16b
f0111e64:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111e69:	e8 ac e4 fe ff       	call   f010031a <_panic>

f0111e6e <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0111e6e:	55                   	push   %ebp
f0111e6f:	89 e5                	mov    %esp,%ebp
f0111e71:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0111e74:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f0111e7b:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111e80:	83 ec 08             	sub    $0x8,%esp
f0111e83:	ff 75 f4             	pushl  -0xc(%ebp)
f0111e86:	50                   	push   %eax
f0111e87:	e8 61 6a ff ff       	call   f01088ed <pt_get_page_permissions>
f0111e8c:	83 c4 10             	add    $0x10,%esp
f0111e8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0111e92:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0111e96:	74 17                	je     f0111eaf <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f0111e98:	83 ec 04             	sub    $0x4,%esp
f0111e9b:	68 88 9c 12 f0       	push   $0xf0129c88
f0111ea0:	68 79 01 00 00       	push   $0x179
f0111ea5:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111eaa:	e8 6b e4 fe ff       	call   f010031a <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f0111eaf:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111eb6:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111ebb:	83 ec 08             	sub    $0x8,%esp
f0111ebe:	ff 75 f4             	pushl  -0xc(%ebp)
f0111ec1:	50                   	push   %eax
f0111ec2:	e8 26 6a ff ff       	call   f01088ed <pt_get_page_permissions>
f0111ec7:	83 c4 10             	add    $0x10,%esp
f0111eca:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f0111ecd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111ed1:	74 17                	je     f0111eea <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f0111ed3:	83 ec 04             	sub    $0x4,%esp
f0111ed6:	68 ac 9c 12 f0       	push   $0xf0129cac
f0111edb:	68 81 01 00 00       	push   $0x181
f0111ee0:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111ee5:	e8 30 e4 fe ff       	call   f010031a <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f0111eea:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111ef1:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111ef6:	83 ec 08             	sub    $0x8,%esp
f0111ef9:	ff 75 f4             	pushl  -0xc(%ebp)
f0111efc:	50                   	push   %eax
f0111efd:	e8 eb 69 ff ff       	call   f01088ed <pt_get_page_permissions>
f0111f02:	83 c4 10             	add    $0x10,%esp
f0111f05:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111f08:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111f0c:	74 17                	je     f0111f25 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0111f0e:	83 ec 04             	sub    $0x4,%esp
f0111f11:	68 d0 9c 12 f0       	push   $0xf0129cd0
f0111f16:	68 89 01 00 00       	push   $0x189
f0111f1b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111f20:	e8 f5 e3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF1000000;
f0111f25:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111f2c:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111f31:	83 ec 08             	sub    $0x8,%esp
f0111f34:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f37:	50                   	push   %eax
f0111f38:	e8 b0 69 ff ff       	call   f01088ed <pt_get_page_permissions>
f0111f3d:	83 c4 10             	add    $0x10,%esp
f0111f40:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0111f43:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0111f47:	74 17                	je     f0111f60 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f0111f49:	83 ec 04             	sub    $0x4,%esp
f0111f4c:	68 f4 9c 12 f0       	push   $0xf0129cf4
f0111f51:	68 90 01 00 00       	push   $0x190
f0111f56:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111f5b:	e8 ba e3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0111f60:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0111f67:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111f6c:	83 ec 08             	sub    $0x8,%esp
f0111f6f:	ff 75 f4             	pushl  -0xc(%ebp)
f0111f72:	50                   	push   %eax
f0111f73:	e8 75 69 ff ff       	call   f01088ed <pt_get_page_permissions>
f0111f78:	83 c4 10             	add    $0x10,%esp
f0111f7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0111f7e:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0111f82:	74 17                	je     f0111f9b <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0111f84:	83 ec 04             	sub    $0x4,%esp
f0111f87:	68 18 9d 12 f0       	push   $0xf0129d18
f0111f8c:	68 97 01 00 00       	push   $0x197
f0111f91:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0111f96:	e8 7f e3 fe ff       	call   f010031a <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f0111f9b:	83 ec 0c             	sub    $0xc,%esp
f0111f9e:	68 3c 9d 12 f0       	push   $0xf0129d3c
f0111fa3:	e8 c4 ef fe ff       	call   f0100f6c <cprintf>
f0111fa8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0111fab:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111fb0:	c9                   	leave  
f0111fb1:	c3                   	ret    

f0111fb2 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f0111fb2:	55                   	push   %ebp
f0111fb3:	89 e5                	mov    %esp,%ebp
f0111fb5:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f0111fb8:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0111fbf:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111fc4:	83 ec 08             	sub    $0x8,%esp
f0111fc7:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fca:	50                   	push   %eax
f0111fcb:	e8 66 69 ff ff       	call   f0108936 <pt_clear_page_table_entry>
f0111fd0:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f0111fd3:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0111fd8:	83 ec 08             	sub    $0x8,%esp
f0111fdb:	ff 75 f4             	pushl  -0xc(%ebp)
f0111fde:	50                   	push   %eax
f0111fdf:	e8 14 49 00 00       	call   f01168f8 <CE>
f0111fe4:	83 c4 10             	add    $0x10,%esp
f0111fe7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0111fea:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f0111fee:	74 17                	je     f0112007 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f0111ff0:	83 ec 04             	sub    $0x4,%esp
f0111ff3:	68 84 9d 12 f0       	push   $0xf0129d84
f0111ff8:	68 a7 01 00 00       	push   $0x1a7
f0111ffd:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112002:	e8 13 e3 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0001000;
f0112007:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011200e:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112013:	83 ec 08             	sub    $0x8,%esp
f0112016:	ff 75 f4             	pushl  -0xc(%ebp)
f0112019:	50                   	push   %eax
f011201a:	e8 17 69 ff ff       	call   f0108936 <pt_clear_page_table_entry>
f011201f:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112022:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112027:	83 ec 08             	sub    $0x8,%esp
f011202a:	ff 75 f4             	pushl  -0xc(%ebp)
f011202d:	50                   	push   %eax
f011202e:	e8 c5 48 00 00       	call   f01168f8 <CE>
f0112033:	83 c4 10             	add    $0x10,%esp
f0112036:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112039:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011203d:	74 17                	je     f0112056 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f011203f:	83 ec 04             	sub    $0x4,%esp
f0112042:	68 b0 9d 12 f0       	push   $0xf0129db0
f0112047:	68 af 01 00 00       	push   $0x1af
f011204c:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112051:	e8 c4 e2 fe ff       	call   f010031a <_panic>
	}

	va = 0xEF800000;
f0112056:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011205d:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112062:	83 ec 08             	sub    $0x8,%esp
f0112065:	ff 75 f4             	pushl  -0xc(%ebp)
f0112068:	50                   	push   %eax
f0112069:	e8 c8 68 ff ff       	call   f0108936 <pt_clear_page_table_entry>
f011206e:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112071:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0112076:	83 ec 08             	sub    $0x8,%esp
f0112079:	ff 75 f4             	pushl  -0xc(%ebp)
f011207c:	50                   	push   %eax
f011207d:	e8 76 48 00 00       	call   f01168f8 <CE>
f0112082:	83 c4 10             	add    $0x10,%esp
f0112085:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f0112088:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011208c:	74 17                	je     f01120a5 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f011208e:	83 ec 04             	sub    $0x4,%esp
f0112091:	68 dc 9d 12 f0       	push   $0xf0129ddc
f0112096:	68 b7 01 00 00       	push   $0x1b7
f011209b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01120a0:	e8 75 e2 fe ff       	call   f010031a <_panic>
	}

	va = 0xF0000000;
f01120a5:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01120ac:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01120b1:	83 ec 08             	sub    $0x8,%esp
f01120b4:	ff 75 f4             	pushl  -0xc(%ebp)
f01120b7:	50                   	push   %eax
f01120b8:	e8 79 68 ff ff       	call   f0108936 <pt_clear_page_table_entry>
f01120bd:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01120c0:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f01120c5:	83 ec 08             	sub    $0x8,%esp
f01120c8:	ff 75 f4             	pushl  -0xc(%ebp)
f01120cb:	50                   	push   %eax
f01120cc:	e8 27 48 00 00       	call   f01168f8 <CE>
f01120d1:	83 c4 10             	add    $0x10,%esp
f01120d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01120d7:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01120db:	74 17                	je     f01120f4 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01120dd:	83 ec 04             	sub    $0x4,%esp
f01120e0:	68 08 9e 12 f0       	push   $0xf0129e08
f01120e5:	68 bf 01 00 00       	push   $0x1bf
f01120ea:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01120ef:	e8 26 e2 fe ff       	call   f010031a <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01120f4:	83 ec 0c             	sub    $0xc,%esp
f01120f7:	68 34 9e 12 f0       	push   $0xf0129e34
f01120fc:	e8 6b ee fe ff       	call   f0100f6c <cprintf>
f0112101:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112104:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112109:	c9                   	leave  
f011210a:	c3                   	ret    

f011210b <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011210b:	55                   	push   %ebp
f011210c:	89 e5                	mov    %esp,%ebp
f011210e:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112111:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112118:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011211d:	83 ec 08             	sub    $0x8,%esp
f0112120:	ff 75 f4             	pushl  -0xc(%ebp)
f0112123:	50                   	push   %eax
f0112124:	e8 0d 68 ff ff       	call   f0108936 <pt_clear_page_table_entry>
f0112129:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f011212c:	83 ec 04             	sub    $0x4,%esp
f011212f:	68 80 9e 12 f0       	push   $0xf0129e80
f0112134:	68 ca 01 00 00       	push   $0x1ca
f0112139:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011213e:	e8 d7 e1 fe ff       	call   f010031a <_panic>

f0112143 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f0112143:	55                   	push   %ebp
f0112144:	89 e5                	mov    %esp,%ebp
f0112146:	57                   	push   %edi
f0112147:	56                   	push   %esi
f0112148:	53                   	push   %ebx
f0112149:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011214f:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112155:	bb c4 a1 12 f0       	mov    $0xf012a1c4,%ebx
f011215a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011215f:	89 c7                	mov    %eax,%edi
f0112161:	89 de                	mov    %ebx,%esi
f0112163:	89 d1                	mov    %edx,%ecx
f0112165:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112167:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f011216d:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112172:	b0 00                	mov    $0x0,%al
f0112174:	89 d7                	mov    %edx,%edi
f0112176:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112178:	6a 00                	push   $0x0
f011217a:	6a 0a                	push   $0xa
f011217c:	6a 14                	push   $0x14
f011217e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112184:	50                   	push   %eax
f0112185:	e8 e7 75 ff ff       	call   f0109771 <env_create>
f011218a:	83 c4 10             	add    $0x10,%esp
f011218d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112190:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112193:	8b 40 64             	mov    0x64(%eax),%eax
f0112196:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112199:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011219c:	8b 40 68             	mov    0x68(%eax),%eax
f011219f:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01121a2:	8b 45 90             	mov    -0x70(%ebp),%eax
f01121a5:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01121a8:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f01121af:	75 70 20 
f01121b2:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f01121b9:	00 00 00 
f01121bc:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f01121c2:	b9 03 00 00 00       	mov    $0x3,%ecx
f01121c7:	b8 00 00 00 00       	mov    $0x0,%eax
f01121cc:	89 d7                	mov    %edx,%edi
f01121ce:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01121d0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01121d3:	8b 40 10             	mov    0x10(%eax),%eax
f01121d6:	83 ec 08             	sub    $0x8,%esp
f01121d9:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01121df:	52                   	push   %edx
f01121e0:	50                   	push   %eax
f01121e1:	e8 f3 e7 00 00       	call   f01209d9 <ltostr>
f01121e6:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01121e9:	83 ec 04             	sub    $0x4,%esp
f01121ec:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01121f2:	50                   	push   %eax
f01121f3:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f01121f9:	50                   	push   %eax
f01121fa:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112200:	50                   	push   %eax
f0112201:	e8 ac e8 00 00       	call   f0120ab2 <strcconcat>
f0112206:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112209:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112210:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0112217:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f011221e:	83 ec 0c             	sub    $0xc,%esp
f0112221:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112224:	e8 d0 48 00 00       	call   f0116af9 <ClearUserSpace>
f0112229:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f011222c:	83 ec 04             	sub    $0x4,%esp
f011222f:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112235:	50                   	push   %eax
f0112236:	68 16 9f 12 f0       	push   $0xf0129f16
f011223b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112241:	50                   	push   %eax
f0112242:	e8 6b e8 00 00       	call   f0120ab2 <strcconcat>
f0112247:	83 c4 10             	add    $0x10,%esp
f011224a:	83 ec 0c             	sub    $0xc,%esp
f011224d:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112253:	50                   	push   %eax
f0112254:	e8 83 fc fe ff       	call   f0101edc <execute_command>
f0112259:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f011225c:	83 ec 04             	sub    $0x4,%esp
f011225f:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112265:	50                   	push   %eax
f0112266:	68 21 9f 12 f0       	push   $0xf0129f21
f011226b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112271:	50                   	push   %eax
f0112272:	e8 3b e8 00 00       	call   f0120ab2 <strcconcat>
f0112277:	83 c4 10             	add    $0x10,%esp
f011227a:	83 ec 0c             	sub    $0xc,%esp
f011227d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112283:	50                   	push   %eax
f0112284:	e8 53 fc fe ff       	call   f0101edc <execute_command>
f0112289:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f011228c:	83 ec 04             	sub    $0x4,%esp
f011228f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112295:	50                   	push   %eax
f0112296:	68 2c 9f 12 f0       	push   $0xf0129f2c
f011229b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01122a1:	50                   	push   %eax
f01122a2:	e8 0b e8 00 00       	call   f0120ab2 <strcconcat>
f01122a7:	83 c4 10             	add    $0x10,%esp
f01122aa:	83 ec 0c             	sub    $0xc,%esp
f01122ad:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f01122b3:	50                   	push   %eax
f01122b4:	e8 23 fc fe ff       	call   f0101edc <execute_command>
f01122b9:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f01122bc:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f01122c3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122c6:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f01122c9:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f01122d0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122d3:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f01122d6:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f01122dd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122e0:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f01122e3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01122e6:	83 ec 08             	sub    $0x8,%esp
f01122e9:	50                   	push   %eax
f01122ea:	ff 75 d4             	pushl  -0x2c(%ebp)
f01122ed:	e8 6e 47 00 00       	call   f0116a60 <GP>
f01122f2:	83 c4 10             	add    $0x10,%esp
f01122f5:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f01122f8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f01122ff:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112306:	e8 fe b3 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011230b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f011230e:	83 ec 0c             	sub    $0xc,%esp
f0112311:	68 38 9f 12 f0       	push   $0xf0129f38
f0112316:	e8 51 ec fe ff       	call   f0100f6c <cprintf>
f011231b:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f011231e:	6a 03                	push   $0x3
f0112320:	68 00 00 90 02       	push   $0x2900000
f0112325:	68 00 00 80 02       	push   $0x2800000
f011232a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011232d:	e8 9f 70 ff ff       	call   f01093d1 <cut_paste_pages>
f0112332:	83 c4 10             	add    $0x10,%esp
f0112335:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112338:	e8 cc b3 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011233d:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112340:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0112347:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f011234b:	75 08                	jne    f0112355 <test_cut_paste_pages+0x212>
f011234d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112350:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112353:	74 2b                	je     f0112380 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112355:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112358:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011235b:	83 ec 0c             	sub    $0xc,%esp
f011235e:	50                   	push   %eax
f011235f:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112362:	68 68 9f 12 f0       	push   $0xf0129f68
f0112367:	68 04 02 00 00       	push   $0x204
f011236c:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112371:	e8 41 e1 fe ff       	call   f01004b7 <_warn>
f0112376:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112379:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112380:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112384:	74 04                	je     f011238a <test_cut_paste_pages+0x247>
f0112386:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f011238a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112391:	83 ec 08             	sub    $0x8,%esp
f0112394:	6a 00                	push   $0x0
f0112396:	6a 01                	push   $0x1
f0112398:	6a 00                	push   $0x0
f011239a:	68 ff 0f 00 00       	push   $0xfff
f011239f:	ff 75 bc             	pushl  -0x44(%ebp)
f01123a2:	6a 01                	push   $0x1
f01123a4:	68 00 30 00 00       	push   $0x3000
f01123a9:	68 00 00 90 02       	push   $0x2900000
f01123ae:	68 00 00 80 02       	push   $0x2800000
f01123b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01123b6:	e8 72 47 00 00       	call   f0116b2d <CCP>
f01123bb:	83 c4 30             	add    $0x30,%esp
f01123be:	83 f8 01             	cmp    $0x1,%eax
f01123c1:	74 21                	je     f01123e4 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01123c3:	83 ec 04             	sub    $0x4,%esp
f01123c6:	68 bc 9f 12 f0       	push   $0xf0129fbc
f01123cb:	68 0c 02 00 00       	push   $0x20c
f01123d0:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01123d5:	e8 dd e0 fe ff       	call   f01004b7 <_warn>
f01123da:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01123dd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f01123e4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01123e8:	74 04                	je     f01123ee <test_cut_paste_pages+0x2ab>
f01123ea:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f01123ee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f01123f5:	83 ec 04             	sub    $0x4,%esp
f01123f8:	6a 00                	push   $0x0
f01123fa:	68 00 00 90 02       	push   $0x2900000
f01123ff:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112402:	e8 b7 41 00 00       	call   f01165be <CB>
f0112407:	83 c4 10             	add    $0x10,%esp
f011240a:	85 c0                	test   %eax,%eax
f011240c:	0f 84 f6 00 00 00    	je     f0112508 <test_cut_paste_pages+0x3c5>
f0112412:	83 ec 04             	sub    $0x4,%esp
f0112415:	6a 00                	push   $0x0
f0112417:	68 00 10 90 02       	push   $0x2901000
f011241c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011241f:	e8 9a 41 00 00       	call   f01165be <CB>
f0112424:	83 c4 10             	add    $0x10,%esp
f0112427:	85 c0                	test   %eax,%eax
f0112429:	0f 84 d9 00 00 00    	je     f0112508 <test_cut_paste_pages+0x3c5>
f011242f:	83 ec 04             	sub    $0x4,%esp
f0112432:	6a 00                	push   $0x0
f0112434:	68 00 20 90 02       	push   $0x2902000
f0112439:	ff 75 d4             	pushl  -0x2c(%ebp)
f011243c:	e8 7d 41 00 00       	call   f01165be <CB>
f0112441:	83 c4 10             	add    $0x10,%esp
f0112444:	85 c0                	test   %eax,%eax
f0112446:	0f 84 bc 00 00 00    	je     f0112508 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f011244c:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112453:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f011245a:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112461:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112464:	8a 00                	mov    (%eax),%al
f0112466:	3c 61                	cmp    $0x61,%al
f0112468:	75 12                	jne    f011247c <test_cut_paste_pages+0x339>
f011246a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011246d:	8a 00                	mov    (%eax),%al
f011246f:	3c 62                	cmp    $0x62,%al
f0112471:	75 09                	jne    f011247c <test_cut_paste_pages+0x339>
f0112473:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112476:	8a 00                	mov    (%eax),%al
f0112478:	3c 63                	cmp    $0x63,%al
f011247a:	74 21                	je     f011249d <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011247c:	83 ec 04             	sub    $0x4,%esp
f011247f:	68 08 a0 12 f0       	push   $0xf012a008
f0112484:	68 19 02 00 00       	push   $0x219
f0112489:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011248e:	e8 24 e0 fe ff       	call   f01004b7 <_warn>
f0112493:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112496:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011249d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01124a1:	74 04                	je     f01124a7 <test_cut_paste_pages+0x364>
f01124a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01124a7:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f01124ae:	83 ec 04             	sub    $0x4,%esp
f01124b1:	6a 01                	push   $0x1
f01124b3:	68 00 10 90 02       	push   $0x2901000
f01124b8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01124bb:	e8 fe 40 00 00       	call   f01165be <CB>
f01124c0:	83 c4 10             	add    $0x10,%esp
f01124c3:	85 c0                	test   %eax,%eax
f01124c5:	74 41                	je     f0112508 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f01124c7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01124ca:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f01124cd:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01124d0:	8a 00                	mov    (%eax),%al
f01124d2:	3c 79                	cmp    $0x79,%al
f01124d4:	74 21                	je     f01124f7 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01124d6:	83 ec 04             	sub    $0x4,%esp
f01124d9:	68 08 a0 12 f0       	push   $0xf012a008
f01124de:	68 24 02 00 00       	push   $0x224
f01124e3:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01124e8:	e8 ca df fe ff       	call   f01004b7 <_warn>
f01124ed:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01124f0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01124f7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01124fb:	74 04                	je     f0112501 <test_cut_paste_pages+0x3be>
f01124fd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112501:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112508:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011250b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f011250e:	6a 02                	push   $0x2
f0112510:	68 00 f0 bf 02       	push   $0x2bff000
f0112515:	68 00 10 90 02       	push   $0x2901000
f011251a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011251d:	e8 af 6e ff ff       	call   f01093d1 <cut_paste_pages>
f0112522:	83 c4 10             	add    $0x10,%esp
f0112525:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112528:	e8 dc b1 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011252d:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112530:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112534:	75 0b                	jne    f0112541 <test_cut_paste_pages+0x3fe>
f0112536:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112539:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011253c:	83 f8 01             	cmp    $0x1,%eax
f011253f:	74 2b                	je     f011256c <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112541:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112544:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112547:	83 ec 0c             	sub    $0xc,%esp
f011254a:	50                   	push   %eax
f011254b:	ff 75 b4             	pushl  -0x4c(%ebp)
f011254e:	68 68 9f 12 f0       	push   $0xf0129f68
f0112553:	68 35 02 00 00       	push   $0x235
f0112558:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011255d:	e8 55 df fe ff       	call   f01004b7 <_warn>
f0112562:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112565:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f011256c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112570:	74 04                	je     f0112576 <test_cut_paste_pages+0x433>
f0112572:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112576:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f011257d:	83 ec 08             	sub    $0x8,%esp
f0112580:	6a 00                	push   $0x0
f0112582:	6a 01                	push   $0x1
f0112584:	6a 00                	push   $0x0
f0112586:	68 ff 0f 00 00       	push   $0xfff
f011258b:	ff 75 bc             	pushl  -0x44(%ebp)
f011258e:	6a 01                	push   $0x1
f0112590:	68 00 20 00 00       	push   $0x2000
f0112595:	68 00 f0 bf 02       	push   $0x2bff000
f011259a:	68 00 10 90 02       	push   $0x2901000
f011259f:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125a2:	e8 86 45 00 00       	call   f0116b2d <CCP>
f01125a7:	83 c4 30             	add    $0x30,%esp
f01125aa:	83 f8 01             	cmp    $0x1,%eax
f01125ad:	74 21                	je     f01125d0 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f01125af:	83 ec 04             	sub    $0x4,%esp
f01125b2:	68 bc 9f 12 f0       	push   $0xf0129fbc
f01125b7:	68 3d 02 00 00       	push   $0x23d
f01125bc:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01125c1:	e8 f1 de fe ff       	call   f01004b7 <_warn>
f01125c6:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f01125c9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01125d0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01125d4:	74 04                	je     f01125da <test_cut_paste_pages+0x497>
f01125d6:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01125da:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f01125e1:	83 ec 04             	sub    $0x4,%esp
f01125e4:	6a 00                	push   $0x0
f01125e6:	68 ff f7 bf 02       	push   $0x2bff7ff
f01125eb:	ff 75 d4             	pushl  -0x2c(%ebp)
f01125ee:	e8 cb 3f 00 00       	call   f01165be <CB>
f01125f3:	83 c4 10             	add    $0x10,%esp
f01125f6:	85 c0                	test   %eax,%eax
f01125f8:	74 6b                	je     f0112665 <test_cut_paste_pages+0x522>
f01125fa:	83 ec 04             	sub    $0x4,%esp
f01125fd:	6a 00                	push   $0x0
f01125ff:	68 ff 0f c0 02       	push   $0x2c00fff
f0112604:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112607:	e8 b2 3f 00 00       	call   f01165be <CB>
f011260c:	83 c4 10             	add    $0x10,%esp
f011260f:	85 c0                	test   %eax,%eax
f0112611:	74 52                	je     f0112665 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112613:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f011261a:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112621:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112624:	8a 00                	mov    (%eax),%al
f0112626:	3c 79                	cmp    $0x79,%al
f0112628:	75 09                	jne    f0112633 <test_cut_paste_pages+0x4f0>
f011262a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011262d:	8a 00                	mov    (%eax),%al
f011262f:	3c 63                	cmp    $0x63,%al
f0112631:	74 21                	je     f0112654 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112633:	83 ec 04             	sub    $0x4,%esp
f0112636:	68 08 a0 12 f0       	push   $0xf012a008
f011263b:	68 49 02 00 00       	push   $0x249
f0112640:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112645:	e8 6d de fe ff       	call   f01004b7 <_warn>
f011264a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011264d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112654:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112658:	74 04                	je     f011265e <test_cut_paste_pages+0x51b>
f011265a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011265e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112665:	83 ec 0c             	sub    $0xc,%esp
f0112668:	68 41 a0 12 f0       	push   $0xf012a041
f011266d:	e8 fa e8 fe ff       	call   f0100f6c <cprintf>
f0112672:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112675:	83 ec 0c             	sub    $0xc,%esp
f0112678:	68 50 a0 12 f0       	push   $0xf012a050
f011267d:	e8 ea e8 fe ff       	call   f0100f6c <cprintf>
f0112682:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112685:	83 ec 04             	sub    $0x4,%esp
f0112688:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f011268e:	50                   	push   %eax
f011268f:	68 79 a0 12 f0       	push   $0xf012a079
f0112694:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011269a:	50                   	push   %eax
f011269b:	e8 12 e4 00 00       	call   f0120ab2 <strcconcat>
f01126a0:	83 c4 10             	add    $0x10,%esp
f01126a3:	83 ec 0c             	sub    $0xc,%esp
f01126a6:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f01126ac:	50                   	push   %eax
f01126ad:	e8 2a f8 fe ff       	call   f0101edc <execute_command>
f01126b2:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f01126b5:	83 ec 04             	sub    $0x4,%esp
f01126b8:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01126be:	50                   	push   %eax
f01126bf:	68 84 a0 12 f0       	push   $0xf012a084
f01126c4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01126ca:	50                   	push   %eax
f01126cb:	e8 e2 e3 00 00       	call   f0120ab2 <strcconcat>
f01126d0:	83 c4 10             	add    $0x10,%esp
f01126d3:	83 ec 0c             	sub    $0xc,%esp
f01126d6:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f01126dc:	50                   	push   %eax
f01126dd:	e8 fa f7 fe ff       	call   f0101edc <execute_command>
f01126e2:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f01126e5:	83 ec 04             	sub    $0x4,%esp
f01126e8:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f01126ee:	50                   	push   %eax
f01126ef:	68 8f a0 12 f0       	push   $0xf012a08f
f01126f4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f01126fa:	50                   	push   %eax
f01126fb:	e8 b2 e3 00 00       	call   f0120ab2 <strcconcat>
f0112700:	83 c4 10             	add    $0x10,%esp
f0112703:	83 ec 0c             	sub    $0xc,%esp
f0112706:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f011270c:	50                   	push   %eax
f011270d:	e8 ca f7 fe ff       	call   f0101edc <execute_command>
f0112712:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112715:	83 ec 04             	sub    $0x4,%esp
f0112718:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011271e:	50                   	push   %eax
f011271f:	68 9a a0 12 f0       	push   $0xf012a09a
f0112724:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011272a:	50                   	push   %eax
f011272b:	e8 82 e3 00 00       	call   f0120ab2 <strcconcat>
f0112730:	83 c4 10             	add    $0x10,%esp
f0112733:	83 ec 0c             	sub    $0xc,%esp
f0112736:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f011273c:	50                   	push   %eax
f011273d:	e8 9a f7 fe ff       	call   f0101edc <execute_command>
f0112742:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112745:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f011274c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011274f:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112752:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112759:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011275c:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f011275f:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112766:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112769:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f011276c:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0112773:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112776:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0112779:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0112780:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112783:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0112786:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f011278d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112790:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0112793:	83 ec 08             	sub    $0x8,%esp
f0112796:	68 00 00 c0 01       	push   $0x1c00000
f011279b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011279e:	e8 bd 42 00 00       	call   f0116a60 <GP>
f01127a3:	83 c4 10             	add    $0x10,%esp
f01127a6:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f01127a9:	83 ec 08             	sub    $0x8,%esp
f01127ac:	68 00 00 40 01       	push   $0x1400000
f01127b1:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127b4:	e8 a7 42 00 00       	call   f0116a60 <GP>
f01127b9:	83 c4 10             	add    $0x10,%esp
f01127bc:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f01127bf:	e8 45 af ff ff       	call   f010d709 <sys_calculate_free_frames>
f01127c4:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f01127c7:	6a 01                	push   $0x1
f01127c9:	68 00 00 40 01       	push   $0x1400000
f01127ce:	68 00 00 c0 01       	push   $0x1c00000
f01127d3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01127d6:	e8 f6 6b ff ff       	call   f01093d1 <cut_paste_pages>
f01127db:	83 c4 10             	add    $0x10,%esp
f01127de:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01127e1:	e8 23 af ff ff       	call   f010d709 <sys_calculate_free_frames>
f01127e6:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01127e9:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f01127ed:	75 08                	jne    f01127f7 <test_cut_paste_pages+0x6b4>
f01127ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01127f2:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01127f5:	74 2b                	je     f0112822 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f01127f7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01127fa:	2b 45 b0             	sub    -0x50(%ebp),%eax
f01127fd:	83 ec 0c             	sub    $0xc,%esp
f0112800:	50                   	push   %eax
f0112801:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112804:	68 a8 a0 12 f0       	push   $0xf012a0a8
f0112809:	68 6c 02 00 00       	push   $0x26c
f011280e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112813:	e8 9f dc fe ff       	call   f01004b7 <_warn>
f0112818:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f011281b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112822:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112826:	74 04                	je     f011282c <test_cut_paste_pages+0x6e9>
f0112828:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f011282c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f0112833:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f011283a:	83 ec 08             	sub    $0x8,%esp
f011283d:	6a 00                	push   $0x0
f011283f:	68 ff 0f 00 00       	push   $0xfff
f0112844:	ff 75 a4             	pushl  -0x5c(%ebp)
f0112847:	68 ff 0f 00 00       	push   $0xfff
f011284c:	ff 75 a0             	pushl  -0x60(%ebp)
f011284f:	6a 01                	push   $0x1
f0112851:	68 00 10 00 00       	push   $0x1000
f0112856:	68 00 00 40 01       	push   $0x1400000
f011285b:	68 00 00 c0 01       	push   $0x1c00000
f0112860:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112863:	e8 c5 42 00 00       	call   f0116b2d <CCP>
f0112868:	83 c4 30             	add    $0x30,%esp
f011286b:	83 f8 01             	cmp    $0x1,%eax
f011286e:	74 28                	je     f0112898 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112870:	83 ec 04             	sub    $0x4,%esp
f0112873:	68 bc 9f 12 f0       	push   $0xf0129fbc
f0112878:	68 75 02 00 00       	push   $0x275
f011287d:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112882:	e8 30 dc fe ff       	call   f01004b7 <_warn>
f0112887:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011288a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112891:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112898:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011289c:	74 04                	je     f01128a2 <test_cut_paste_pages+0x75f>
f011289e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f01128a2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f01128a9:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01128ad:	0f 84 92 00 00 00    	je     f0112945 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f01128b3:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f01128ba:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f01128c1:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f01128c8:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f01128cf:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f01128d6:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01128dd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01128e0:	8a 00                	mov    (%eax),%al
f01128e2:	3c 61                	cmp    $0x61,%al
f01128e4:	75 2d                	jne    f0112913 <test_cut_paste_pages+0x7d0>
f01128e6:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01128e9:	8a 00                	mov    (%eax),%al
f01128eb:	3c 78                	cmp    $0x78,%al
f01128ed:	75 24                	jne    f0112913 <test_cut_paste_pages+0x7d0>
f01128ef:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01128f2:	8a 00                	mov    (%eax),%al
f01128f4:	3c 62                	cmp    $0x62,%al
f01128f6:	75 1b                	jne    f0112913 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f01128f8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01128fb:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f01128fd:	3c 79                	cmp    $0x79,%al
f01128ff:	75 12                	jne    f0112913 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112901:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112904:	8a 00                	mov    (%eax),%al
f0112906:	3c 63                	cmp    $0x63,%al
f0112908:	75 09                	jne    f0112913 <test_cut_paste_pages+0x7d0>
f011290a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011290d:	8a 00                	mov    (%eax),%al
f011290f:	3c 7a                	cmp    $0x7a,%al
f0112911:	74 21                	je     f0112934 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112913:	83 ec 04             	sub    $0x4,%esp
f0112916:	68 08 a0 12 f0       	push   $0xf012a008
f011291b:	68 87 02 00 00       	push   $0x287
f0112920:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112925:	e8 8d db fe ff       	call   f01004b7 <_warn>
f011292a:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011292d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112934:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112938:	74 04                	je     f011293e <test_cut_paste_pages+0x7fb>
f011293a:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011293e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f0112945:	e8 bf ad ff ff       	call   f010d709 <sys_calculate_free_frames>
f011294a:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f011294d:	6a 03                	push   $0x3
f011294f:	68 00 f0 bf 01       	push   $0x1bff000
f0112954:	68 00 00 40 01       	push   $0x1400000
f0112959:	ff 75 d4             	pushl  -0x2c(%ebp)
f011295c:	e8 70 6a ff ff       	call   f01093d1 <cut_paste_pages>
f0112961:	83 c4 10             	add    $0x10,%esp
f0112964:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112967:	e8 9d ad ff ff       	call   f010d709 <sys_calculate_free_frames>
f011296c:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f011296f:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0112973:	75 08                	jne    f011297d <test_cut_paste_pages+0x83a>
f0112975:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112978:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011297b:	74 2b                	je     f01129a8 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011297d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112980:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112983:	83 ec 0c             	sub    $0xc,%esp
f0112986:	50                   	push   %eax
f0112987:	ff 75 b4             	pushl  -0x4c(%ebp)
f011298a:	68 a8 a0 12 f0       	push   $0xf012a0a8
f011298f:	68 96 02 00 00       	push   $0x296
f0112994:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112999:	e8 19 db fe ff       	call   f01004b7 <_warn>
f011299e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01129a1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01129a8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01129ac:	74 04                	je     f01129b2 <test_cut_paste_pages+0x86f>
f01129ae:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01129b2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f01129b9:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01129c0:	83 ec 04             	sub    $0x4,%esp
f01129c3:	6a 00                	push   $0x0
f01129c5:	68 00 00 40 01       	push   $0x1400000
f01129ca:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129cd:	e8 ec 3b 00 00       	call   f01165be <CB>
f01129d2:	83 c4 10             	add    $0x10,%esp
f01129d5:	83 f8 01             	cmp    $0x1,%eax
f01129d8:	0f 85 80 00 00 00    	jne    f0112a5e <test_cut_paste_pages+0x91b>
f01129de:	83 ec 04             	sub    $0x4,%esp
f01129e1:	6a 00                	push   $0x0
f01129e3:	68 00 10 40 01       	push   $0x1401000
f01129e8:	ff 75 d4             	pushl  -0x2c(%ebp)
f01129eb:	e8 ce 3b 00 00       	call   f01165be <CB>
f01129f0:	83 c4 10             	add    $0x10,%esp
f01129f3:	83 f8 01             	cmp    $0x1,%eax
f01129f6:	75 66                	jne    f0112a5e <test_cut_paste_pages+0x91b>
f01129f8:	83 ec 04             	sub    $0x4,%esp
f01129fb:	6a 00                	push   $0x0
f01129fd:	68 00 20 40 01       	push   $0x1402000
f0112a02:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a05:	e8 b4 3b 00 00       	call   f01165be <CB>
f0112a0a:	83 c4 10             	add    $0x10,%esp
f0112a0d:	83 f8 01             	cmp    $0x1,%eax
f0112a10:	75 4c                	jne    f0112a5e <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112a12:	83 ec 04             	sub    $0x4,%esp
f0112a15:	6a 00                	push   $0x0
f0112a17:	68 00 f0 bf 01       	push   $0x1bff000
f0112a1c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a1f:	e8 9a 3b 00 00       	call   f01165be <CB>
f0112a24:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0112a27:	85 c0                	test   %eax,%eax
f0112a29:	75 33                	jne    f0112a5e <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f0112a2b:	83 ec 04             	sub    $0x4,%esp
f0112a2e:	6a 00                	push   $0x0
f0112a30:	68 00 00 c0 01       	push   $0x1c00000
f0112a35:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a38:	e8 81 3b 00 00       	call   f01165be <CB>
f0112a3d:	83 c4 10             	add    $0x10,%esp
f0112a40:	83 f8 01             	cmp    $0x1,%eax
f0112a43:	75 19                	jne    f0112a5e <test_cut_paste_pages+0x91b>
f0112a45:	83 ec 04             	sub    $0x4,%esp
f0112a48:	6a 00                	push   $0x0
f0112a4a:	68 00 10 c0 01       	push   $0x1c01000
f0112a4f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112a52:	e8 67 3b 00 00       	call   f01165be <CB>
f0112a57:	83 c4 10             	add    $0x10,%esp
f0112a5a:	85 c0                	test   %eax,%eax
f0112a5c:	74 28                	je     f0112a86 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f0112a5e:	83 ec 04             	sub    $0x4,%esp
f0112a61:	68 08 a1 12 f0       	push   $0xf012a108
f0112a66:	68 9f 02 00 00       	push   $0x29f
f0112a6b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112a70:	e8 42 da fe ff       	call   f01004b7 <_warn>
f0112a75:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112a78:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0112a7f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0112a86:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112a8a:	74 04                	je     f0112a90 <test_cut_paste_pages+0x94d>
f0112a8c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112a90:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0112a97:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0112a9b:	0f 84 99 00 00 00    	je     f0112b3a <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0112aa1:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0112aa8:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0112aaf:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0112ab6:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f0112abd:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0112ac4:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112acb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112ace:	8a 00                	mov    (%eax),%al
f0112ad0:	3c 61                	cmp    $0x61,%al
f0112ad2:	75 2d                	jne    f0112b01 <test_cut_paste_pages+0x9be>
f0112ad4:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112ad7:	8a 00                	mov    (%eax),%al
f0112ad9:	3c 78                	cmp    $0x78,%al
f0112adb:	75 24                	jne    f0112b01 <test_cut_paste_pages+0x9be>
f0112add:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112ae0:	8a 00                	mov    (%eax),%al
f0112ae2:	3c 62                	cmp    $0x62,%al
f0112ae4:	75 1b                	jne    f0112b01 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112ae6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0112ae9:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f0112aeb:	3c 79                	cmp    $0x79,%al
f0112aed:	75 12                	jne    f0112b01 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0112aef:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112af2:	8a 00                	mov    (%eax),%al
f0112af4:	3c 63                	cmp    $0x63,%al
f0112af6:	75 09                	jne    f0112b01 <test_cut_paste_pages+0x9be>
f0112af8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0112afb:	8a 00                	mov    (%eax),%al
f0112afd:	3c 7a                	cmp    $0x7a,%al
f0112aff:	74 28                	je     f0112b29 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0112b01:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0112b08:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112b0f:	83 ec 04             	sub    $0x4,%esp
f0112b12:	68 08 a0 12 f0       	push   $0xf012a008
f0112b17:	68 b3 02 00 00       	push   $0x2b3
f0112b1c:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0112b21:	e8 91 d9 fe ff       	call   f01004b7 <_warn>
f0112b26:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f0112b29:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112b2d:	74 04                	je     f0112b33 <test_cut_paste_pages+0x9f0>
f0112b2f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112b33:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f0112b3a:	83 ec 0c             	sub    $0xc,%esp
f0112b3d:	68 41 a1 12 f0       	push   $0xf012a141
f0112b42:	e8 25 e4 fe ff       	call   f0100f6c <cprintf>
f0112b47:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f0112b4a:	83 ec 08             	sub    $0x8,%esp
f0112b4d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0112b50:	68 50 a1 12 f0       	push   $0xf012a150
f0112b55:	e8 12 e4 fe ff       	call   f0100f6c <cprintf>
f0112b5a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0112b5d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0112b61:	75 10                	jne    f0112b73 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f0112b63:	83 ec 0c             	sub    $0xc,%esp
f0112b66:	68 84 a1 12 f0       	push   $0xf012a184
f0112b6b:	e8 fc e3 fe ff       	call   f0100f6c <cprintf>
f0112b70:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0112b73:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0112b78:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0112b7b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0112b7e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0112b81:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112b86:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0112b89:	5b                   	pop    %ebx
f0112b8a:	5e                   	pop    %esi
f0112b8b:	5f                   	pop    %edi
f0112b8c:	5d                   	pop    %ebp
f0112b8d:	c3                   	ret    

f0112b8e <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f0112b8e:	55                   	push   %ebp
f0112b8f:	89 e5                	mov    %esp,%ebp
f0112b91:	57                   	push   %edi
f0112b92:	56                   	push   %esi
f0112b93:	53                   	push   %ebx
f0112b94:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0112b9a:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112ba0:	bb c4 a1 12 f0       	mov    $0xf012a1c4,%ebx
f0112ba5:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112baa:	89 c7                	mov    %eax,%edi
f0112bac:	89 de                	mov    %ebx,%esi
f0112bae:	89 d1                	mov    %edx,%ecx
f0112bb0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112bb2:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0112bb8:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112bbd:	b0 00                	mov    $0x0,%al
f0112bbf:	89 d7                	mov    %edx,%edi
f0112bc1:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112bc3:	6a 00                	push   $0x0
f0112bc5:	6a 0a                	push   $0xa
f0112bc7:	6a 14                	push   $0x14
f0112bc9:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0112bcf:	50                   	push   %eax
f0112bd0:	e8 9c 6b ff ff       	call   f0109771 <env_create>
f0112bd5:	83 c4 10             	add    $0x10,%esp
f0112bd8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112bdb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112bde:	8b 40 64             	mov    0x64(%eax),%eax
f0112be1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112be4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112be7:	8b 40 68             	mov    0x68(%eax),%eax
f0112bea:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0112bf0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0112bf6:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112bf9:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0112c00:	75 70 20 
f0112c03:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f0112c0a:	00 00 00 
f0112c0d:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112c13:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112c18:	b8 00 00 00 00       	mov    $0x0,%eax
f0112c1d:	89 d7                	mov    %edx,%edi
f0112c1f:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112c21:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112c24:	8b 40 10             	mov    0x10(%eax),%eax
f0112c27:	83 ec 08             	sub    $0x8,%esp
f0112c2a:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f0112c30:	52                   	push   %edx
f0112c31:	50                   	push   %eax
f0112c32:	e8 a2 dd 00 00       	call   f01209d9 <ltostr>
f0112c37:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112c3a:	83 ec 04             	sub    $0x4,%esp
f0112c3d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112c43:	50                   	push   %eax
f0112c44:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f0112c4a:	50                   	push   %eax
f0112c4b:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f0112c51:	50                   	push   %eax
f0112c52:	e8 5b de 00 00       	call   f0120ab2 <strcconcat>
f0112c57:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f0112c5a:	83 ec 0c             	sub    $0xc,%esp
f0112c5d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c60:	e8 94 3e 00 00       	call   f0116af9 <ClearUserSpace>
f0112c65:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f0112c68:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f0112c6f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0112c76:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0112c7d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0112c84:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0112c8b:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0112c92:	83 ec 0c             	sub    $0xc,%esp
f0112c95:	68 f8 a1 12 f0       	push   $0xf012a1f8
f0112c9a:	e8 cd e2 fe ff       	call   f0100f6c <cprintf>
f0112c9f:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0112ca2:	83 ec 04             	sub    $0x4,%esp
f0112ca5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112cab:	50                   	push   %eax
f0112cac:	68 2e a2 12 f0       	push   $0xf012a22e
f0112cb1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112cb7:	50                   	push   %eax
f0112cb8:	e8 f5 dd 00 00       	call   f0120ab2 <strcconcat>
f0112cbd:	83 c4 10             	add    $0x10,%esp
f0112cc0:	83 ec 0c             	sub    $0xc,%esp
f0112cc3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112cc9:	50                   	push   %eax
f0112cca:	e8 0d f2 fe ff       	call   f0101edc <execute_command>
f0112ccf:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0112cd2:	83 ec 04             	sub    $0x4,%esp
f0112cd5:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112cdb:	50                   	push   %eax
f0112cdc:	68 33 a2 12 f0       	push   $0xf012a233
f0112ce1:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112ce7:	50                   	push   %eax
f0112ce8:	e8 c5 dd 00 00       	call   f0120ab2 <strcconcat>
f0112ced:	83 c4 10             	add    $0x10,%esp
f0112cf0:	83 ec 0c             	sub    $0xc,%esp
f0112cf3:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0112cf9:	50                   	push   %eax
f0112cfa:	e8 dd f1 fe ff       	call   f0101edc <execute_command>
f0112cff:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0112d02:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112d08:	bb 39 a5 12 f0       	mov    $0xf012a539,%ebx
f0112d0d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d12:	89 c7                	mov    %eax,%edi
f0112d14:	89 de                	mov    %ebx,%esi
f0112d16:	89 d1                	mov    %edx,%ecx
f0112d18:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d1a:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0112d20:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d25:	b0 00                	mov    $0x0,%al
f0112d27:	89 d7                	mov    %edx,%edi
f0112d29:	f3 aa                	rep stos %al,%es:(%edi)
f0112d2b:	83 ec 0c             	sub    $0xc,%esp
f0112d2e:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0112d34:	50                   	push   %eax
f0112d35:	e8 a2 f1 fe ff       	call   f0101edc <execute_command>
f0112d3a:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f0112d3d:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112d43:	bb 9d a5 12 f0       	mov    $0xf012a59d,%ebx
f0112d48:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d4d:	89 c7                	mov    %eax,%edi
f0112d4f:	89 de                	mov    %ebx,%esi
f0112d51:	89 d1                	mov    %edx,%ecx
f0112d53:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d55:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0112d5b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d60:	b0 00                	mov    $0x0,%al
f0112d62:	89 d7                	mov    %edx,%edi
f0112d64:	f3 aa                	rep stos %al,%es:(%edi)
f0112d66:	83 ec 0c             	sub    $0xc,%esp
f0112d69:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0112d6f:	50                   	push   %eax
f0112d70:	e8 67 f1 fe ff       	call   f0101edc <execute_command>
f0112d75:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0112d78:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112d7e:	bb 01 a6 12 f0       	mov    $0xf012a601,%ebx
f0112d83:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112d88:	89 c7                	mov    %eax,%edi
f0112d8a:	89 de                	mov    %ebx,%esi
f0112d8c:	89 d1                	mov    %edx,%ecx
f0112d8e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112d90:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0112d96:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112d9b:	b0 00                	mov    $0x0,%al
f0112d9d:	89 d7                	mov    %edx,%edi
f0112d9f:	f3 aa                	rep stos %al,%es:(%edi)
f0112da1:	83 ec 0c             	sub    $0xc,%esp
f0112da4:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0112daa:	50                   	push   %eax
f0112dab:	e8 2c f1 fe ff       	call   f0101edc <execute_command>
f0112db0:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0112db3:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112db9:	bb 65 a6 12 f0       	mov    $0xf012a665,%ebx
f0112dbe:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112dc3:	89 c7                	mov    %eax,%edi
f0112dc5:	89 de                	mov    %ebx,%esi
f0112dc7:	89 d1                	mov    %edx,%ecx
f0112dc9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112dcb:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0112dd1:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112dd6:	b0 00                	mov    $0x0,%al
f0112dd8:	89 d7                	mov    %edx,%edi
f0112dda:	f3 aa                	rep stos %al,%es:(%edi)
f0112ddc:	83 ec 0c             	sub    $0xc,%esp
f0112ddf:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0112de5:	50                   	push   %eax
f0112de6:	e8 f1 f0 fe ff       	call   f0101edc <execute_command>
f0112deb:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f0112dee:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112df4:	bb c9 a6 12 f0       	mov    $0xf012a6c9,%ebx
f0112df9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112dfe:	89 c7                	mov    %eax,%edi
f0112e00:	89 de                	mov    %ebx,%esi
f0112e02:	89 d1                	mov    %edx,%ecx
f0112e04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e06:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0112e0c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e11:	b0 00                	mov    $0x0,%al
f0112e13:	89 d7                	mov    %edx,%edi
f0112e15:	f3 aa                	rep stos %al,%es:(%edi)
f0112e17:	83 ec 0c             	sub    $0xc,%esp
f0112e1a:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0112e20:	50                   	push   %eax
f0112e21:	e8 b6 f0 fe ff       	call   f0101edc <execute_command>
f0112e26:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f0112e29:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112e2f:	bb 2d a7 12 f0       	mov    $0xf012a72d,%ebx
f0112e34:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112e39:	89 c7                	mov    %eax,%edi
f0112e3b:	89 de                	mov    %ebx,%esi
f0112e3d:	89 d1                	mov    %edx,%ecx
f0112e3f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112e41:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0112e47:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112e4c:	b0 00                	mov    $0x0,%al
f0112e4e:	89 d7                	mov    %edx,%edi
f0112e50:	f3 aa                	rep stos %al,%es:(%edi)
f0112e52:	83 ec 0c             	sub    $0xc,%esp
f0112e55:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0112e5b:	50                   	push   %eax
f0112e5c:	e8 7b f0 fe ff       	call   f0101edc <execute_command>
f0112e61:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f0112e64:	83 ec 04             	sub    $0x4,%esp
f0112e67:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e6d:	50                   	push   %eax
f0112e6e:	68 3b a2 12 f0       	push   $0xf012a23b
f0112e73:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112e79:	50                   	push   %eax
f0112e7a:	e8 33 dc 00 00       	call   f0120ab2 <strcconcat>
f0112e7f:	83 c4 10             	add    $0x10,%esp
f0112e82:	83 ec 0c             	sub    $0xc,%esp
f0112e85:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e8b:	50                   	push   %eax
f0112e8c:	e8 4b f0 fe ff       	call   f0101edc <execute_command>
f0112e91:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0112e94:	83 ec 04             	sub    $0x4,%esp
f0112e97:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112e9d:	50                   	push   %eax
f0112e9e:	68 45 a2 12 f0       	push   $0xf012a245
f0112ea3:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0112ea9:	50                   	push   %eax
f0112eaa:	e8 03 dc 00 00       	call   f0120ab2 <strcconcat>
f0112eaf:	83 c4 10             	add    $0x10,%esp
f0112eb2:	83 ec 0c             	sub    $0xc,%esp
f0112eb5:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0112ebb:	50                   	push   %eax
f0112ebc:	e8 1b f0 fe ff       	call   f0101edc <execute_command>
f0112ec1:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0112ec4:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112eca:	bb 91 a7 12 f0       	mov    $0xf012a791,%ebx
f0112ecf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112ed4:	89 c7                	mov    %eax,%edi
f0112ed6:	89 de                	mov    %ebx,%esi
f0112ed8:	89 d1                	mov    %edx,%ecx
f0112eda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112edc:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0112ee2:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112ee7:	b0 00                	mov    $0x0,%al
f0112ee9:	89 d7                	mov    %edx,%edi
f0112eeb:	f3 aa                	rep stos %al,%es:(%edi)
f0112eed:	83 ec 0c             	sub    $0xc,%esp
f0112ef0:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0112ef6:	50                   	push   %eax
f0112ef7:	e8 e0 ef fe ff       	call   f0101edc <execute_command>
f0112efc:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f0112eff:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112f05:	bb f5 a7 12 f0       	mov    $0xf012a7f5,%ebx
f0112f0a:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f0f:	89 c7                	mov    %eax,%edi
f0112f11:	89 de                	mov    %ebx,%esi
f0112f13:	89 d1                	mov    %edx,%ecx
f0112f15:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f17:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0112f1d:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f22:	b0 00                	mov    $0x0,%al
f0112f24:	89 d7                	mov    %edx,%edi
f0112f26:	f3 aa                	rep stos %al,%es:(%edi)
f0112f28:	83 ec 0c             	sub    $0xc,%esp
f0112f2b:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0112f31:	50                   	push   %eax
f0112f32:	e8 a5 ef fe ff       	call   f0101edc <execute_command>
f0112f37:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f0112f3a:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112f40:	bb 59 a8 12 f0       	mov    $0xf012a859,%ebx
f0112f45:	ba 0f 00 00 00       	mov    $0xf,%edx
f0112f4a:	89 c7                	mov    %eax,%edi
f0112f4c:	89 de                	mov    %ebx,%esi
f0112f4e:	89 d1                	mov    %edx,%ecx
f0112f50:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112f52:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0112f58:	b9 55 00 00 00       	mov    $0x55,%ecx
f0112f5d:	b0 00                	mov    $0x0,%al
f0112f5f:	89 d7                	mov    %edx,%edi
f0112f61:	f3 aa                	rep stos %al,%es:(%edi)
f0112f63:	83 ec 0c             	sub    $0xc,%esp
f0112f66:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0112f6c:	50                   	push   %eax
f0112f6d:	e8 6a ef fe ff       	call   f0101edc <execute_command>
f0112f72:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0112f75:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0112f7c:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0112f83:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f0112f8a:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0112f91:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0112f98:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f0112f9f:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0112fa6:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f0112fad:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0112fb4:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f0112fbb:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0112fc2:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0112fc9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0112fcc:	8a 00                	mov    (%eax),%al
f0112fce:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0112fd4:	8b 45 98             	mov    -0x68(%ebp),%eax
f0112fd7:	8a 00                	mov    (%eax),%al
f0112fd9:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f0112fdf:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112fe2:	8a 00                	mov    (%eax),%al
f0112fe4:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0112fea:	e8 1a a7 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0112fef:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0112ff2:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0112ff5:	89 d0                	mov    %edx,%eax
f0112ff7:	01 c0                	add    %eax,%eax
f0112ff9:	01 d0                	add    %edx,%eax
f0112ffb:	01 c0                	add    %eax,%eax
f0112ffd:	50                   	push   %eax
f0112ffe:	68 00 00 10 00       	push   $0x100000
f0113003:	6a 00                	push   $0x0
f0113005:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113008:	e8 de 63 ff ff       	call   f01093eb <copy_paste_chunk>
f011300d:	83 c4 10             	add    $0x10,%esp
f0113010:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113013:	e8 f1 a6 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113018:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f011301b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113022:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f0113026:	75 08                	jne    f0113030 <test_copy_paste_chunk+0x4a2>
f0113028:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011302b:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011302e:	74 2b                	je     f011305b <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113030:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113033:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113036:	83 ec 0c             	sub    $0xc,%esp
f0113039:	50                   	push   %eax
f011303a:	ff 75 88             	pushl  -0x78(%ebp)
f011303d:	68 54 a2 12 f0       	push   $0xf012a254
f0113042:	68 06 03 00 00       	push   $0x306
f0113047:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011304c:	e8 66 d4 fe ff       	call   f01004b7 <_warn>
f0113051:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113054:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011305b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011305f:	74 04                	je     f0113065 <test_copy_paste_chunk+0x4d7>
f0113061:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113065:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f011306c:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011306f:	8a 00                	mov    (%eax),%al
f0113071:	3c 61                	cmp    $0x61,%al
f0113073:	75 75                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f0113075:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113078:	8a 00                	mov    (%eax),%al
f011307a:	3c 78                	cmp    $0x78,%al
f011307c:	75 6c                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f011307e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113081:	8a 00                	mov    (%eax),%al
f0113083:	3c 62                	cmp    $0x62,%al
f0113085:	75 63                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f0113087:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011308a:	8a 00                	mov    (%eax),%al
f011308c:	3c 79                	cmp    $0x79,%al
f011308e:	75 5a                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f0113090:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113093:	8a 00                	mov    (%eax),%al
f0113095:	3c 63                	cmp    $0x63,%al
f0113097:	75 51                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f0113099:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011309c:	8a 00                	mov    (%eax),%al
f011309e:	3c 7a                	cmp    $0x7a,%al
f01130a0:	75 48                	jne    f01130ea <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f01130a2:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01130a5:	8a 00                	mov    (%eax),%al
f01130a7:	3c 64                	cmp    $0x64,%al
f01130a9:	75 3f                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f01130ab:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01130ae:	8a 10                	mov    (%eax),%dl
f01130b0:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f01130b6:	38 c2                	cmp    %al,%dl
f01130b8:	75 30                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f01130ba:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01130bd:	8a 00                	mov    (%eax),%al
f01130bf:	3c 65                	cmp    $0x65,%al
f01130c1:	75 27                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f01130c3:	8b 45 98             	mov    -0x68(%ebp),%eax
f01130c6:	8a 10                	mov    (%eax),%dl
f01130c8:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f01130ce:	38 c2                	cmp    %al,%dl
f01130d0:	75 18                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f01130d2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01130d5:	8a 00                	mov    (%eax),%al
f01130d7:	3c 66                	cmp    $0x66,%al
f01130d9:	75 0f                	jne    f01130ea <test_copy_paste_chunk+0x55c>
f01130db:	8b 45 90             	mov    -0x70(%ebp),%eax
f01130de:	8a 10                	mov    (%eax),%dl
f01130e0:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01130e6:	38 c2                	cmp    %al,%dl
f01130e8:	74 21                	je     f011310b <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01130ea:	83 ec 04             	sub    $0x4,%esp
f01130ed:	68 b8 a2 12 f0       	push   $0xf012a2b8
f01130f2:	68 0f 03 00 00       	push   $0x30f
f01130f7:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01130fc:	e8 b6 d3 fe ff       	call   f01004b7 <_warn>
f0113101:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113104:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011310b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011310f:	74 04                	je     f0113115 <test_copy_paste_chunk+0x587>
f0113111:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113115:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f011311c:	83 ec 0c             	sub    $0xc,%esp
f011311f:	68 f2 a2 12 f0       	push   $0xf012a2f2
f0113124:	e8 43 de fe ff       	call   f0100f6c <cprintf>
f0113129:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f011312c:	83 ec 0c             	sub    $0xc,%esp
f011312f:	68 04 a3 12 f0       	push   $0xf012a304
f0113134:	e8 33 de fe ff       	call   f0100f6c <cprintf>
f0113139:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f011313c:	83 ec 04             	sub    $0x4,%esp
f011313f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113145:	50                   	push   %eax
f0113146:	68 3a a3 12 f0       	push   $0xf012a33a
f011314b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113151:	50                   	push   %eax
f0113152:	e8 5b d9 00 00       	call   f0120ab2 <strcconcat>
f0113157:	83 c4 10             	add    $0x10,%esp
f011315a:	83 ec 0c             	sub    $0xc,%esp
f011315d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113163:	50                   	push   %eax
f0113164:	e8 73 ed fe ff       	call   f0101edc <execute_command>
f0113169:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f011316c:	83 ec 04             	sub    $0x4,%esp
f011316f:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113175:	50                   	push   %eax
f0113176:	68 44 a3 12 f0       	push   $0xf012a344
f011317b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113181:	50                   	push   %eax
f0113182:	e8 2b d9 00 00       	call   f0120ab2 <strcconcat>
f0113187:	83 c4 10             	add    $0x10,%esp
f011318a:	83 ec 0c             	sub    $0xc,%esp
f011318d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113193:	50                   	push   %eax
f0113194:	e8 43 ed fe ff       	call   f0101edc <execute_command>
f0113199:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f011319c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01131a2:	bb bd a8 12 f0       	mov    $0xf012a8bd,%ebx
f01131a7:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131ac:	89 c7                	mov    %eax,%edi
f01131ae:	89 de                	mov    %ebx,%esi
f01131b0:	89 d1                	mov    %edx,%ecx
f01131b2:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131b4:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01131ba:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131bf:	b0 00                	mov    $0x0,%al
f01131c1:	89 d7                	mov    %edx,%edi
f01131c3:	f3 aa                	rep stos %al,%es:(%edi)
f01131c5:	83 ec 0c             	sub    $0xc,%esp
f01131c8:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01131ce:	50                   	push   %eax
f01131cf:	e8 08 ed fe ff       	call   f0101edc <execute_command>
f01131d4:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f01131d7:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01131dd:	bb 21 a9 12 f0       	mov    $0xf012a921,%ebx
f01131e2:	ba 0f 00 00 00       	mov    $0xf,%edx
f01131e7:	89 c7                	mov    %eax,%edi
f01131e9:	89 de                	mov    %ebx,%esi
f01131eb:	89 d1                	mov    %edx,%ecx
f01131ed:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01131ef:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01131f5:	b9 55 00 00 00       	mov    $0x55,%ecx
f01131fa:	b0 00                	mov    $0x0,%al
f01131fc:	89 d7                	mov    %edx,%edi
f01131fe:	f3 aa                	rep stos %al,%es:(%edi)
f0113200:	83 ec 0c             	sub    $0xc,%esp
f0113203:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113209:	50                   	push   %eax
f011320a:	e8 cd ec fe ff       	call   f0101edc <execute_command>
f011320f:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0113212:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113218:	bb 85 a9 12 f0       	mov    $0xf012a985,%ebx
f011321d:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113222:	89 c7                	mov    %eax,%edi
f0113224:	89 de                	mov    %ebx,%esi
f0113226:	89 d1                	mov    %edx,%ecx
f0113228:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011322a:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113230:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113235:	b0 00                	mov    $0x0,%al
f0113237:	89 d7                	mov    %edx,%edi
f0113239:	f3 aa                	rep stos %al,%es:(%edi)
f011323b:	83 ec 0c             	sub    $0xc,%esp
f011323e:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113244:	50                   	push   %eax
f0113245:	e8 92 ec fe ff       	call   f0101edc <execute_command>
f011324a:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f011324d:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113253:	bb e9 a9 12 f0       	mov    $0xf012a9e9,%ebx
f0113258:	ba 0f 00 00 00       	mov    $0xf,%edx
f011325d:	89 c7                	mov    %eax,%edi
f011325f:	89 de                	mov    %ebx,%esi
f0113261:	89 d1                	mov    %edx,%ecx
f0113263:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113265:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f011326b:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113270:	b0 00                	mov    $0x0,%al
f0113272:	89 d7                	mov    %edx,%edi
f0113274:	f3 aa                	rep stos %al,%es:(%edi)
f0113276:	83 ec 0c             	sub    $0xc,%esp
f0113279:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f011327f:	50                   	push   %eax
f0113280:	e8 57 ec fe ff       	call   f0101edc <execute_command>
f0113285:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113288:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f011328e:	bb 4d aa 12 f0       	mov    $0xf012aa4d,%ebx
f0113293:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113298:	89 c7                	mov    %eax,%edi
f011329a:	89 de                	mov    %ebx,%esi
f011329c:	89 d1                	mov    %edx,%ecx
f011329e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132a0:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f01132a6:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132ab:	b0 00                	mov    $0x0,%al
f01132ad:	89 d7                	mov    %edx,%edi
f01132af:	f3 aa                	rep stos %al,%es:(%edi)
f01132b1:	83 ec 0c             	sub    $0xc,%esp
f01132b4:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01132ba:	50                   	push   %eax
f01132bb:	e8 1c ec fe ff       	call   f0101edc <execute_command>
f01132c0:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f01132c3:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01132c9:	bb b1 aa 12 f0       	mov    $0xf012aab1,%ebx
f01132ce:	ba 0f 00 00 00       	mov    $0xf,%edx
f01132d3:	89 c7                	mov    %eax,%edi
f01132d5:	89 de                	mov    %ebx,%esi
f01132d7:	89 d1                	mov    %edx,%ecx
f01132d9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01132db:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01132e1:	b9 55 00 00 00       	mov    $0x55,%ecx
f01132e6:	b0 00                	mov    $0x0,%al
f01132e8:	89 d7                	mov    %edx,%edi
f01132ea:	f3 aa                	rep stos %al,%es:(%edi)
f01132ec:	83 ec 0c             	sub    $0xc,%esp
f01132ef:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01132f5:	50                   	push   %eax
f01132f6:	e8 e1 eb fe ff       	call   f0101edc <execute_command>
f01132fb:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f01132fe:	83 ec 04             	sub    $0x4,%esp
f0113301:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113307:	50                   	push   %eax
f0113308:	68 4e a3 12 f0       	push   $0xf012a34e
f011330d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113313:	50                   	push   %eax
f0113314:	e8 99 d7 00 00       	call   f0120ab2 <strcconcat>
f0113319:	83 c4 10             	add    $0x10,%esp
f011331c:	83 ec 0c             	sub    $0xc,%esp
f011331f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113325:	50                   	push   %eax
f0113326:	e8 b1 eb fe ff       	call   f0101edc <execute_command>
f011332b:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f011332e:	83 ec 04             	sub    $0x4,%esp
f0113331:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113337:	50                   	push   %eax
f0113338:	68 58 a3 12 f0       	push   $0xf012a358
f011333d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113343:	50                   	push   %eax
f0113344:	e8 69 d7 00 00       	call   f0120ab2 <strcconcat>
f0113349:	83 c4 10             	add    $0x10,%esp
f011334c:	83 ec 0c             	sub    $0xc,%esp
f011334f:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113355:	50                   	push   %eax
f0113356:	e8 81 eb fe ff       	call   f0101edc <execute_command>
f011335b:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f011335e:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113364:	bb 15 ab 12 f0       	mov    $0xf012ab15,%ebx
f0113369:	ba 0f 00 00 00       	mov    $0xf,%edx
f011336e:	89 c7                	mov    %eax,%edi
f0113370:	89 de                	mov    %ebx,%esi
f0113372:	89 d1                	mov    %edx,%ecx
f0113374:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113376:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f011337c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113381:	b0 00                	mov    $0x0,%al
f0113383:	89 d7                	mov    %edx,%edi
f0113385:	f3 aa                	rep stos %al,%es:(%edi)
f0113387:	83 ec 0c             	sub    $0xc,%esp
f011338a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113390:	50                   	push   %eax
f0113391:	e8 46 eb fe ff       	call   f0101edc <execute_command>
f0113396:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113399:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f011339f:	bb 79 ab 12 f0       	mov    $0xf012ab79,%ebx
f01133a4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133a9:	89 c7                	mov    %eax,%edi
f01133ab:	89 de                	mov    %ebx,%esi
f01133ad:	89 d1                	mov    %edx,%ecx
f01133af:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133b1:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01133b7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133bc:	b0 00                	mov    $0x0,%al
f01133be:	89 d7                	mov    %edx,%edi
f01133c0:	f3 aa                	rep stos %al,%es:(%edi)
f01133c2:	83 ec 0c             	sub    $0xc,%esp
f01133c5:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01133cb:	50                   	push   %eax
f01133cc:	e8 0b eb fe ff       	call   f0101edc <execute_command>
f01133d1:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f01133d4:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01133da:	bb dd ab 12 f0       	mov    $0xf012abdd,%ebx
f01133df:	ba 0f 00 00 00       	mov    $0xf,%edx
f01133e4:	89 c7                	mov    %eax,%edi
f01133e6:	89 de                	mov    %ebx,%esi
f01133e8:	89 d1                	mov    %edx,%ecx
f01133ea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01133ec:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01133f2:	b9 55 00 00 00       	mov    $0x55,%ecx
f01133f7:	b0 00                	mov    $0x0,%al
f01133f9:	89 d7                	mov    %edx,%edi
f01133fb:	f3 aa                	rep stos %al,%es:(%edi)
f01133fd:	83 ec 0c             	sub    $0xc,%esp
f0113400:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113406:	50                   	push   %eax
f0113407:	e8 d0 ea fe ff       	call   f0101edc <execute_command>
f011340c:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f011340f:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113416:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f011341d:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113424:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f011342b:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113432:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113439:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113440:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113447:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f011344e:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113455:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f011345c:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113463:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113466:	8a 00                	mov    (%eax),%al
f0113468:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011346e:	e8 96 a2 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113473:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113476:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113479:	89 d0                	mov    %edx,%eax
f011347b:	01 c0                	add    %eax,%eax
f011347d:	01 d0                	add    %edx,%eax
f011347f:	01 c0                	add    %eax,%eax
f0113481:	50                   	push   %eax
f0113482:	68 00 00 40 00       	push   $0x400000
f0113487:	68 00 00 20 00       	push   $0x200000
f011348c:	ff 75 d4             	pushl  -0x2c(%ebp)
f011348f:	e8 57 5f ff ff       	call   f01093eb <copy_paste_chunk>
f0113494:	83 c4 10             	add    $0x10,%esp
f0113497:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011349a:	e8 6a a2 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011349f:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01134a2:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01134a9:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f01134ad:	75 08                	jne    f01134b7 <test_copy_paste_chunk+0x929>
f01134af:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01134b2:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01134b5:	74 2b                	je     f01134e2 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01134b7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01134ba:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01134bd:	83 ec 0c             	sub    $0xc,%esp
f01134c0:	50                   	push   %eax
f01134c1:	ff 75 80             	pushl  -0x80(%ebp)
f01134c4:	68 64 a3 12 f0       	push   $0xf012a364
f01134c9:	68 3f 03 00 00       	push   $0x33f
f01134ce:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01134d3:	e8 df cf fe ff       	call   f01004b7 <_warn>
f01134d8:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01134db:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01134e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01134e6:	74 04                	je     f01134ec <test_copy_paste_chunk+0x95e>
f01134e8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01134ec:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f01134f3:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f01134fa:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f01134fd:	83 ec 08             	sub    $0x8,%esp
f0113500:	6a 01                	push   $0x1
f0113502:	6a 07                	push   $0x7
f0113504:	6a 07                	push   $0x7
f0113506:	6a 07                	push   $0x7
f0113508:	6a 07                	push   $0x7
f011350a:	6a 01                	push   $0x1
f011350c:	68 00 20 00 00       	push   $0x2000
f0113511:	68 00 00 40 00       	push   $0x400000
f0113516:	68 00 00 20 00       	push   $0x200000
f011351b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011351e:	e8 0a 36 00 00       	call   f0116b2d <CCP>
f0113523:	83 c4 30             	add    $0x30,%esp
f0113526:	83 f8 01             	cmp    $0x1,%eax
f0113529:	74 2b                	je     f0113556 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f011352b:	83 ec 04             	sub    $0x4,%esp
f011352e:	68 b8 a3 12 f0       	push   $0xf012a3b8
f0113533:	68 48 03 00 00       	push   $0x348
f0113538:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011353d:	e8 75 cf fe ff       	call   f01004b7 <_warn>
f0113542:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113545:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f011354c:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113553:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113556:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011355a:	74 04                	je     f0113560 <test_copy_paste_chunk+0x9d2>
f011355c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113560:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113567:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011356a:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f011356d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113570:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113573:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113576:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113579:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011357c:	8a 00                	mov    (%eax),%al
f011357e:	3c 61                	cmp    $0x61,%al
f0113580:	75 69                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f0113582:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113585:	8a 00                	mov    (%eax),%al
f0113587:	3c 61                	cmp    $0x61,%al
f0113589:	75 60                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f011358b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011358e:	8a 00                	mov    (%eax),%al
f0113590:	3c 79                	cmp    $0x79,%al
f0113592:	75 57                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f0113594:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113597:	8a 00                	mov    (%eax),%al
f0113599:	3c 62                	cmp    $0x62,%al
f011359b:	75 4e                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f011359d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01135a0:	8a 00                	mov    (%eax),%al
f01135a2:	3c 63                	cmp    $0x63,%al
f01135a4:	75 45                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f01135a6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01135a9:	8a 00                	mov    (%eax),%al
f01135ab:	3c 7a                	cmp    $0x7a,%al
f01135ad:	75 3c                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f01135af:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01135b2:	8a 00                	mov    (%eax),%al
f01135b4:	3c 77                	cmp    $0x77,%al
f01135b6:	75 33                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f01135b8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01135bb:	8a 00                	mov    (%eax),%al
f01135bd:	3c 64                	cmp    $0x64,%al
f01135bf:	75 2a                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f01135c1:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01135c4:	8a 00                	mov    (%eax),%al
f01135c6:	3c 65                	cmp    $0x65,%al
f01135c8:	75 21                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f01135ca:	8b 45 98             	mov    -0x68(%ebp),%eax
f01135cd:	8a 00                	mov    (%eax),%al
f01135cf:	3c 65                	cmp    $0x65,%al
f01135d1:	75 18                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f01135d3:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01135d6:	8a 00                	mov    (%eax),%al
f01135d8:	3c 66                	cmp    $0x66,%al
f01135da:	75 0f                	jne    f01135eb <test_copy_paste_chunk+0xa5d>
f01135dc:	8b 45 90             	mov    -0x70(%ebp),%eax
f01135df:	8a 10                	mov    (%eax),%dl
f01135e1:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f01135e7:	38 c2                	cmp    %al,%dl
f01135e9:	74 21                	je     f011360c <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f01135eb:	83 ec 04             	sub    $0x4,%esp
f01135ee:	68 b8 a2 12 f0       	push   $0xf012a2b8
f01135f3:	68 56 03 00 00       	push   $0x356
f01135f8:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01135fd:	e8 b5 ce fe ff       	call   f01004b7 <_warn>
f0113602:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113605:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011360c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113610:	74 04                	je     f0113616 <test_copy_paste_chunk+0xa88>
f0113612:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113616:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f011361d:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113620:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113623:	e8 e1 a0 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113628:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f011362b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011362e:	89 c2                	mov    %eax,%edx
f0113630:	01 d2                	add    %edx,%edx
f0113632:	01 d0                	add    %edx,%eax
f0113634:	50                   	push   %eax
f0113635:	68 00 08 20 00       	push   $0x200800
f011363a:	68 00 08 40 00       	push   $0x400800
f011363f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113642:	e8 a4 5d ff ff       	call   f01093eb <copy_paste_chunk>
f0113647:	83 c4 10             	add    $0x10,%esp
f011364a:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011364d:	e8 b7 a0 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113652:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113655:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113659:	75 08                	jne    f0113663 <test_copy_paste_chunk+0xad5>
f011365b:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011365e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113661:	74 2b                	je     f011368e <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113663:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113666:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113669:	83 ec 0c             	sub    $0xc,%esp
f011366c:	50                   	push   %eax
f011366d:	ff 75 80             	pushl  -0x80(%ebp)
f0113670:	68 64 a3 12 f0       	push   $0xf012a364
f0113675:	68 66 03 00 00       	push   $0x366
f011367a:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011367f:	e8 33 ce fe ff       	call   f01004b7 <_warn>
f0113684:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113687:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011368e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113692:	74 04                	je     f0113698 <test_copy_paste_chunk+0xb0a>
f0113694:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113698:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f011369f:	83 ec 08             	sub    $0x8,%esp
f01136a2:	6a 01                	push   $0x1
f01136a4:	6a 07                	push   $0x7
f01136a6:	6a 07                	push   $0x7
f01136a8:	6a 07                	push   $0x7
f01136aa:	6a 07                	push   $0x7
f01136ac:	6a 01                	push   $0x1
f01136ae:	68 00 20 00 00       	push   $0x2000
f01136b3:	68 00 00 20 00       	push   $0x200000
f01136b8:	68 00 00 40 00       	push   $0x400000
f01136bd:	ff 75 d4             	pushl  -0x2c(%ebp)
f01136c0:	e8 68 34 00 00       	call   f0116b2d <CCP>
f01136c5:	83 c4 30             	add    $0x30,%esp
f01136c8:	83 f8 01             	cmp    $0x1,%eax
f01136cb:	74 21                	je     f01136ee <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01136cd:	83 ec 04             	sub    $0x4,%esp
f01136d0:	68 04 a4 12 f0       	push   $0xf012a404
f01136d5:	68 6e 03 00 00       	push   $0x36e
f01136da:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01136df:	e8 d3 cd fe ff       	call   f01004b7 <_warn>
f01136e4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01136e7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01136ee:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01136f2:	74 04                	je     f01136f8 <test_copy_paste_chunk+0xb6a>
f01136f4:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01136f8:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f01136ff:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113702:	8a 00                	mov    (%eax),%al
f0113704:	3c 61                	cmp    $0x61,%al
f0113706:	75 69                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113708:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011370b:	8a 00                	mov    (%eax),%al
f011370d:	3c 61                	cmp    $0x61,%al
f011370f:	75 60                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113711:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113714:	8a 00                	mov    (%eax),%al
f0113716:	3c 79                	cmp    $0x79,%al
f0113718:	75 57                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f011371a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011371d:	8a 00                	mov    (%eax),%al
f011371f:	3c 62                	cmp    $0x62,%al
f0113721:	75 4e                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113723:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113726:	8a 00                	mov    (%eax),%al
f0113728:	3c 7a                	cmp    $0x7a,%al
f011372a:	75 45                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f011372c:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011372f:	8a 00                	mov    (%eax),%al
f0113731:	3c 7a                	cmp    $0x7a,%al
f0113733:	75 3c                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113735:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113738:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f011373a:	3c 64                	cmp    $0x64,%al
f011373c:	75 33                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f011373e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113741:	8a 00                	mov    (%eax),%al
f0113743:	3c 64                	cmp    $0x64,%al
f0113745:	75 2a                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113747:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011374a:	8a 00                	mov    (%eax),%al
f011374c:	3c 65                	cmp    $0x65,%al
f011374e:	75 21                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113750:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113753:	8a 00                	mov    (%eax),%al
f0113755:	3c 78                	cmp    $0x78,%al
f0113757:	75 18                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113759:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011375c:	8a 00                	mov    (%eax),%al
f011375e:	3c 66                	cmp    $0x66,%al
f0113760:	75 0f                	jne    f0113771 <test_copy_paste_chunk+0xbe3>
f0113762:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113765:	8a 10                	mov    (%eax),%dl
f0113767:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f011376d:	38 c2                	cmp    %al,%dl
f011376f:	74 21                	je     f0113792 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113771:	83 ec 04             	sub    $0x4,%esp
f0113774:	68 b8 a2 12 f0       	push   $0xf012a2b8
f0113779:	68 77 03 00 00       	push   $0x377
f011377e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113783:	e8 2f cd fe ff       	call   f01004b7 <_warn>
f0113788:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011378b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113792:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113796:	74 04                	je     f011379c <test_copy_paste_chunk+0xc0e>
f0113798:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011379c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f01137a3:	83 ec 0c             	sub    $0xc,%esp
f01137a6:	68 4f a4 12 f0       	push   $0xf012a44f
f01137ab:	e8 bc d7 fe ff       	call   f0100f6c <cprintf>
f01137b0:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f01137b3:	83 ec 0c             	sub    $0xc,%esp
f01137b6:	68 60 a4 12 f0       	push   $0xf012a460
f01137bb:	e8 ac d7 fe ff       	call   f0100f6c <cprintf>
f01137c0:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f01137c3:	83 ec 04             	sub    $0x4,%esp
f01137c6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01137cc:	50                   	push   %eax
f01137cd:	68 94 a4 12 f0       	push   $0xf012a494
f01137d2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01137d8:	50                   	push   %eax
f01137d9:	e8 d4 d2 00 00       	call   f0120ab2 <strcconcat>
f01137de:	83 c4 10             	add    $0x10,%esp
f01137e1:	83 ec 0c             	sub    $0xc,%esp
f01137e4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01137ea:	50                   	push   %eax
f01137eb:	e8 ec e6 fe ff       	call   f0101edc <execute_command>
f01137f0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f01137f3:	83 ec 04             	sub    $0x4,%esp
f01137f6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01137fc:	50                   	push   %eax
f01137fd:	68 9e a4 12 f0       	push   $0xf012a49e
f0113802:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113808:	50                   	push   %eax
f0113809:	e8 a4 d2 00 00       	call   f0120ab2 <strcconcat>
f011380e:	83 c4 10             	add    $0x10,%esp
f0113811:	83 ec 0c             	sub    $0xc,%esp
f0113814:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011381a:	50                   	push   %eax
f011381b:	e8 bc e6 fe ff       	call   f0101edc <execute_command>
f0113820:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f0113823:	83 ec 04             	sub    $0x4,%esp
f0113826:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011382c:	50                   	push   %eax
f011382d:	68 a8 a4 12 f0       	push   $0xf012a4a8
f0113832:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113838:	50                   	push   %eax
f0113839:	e8 74 d2 00 00       	call   f0120ab2 <strcconcat>
f011383e:	83 c4 10             	add    $0x10,%esp
f0113841:	83 ec 0c             	sub    $0xc,%esp
f0113844:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011384a:	50                   	push   %eax
f011384b:	e8 8c e6 fe ff       	call   f0101edc <execute_command>
f0113850:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f0113853:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113859:	bb 41 ac 12 f0       	mov    $0xf012ac41,%ebx
f011385e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113863:	89 c7                	mov    %eax,%edi
f0113865:	89 de                	mov    %ebx,%esi
f0113867:	89 d1                	mov    %edx,%ecx
f0113869:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011386b:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113871:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113876:	b0 00                	mov    $0x0,%al
f0113878:	89 d7                	mov    %edx,%edi
f011387a:	f3 aa                	rep stos %al,%es:(%edi)
f011387c:	83 ec 0c             	sub    $0xc,%esp
f011387f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113885:	50                   	push   %eax
f0113886:	e8 51 e6 fe ff       	call   f0101edc <execute_command>
f011388b:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f011388e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113894:	bb a5 ac 12 f0       	mov    $0xf012aca5,%ebx
f0113899:	ba 0f 00 00 00       	mov    $0xf,%edx
f011389e:	89 c7                	mov    %eax,%edi
f01138a0:	89 de                	mov    %ebx,%esi
f01138a2:	89 d1                	mov    %edx,%ecx
f01138a4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138a6:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01138ac:	b9 55 00 00 00       	mov    $0x55,%ecx
f01138b1:	b0 00                	mov    $0x0,%al
f01138b3:	89 d7                	mov    %edx,%edi
f01138b5:	f3 aa                	rep stos %al,%es:(%edi)
f01138b7:	83 ec 0c             	sub    $0xc,%esp
f01138ba:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01138c0:	50                   	push   %eax
f01138c1:	e8 16 e6 fe ff       	call   f0101edc <execute_command>
f01138c6:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f01138c9:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01138cf:	bb 09 ad 12 f0       	mov    $0xf012ad09,%ebx
f01138d4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01138d9:	89 c7                	mov    %eax,%edi
f01138db:	89 de                	mov    %ebx,%esi
f01138dd:	89 d1                	mov    %edx,%ecx
f01138df:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01138e1:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01138e7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01138ec:	b0 00                	mov    $0x0,%al
f01138ee:	89 d7                	mov    %edx,%edi
f01138f0:	f3 aa                	rep stos %al,%es:(%edi)
f01138f2:	83 ec 0c             	sub    $0xc,%esp
f01138f5:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01138fb:	50                   	push   %eax
f01138fc:	e8 db e5 fe ff       	call   f0101edc <execute_command>
f0113901:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113904:	e8 00 9e ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113909:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011390c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011390f:	89 d0                	mov    %edx,%eax
f0113911:	01 c0                	add    %eax,%eax
f0113913:	01 d0                	add    %edx,%eax
f0113915:	c1 e0 02             	shl    $0x2,%eax
f0113918:	50                   	push   %eax
f0113919:	68 00 00 90 00       	push   $0x900000
f011391e:	68 00 00 80 00       	push   $0x800000
f0113923:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113926:	e8 c0 5a ff ff       	call   f01093eb <copy_paste_chunk>
f011392b:	83 c4 10             	add    $0x10,%esp
f011392e:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113934:	e8 d0 9d ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113939:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011393c:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113943:	75 0b                	jne    f0113950 <test_copy_paste_chunk+0xdc2>
f0113945:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113948:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011394b:	83 f8 03             	cmp    $0x3,%eax
f011394e:	74 2e                	je     f011397e <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113950:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113953:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113956:	83 ec 0c             	sub    $0xc,%esp
f0113959:	50                   	push   %eax
f011395a:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113960:	68 64 a3 12 f0       	push   $0xf012a364
f0113965:	68 95 03 00 00       	push   $0x395
f011396a:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011396f:	e8 43 cb fe ff       	call   f01004b7 <_warn>
f0113974:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113977:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011397e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113982:	74 04                	je     f0113988 <test_copy_paste_chunk+0xdfa>
f0113984:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113988:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f011398f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113996:	83 ec 08             	sub    $0x8,%esp
f0113999:	6a 01                	push   $0x1
f011399b:	6a 07                	push   $0x7
f011399d:	6a 07                	push   $0x7
f011399f:	6a 07                	push   $0x7
f01139a1:	6a 07                	push   $0x7
f01139a3:	6a 01                	push   $0x1
f01139a5:	68 00 30 00 00       	push   $0x3000
f01139aa:	68 00 00 90 00       	push   $0x900000
f01139af:	68 00 00 80 00       	push   $0x800000
f01139b4:	ff 75 d4             	pushl  -0x2c(%ebp)
f01139b7:	e8 71 31 00 00       	call   f0116b2d <CCP>
f01139bc:	83 c4 30             	add    $0x30,%esp
f01139bf:	83 f8 01             	cmp    $0x1,%eax
f01139c2:	74 28                	je     f01139ec <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f01139c4:	83 ec 04             	sub    $0x4,%esp
f01139c7:	68 04 a4 12 f0       	push   $0xf012a404
f01139cc:	68 9e 03 00 00       	push   $0x39e
f01139d1:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01139d6:	e8 dc ca fe ff       	call   f01004b7 <_warn>
f01139db:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01139de:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f01139e5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f01139ec:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01139f0:	74 04                	je     f01139f6 <test_copy_paste_chunk+0xe68>
f01139f2:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01139f6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f01139fd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113a01:	0f 84 9e 00 00 00    	je     f0113aa5 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0113a07:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f0113a0e:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f0113a15:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f0113a1c:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f0113a23:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f0113a2a:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f0113a31:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a34:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f0113a37:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a3a:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f0113a3d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113a40:	8a 00                	mov    (%eax),%al
f0113a42:	3c 61                	cmp    $0x61,%al
f0113a44:	75 2d                	jne    f0113a73 <test_copy_paste_chunk+0xee5>
f0113a46:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113a49:	8a 00                	mov    (%eax),%al
f0113a4b:	3c 61                	cmp    $0x61,%al
f0113a4d:	75 24                	jne    f0113a73 <test_copy_paste_chunk+0xee5>
f0113a4f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113a52:	8a 00                	mov    (%eax),%al
f0113a54:	3c 79                	cmp    $0x79,%al
f0113a56:	75 1b                	jne    f0113a73 <test_copy_paste_chunk+0xee5>
f0113a58:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113a5b:	8a 00                	mov    (%eax),%al
f0113a5d:	3c 62                	cmp    $0x62,%al
f0113a5f:	75 12                	jne    f0113a73 <test_copy_paste_chunk+0xee5>
f0113a61:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113a64:	8a 00                	mov    (%eax),%al
f0113a66:	3c 63                	cmp    $0x63,%al
f0113a68:	75 09                	jne    f0113a73 <test_copy_paste_chunk+0xee5>
f0113a6a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113a6d:	8a 00                	mov    (%eax),%al
f0113a6f:	3c 7a                	cmp    $0x7a,%al
f0113a71:	74 21                	je     f0113a94 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113a73:	83 ec 04             	sub    $0x4,%esp
f0113a76:	68 b8 a2 12 f0       	push   $0xf012a2b8
f0113a7b:	68 b0 03 00 00       	push   $0x3b0
f0113a80:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113a85:	e8 2d ca fe ff       	call   f01004b7 <_warn>
f0113a8a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113a8d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0113a94:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113a98:	74 04                	je     f0113a9e <test_copy_paste_chunk+0xf10>
f0113a9a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f0113a9e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113aa5:	e8 5f 9c ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113aaa:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f0113aad:	6a 00                	push   $0x0
f0113aaf:	6a 02                	push   $0x2
f0113ab1:	68 00 10 90 00       	push   $0x901000
f0113ab6:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113ab9:	e8 b1 2b 00 00       	call   f011666f <SB>
f0113abe:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0113ac1:	6a 00                	push   $0x0
f0113ac3:	6a 02                	push   $0x2
f0113ac5:	68 00 20 90 00       	push   $0x902000
f0113aca:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113acd:	e8 9d 2b 00 00       	call   f011666f <SB>
f0113ad2:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0113ad5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113ad8:	c1 e0 03             	shl    $0x3,%eax
f0113adb:	50                   	push   %eax
f0113adc:	68 00 f0 bf 00       	push   $0xbff000
f0113ae1:	68 00 10 90 00       	push   $0x901000
f0113ae6:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113ae9:	e8 fd 58 ff ff       	call   f01093eb <copy_paste_chunk>
f0113aee:	83 c4 10             	add    $0x10,%esp
f0113af1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113af7:	e8 0d 9c ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113afc:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f0113aff:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0113b06:	75 0b                	jne    f0113b13 <test_copy_paste_chunk+0xf85>
f0113b08:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b0b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b0e:	83 f8 03             	cmp    $0x3,%eax
f0113b11:	74 2e                	je     f0113b41 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113b13:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113b16:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113b19:	83 ec 0c             	sub    $0xc,%esp
f0113b1c:	50                   	push   %eax
f0113b1d:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f0113b23:	68 64 a3 12 f0       	push   $0xf012a364
f0113b28:	68 c0 03 00 00       	push   $0x3c0
f0113b2d:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113b32:	e8 80 c9 fe ff       	call   f01004b7 <_warn>
f0113b37:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113b3a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113b41:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113b45:	74 04                	je     f0113b4b <test_copy_paste_chunk+0xfbd>
f0113b47:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113b4b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f0113b52:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f0113b59:	83 ec 08             	sub    $0x8,%esp
f0113b5c:	6a 01                	push   $0x1
f0113b5e:	6a 07                	push   $0x7
f0113b60:	6a 03                	push   $0x3
f0113b62:	6a 07                	push   $0x7
f0113b64:	6a 03                	push   $0x3
f0113b66:	6a 01                	push   $0x1
f0113b68:	68 00 20 00 00       	push   $0x2000
f0113b6d:	68 00 f0 bf 00       	push   $0xbff000
f0113b72:	68 00 10 90 00       	push   $0x901000
f0113b77:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113b7a:	e8 ae 2f 00 00       	call   f0116b2d <CCP>
f0113b7f:	83 c4 30             	add    $0x30,%esp
f0113b82:	83 f8 01             	cmp    $0x1,%eax
f0113b85:	74 28                	je     f0113baf <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113b87:	83 ec 04             	sub    $0x4,%esp
f0113b8a:	68 04 a4 12 f0       	push   $0xf012a404
f0113b8f:	68 c9 03 00 00       	push   $0x3c9
f0113b94:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113b99:	e8 19 c9 fe ff       	call   f01004b7 <_warn>
f0113b9e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113ba1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0113ba8:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f0113baf:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113bb3:	74 04                	je     f0113bb9 <test_copy_paste_chunk+0x102b>
f0113bb5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113bb9:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0113bc0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0113bc4:	74 72                	je     f0113c38 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0113bc6:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f0113bcd:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0113bd4:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f0113bdb:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0113be2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113be5:	8a 00                	mov    (%eax),%al
f0113be7:	3c 62                	cmp    $0x62,%al
f0113be9:	75 1b                	jne    f0113c06 <test_copy_paste_chunk+0x1078>
f0113beb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113bee:	8a 00                	mov    (%eax),%al
f0113bf0:	3c 62                	cmp    $0x62,%al
f0113bf2:	75 12                	jne    f0113c06 <test_copy_paste_chunk+0x1078>
f0113bf4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113bf7:	8a 00                	mov    (%eax),%al
f0113bf9:	3c 7a                	cmp    $0x7a,%al
f0113bfb:	75 09                	jne    f0113c06 <test_copy_paste_chunk+0x1078>
f0113bfd:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113c00:	8a 00                	mov    (%eax),%al
f0113c02:	3c 7a                	cmp    $0x7a,%al
f0113c04:	74 21                	je     f0113c27 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113c06:	83 ec 04             	sub    $0x4,%esp
f0113c09:	68 b8 a2 12 f0       	push   $0xf012a2b8
f0113c0e:	68 d5 03 00 00       	push   $0x3d5
f0113c13:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113c18:	e8 9a c8 fe ff       	call   f01004b7 <_warn>
f0113c1d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0113c20:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0113c27:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113c2b:	74 04                	je     f0113c31 <test_copy_paste_chunk+0x10a3>
f0113c2d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0113c31:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0113c38:	83 ec 0c             	sub    $0xc,%esp
f0113c3b:	68 b2 a4 12 f0       	push   $0xf012a4b2
f0113c40:	e8 27 d3 fe ff       	call   f0100f6c <cprintf>
f0113c45:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f0113c48:	83 ec 08             	sub    $0x8,%esp
f0113c4b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0113c4e:	68 c4 a4 12 f0       	push   $0xf012a4c4
f0113c53:	e8 14 d3 fe ff       	call   f0100f6c <cprintf>
f0113c58:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0113c5b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0113c5f:	75 10                	jne    f0113c71 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f0113c61:	83 ec 0c             	sub    $0xc,%esp
f0113c64:	68 f8 a4 12 f0       	push   $0xf012a4f8
f0113c69:	e8 fe d2 fe ff       	call   f0100f6c <cprintf>
f0113c6e:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113c71:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0113c76:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0113c79:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113c7c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113c7f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113c84:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113c87:	5b                   	pop    %ebx
f0113c88:	5e                   	pop    %esi
f0113c89:	5f                   	pop    %edi
f0113c8a:	5d                   	pop    %ebp
f0113c8b:	c3                   	ret    

f0113c8c <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f0113c8c:	55                   	push   %ebp
f0113c8d:	89 e5                	mov    %esp,%ebp
f0113c8f:	57                   	push   %edi
f0113c90:	56                   	push   %esi
f0113c91:	53                   	push   %ebx
f0113c92:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0113c98:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113c9e:	bb c4 a1 12 f0       	mov    $0xf012a1c4,%ebx
f0113ca3:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ca8:	89 c7                	mov    %eax,%edi
f0113caa:	89 de                	mov    %ebx,%esi
f0113cac:	89 d1                	mov    %edx,%ecx
f0113cae:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113cb0:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0113cb6:	b9 23 00 00 00       	mov    $0x23,%ecx
f0113cbb:	b0 00                	mov    $0x0,%al
f0113cbd:	89 d7                	mov    %edx,%edi
f0113cbf:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113cc1:	6a 00                	push   $0x0
f0113cc3:	6a 0a                	push   $0xa
f0113cc5:	6a 14                	push   $0x14
f0113cc7:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f0113ccd:	50                   	push   %eax
f0113cce:	e8 9e 5a ff ff       	call   f0109771 <env_create>
f0113cd3:	83 c4 10             	add    $0x10,%esp
f0113cd6:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0113cd9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113cdc:	8b 40 64             	mov    0x64(%eax),%eax
f0113cdf:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0113ce2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0113ce5:	8b 40 68             	mov    0x68(%eax),%eax
f0113ce8:	89 45 80             	mov    %eax,-0x80(%ebp)
f0113ceb:	8b 45 80             	mov    -0x80(%ebp),%eax
f0113cee:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0113cf1:	83 ec 0c             	sub    $0xc,%esp
f0113cf4:	ff 75 cc             	pushl  -0x34(%ebp)
f0113cf7:	e8 fd 2d 00 00       	call   f0116af9 <ClearUserSpace>
f0113cfc:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0113cff:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0113d06:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0113d0d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f0113d14:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f0113d18:	83 ec 0c             	sub    $0xc,%esp
f0113d1b:	68 70 ad 12 f0       	push   $0xf012ad70
f0113d20:	e8 47 d2 fe ff       	call   f0100f6c <cprintf>
f0113d25:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f0113d28:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f0113d2f:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f0113d36:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113d39:	8a 00                	mov    (%eax),%al
f0113d3b:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f0113d41:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113d44:	8a 00                	mov    (%eax),%al
f0113d46:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113d4c:	e8 b8 99 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113d51:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f0113d54:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d57:	89 d0                	mov    %edx,%eax
f0113d59:	01 c0                	add    %eax,%eax
f0113d5b:	01 d0                	add    %edx,%eax
f0113d5d:	01 c0                	add    %eax,%eax
f0113d5f:	83 ec 0c             	sub    $0xc,%esp
f0113d62:	6a 02                	push   $0x2
f0113d64:	50                   	push   %eax
f0113d65:	68 00 40 10 f0       	push   $0xf0104000
f0113d6a:	68 00 00 10 f0       	push   $0xf0100000
f0113d6f:	ff 75 cc             	pushl  -0x34(%ebp)
f0113d72:	e8 8e 56 ff ff       	call   f0109405 <share_chunk>
f0113d77:	83 c4 20             	add    $0x20,%esp
f0113d7a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d7d:	e8 87 99 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113d82:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0113d85:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0113d89:	75 08                	jne    f0113d93 <test_share_chunk+0x107>
f0113d8b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d8e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0113d91:	74 28                	je     f0113dbb <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0113d93:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113d96:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113d99:	83 ec 0c             	sub    $0xc,%esp
f0113d9c:	50                   	push   %eax
f0113d9d:	ff 75 b0             	pushl  -0x50(%ebp)
f0113da0:	68 9c ad 12 f0       	push   $0xf012ad9c
f0113da5:	68 11 04 00 00       	push   $0x411
f0113daa:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113daf:	e8 03 c7 fe ff       	call   f01004b7 <_warn>
f0113db4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113db7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113dbb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113dbf:	74 04                	je     f0113dc5 <test_share_chunk+0x139>
f0113dc1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113dc5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0113dc9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113dcc:	c1 e0 03             	shl    $0x3,%eax
f0113dcf:	83 ec 08             	sub    $0x8,%esp
f0113dd2:	68 fd 00 00 00       	push   $0xfd
f0113dd7:	6a 07                	push   $0x7
f0113dd9:	6a 03                	push   $0x3
f0113ddb:	6a 07                	push   $0x7
f0113ddd:	6a 03                	push   $0x3
f0113ddf:	6a 01                	push   $0x1
f0113de1:	50                   	push   %eax
f0113de2:	68 00 40 10 f0       	push   $0xf0104000
f0113de7:	68 00 00 10 f0       	push   $0xf0100000
f0113dec:	ff 75 cc             	pushl  -0x34(%ebp)
f0113def:	e8 39 2d 00 00       	call   f0116b2d <CCP>
f0113df4:	83 c4 30             	add    $0x30,%esp
f0113df7:	85 c0                	test   %eax,%eax
f0113df9:	75 1e                	jne    f0113e19 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113dfb:	83 ec 04             	sub    $0x4,%esp
f0113dfe:	68 f8 ad 12 f0       	push   $0xf012adf8
f0113e03:	68 19 04 00 00       	push   $0x419
f0113e08:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113e0d:	e8 a5 c6 fe ff       	call   f01004b7 <_warn>
f0113e12:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e15:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113e19:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e1d:	74 04                	je     f0113e23 <test_share_chunk+0x197>
f0113e1f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f0113e23:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e26:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f0113e29:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e2c:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f0113e2f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e32:	8a 00                	mov    (%eax),%al
f0113e34:	3c 41                	cmp    $0x41,%al
f0113e36:	75 09                	jne    f0113e41 <test_share_chunk+0x1b5>
f0113e38:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e3b:	8a 00                	mov    (%eax),%al
f0113e3d:	3c 42                	cmp    $0x42,%al
f0113e3f:	74 1e                	je     f0113e5f <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0113e41:	83 ec 04             	sub    $0x4,%esp
f0113e44:	68 40 ae 12 f0       	push   $0xf012ae40
f0113e49:	68 23 04 00 00       	push   $0x423
f0113e4e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113e53:	e8 5f c6 fe ff       	call   f01004b7 <_warn>
f0113e58:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e5b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0113e5f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113e63:	74 04                	je     f0113e69 <test_share_chunk+0x1dd>
f0113e65:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113e69:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f0113e6d:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0113e73:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e76:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0113e78:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f0113e7e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e81:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0113e83:	83 ec 0c             	sub    $0xc,%esp
f0113e86:	68 75 ae 12 f0       	push   $0xf012ae75
f0113e8b:	e8 dc d0 fe ff       	call   f0100f6c <cprintf>
f0113e90:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0113e93:	83 ec 0c             	sub    $0xc,%esp
f0113e96:	68 84 ae 12 f0       	push   $0xf012ae84
f0113e9b:	e8 cc d0 fe ff       	call   f0100f6c <cprintf>
f0113ea0:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113ea3:	e8 61 98 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113ea8:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0113eab:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113eae:	c1 e0 05             	shl    $0x5,%eax
f0113eb1:	83 ec 0c             	sub    $0xc,%esp
f0113eb4:	68 02 0e 00 00       	push   $0xe02
f0113eb9:	50                   	push   %eax
f0113eba:	68 00 00 00 40       	push   $0x40000000
f0113ebf:	68 00 00 00 f0       	push   $0xf0000000
f0113ec4:	ff 75 cc             	pushl  -0x34(%ebp)
f0113ec7:	e8 39 55 ff ff       	call   f0109405 <share_chunk>
f0113ecc:	83 c4 20             	add    $0x20,%esp
f0113ecf:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113ed2:	e8 32 98 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0113ed7:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f0113eda:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f0113ede:	75 1f                	jne    f0113eff <test_share_chunk+0x273>
f0113ee0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113ee3:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113ee6:	89 c1                	mov    %eax,%ecx
f0113ee8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113eeb:	c1 e0 05             	shl    $0x5,%eax
f0113eee:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0113ef1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0113ef8:	99                   	cltd   
f0113ef9:	f7 fb                	idiv   %ebx
f0113efb:	39 c1                	cmp    %eax,%ecx
f0113efd:	74 28                	je     f0113f27 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113eff:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113f02:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0113f05:	83 ec 0c             	sub    $0xc,%esp
f0113f08:	50                   	push   %eax
f0113f09:	ff 75 a8             	pushl  -0x58(%ebp)
f0113f0c:	68 c0 ae 12 f0       	push   $0xf012aec0
f0113f11:	68 3b 04 00 00       	push   $0x43b
f0113f16:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113f1b:	e8 97 c5 fe ff       	call   f01004b7 <_warn>
f0113f20:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f23:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113f27:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113f2b:	74 04                	je     f0113f31 <test_share_chunk+0x2a5>
f0113f2d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f31:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0113f35:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113f3c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113f3f:	c1 e0 05             	shl    $0x5,%eax
f0113f42:	83 ec 08             	sub    $0x8,%esp
f0113f45:	6a 02                	push   $0x2
f0113f47:	6a 07                	push   $0x7
f0113f49:	6a 03                	push   $0x3
f0113f4b:	68 07 0e 00 00       	push   $0xe07
f0113f50:	68 03 0e 00 00       	push   $0xe03
f0113f55:	6a ff                	push   $0xffffffff
f0113f57:	50                   	push   %eax
f0113f58:	68 00 00 00 40       	push   $0x40000000
f0113f5d:	68 00 00 00 f0       	push   $0xf0000000
f0113f62:	ff 75 cc             	pushl  -0x34(%ebp)
f0113f65:	e8 c3 2b 00 00       	call   f0116b2d <CCP>
f0113f6a:	83 c4 30             	add    $0x30,%esp
f0113f6d:	85 c0                	test   %eax,%eax
f0113f6f:	75 25                	jne    f0113f96 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113f71:	83 ec 04             	sub    $0x4,%esp
f0113f74:	68 f8 ad 12 f0       	push   $0xf012adf8
f0113f79:	68 44 04 00 00       	push   $0x444
f0113f7e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113f83:	e8 2f c5 fe ff       	call   f01004b7 <_warn>
f0113f88:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f8b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0113f8f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0113f96:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113f99:	89 d0                	mov    %edx,%eax
f0113f9b:	01 c0                	add    %eax,%eax
f0113f9d:	01 d0                	add    %edx,%eax
f0113f9f:	c1 e0 02             	shl    $0x2,%eax
f0113fa2:	83 ec 08             	sub    $0x8,%esp
f0113fa5:	6a 02                	push   $0x2
f0113fa7:	6a 07                	push   $0x7
f0113fa9:	6a 03                	push   $0x3
f0113fab:	68 07 0e 00 00       	push   $0xe07
f0113fb0:	68 03 0e 00 00       	push   $0xe03
f0113fb5:	6a 02                	push   $0x2
f0113fb7:	50                   	push   %eax
f0113fb8:	68 00 00 00 40       	push   $0x40000000
f0113fbd:	68 00 00 00 f0       	push   $0xf0000000
f0113fc2:	ff 75 cc             	pushl  -0x34(%ebp)
f0113fc5:	e8 63 2b 00 00       	call   f0116b2d <CCP>
f0113fca:	83 c4 30             	add    $0x30,%esp
f0113fcd:	85 c0                	test   %eax,%eax
f0113fcf:	75 1e                	jne    f0113fef <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0113fd1:	83 ec 04             	sub    $0x4,%esp
f0113fd4:	68 f8 ad 12 f0       	push   $0xf012adf8
f0113fd9:	68 4b 04 00 00       	push   $0x44b
f0113fde:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0113fe3:	e8 cf c4 fe ff       	call   f01004b7 <_warn>
f0113fe8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113feb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0113fef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0113ff3:	74 04                	je     f0113ff9 <test_share_chunk+0x36d>
f0113ff5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113ff9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f0113ffd:	b8 a8 79 57 f0       	mov    $0xf05779a8,%eax
f0114002:	05 00 00 00 10       	add    $0x10000000,%eax
f0114007:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011400a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011400d:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f0114012:	83 ec 08             	sub    $0x8,%esp
f0114015:	6a 02                	push   $0x2
f0114017:	6a 07                	push   $0x7
f0114019:	6a 03                	push   $0x3
f011401b:	68 07 0e 00 00       	push   $0xe07
f0114020:	68 03 0e 00 00       	push   $0xe03
f0114025:	6a 02                	push   $0x2
f0114027:	50                   	push   %eax
f0114028:	68 00 00 0a 40       	push   $0x400a0000
f011402d:	68 00 00 0a f0       	push   $0xf00a0000
f0114032:	ff 75 cc             	pushl  -0x34(%ebp)
f0114035:	e8 f3 2a 00 00       	call   f0116b2d <CCP>
f011403a:	83 c4 30             	add    $0x30,%esp
f011403d:	85 c0                	test   %eax,%eax
f011403f:	75 1e                	jne    f011405f <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114041:	83 ec 04             	sub    $0x4,%esp
f0114044:	68 f8 ad 12 f0       	push   $0xf012adf8
f0114049:	68 55 04 00 00       	push   $0x455
f011404e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114053:	e8 5f c4 fe ff       	call   f01004b7 <_warn>
f0114058:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011405b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011405f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114063:	74 04                	je     f0114069 <test_share_chunk+0x3dd>
f0114065:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114069:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f011406d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114071:	0f 84 a4 00 00 00    	je     f011411b <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114077:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f011407e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114081:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114084:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011408b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011408e:	8a 00                	mov    (%eax),%al
f0114090:	3c 41                	cmp    $0x41,%al
f0114092:	75 09                	jne    f011409d <test_share_chunk+0x411>
f0114094:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114097:	8a 00                	mov    (%eax),%al
f0114099:	3c 41                	cmp    $0x41,%al
f011409b:	74 1e                	je     f01140bb <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011409d:	83 ec 04             	sub    $0x4,%esp
f01140a0:	68 40 ae 12 f0       	push   $0xf012ae40
f01140a5:	68 62 04 00 00       	push   $0x462
f01140aa:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01140af:	e8 03 c4 fe ff       	call   f01004b7 <_warn>
f01140b4:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01140b7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01140bb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01140bf:	74 04                	je     f01140c5 <test_share_chunk+0x439>
f01140c1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01140c5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f01140c9:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f01140d0:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140d3:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f01140d6:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f01140dd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01140e0:	8a 00                	mov    (%eax),%al
f01140e2:	3c 43                	cmp    $0x43,%al
f01140e4:	75 09                	jne    f01140ef <test_share_chunk+0x463>
f01140e6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01140e9:	8a 00                	mov    (%eax),%al
f01140eb:	3c 43                	cmp    $0x43,%al
f01140ed:	74 1e                	je     f011410d <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01140ef:	83 ec 04             	sub    $0x4,%esp
f01140f2:	68 40 ae 12 f0       	push   $0xf012ae40
f01140f7:	68 6d 04 00 00       	push   $0x46d
f01140fc:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114101:	e8 b1 c3 fe ff       	call   f01004b7 <_warn>
f0114106:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114109:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011410d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114111:	74 04                	je     f0114117 <test_share_chunk+0x48b>
f0114113:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114117:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f011411b:	83 ec 0c             	sub    $0xc,%esp
f011411e:	68 4f a4 12 f0       	push   $0xf012a44f
f0114123:	e8 44 ce fe ff       	call   f0100f6c <cprintf>
f0114128:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f011412b:	83 ec 0c             	sub    $0xc,%esp
f011412e:	68 10 af 12 f0       	push   $0xf012af10
f0114133:	e8 34 ce fe ff       	call   f0100f6c <cprintf>
f0114138:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011413b:	e8 c9 95 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114140:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f0114143:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114146:	89 d0                	mov    %edx,%eax
f0114148:	c1 e0 03             	shl    $0x3,%eax
f011414b:	01 d0                	add    %edx,%eax
f011414d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0114154:	01 d0                	add    %edx,%eax
f0114156:	c1 e0 03             	shl    $0x3,%eax
f0114159:	83 ec 0c             	sub    $0xc,%esp
f011415c:	6a 06                	push   $0x6
f011415e:	50                   	push   %eax
f011415f:	6a 00                	push   $0x0
f0114161:	68 00 00 00 40       	push   $0x40000000
f0114166:	ff 75 cc             	pushl  -0x34(%ebp)
f0114169:	e8 97 52 ff ff       	call   f0109405 <share_chunk>
f011416e:	83 c4 20             	add    $0x20,%esp
f0114171:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114174:	e8 90 95 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114179:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f011417c:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114180:	75 0b                	jne    f011418d <test_share_chunk+0x501>
f0114182:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114185:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114188:	83 f8 01             	cmp    $0x1,%eax
f011418b:	74 28                	je     f01141b5 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011418d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114190:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114193:	83 ec 0c             	sub    $0xc,%esp
f0114196:	50                   	push   %eax
f0114197:	ff 75 a0             	pushl  -0x60(%ebp)
f011419a:	68 c0 ae 12 f0       	push   $0xf012aec0
f011419f:	68 83 04 00 00       	push   $0x483
f01141a4:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01141a9:	e8 09 c3 fe ff       	call   f01004b7 <_warn>
f01141ae:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01141b1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01141b5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01141b9:	74 04                	je     f01141bf <test_share_chunk+0x533>
f01141bb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01141bf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01141c3:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01141ca:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01141cd:	05 00 80 02 00       	add    $0x28000,%eax
f01141d2:	c1 e0 02             	shl    $0x2,%eax
f01141d5:	83 ec 08             	sub    $0x8,%esp
f01141d8:	6a 02                	push   $0x2
f01141da:	6a 07                	push   $0x7
f01141dc:	6a 03                	push   $0x3
f01141de:	6a 07                	push   $0x7
f01141e0:	6a 07                	push   $0x7
f01141e2:	6a ff                	push   $0xffffffff
f01141e4:	50                   	push   %eax
f01141e5:	6a 00                	push   $0x0
f01141e7:	68 00 00 00 40       	push   $0x40000000
f01141ec:	ff 75 cc             	pushl  -0x34(%ebp)
f01141ef:	e8 39 29 00 00       	call   f0116b2d <CCP>
f01141f4:	83 c4 30             	add    $0x30,%esp
f01141f7:	85 c0                	test   %eax,%eax
f01141f9:	75 25                	jne    f0114220 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01141fb:	83 ec 04             	sub    $0x4,%esp
f01141fe:	68 f8 ad 12 f0       	push   $0xf012adf8
f0114203:	68 8c 04 00 00       	push   $0x48c
f0114208:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011420d:	e8 a5 c2 fe ff       	call   f01004b7 <_warn>
f0114212:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114215:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114219:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114220:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114223:	89 d0                	mov    %edx,%eax
f0114225:	01 c0                	add    %eax,%eax
f0114227:	01 d0                	add    %edx,%eax
f0114229:	c1 e0 02             	shl    $0x2,%eax
f011422c:	83 ec 08             	sub    $0x8,%esp
f011422f:	6a 02                	push   $0x2
f0114231:	6a 07                	push   $0x7
f0114233:	6a 03                	push   $0x3
f0114235:	6a 07                	push   $0x7
f0114237:	6a 07                	push   $0x7
f0114239:	6a 03                	push   $0x3
f011423b:	50                   	push   %eax
f011423c:	6a 00                	push   $0x0
f011423e:	68 00 00 00 40       	push   $0x40000000
f0114243:	ff 75 cc             	pushl  -0x34(%ebp)
f0114246:	e8 e2 28 00 00       	call   f0116b2d <CCP>
f011424b:	83 c4 30             	add    $0x30,%esp
f011424e:	85 c0                	test   %eax,%eax
f0114250:	75 1e                	jne    f0114270 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114252:	83 ec 04             	sub    $0x4,%esp
f0114255:	68 f8 ad 12 f0       	push   $0xf012adf8
f011425a:	68 93 04 00 00       	push   $0x493
f011425f:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114264:	e8 4e c2 fe ff       	call   f01004b7 <_warn>
f0114269:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011426c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114270:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114274:	74 04                	je     f011427a <test_share_chunk+0x5ee>
f0114276:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011427a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f011427e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114281:	89 d0                	mov    %edx,%eax
f0114283:	01 c0                	add    %eax,%eax
f0114285:	01 d0                	add    %edx,%eax
f0114287:	c1 e0 02             	shl    $0x2,%eax
f011428a:	f7 d8                	neg    %eax
f011428c:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114291:	83 ec 08             	sub    $0x8,%esp
f0114294:	6a 02                	push   $0x2
f0114296:	6a 07                	push   $0x7
f0114298:	6a 03                	push   $0x3
f011429a:	6a 07                	push   $0x7
f011429c:	6a 07                	push   $0x7
f011429e:	6a 02                	push   $0x2
f01142a0:	50                   	push   %eax
f01142a1:	68 00 30 00 00       	push   $0x3000
f01142a6:	68 00 30 00 40       	push   $0x40003000
f01142ab:	ff 75 cc             	pushl  -0x34(%ebp)
f01142ae:	e8 7a 28 00 00       	call   f0116b2d <CCP>
f01142b3:	83 c4 30             	add    $0x30,%esp
f01142b6:	85 c0                	test   %eax,%eax
f01142b8:	75 1e                	jne    f01142d8 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01142ba:	83 ec 04             	sub    $0x4,%esp
f01142bd:	68 f8 ad 12 f0       	push   $0xf012adf8
f01142c2:	68 9b 04 00 00       	push   $0x49b
f01142c7:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01142cc:	e8 e6 c1 fe ff       	call   f01004b7 <_warn>
f01142d1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01142d4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01142d8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01142dc:	74 04                	je     f01142e2 <test_share_chunk+0x656>
f01142de:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01142e2:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f01142e6:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01142e9:	c1 e0 02             	shl    $0x2,%eax
f01142ec:	83 ec 08             	sub    $0x8,%esp
f01142ef:	6a 02                	push   $0x2
f01142f1:	6a 07                	push   $0x7
f01142f3:	6a 03                	push   $0x3
f01142f5:	6a 07                	push   $0x7
f01142f7:	6a 07                	push   $0x7
f01142f9:	6a 03                	push   $0x3
f01142fb:	50                   	push   %eax
f01142fc:	68 00 00 0a 00       	push   $0xa0000
f0114301:	68 00 00 0a 40       	push   $0x400a0000
f0114306:	ff 75 cc             	pushl  -0x34(%ebp)
f0114309:	e8 1f 28 00 00       	call   f0116b2d <CCP>
f011430e:	83 c4 30             	add    $0x30,%esp
f0114311:	85 c0                	test   %eax,%eax
f0114313:	75 1e                	jne    f0114333 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114315:	83 ec 04             	sub    $0x4,%esp
f0114318:	68 f8 ad 12 f0       	push   $0xf012adf8
f011431d:	68 a3 04 00 00       	push   $0x4a3
f0114322:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114327:	e8 8b c1 fe ff       	call   f01004b7 <_warn>
f011432c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011432f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114333:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114337:	74 04                	je     f011433d <test_share_chunk+0x6b1>
f0114339:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011433d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114341:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114345:	0f 84 92 00 00 00    	je     f01143dd <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f011434b:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114352:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114359:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114360:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114367:	8b 45 98             	mov    -0x68(%ebp),%eax
f011436a:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f011436d:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114374:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011437b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011437e:	8a 00                	mov    (%eax),%al
f0114380:	3c 41                	cmp    $0x41,%al
f0114382:	75 2d                	jne    f01143b1 <test_share_chunk+0x725>
f0114384:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114387:	8a 00                	mov    (%eax),%al
f0114389:	3c 41                	cmp    $0x41,%al
f011438b:	75 24                	jne    f01143b1 <test_share_chunk+0x725>
f011438d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114390:	8a 00                	mov    (%eax),%al
f0114392:	3c 41                	cmp    $0x41,%al
f0114394:	75 1b                	jne    f01143b1 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114396:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114399:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f011439b:	3c 44                	cmp    $0x44,%al
f011439d:	75 12                	jne    f01143b1 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f011439f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f01143a2:	8a 00                	mov    (%eax),%al
f01143a4:	3c 44                	cmp    $0x44,%al
f01143a6:	75 09                	jne    f01143b1 <test_share_chunk+0x725>
f01143a8:	8b 45 90             	mov    -0x70(%ebp),%eax
f01143ab:	8a 00                	mov    (%eax),%al
f01143ad:	3c 44                	cmp    $0x44,%al
f01143af:	74 1e                	je     f01143cf <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01143b1:	83 ec 04             	sub    $0x4,%esp
f01143b4:	68 40 ae 12 f0       	push   $0xf012ae40
f01143b9:	68 b5 04 00 00       	push   $0x4b5
f01143be:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01143c3:	e8 ef c0 fe ff       	call   f01004b7 <_warn>
f01143c8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01143cb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f01143cf:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01143d3:	74 04                	je     f01143d9 <test_share_chunk+0x74d>
f01143d5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01143d9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01143dd:	83 ec 0c             	sub    $0xc,%esp
f01143e0:	68 b2 a4 12 f0       	push   $0xf012a4b2
f01143e5:	e8 82 cb fe ff       	call   f0100f6c <cprintf>
f01143ea:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f01143ed:	83 ec 0c             	sub    $0xc,%esp
f01143f0:	68 4c af 12 f0       	push   $0xf012af4c
f01143f5:	e8 72 cb fe ff       	call   f0100f6c <cprintf>
f01143fa:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01143fd:	e8 07 93 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114402:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114405:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114408:	89 d0                	mov    %edx,%eax
f011440a:	01 c0                	add    %eax,%eax
f011440c:	01 d0                	add    %edx,%eax
f011440e:	01 c0                	add    %eax,%eax
f0114410:	01 d0                	add    %edx,%eax
f0114412:	83 ec 0c             	sub    $0xc,%esp
f0114415:	6a 04                	push   $0x4
f0114417:	50                   	push   %eax
f0114418:	68 00 fc 3f 00       	push   $0x3ffc00
f011441d:	68 00 fc 09 00       	push   $0x9fc00
f0114422:	ff 75 cc             	pushl  -0x34(%ebp)
f0114425:	e8 db 4f ff ff       	call   f0109405 <share_chunk>
f011442a:	83 c4 20             	add    $0x20,%esp
f011442d:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114430:	e8 d4 92 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114435:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114438:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f011443c:	75 0b                	jne    f0114449 <test_share_chunk+0x7bd>
f011443e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114441:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114444:	83 f8 01             	cmp    $0x1,%eax
f0114447:	74 28                	je     f0114471 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114449:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011444c:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011444f:	83 ec 0c             	sub    $0xc,%esp
f0114452:	50                   	push   %eax
f0114453:	ff 75 8c             	pushl  -0x74(%ebp)
f0114456:	68 c0 ae 12 f0       	push   $0xf012aec0
f011445b:	68 cb 04 00 00       	push   $0x4cb
f0114460:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114465:	e8 4d c0 fe ff       	call   f01004b7 <_warn>
f011446a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011446d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114471:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114475:	74 04                	je     f011447b <test_share_chunk+0x7ef>
f0114477:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011447b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f011447f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114486:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114489:	89 d0                	mov    %edx,%eax
f011448b:	01 c0                	add    %eax,%eax
f011448d:	01 d0                	add    %edx,%eax
f011448f:	c1 e0 02             	shl    $0x2,%eax
f0114492:	83 ec 08             	sub    $0x8,%esp
f0114495:	6a 02                	push   $0x2
f0114497:	6a 07                	push   $0x7
f0114499:	6a 07                	push   $0x7
f011449b:	6a 07                	push   $0x7
f011449d:	6a 05                	push   $0x5
f011449f:	6a ff                	push   $0xffffffff
f01144a1:	50                   	push   %eax
f01144a2:	68 00 f0 3f 00       	push   $0x3ff000
f01144a7:	68 00 f0 09 00       	push   $0x9f000
f01144ac:	ff 75 cc             	pushl  -0x34(%ebp)
f01144af:	e8 79 26 00 00       	call   f0116b2d <CCP>
f01144b4:	83 c4 30             	add    $0x30,%esp
f01144b7:	85 c0                	test   %eax,%eax
f01144b9:	75 25                	jne    f01144e0 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01144bb:	83 ec 04             	sub    $0x4,%esp
f01144be:	68 f8 ad 12 f0       	push   $0xf012adf8
f01144c3:	68 d4 04 00 00       	push   $0x4d4
f01144c8:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01144cd:	e8 e5 bf fe ff       	call   f01004b7 <_warn>
f01144d2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01144d5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f01144d9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f01144e0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01144e4:	74 04                	je     f01144ea <test_share_chunk+0x85e>
f01144e6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01144ea:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f01144ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01144f1:	c1 e0 02             	shl    $0x2,%eax
f01144f4:	83 ec 08             	sub    $0x8,%esp
f01144f7:	6a 02                	push   $0x2
f01144f9:	6a 07                	push   $0x7
f01144fb:	6a 07                	push   $0x7
f01144fd:	6a 07                	push   $0x7
f01144ff:	6a 05                	push   $0x5
f0114501:	6a 03                	push   $0x3
f0114503:	50                   	push   %eax
f0114504:	68 00 f0 3f 00       	push   $0x3ff000
f0114509:	68 00 f0 09 00       	push   $0x9f000
f011450e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114511:	e8 17 26 00 00       	call   f0116b2d <CCP>
f0114516:	83 c4 30             	add    $0x30,%esp
f0114519:	85 c0                	test   %eax,%eax
f011451b:	75 1e                	jne    f011453b <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011451d:	83 ec 04             	sub    $0x4,%esp
f0114520:	68 f8 ad 12 f0       	push   $0xf012adf8
f0114525:	68 dd 04 00 00       	push   $0x4dd
f011452a:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011452f:	e8 83 bf fe ff       	call   f01004b7 <_warn>
f0114534:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114537:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011453b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011453f:	74 04                	je     f0114545 <test_share_chunk+0x8b9>
f0114541:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114545:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114549:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011454c:	c1 e0 03             	shl    $0x3,%eax
f011454f:	83 ec 08             	sub    $0x8,%esp
f0114552:	6a 02                	push   $0x2
f0114554:	6a 07                	push   $0x7
f0114556:	6a 07                	push   $0x7
f0114558:	6a 07                	push   $0x7
f011455a:	6a 05                	push   $0x5
f011455c:	6a 04                	push   $0x4
f011455e:	50                   	push   %eax
f011455f:	68 00 00 40 00       	push   $0x400000
f0114564:	68 00 00 0a 00       	push   $0xa0000
f0114569:	ff 75 cc             	pushl  -0x34(%ebp)
f011456c:	e8 bc 25 00 00       	call   f0116b2d <CCP>
f0114571:	83 c4 30             	add    $0x30,%esp
f0114574:	85 c0                	test   %eax,%eax
f0114576:	75 1e                	jne    f0114596 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114578:	83 ec 04             	sub    $0x4,%esp
f011457b:	68 f8 ad 12 f0       	push   $0xf012adf8
f0114580:	68 e5 04 00 00       	push   $0x4e5
f0114585:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011458a:	e8 28 bf fe ff       	call   f01004b7 <_warn>
f011458f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114592:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114596:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011459a:	74 04                	je     f01145a0 <test_share_chunk+0x914>
f011459c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01145a0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01145a4:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01145a8:	0f 84 b2 00 00 00    	je     f0114660 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f01145ae:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f01145b5:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f01145bc:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f01145c3:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f01145ca:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f01145d1:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f01145d8:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f01145df:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f01145e6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145e9:	8a 00                	mov    (%eax),%al
f01145eb:	3c 44                	cmp    $0x44,%al
f01145ed:	75 45                	jne    f0114634 <test_share_chunk+0x9a8>
f01145ef:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145f2:	8a 00                	mov    (%eax),%al
f01145f4:	3c 44                	cmp    $0x44,%al
f01145f6:	75 3c                	jne    f0114634 <test_share_chunk+0x9a8>
f01145f8:	8b 45 9c             	mov    -0x64(%ebp),%eax
f01145fb:	8a 00                	mov    (%eax),%al
f01145fd:	3c 44                	cmp    $0x44,%al
f01145ff:	75 33                	jne    f0114634 <test_share_chunk+0x9a8>
f0114601:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114604:	8a 00                	mov    (%eax),%al
f0114606:	3c 44                	cmp    $0x44,%al
f0114608:	75 2a                	jne    f0114634 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f011460a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011460d:	8a 10                	mov    (%eax),%dl
f011460f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114612:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114614:	38 c2                	cmp    %al,%dl
f0114616:	75 1c                	jne    f0114634 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114618:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011461b:	8a 10                	mov    (%eax),%dl
f011461d:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114620:	8a 00                	mov    (%eax),%al
f0114622:	38 c2                	cmp    %al,%dl
f0114624:	75 0e                	jne    f0114634 <test_share_chunk+0x9a8>
f0114626:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114629:	8a 10                	mov    (%eax),%dl
f011462b:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011462e:	8a 00                	mov    (%eax),%al
f0114630:	38 c2                	cmp    %al,%dl
f0114632:	74 1e                	je     f0114652 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114634:	83 ec 04             	sub    $0x4,%esp
f0114637:	68 40 ae 12 f0       	push   $0xf012ae40
f011463c:	68 fa 04 00 00       	push   $0x4fa
f0114641:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114646:	e8 6c be fe ff       	call   f01004b7 <_warn>
f011464b:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011464e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114652:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114656:	74 04                	je     f011465c <test_share_chunk+0x9d0>
f0114658:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f011465c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114660:	83 ec 0c             	sub    $0xc,%esp
f0114663:	68 84 af 12 f0       	push   $0xf012af84
f0114668:	e8 ff c8 fe ff       	call   f0100f6c <cprintf>
f011466d:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114670:	83 ec 08             	sub    $0x8,%esp
f0114673:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114676:	68 94 af 12 f0       	push   $0xf012af94
f011467b:	e8 ec c8 fe ff       	call   f0100f6c <cprintf>
f0114680:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114683:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114687:	75 10                	jne    f0114699 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114689:	83 ec 0c             	sub    $0xc,%esp
f011468c:	68 c4 af 12 f0       	push   $0xf012afc4
f0114691:	e8 d6 c8 fe ff       	call   f0100f6c <cprintf>
f0114696:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114699:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f011469e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f01146a1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01146a4:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01146a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01146ac:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01146af:	5b                   	pop    %ebx
f01146b0:	5e                   	pop    %esi
f01146b1:	5f                   	pop    %edi
f01146b2:	5d                   	pop    %ebp
f01146b3:	c3                   	ret    

f01146b4 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f01146b4:	55                   	push   %ebp
f01146b5:	89 e5                	mov    %esp,%ebp
f01146b7:	57                   	push   %edi
f01146b8:	56                   	push   %esi
f01146b9:	53                   	push   %ebx
f01146ba:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01146c0:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01146c6:	bb c4 a1 12 f0       	mov    $0xf012a1c4,%ebx
f01146cb:	ba 0f 00 00 00       	mov    $0xf,%edx
f01146d0:	89 c7                	mov    %eax,%edi
f01146d2:	89 de                	mov    %ebx,%esi
f01146d4:	89 d1                	mov    %edx,%ecx
f01146d6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01146d8:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01146de:	b9 23 00 00 00       	mov    $0x23,%ecx
f01146e3:	b0 00                	mov    $0x0,%al
f01146e5:	89 d7                	mov    %edx,%edi
f01146e7:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01146e9:	6a 00                	push   $0x0
f01146eb:	6a 0a                	push   $0xa
f01146ed:	6a 14                	push   $0x14
f01146ef:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01146f5:	50                   	push   %eax
f01146f6:	e8 76 50 ff ff       	call   f0109771 <env_create>
f01146fb:	83 c4 10             	add    $0x10,%esp
f01146fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114701:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114704:	8b 40 64             	mov    0x64(%eax),%eax
f0114707:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f011470a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011470d:	8b 40 68             	mov    0x68(%eax),%eax
f0114710:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114713:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114716:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114719:	83 ec 0c             	sub    $0xc,%esp
f011471c:	ff 75 cc             	pushl  -0x34(%ebp)
f011471f:	e8 d5 23 00 00       	call   f0116af9 <ClearUserSpace>
f0114724:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114727:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011472e:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114735:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f011473c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114740:	83 ec 0c             	sub    $0xc,%esp
f0114743:	68 00 b0 12 f0       	push   $0xf012b000
f0114748:	e8 1f c8 fe ff       	call   f0100f6c <cprintf>
f011474d:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114750:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114757:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f011475e:	eb 03                	jmp    f0114763 <test_allocate_chunk+0xaf>
f0114760:	ff 4d e4             	decl   -0x1c(%ebp)
f0114763:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011476a:	76 09                	jbe    f0114775 <test_allocate_chunk+0xc1>
f011476c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011476f:	8a 00                	mov    (%eax),%al
f0114771:	84 c0                	test   %al,%al
f0114773:	74 eb                	je     f0114760 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0114775:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011477c:	75 06                	jne    f0114784 <test_allocate_chunk+0xd0>
f011477e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114781:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0114784:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114787:	8a 00                	mov    (%eax),%al
f0114789:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f011478f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114792:	8a 00                	mov    (%eax),%al
f0114794:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011479a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011479d:	8a 00                	mov    (%eax),%al
f011479f:	0f be c0             	movsbl %al,%eax
f01147a2:	83 ec 08             	sub    $0x8,%esp
f01147a5:	50                   	push   %eax
f01147a6:	68 2a b0 12 f0       	push   $0xf012b02a
f01147ab:	e8 bc c7 fe ff       	call   f0100f6c <cprintf>
f01147b0:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f01147b3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01147b6:	8a 00                	mov    (%eax),%al
f01147b8:	0f be c0             	movsbl %al,%eax
f01147bb:	83 ec 08             	sub    $0x8,%esp
f01147be:	50                   	push   %eax
f01147bf:	68 36 b0 12 f0       	push   $0xf012b036
f01147c4:	e8 a3 c7 fe ff       	call   f0100f6c <cprintf>
f01147c9:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f01147cc:	83 ec 08             	sub    $0x8,%esp
f01147cf:	68 00 f0 bf ef       	push   $0xefbff000
f01147d4:	ff 75 cc             	pushl  -0x34(%ebp)
f01147d7:	e8 84 22 00 00       	call   f0116a60 <GP>
f01147dc:	83 c4 10             	add    $0x10,%esp
f01147df:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01147e2:	e8 22 8f ff ff       	call   f010d709 <sys_calculate_free_frames>
f01147e7:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f01147ea:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01147ed:	c1 e0 02             	shl    $0x2,%eax
f01147f0:	6a 02                	push   $0x2
f01147f2:	50                   	push   %eax
f01147f3:	68 00 f0 bf ef       	push   $0xefbff000
f01147f8:	ff 75 cc             	pushl  -0x34(%ebp)
f01147fb:	e8 1f 4c ff ff       	call   f010941f <allocate_chunk>
f0114800:	83 c4 10             	add    $0x10,%esp
f0114803:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114806:	e8 fe 8e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011480b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011480e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114812:	75 08                	jne    f011481c <test_allocate_chunk+0x168>
f0114814:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114817:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011481a:	74 2a                	je     f0114846 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011481c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011481f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114822:	83 ec 08             	sub    $0x8,%esp
f0114825:	6a 00                	push   $0x0
f0114827:	50                   	push   %eax
f0114828:	ff 75 b0             	pushl  -0x50(%ebp)
f011482b:	68 44 b0 12 f0       	push   $0xf012b044
f0114830:	68 3a 05 00 00       	push   $0x53a
f0114835:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011483a:	e8 78 bc fe ff       	call   f01004b7 <_warn>
f011483f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114842:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114846:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011484a:	74 04                	je     f0114850 <test_allocate_chunk+0x19c>
f011484c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114850:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114854:	e8 b0 8e ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114859:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f011485c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011485f:	01 c0                	add    %eax,%eax
f0114861:	89 c1                	mov    %eax,%ecx
f0114863:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114866:	89 d0                	mov    %edx,%eax
f0114868:	c1 e0 02             	shl    $0x2,%eax
f011486b:	01 d0                	add    %edx,%eax
f011486d:	f7 d8                	neg    %eax
f011486f:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0114874:	6a 02                	push   $0x2
f0114876:	51                   	push   %ecx
f0114877:	50                   	push   %eax
f0114878:	ff 75 cc             	pushl  -0x34(%ebp)
f011487b:	e8 9f 4b ff ff       	call   f010941f <allocate_chunk>
f0114880:	83 c4 10             	add    $0x10,%esp
f0114883:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114886:	e8 7e 8e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011488b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011488e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114892:	75 08                	jne    f011489c <test_allocate_chunk+0x1e8>
f0114894:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114897:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011489a:	74 2a                	je     f01148c6 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011489c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011489f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01148a2:	83 ec 08             	sub    $0x8,%esp
f01148a5:	6a 00                	push   $0x0
f01148a7:	50                   	push   %eax
f01148a8:	ff 75 b0             	pushl  -0x50(%ebp)
f01148ab:	68 44 b0 12 f0       	push   $0xf012b044
f01148b0:	68 48 05 00 00       	push   $0x548
f01148b5:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01148ba:	e8 f8 bb fe ff       	call   f01004b7 <_warn>
f01148bf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01148c2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01148c6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01148ca:	74 04                	je     f01148d0 <test_allocate_chunk+0x21c>
f01148cc:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f01148d0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f01148d4:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01148d7:	c1 e0 02             	shl    $0x2,%eax
f01148da:	83 ec 08             	sub    $0x8,%esp
f01148dd:	6a 03                	push   $0x3
f01148df:	6a 00                	push   $0x0
f01148e1:	6a 00                	push   $0x0
f01148e3:	68 ff 0f 00 00       	push   $0xfff
f01148e8:	ff 75 b8             	pushl  -0x48(%ebp)
f01148eb:	6a 01                	push   $0x1
f01148ed:	50                   	push   %eax
f01148ee:	68 00 f0 bf ef       	push   $0xefbff000
f01148f3:	6a 00                	push   $0x0
f01148f5:	ff 75 cc             	pushl  -0x34(%ebp)
f01148f8:	e8 30 22 00 00       	call   f0116b2d <CCP>
f01148fd:	83 c4 30             	add    $0x30,%esp
f0114900:	85 c0                	test   %eax,%eax
f0114902:	75 1e                	jne    f0114922 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114904:	83 ec 04             	sub    $0x4,%esp
f0114907:	68 ac b0 12 f0       	push   $0xf012b0ac
f011490c:	68 50 05 00 00       	push   $0x550
f0114911:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114916:	e8 9c bb fe ff       	call   f01004b7 <_warn>
f011491b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011491e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114922:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114926:	74 04                	je     f011492c <test_allocate_chunk+0x278>
f0114928:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f011492c:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f0114930:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114933:	8a 10                	mov    (%eax),%dl
f0114935:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f011493b:	38 c2                	cmp    %al,%dl
f011493d:	75 0f                	jne    f011494e <test_allocate_chunk+0x29a>
f011493f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114942:	8a 10                	mov    (%eax),%dl
f0114944:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f011494a:	38 c2                	cmp    %al,%dl
f011494c:	74 1e                	je     f011496c <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f011494e:	83 ec 04             	sub    $0x4,%esp
f0114951:	68 f8 b0 12 f0       	push   $0xf012b0f8
f0114956:	68 58 05 00 00       	push   $0x558
f011495b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114960:	e8 52 bb fe ff       	call   f01004b7 <_warn>
f0114965:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114968:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f011496c:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114970:	74 04                	je     f0114976 <test_allocate_chunk+0x2c2>
f0114972:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114976:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011497a:	83 ec 0c             	sub    $0xc,%esp
f011497d:	68 75 ae 12 f0       	push   $0xf012ae75
f0114982:	e8 e5 c5 fe ff       	call   f0100f6c <cprintf>
f0114987:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011498a:	83 ec 0c             	sub    $0xc,%esp
f011498d:	68 30 b1 12 f0       	push   $0xf012b130
f0114992:	e8 d5 c5 fe ff       	call   f0100f6c <cprintf>
f0114997:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011499a:	e8 6a 8d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011499f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f01149a2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01149a5:	c1 e0 05             	shl    $0x5,%eax
f01149a8:	68 02 0e 00 00       	push   $0xe02
f01149ad:	50                   	push   %eax
f01149ae:	6a 00                	push   $0x0
f01149b0:	ff 75 cc             	pushl  -0x34(%ebp)
f01149b3:	e8 67 4a ff ff       	call   f010941f <allocate_chunk>
f01149b8:	83 c4 10             	add    $0x10,%esp
f01149bb:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01149be:	e8 46 8d ff ff       	call   f010d709 <sys_calculate_free_frames>
f01149c3:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f01149c6:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f01149ca:	75 36                	jne    f0114a02 <test_allocate_chunk+0x34e>
f01149cc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01149cf:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01149d2:	89 c1                	mov    %eax,%ecx
f01149d4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01149d7:	c1 e0 05             	shl    $0x5,%eax
f01149da:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01149dd:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01149e4:	99                   	cltd   
f01149e5:	f7 fe                	idiv   %esi
f01149e7:	89 c3                	mov    %eax,%ebx
f01149e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01149ec:	c1 e0 05             	shl    $0x5,%eax
f01149ef:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01149f2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01149f9:	99                   	cltd   
f01149fa:	f7 fe                	idiv   %esi
f01149fc:	01 d8                	add    %ebx,%eax
f01149fe:	39 c1                	cmp    %eax,%ecx
f0114a00:	74 54                	je     f0114a56 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0114a02:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a05:	c1 e0 05             	shl    $0x5,%eax
f0114a08:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114a0b:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114a12:	99                   	cltd   
f0114a13:	f7 ff                	idiv   %edi
f0114a15:	89 c1                	mov    %eax,%ecx
f0114a17:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a1a:	c1 e0 05             	shl    $0x5,%eax
f0114a1d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114a20:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114a27:	99                   	cltd   
f0114a28:	f7 fe                	idiv   %esi
f0114a2a:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114a2d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a30:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a33:	83 ec 08             	sub    $0x8,%esp
f0114a36:	52                   	push   %edx
f0114a37:	50                   	push   %eax
f0114a38:	ff 75 a8             	pushl  -0x58(%ebp)
f0114a3b:	68 70 b1 12 f0       	push   $0xf012b170
f0114a40:	68 6d 05 00 00       	push   $0x56d
f0114a45:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114a4a:	e8 68 ba fe ff       	call   f01004b7 <_warn>
f0114a4f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a52:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114a56:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114a5a:	74 04                	je     f0114a60 <test_allocate_chunk+0x3ac>
f0114a5c:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114a60:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114a64:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114a6b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114a6e:	c1 e0 05             	shl    $0x5,%eax
f0114a71:	83 ec 08             	sub    $0x8,%esp
f0114a74:	6a 03                	push   $0x3
f0114a76:	6a 00                	push   $0x0
f0114a78:	6a 00                	push   $0x0
f0114a7a:	68 07 0e 00 00       	push   $0xe07
f0114a7f:	68 03 0e 00 00       	push   $0xe03
f0114a84:	6a 01                	push   $0x1
f0114a86:	50                   	push   %eax
f0114a87:	6a 00                	push   $0x0
f0114a89:	6a 00                	push   $0x0
f0114a8b:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a8e:	e8 9a 20 00 00       	call   f0116b2d <CCP>
f0114a93:	83 c4 30             	add    $0x30,%esp
f0114a96:	85 c0                	test   %eax,%eax
f0114a98:	75 25                	jne    f0114abf <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114a9a:	83 ec 04             	sub    $0x4,%esp
f0114a9d:	68 ac b0 12 f0       	push   $0xf012b0ac
f0114aa2:	68 76 05 00 00       	push   $0x576
f0114aa7:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114aac:	e8 06 ba fe ff       	call   f01004b7 <_warn>
f0114ab1:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114ab4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114ab8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f0114abf:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114ac3:	74 04                	je     f0114ac9 <test_allocate_chunk+0x415>
f0114ac5:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ac9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114acd:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114ad1:	74 5a                	je     f0114b2d <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0114ad3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114ad6:	01 c0                	add    %eax,%eax
f0114ad8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114adb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114ade:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0114ae1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ae4:	01 c0                	add    %eax,%eax
f0114ae6:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114ae9:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114aec:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114aef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114af2:	8a 00                	mov    (%eax),%al
f0114af4:	3c 4b                	cmp    $0x4b,%al
f0114af6:	75 09                	jne    f0114b01 <test_allocate_chunk+0x44d>
f0114af8:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114afb:	8a 00                	mov    (%eax),%al
f0114afd:	3c 4d                	cmp    $0x4d,%al
f0114aff:	74 1e                	je     f0114b1f <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114b01:	83 ec 04             	sub    $0x4,%esp
f0114b04:	68 f8 b0 12 f0       	push   $0xf012b0f8
f0114b09:	68 84 05 00 00       	push   $0x584
f0114b0e:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114b13:	e8 9f b9 fe ff       	call   f01004b7 <_warn>
f0114b18:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114b1b:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114b1f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114b23:	74 04                	je     f0114b29 <test_allocate_chunk+0x475>
f0114b25:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114b29:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f0114b2d:	83 ec 0c             	sub    $0xc,%esp
f0114b30:	68 4f a4 12 f0       	push   $0xf012a44f
f0114b35:	e8 32 c4 fe ff       	call   f0100f6c <cprintf>
f0114b3a:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f0114b3d:	83 ec 0c             	sub    $0xc,%esp
f0114b40:	68 d0 b1 12 f0       	push   $0xf012b1d0
f0114b45:	e8 22 c4 fe ff       	call   f0100f6c <cprintf>
f0114b4a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114b4d:	e8 b7 8b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114b52:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f0114b55:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b58:	c1 e0 06             	shl    $0x6,%eax
f0114b5b:	89 c2                	mov    %eax,%edx
f0114b5d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b60:	c1 e0 05             	shl    $0x5,%eax
f0114b63:	6a 00                	push   $0x0
f0114b65:	52                   	push   %edx
f0114b66:	50                   	push   %eax
f0114b67:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b6a:	e8 b0 48 ff ff       	call   f010941f <allocate_chunk>
f0114b6f:	83 c4 10             	add    $0x10,%esp
f0114b72:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114b75:	e8 8f 8b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114b7a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f0114b7d:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0114b81:	75 36                	jne    f0114bb9 <test_allocate_chunk+0x505>
f0114b83:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114b86:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114b89:	89 c1                	mov    %eax,%ecx
f0114b8b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114b8e:	c1 e0 06             	shl    $0x6,%eax
f0114b91:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114b94:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114b9b:	99                   	cltd   
f0114b9c:	f7 ff                	idiv   %edi
f0114b9e:	89 c3                	mov    %eax,%ebx
f0114ba0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ba3:	c1 e0 06             	shl    $0x6,%eax
f0114ba6:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ba9:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114bb0:	99                   	cltd   
f0114bb1:	f7 fe                	idiv   %esi
f0114bb3:	01 d8                	add    %ebx,%eax
f0114bb5:	39 c1                	cmp    %eax,%ecx
f0114bb7:	74 54                	je     f0114c0d <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0114bb9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bbc:	c1 e0 06             	shl    $0x6,%eax
f0114bbf:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114bc2:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114bc9:	99                   	cltd   
f0114bca:	f7 fb                	idiv   %ebx
f0114bcc:	89 c1                	mov    %eax,%ecx
f0114bce:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114bd1:	c1 e0 06             	shl    $0x6,%eax
f0114bd4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114bd7:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114bde:	99                   	cltd   
f0114bdf:	f7 ff                	idiv   %edi
f0114be1:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114be4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114be7:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114bea:	83 ec 08             	sub    $0x8,%esp
f0114bed:	52                   	push   %edx
f0114bee:	50                   	push   %eax
f0114bef:	ff 75 a4             	pushl  -0x5c(%ebp)
f0114bf2:	68 70 b1 12 f0       	push   $0xf012b170
f0114bf7:	68 9a 05 00 00       	push   $0x59a
f0114bfc:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114c01:	e8 b1 b8 fe ff       	call   f01004b7 <_warn>
f0114c06:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114c09:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114c0d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c11:	74 04                	je     f0114c17 <test_allocate_chunk+0x563>
f0114c13:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114c17:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114c1b:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114c22:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c25:	c1 e0 06             	shl    $0x6,%eax
f0114c28:	89 c2                	mov    %eax,%edx
f0114c2a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114c2d:	c1 e0 05             	shl    $0x5,%eax
f0114c30:	83 ec 08             	sub    $0x8,%esp
f0114c33:	6a 03                	push   $0x3
f0114c35:	6a 00                	push   $0x0
f0114c37:	6a 00                	push   $0x0
f0114c39:	68 07 0e 00 00       	push   $0xe07
f0114c3e:	6a 01                	push   $0x1
f0114c40:	6a 01                	push   $0x1
f0114c42:	52                   	push   %edx
f0114c43:	50                   	push   %eax
f0114c44:	6a 00                	push   $0x0
f0114c46:	ff 75 cc             	pushl  -0x34(%ebp)
f0114c49:	e8 df 1e 00 00       	call   f0116b2d <CCP>
f0114c4e:	83 c4 30             	add    $0x30,%esp
f0114c51:	85 c0                	test   %eax,%eax
f0114c53:	75 25                	jne    f0114c7a <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114c55:	83 ec 04             	sub    $0x4,%esp
f0114c58:	68 ac b0 12 f0       	push   $0xf012b0ac
f0114c5d:	68 a3 05 00 00       	push   $0x5a3
f0114c62:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114c67:	e8 4b b8 fe ff       	call   f01004b7 <_warn>
f0114c6c:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114c6f:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114c73:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f0114c7a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114c7e:	74 04                	je     f0114c84 <test_allocate_chunk+0x5d0>
f0114c80:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114c84:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0114c88:	83 ec 0c             	sub    $0xc,%esp
f0114c8b:	68 b2 a4 12 f0       	push   $0xf012a4b2
f0114c90:	e8 d7 c2 fe ff       	call   f0100f6c <cprintf>
f0114c95:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0114c98:	83 ec 0c             	sub    $0xc,%esp
f0114c9b:	68 10 b2 12 f0       	push   $0xf012b210
f0114ca0:	e8 c7 c2 fe ff       	call   f0100f6c <cprintf>
f0114ca5:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114ca8:	e8 5c 8a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114cad:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0114cb0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cb3:	c1 e0 06             	shl    $0x6,%eax
f0114cb6:	68 06 0e 00 00       	push   $0xe06
f0114cbb:	50                   	push   %eax
f0114cbc:	68 00 00 00 80       	push   $0x80000000
f0114cc1:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cc4:	e8 56 47 ff ff       	call   f010941f <allocate_chunk>
f0114cc9:	83 c4 10             	add    $0x10,%esp
f0114ccc:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ccf:	e8 35 8a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114cd4:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0114cd7:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f0114cdb:	75 36                	jne    f0114d13 <test_allocate_chunk+0x65f>
f0114cdd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ce0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ce3:	89 c1                	mov    %eax,%ecx
f0114ce5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114ce8:	c1 e0 06             	shl    $0x6,%eax
f0114ceb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114cee:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114cf5:	99                   	cltd   
f0114cf6:	f7 fb                	idiv   %ebx
f0114cf8:	89 c3                	mov    %eax,%ebx
f0114cfa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114cfd:	c1 e0 06             	shl    $0x6,%eax
f0114d00:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114d03:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0114d0a:	99                   	cltd   
f0114d0b:	f7 fe                	idiv   %esi
f0114d0d:	01 d8                	add    %ebx,%eax
f0114d0f:	39 c1                	cmp    %eax,%ecx
f0114d11:	74 54                	je     f0114d67 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f0114d13:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d16:	c1 e0 06             	shl    $0x6,%eax
f0114d19:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d1c:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f0114d23:	99                   	cltd   
f0114d24:	f7 ff                	idiv   %edi
f0114d26:	89 c1                	mov    %eax,%ecx
f0114d28:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d2b:	c1 e0 06             	shl    $0x6,%eax
f0114d2e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114d31:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114d38:	99                   	cltd   
f0114d39:	f7 fb                	idiv   %ebx
f0114d3b:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0114d3e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114d41:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114d44:	83 ec 08             	sub    $0x8,%esp
f0114d47:	52                   	push   %edx
f0114d48:	50                   	push   %eax
f0114d49:	ff 75 9c             	pushl  -0x64(%ebp)
f0114d4c:	68 70 b1 12 f0       	push   $0xf012b170
f0114d51:	68 b9 05 00 00       	push   $0x5b9
f0114d56:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114d5b:	e8 57 b7 fe ff       	call   f01004b7 <_warn>
f0114d60:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114d63:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f0114d67:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114d6b:	74 04                	je     f0114d71 <test_allocate_chunk+0x6bd>
f0114d6d:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114d71:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114d75:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114d7c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0114d7f:	c1 e0 06             	shl    $0x6,%eax
f0114d82:	83 ec 08             	sub    $0x8,%esp
f0114d85:	6a 03                	push   $0x3
f0114d87:	6a 00                	push   $0x0
f0114d89:	6a 00                	push   $0x0
f0114d8b:	68 07 0e 00 00       	push   $0xe07
f0114d90:	68 07 0e 00 00       	push   $0xe07
f0114d95:	6a 01                	push   $0x1
f0114d97:	50                   	push   %eax
f0114d98:	68 00 00 00 80       	push   $0x80000000
f0114d9d:	6a 00                	push   $0x0
f0114d9f:	ff 75 cc             	pushl  -0x34(%ebp)
f0114da2:	e8 86 1d 00 00       	call   f0116b2d <CCP>
f0114da7:	83 c4 30             	add    $0x30,%esp
f0114daa:	85 c0                	test   %eax,%eax
f0114dac:	75 25                	jne    f0114dd3 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114dae:	83 ec 04             	sub    $0x4,%esp
f0114db1:	68 ac b0 12 f0       	push   $0xf012b0ac
f0114db6:	68 c2 05 00 00       	push   $0x5c2
f0114dbb:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114dc0:	e8 f2 b6 fe ff       	call   f01004b7 <_warn>
f0114dc5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114dc8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114dcc:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0114dd3:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114dd7:	74 04                	je     f0114ddd <test_allocate_chunk+0x729>
f0114dd9:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ddd:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0114de1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114de5:	74 6f                	je     f0114e56 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0114de7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114dea:	01 c0                	add    %eax,%eax
f0114dec:	05 00 00 00 80       	add    $0x80000000,%eax
f0114df1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0114df4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114df7:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f0114dfa:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114dfd:	89 d0                	mov    %edx,%eax
f0114dff:	c1 e0 02             	shl    $0x2,%eax
f0114e02:	01 d0                	add    %edx,%eax
f0114e04:	01 c0                	add    %eax,%eax
f0114e06:	01 d0                	add    %edx,%eax
f0114e08:	01 c0                	add    %eax,%eax
f0114e0a:	05 00 00 00 80       	add    $0x80000000,%eax
f0114e0f:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0114e12:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e15:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f0114e18:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114e1b:	8a 00                	mov    (%eax),%al
f0114e1d:	3c 4b                	cmp    $0x4b,%al
f0114e1f:	75 09                	jne    f0114e2a <test_allocate_chunk+0x776>
f0114e21:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e24:	8a 00                	mov    (%eax),%al
f0114e26:	3c 4d                	cmp    $0x4d,%al
f0114e28:	74 1e                	je     f0114e48 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0114e2a:	83 ec 04             	sub    $0x4,%esp
f0114e2d:	68 f8 b0 12 f0       	push   $0xf012b0f8
f0114e32:	68 d0 05 00 00       	push   $0x5d0
f0114e37:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114e3c:	e8 76 b6 fe ff       	call   f01004b7 <_warn>
f0114e41:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114e44:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f0114e48:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114e4c:	74 04                	je     f0114e52 <test_allocate_chunk+0x79e>
f0114e4e:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f0114e52:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114e56:	83 ec 0c             	sub    $0xc,%esp
f0114e59:	68 84 af 12 f0       	push   $0xf012af84
f0114e5e:	e8 09 c1 fe ff       	call   f0100f6c <cprintf>
f0114e63:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f0114e66:	83 ec 0c             	sub    $0xc,%esp
f0114e69:	68 4c b2 12 f0       	push   $0xf012b24c
f0114e6e:	e8 f9 c0 fe ff       	call   f0100f6c <cprintf>
f0114e73:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114e76:	e8 8e 88 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114e7b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f0114e7e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114e81:	89 d0                	mov    %edx,%eax
f0114e83:	01 c0                	add    %eax,%eax
f0114e85:	01 d0                	add    %edx,%eax
f0114e87:	01 c0                	add    %eax,%eax
f0114e89:	01 d0                	add    %edx,%eax
f0114e8b:	68 04 0e 00 00       	push   $0xe04
f0114e90:	50                   	push   %eax
f0114e91:	68 00 fc 3f 40       	push   $0x403ffc00
f0114e96:	ff 75 cc             	pushl  -0x34(%ebp)
f0114e99:	e8 81 45 ff ff       	call   f010941f <allocate_chunk>
f0114e9e:	83 c4 10             	add    $0x10,%esp
f0114ea1:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114ea4:	e8 60 88 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0114ea9:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f0114eac:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0114eb0:	75 0b                	jne    f0114ebd <test_allocate_chunk+0x809>
f0114eb2:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114eb5:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114eb8:	83 f8 05             	cmp    $0x5,%eax
f0114ebb:	74 2a                	je     f0114ee7 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f0114ebd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114ec0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114ec3:	83 ec 08             	sub    $0x8,%esp
f0114ec6:	6a 05                	push   $0x5
f0114ec8:	50                   	push   %eax
f0114ec9:	ff 75 98             	pushl  -0x68(%ebp)
f0114ecc:	68 70 b1 12 f0       	push   $0xf012b170
f0114ed1:	68 e7 05 00 00       	push   $0x5e7
f0114ed6:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114edb:	e8 d7 b5 fe ff       	call   f01004b7 <_warn>
f0114ee0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114ee3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0114ee7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114eeb:	74 04                	je     f0114ef1 <test_allocate_chunk+0x83d>
f0114eed:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0114ef1:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0114ef5:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f0114efc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114eff:	89 d0                	mov    %edx,%eax
f0114f01:	01 c0                	add    %eax,%eax
f0114f03:	01 d0                	add    %edx,%eax
f0114f05:	c1 e0 02             	shl    $0x2,%eax
f0114f08:	83 ec 08             	sub    $0x8,%esp
f0114f0b:	6a 03                	push   $0x3
f0114f0d:	6a 00                	push   $0x0
f0114f0f:	6a 00                	push   $0x0
f0114f11:	68 07 0e 00 00       	push   $0xe07
f0114f16:	68 05 0e 00 00       	push   $0xe05
f0114f1b:	6a 01                	push   $0x1
f0114f1d:	50                   	push   %eax
f0114f1e:	68 00 f0 3f 40       	push   $0x403ff000
f0114f23:	6a 00                	push   $0x0
f0114f25:	ff 75 cc             	pushl  -0x34(%ebp)
f0114f28:	e8 00 1c 00 00       	call   f0116b2d <CCP>
f0114f2d:	83 c4 30             	add    $0x30,%esp
f0114f30:	85 c0                	test   %eax,%eax
f0114f32:	75 25                	jne    f0114f59 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0114f34:	83 ec 04             	sub    $0x4,%esp
f0114f37:	68 ac b0 12 f0       	push   $0xf012b0ac
f0114f3c:	68 f0 05 00 00       	push   $0x5f0
f0114f41:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0114f46:	e8 6c b5 fe ff       	call   f01004b7 <_warn>
f0114f4b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114f4e:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0114f52:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f0114f59:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0114f5d:	74 04                	je     f0114f63 <test_allocate_chunk+0x8af>
f0114f5f:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0114f63:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f0114f67:	83 ec 0c             	sub    $0xc,%esp
f0114f6a:	68 83 b2 12 f0       	push   $0xf012b283
f0114f6f:	e8 f8 bf fe ff       	call   f0100f6c <cprintf>
f0114f74:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0114f77:	83 ec 08             	sub    $0x8,%esp
f0114f7a:	ff 75 e0             	pushl  -0x20(%ebp)
f0114f7d:	68 94 b2 12 f0       	push   $0xf012b294
f0114f82:	e8 e5 bf fe ff       	call   f0100f6c <cprintf>
f0114f87:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114f8a:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f0114f8e:	75 10                	jne    f0114fa0 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0114f90:	83 ec 0c             	sub    $0xc,%esp
f0114f93:	68 c8 b2 12 f0       	push   $0xf012b2c8
f0114f98:	e8 cf bf fe ff       	call   f0100f6c <cprintf>
f0114f9d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114fa0:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0114fa5:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114fa8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114fab:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114fae:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114fb3:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114fb6:	5b                   	pop    %ebx
f0114fb7:	5e                   	pop    %esi
f0114fb8:	5f                   	pop    %edi
f0114fb9:	5d                   	pop    %ebp
f0114fba:	c3                   	ret    

f0114fbb <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f0114fbb:	55                   	push   %ebp
f0114fbc:	89 e5                	mov    %esp,%ebp
f0114fbe:	57                   	push   %edi
f0114fbf:	56                   	push   %esi
f0114fc0:	53                   	push   %ebx
f0114fc1:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114fc7:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114fca:	bb c4 a1 12 f0       	mov    $0xf012a1c4,%ebx
f0114fcf:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114fd4:	89 c7                	mov    %eax,%edi
f0114fd6:	89 de                	mov    %ebx,%esi
f0114fd8:	89 d1                	mov    %edx,%ecx
f0114fda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114fdc:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0114fdf:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114fe4:	b0 00                	mov    $0x0,%al
f0114fe6:	89 d7                	mov    %edx,%edi
f0114fe8:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114fea:	6a 00                	push   $0x0
f0114fec:	6a 0a                	push   $0xa
f0114fee:	6a 14                	push   $0x14
f0114ff0:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0114ff3:	50                   	push   %eax
f0114ff4:	e8 78 47 ff ff       	call   f0109771 <env_create>
f0114ff9:	83 c4 10             	add    $0x10,%esp
f0114ffc:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114fff:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115002:	8b 40 64             	mov    0x64(%eax),%eax
f0115005:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115008:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011500b:	8b 40 68             	mov    0x68(%eax),%eax
f011500e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115011:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115014:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0115017:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f011501e:	75 70 20 
f0115021:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f0115028:	00 00 00 
f011502b:	8d 55 82             	lea    -0x7e(%ebp),%edx
f011502e:	b9 03 00 00 00       	mov    $0x3,%ecx
f0115033:	b8 00 00 00 00       	mov    $0x0,%eax
f0115038:	89 d7                	mov    %edx,%edi
f011503a:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f011503c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011503f:	8b 40 10             	mov    0x10(%eax),%eax
f0115042:	83 ec 08             	sub    $0x8,%esp
f0115045:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f011504b:	52                   	push   %edx
f011504c:	50                   	push   %eax
f011504d:	e8 87 b9 00 00       	call   f01209d9 <ltostr>
f0115052:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0115055:	83 ec 04             	sub    $0x4,%esp
f0115058:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011505e:	50                   	push   %eax
f011505f:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0115065:	50                   	push   %eax
f0115066:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f011506c:	50                   	push   %eax
f011506d:	e8 40 ba 00 00       	call   f0120ab2 <strcconcat>
f0115072:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115075:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011507c:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115083:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011508a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115091:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115095:	83 ec 0c             	sub    $0xc,%esp
f0115098:	ff 75 d8             	pushl  -0x28(%ebp)
f011509b:	e8 59 1a 00 00       	call   f0116af9 <ClearUserSpace>
f01150a0:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01150a3:	83 ec 0c             	sub    $0xc,%esp
f01150a6:	68 08 b3 12 f0       	push   $0xf012b308
f01150ab:	e8 bc be fe ff       	call   f0100f6c <cprintf>
f01150b0:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f01150b3:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01150b6:	c1 e0 03             	shl    $0x3,%eax
f01150b9:	83 ec 04             	sub    $0x4,%esp
f01150bc:	50                   	push   %eax
f01150bd:	6a 00                	push   $0x0
f01150bf:	ff 75 d8             	pushl  -0x28(%ebp)
f01150c2:	e8 8c 43 ff ff       	call   f0109453 <calculate_required_frames>
f01150c7:	83 c4 10             	add    $0x10,%esp
f01150ca:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f01150cd:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f01150d1:	74 23                	je     f01150f6 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f01150d3:	83 ec 0c             	sub    $0xc,%esp
f01150d6:	6a 03                	push   $0x3
f01150d8:	ff 75 c8             	pushl  -0x38(%ebp)
f01150db:	68 3c b3 12 f0       	push   $0xf012b33c
f01150e0:	68 29 06 00 00       	push   $0x629
f01150e5:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01150ea:	e8 c8 b3 fe ff       	call   f01004b7 <_warn>
f01150ef:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150f2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01150f6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01150fa:	74 04                	je     f0115100 <test_calculate_required_frames+0x145>
f01150fc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115100:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115104:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115107:	c1 e0 02             	shl    $0x2,%eax
f011510a:	83 ec 04             	sub    $0x4,%esp
f011510d:	50                   	push   %eax
f011510e:	6a 00                	push   $0x0
f0115110:	ff 75 d8             	pushl  -0x28(%ebp)
f0115113:	e8 3b 43 ff ff       	call   f0109453 <calculate_required_frames>
f0115118:	83 c4 10             	add    $0x10,%esp
f011511b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f011511e:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f0115125:	74 26                	je     f011514d <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f0115127:	83 ec 0c             	sub    $0xc,%esp
f011512a:	68 01 04 00 00       	push   $0x401
f011512f:	ff 75 c8             	pushl  -0x38(%ebp)
f0115132:	68 3c b3 12 f0       	push   $0xf012b33c
f0115137:	68 33 06 00 00       	push   $0x633
f011513c:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115141:	e8 71 b3 fe ff       	call   f01004b7 <_warn>
f0115146:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115149:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011514d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115151:	74 04                	je     f0115157 <test_calculate_required_frames+0x19c>
f0115153:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115157:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011515b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011515e:	c1 e0 0a             	shl    $0xa,%eax
f0115161:	83 ec 04             	sub    $0x4,%esp
f0115164:	50                   	push   %eax
f0115165:	6a 00                	push   $0x0
f0115167:	ff 75 d8             	pushl  -0x28(%ebp)
f011516a:	e8 e4 42 ff ff       	call   f0109453 <calculate_required_frames>
f011516f:	83 c4 10             	add    $0x10,%esp
f0115172:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115175:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115178:	c1 e0 0a             	shl    $0xa,%eax
f011517b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011517e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115185:	99                   	cltd   
f0115186:	f7 fb                	idiv   %ebx
f0115188:	89 c1                	mov    %eax,%ecx
f011518a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011518d:	c1 e0 0a             	shl    $0xa,%eax
f0115190:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115193:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011519a:	99                   	cltd   
f011519b:	f7 fe                	idiv   %esi
f011519d:	01 c8                	add    %ecx,%eax
f011519f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01151a2:	74 4c                	je     f01151f0 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f01151a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01151a7:	c1 e0 0a             	shl    $0xa,%eax
f01151aa:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01151ad:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01151b4:	99                   	cltd   
f01151b5:	f7 fb                	idiv   %ebx
f01151b7:	89 c1                	mov    %eax,%ecx
f01151b9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01151bc:	c1 e0 0a             	shl    $0xa,%eax
f01151bf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01151c2:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01151c9:	99                   	cltd   
f01151ca:	f7 fe                	idiv   %esi
f01151cc:	01 c8                	add    %ecx,%eax
f01151ce:	83 ec 0c             	sub    $0xc,%esp
f01151d1:	50                   	push   %eax
f01151d2:	ff 75 c8             	pushl  -0x38(%ebp)
f01151d5:	68 3c b3 12 f0       	push   $0xf012b33c
f01151da:	68 3d 06 00 00       	push   $0x63d
f01151df:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01151e4:	e8 ce b2 fe ff       	call   f01004b7 <_warn>
f01151e9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01151ec:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01151f0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01151f4:	74 04                	je     f01151fa <test_calculate_required_frames+0x23f>
f01151f6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01151fa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f01151fe:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115201:	89 d0                	mov    %edx,%eax
f0115203:	01 c0                	add    %eax,%eax
f0115205:	01 d0                	add    %edx,%eax
f0115207:	01 c0                	add    %eax,%eax
f0115209:	83 ec 04             	sub    $0x4,%esp
f011520c:	50                   	push   %eax
f011520d:	68 00 10 00 00       	push   $0x1000
f0115212:	ff 75 d8             	pushl  -0x28(%ebp)
f0115215:	e8 39 42 ff ff       	call   f0109453 <calculate_required_frames>
f011521a:	83 c4 10             	add    $0x10,%esp
f011521d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115220:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115224:	74 23                	je     f0115249 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115226:	83 ec 0c             	sub    $0xc,%esp
f0115229:	6a 03                	push   $0x3
f011522b:	ff 75 c8             	pushl  -0x38(%ebp)
f011522e:	68 3c b3 12 f0       	push   $0xf012b33c
f0115233:	68 49 06 00 00       	push   $0x649
f0115238:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011523d:	e8 75 b2 fe ff       	call   f01004b7 <_warn>
f0115242:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115245:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115249:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011524d:	74 04                	je     f0115253 <test_calculate_required_frames+0x298>
f011524f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115253:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115257:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011525a:	89 c2                	mov    %eax,%edx
f011525c:	01 d2                	add    %edx,%edx
f011525e:	01 d0                	add    %edx,%eax
f0115260:	83 ec 04             	sub    $0x4,%esp
f0115263:	50                   	push   %eax
f0115264:	68 00 18 00 00       	push   $0x1800
f0115269:	ff 75 d8             	pushl  -0x28(%ebp)
f011526c:	e8 e2 41 ff ff       	call   f0109453 <calculate_required_frames>
f0115271:	83 c4 10             	add    $0x10,%esp
f0115274:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115277:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f011527b:	74 23                	je     f01152a0 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f011527d:	83 ec 0c             	sub    $0xc,%esp
f0115280:	6a 03                	push   $0x3
f0115282:	ff 75 c8             	pushl  -0x38(%ebp)
f0115285:	68 3c b3 12 f0       	push   $0xf012b33c
f011528a:	68 53 06 00 00       	push   $0x653
f011528f:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115294:	e8 1e b2 fe ff       	call   f01004b7 <_warn>
f0115299:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011529c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01152a0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01152a4:	74 04                	je     f01152aa <test_calculate_required_frames+0x2ef>
f01152a6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01152aa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f01152ae:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01152b1:	89 d0                	mov    %edx,%eax
f01152b3:	c1 e0 02             	shl    $0x2,%eax
f01152b6:	01 d0                	add    %edx,%eax
f01152b8:	01 c0                	add    %eax,%eax
f01152ba:	83 ec 04             	sub    $0x4,%esp
f01152bd:	50                   	push   %eax
f01152be:	68 00 00 40 00       	push   $0x400000
f01152c3:	ff 75 d8             	pushl  -0x28(%ebp)
f01152c6:	e8 88 41 ff ff       	call   f0109453 <calculate_required_frames>
f01152cb:	83 c4 10             	add    $0x10,%esp
f01152ce:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f01152d1:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f01152d8:	74 26                	je     f0115300 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f01152da:	83 ec 0c             	sub    $0xc,%esp
f01152dd:	68 03 0a 00 00       	push   $0xa03
f01152e2:	ff 75 c8             	pushl  -0x38(%ebp)
f01152e5:	68 3c b3 12 f0       	push   $0xf012b33c
f01152ea:	68 5d 06 00 00       	push   $0x65d
f01152ef:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01152f4:	e8 be b1 fe ff       	call   f01004b7 <_warn>
f01152f9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152fc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115300:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115304:	74 04                	je     f011530a <test_calculate_required_frames+0x34f>
f0115306:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011530a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f011530e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115311:	01 c0                	add    %eax,%eax
f0115313:	83 ec 04             	sub    $0x4,%esp
f0115316:	50                   	push   %eax
f0115317:	68 00 00 70 00       	push   $0x700000
f011531c:	ff 75 d8             	pushl  -0x28(%ebp)
f011531f:	e8 2f 41 ff ff       	call   f0109453 <calculate_required_frames>
f0115324:	83 c4 10             	add    $0x10,%esp
f0115327:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f011532a:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115331:	74 26                	je     f0115359 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115333:	83 ec 0c             	sub    $0xc,%esp
f0115336:	68 02 02 00 00       	push   $0x202
f011533b:	ff 75 c8             	pushl  -0x38(%ebp)
f011533e:	68 3c b3 12 f0       	push   $0xf012b33c
f0115343:	68 69 06 00 00       	push   $0x669
f0115348:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011534d:	e8 65 b1 fe ff       	call   f01004b7 <_warn>
f0115352:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115355:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115359:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011535d:	74 04                	je     f0115363 <test_calculate_required_frames+0x3a8>
f011535f:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115363:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115367:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011536a:	83 ec 04             	sub    $0x4,%esp
f011536d:	50                   	push   %eax
f011536e:	68 ff ff 3f 00       	push   $0x3fffff
f0115373:	ff 75 d8             	pushl  -0x28(%ebp)
f0115376:	e8 d8 40 ff ff       	call   f0109453 <calculate_required_frames>
f011537b:	83 c4 10             	add    $0x10,%esp
f011537e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115381:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115385:	74 23                	je     f01153aa <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115387:	83 ec 0c             	sub    $0xc,%esp
f011538a:	6a 04                	push   $0x4
f011538c:	ff 75 c8             	pushl  -0x38(%ebp)
f011538f:	68 3c b3 12 f0       	push   $0xf012b33c
f0115394:	68 73 06 00 00       	push   $0x673
f0115399:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011539e:	e8 14 b1 fe ff       	call   f01004b7 <_warn>
f01153a3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01153a6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01153aa:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01153ae:	74 04                	je     f01153b4 <test_calculate_required_frames+0x3f9>
f01153b0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01153b4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f01153b8:	83 ec 0c             	sub    $0xc,%esp
f01153bb:	68 75 ae 12 f0       	push   $0xf012ae75
f01153c0:	e8 a7 bb fe ff       	call   f0100f6c <cprintf>
f01153c5:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f01153c8:	83 ec 0c             	sub    $0xc,%esp
f01153cb:	68 94 b3 12 f0       	push   $0xf012b394
f01153d0:	e8 97 bb fe ff       	call   f0100f6c <cprintf>
f01153d5:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f01153d8:	83 ec 04             	sub    $0x4,%esp
f01153db:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01153e1:	50                   	push   %eax
f01153e2:	68 2e a2 12 f0       	push   $0xf012a22e
f01153e7:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01153ed:	50                   	push   %eax
f01153ee:	e8 bf b6 00 00       	call   f0120ab2 <strcconcat>
f01153f3:	83 c4 10             	add    $0x10,%esp
f01153f6:	83 ec 0c             	sub    $0xc,%esp
f01153f9:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f01153ff:	50                   	push   %eax
f0115400:	e8 d7 ca fe ff       	call   f0101edc <execute_command>
f0115405:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115408:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011540b:	c1 e0 03             	shl    $0x3,%eax
f011540e:	83 ec 04             	sub    $0x4,%esp
f0115411:	50                   	push   %eax
f0115412:	6a 00                	push   $0x0
f0115414:	ff 75 d8             	pushl  -0x28(%ebp)
f0115417:	e8 37 40 ff ff       	call   f0109453 <calculate_required_frames>
f011541c:	83 c4 10             	add    $0x10,%esp
f011541f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115422:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115429:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011542c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011542f:	74 24                	je     f0115455 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115431:	83 ec 0c             	sub    $0xc,%esp
f0115434:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115437:	ff 75 c8             	pushl  -0x38(%ebp)
f011543a:	68 3c b3 12 f0       	push   $0xf012b33c
f011543f:	68 87 06 00 00       	push   $0x687
f0115444:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115449:	e8 69 b0 fe ff       	call   f01004b7 <_warn>
f011544e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115451:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115455:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115459:	74 04                	je     f011545f <test_calculate_required_frames+0x4a4>
f011545b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011545f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115463:	83 ec 04             	sub    $0x4,%esp
f0115466:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011546c:	50                   	push   %eax
f011546d:	68 3b a2 12 f0       	push   $0xf012a23b
f0115472:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115478:	50                   	push   %eax
f0115479:	e8 34 b6 00 00       	call   f0120ab2 <strcconcat>
f011547e:	83 c4 10             	add    $0x10,%esp
f0115481:	83 ec 0c             	sub    $0xc,%esp
f0115484:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f011548a:	50                   	push   %eax
f011548b:	e8 4c ca fe ff       	call   f0101edc <execute_command>
f0115490:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115493:	83 ec 04             	sub    $0x4,%esp
f0115496:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011549c:	50                   	push   %eax
f011549d:	68 c8 b3 12 f0       	push   $0xf012b3c8
f01154a2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01154a8:	50                   	push   %eax
f01154a9:	e8 04 b6 00 00       	call   f0120ab2 <strcconcat>
f01154ae:	83 c4 10             	add    $0x10,%esp
f01154b1:	83 ec 0c             	sub    $0xc,%esp
f01154b4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01154ba:	50                   	push   %eax
f01154bb:	e8 1c ca fe ff       	call   f0101edc <execute_command>
f01154c0:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f01154c3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01154c6:	c1 e0 03             	shl    $0x3,%eax
f01154c9:	83 ec 04             	sub    $0x4,%esp
f01154cc:	50                   	push   %eax
f01154cd:	6a 00                	push   $0x0
f01154cf:	ff 75 d8             	pushl  -0x28(%ebp)
f01154d2:	e8 7c 3f ff ff       	call   f0109453 <calculate_required_frames>
f01154d7:	83 c4 10             	add    $0x10,%esp
f01154da:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f01154dd:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f01154e4:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01154e7:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01154ea:	74 24                	je     f0115510 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01154ec:	83 ec 0c             	sub    $0xc,%esp
f01154ef:	ff 75 c4             	pushl  -0x3c(%ebp)
f01154f2:	ff 75 c8             	pushl  -0x38(%ebp)
f01154f5:	68 3c b3 12 f0       	push   $0xf012b33c
f01154fa:	68 95 06 00 00       	push   $0x695
f01154ff:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115504:	e8 ae af fe ff       	call   f01004b7 <_warn>
f0115509:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011550c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115510:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115514:	74 04                	je     f011551a <test_calculate_required_frames+0x55f>
f0115516:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011551a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f011551e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115521:	c1 e0 0a             	shl    $0xa,%eax
f0115524:	83 ec 04             	sub    $0x4,%esp
f0115527:	50                   	push   %eax
f0115528:	6a 00                	push   $0x0
f011552a:	ff 75 d8             	pushl  -0x28(%ebp)
f011552d:	e8 21 3f ff ff       	call   f0109453 <calculate_required_frames>
f0115532:	83 c4 10             	add    $0x10,%esp
f0115535:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115538:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011553b:	c1 e0 0a             	shl    $0xa,%eax
f011553e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115541:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115548:	99                   	cltd   
f0115549:	f7 fb                	idiv   %ebx
f011554b:	89 c1                	mov    %eax,%ecx
f011554d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115550:	c1 e0 0a             	shl    $0xa,%eax
f0115553:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115556:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011555d:	99                   	cltd   
f011555e:	f7 fe                	idiv   %esi
f0115560:	01 c8                	add    %ecx,%eax
f0115562:	83 e8 05             	sub    $0x5,%eax
f0115565:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115568:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011556b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011556e:	74 24                	je     f0115594 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115570:	83 ec 0c             	sub    $0xc,%esp
f0115573:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115576:	ff 75 c8             	pushl  -0x38(%ebp)
f0115579:	68 3c b3 12 f0       	push   $0xf012b33c
f011557e:	68 a0 06 00 00       	push   $0x6a0
f0115583:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115588:	e8 2a af fe ff       	call   f01004b7 <_warn>
f011558d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115590:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115594:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115598:	74 04                	je     f011559e <test_calculate_required_frames+0x5e3>
f011559a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011559e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f01155a2:	83 ec 04             	sub    $0x4,%esp
f01155a5:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01155ab:	50                   	push   %eax
f01155ac:	68 d4 b3 12 f0       	push   $0xf012b3d4
f01155b1:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01155b7:	50                   	push   %eax
f01155b8:	e8 f5 b4 00 00       	call   f0120ab2 <strcconcat>
f01155bd:	83 c4 10             	add    $0x10,%esp
f01155c0:	83 ec 0c             	sub    $0xc,%esp
f01155c3:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01155c9:	50                   	push   %eax
f01155ca:	e8 0d c9 fe ff       	call   f0101edc <execute_command>
f01155cf:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f01155d2:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01155d5:	89 c2                	mov    %eax,%edx
f01155d7:	01 d2                	add    %edx,%edx
f01155d9:	01 d0                	add    %edx,%eax
f01155db:	83 ec 04             	sub    $0x4,%esp
f01155de:	50                   	push   %eax
f01155df:	68 00 18 00 00       	push   $0x1800
f01155e4:	ff 75 d8             	pushl  -0x28(%ebp)
f01155e7:	e8 67 3e ff ff       	call   f0109453 <calculate_required_frames>
f01155ec:	83 c4 10             	add    $0x10,%esp
f01155ef:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f01155f2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f01155f9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01155fc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01155ff:	74 24                	je     f0115625 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115601:	83 ec 0c             	sub    $0xc,%esp
f0115604:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115607:	ff 75 c8             	pushl  -0x38(%ebp)
f011560a:	68 3c b3 12 f0       	push   $0xf012b33c
f011560f:	68 af 06 00 00       	push   $0x6af
f0115614:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115619:	e8 99 ae fe ff       	call   f01004b7 <_warn>
f011561e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115621:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115625:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115629:	74 04                	je     f011562f <test_calculate_required_frames+0x674>
f011562b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011562f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115633:	83 ec 04             	sub    $0x4,%esp
f0115636:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011563c:	50                   	push   %eax
f011563d:	68 94 a4 12 f0       	push   $0xf012a494
f0115642:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115648:	50                   	push   %eax
f0115649:	e8 64 b4 00 00       	call   f0120ab2 <strcconcat>
f011564e:	83 c4 10             	add    $0x10,%esp
f0115651:	83 ec 0c             	sub    $0xc,%esp
f0115654:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011565a:	50                   	push   %eax
f011565b:	e8 7c c8 fe ff       	call   f0101edc <execute_command>
f0115660:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115663:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115666:	89 d0                	mov    %edx,%eax
f0115668:	c1 e0 02             	shl    $0x2,%eax
f011566b:	01 d0                	add    %edx,%eax
f011566d:	01 c0                	add    %eax,%eax
f011566f:	83 ec 04             	sub    $0x4,%esp
f0115672:	50                   	push   %eax
f0115673:	68 00 00 40 00       	push   $0x400000
f0115678:	ff 75 d8             	pushl  -0x28(%ebp)
f011567b:	e8 d3 3d ff ff       	call   f0109453 <calculate_required_frames>
f0115680:	83 c4 10             	add    $0x10,%esp
f0115683:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115686:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f011568d:	74 26                	je     f01156b5 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f011568f:	83 ec 0c             	sub    $0xc,%esp
f0115692:	68 03 0a 00 00       	push   $0xa03
f0115697:	ff 75 c8             	pushl  -0x38(%ebp)
f011569a:	68 3c b3 12 f0       	push   $0xf012b33c
f011569f:	68 bb 06 00 00       	push   $0x6bb
f01156a4:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01156a9:	e8 09 ae fe ff       	call   f01004b7 <_warn>
f01156ae:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01156b1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01156b5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01156b9:	74 04                	je     f01156bf <test_calculate_required_frames+0x704>
f01156bb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01156bf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f01156c3:	83 ec 04             	sub    $0x4,%esp
f01156c6:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01156cc:	50                   	push   %eax
f01156cd:	68 9e a4 12 f0       	push   $0xf012a49e
f01156d2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01156d8:	50                   	push   %eax
f01156d9:	e8 d4 b3 00 00       	call   f0120ab2 <strcconcat>
f01156de:	83 c4 10             	add    $0x10,%esp
f01156e1:	83 ec 0c             	sub    $0xc,%esp
f01156e4:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f01156ea:	50                   	push   %eax
f01156eb:	e8 ec c7 fe ff       	call   f0101edc <execute_command>
f01156f0:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01156f3:	83 ec 04             	sub    $0x4,%esp
f01156f6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f01156fc:	50                   	push   %eax
f01156fd:	68 dc b3 12 f0       	push   $0xf012b3dc
f0115702:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115708:	50                   	push   %eax
f0115709:	e8 a4 b3 00 00       	call   f0120ab2 <strcconcat>
f011570e:	83 c4 10             	add    $0x10,%esp
f0115711:	83 ec 0c             	sub    $0xc,%esp
f0115714:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f011571a:	50                   	push   %eax
f011571b:	e8 bc c7 fe ff       	call   f0101edc <execute_command>
f0115720:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115723:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115726:	01 c0                	add    %eax,%eax
f0115728:	83 ec 04             	sub    $0x4,%esp
f011572b:	50                   	push   %eax
f011572c:	68 00 00 70 00       	push   $0x700000
f0115731:	ff 75 d8             	pushl  -0x28(%ebp)
f0115734:	e8 1a 3d ff ff       	call   f0109453 <calculate_required_frames>
f0115739:	83 c4 10             	add    $0x10,%esp
f011573c:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f011573f:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115746:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115749:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011574c:	74 24                	je     f0115772 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f011574e:	83 ec 0c             	sub    $0xc,%esp
f0115751:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115754:	ff 75 c8             	pushl  -0x38(%ebp)
f0115757:	68 3c b3 12 f0       	push   $0xf012b33c
f011575c:	68 cb 06 00 00       	push   $0x6cb
f0115761:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115766:	e8 4c ad fe ff       	call   f01004b7 <_warn>
f011576b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011576e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115772:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115776:	74 04                	je     f011577c <test_calculate_required_frames+0x7c1>
f0115778:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011577c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115780:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115783:	83 ec 04             	sub    $0x4,%esp
f0115786:	50                   	push   %eax
f0115787:	68 ff ff 3f 00       	push   $0x3fffff
f011578c:	ff 75 d8             	pushl  -0x28(%ebp)
f011578f:	e8 bf 3c ff ff       	call   f0109453 <calculate_required_frames>
f0115794:	83 c4 10             	add    $0x10,%esp
f0115797:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011579a:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f01157a1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01157a4:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01157a7:	74 24                	je     f01157cd <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f01157a9:	83 ec 0c             	sub    $0xc,%esp
f01157ac:	ff 75 c4             	pushl  -0x3c(%ebp)
f01157af:	ff 75 c8             	pushl  -0x38(%ebp)
f01157b2:	68 3c b3 12 f0       	push   $0xf012b33c
f01157b7:	68 d6 06 00 00       	push   $0x6d6
f01157bc:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01157c1:	e8 f1 ac fe ff       	call   f01004b7 <_warn>
f01157c6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01157c9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01157cd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01157d1:	74 04                	je     f01157d7 <test_calculate_required_frames+0x81c>
f01157d3:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01157d7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f01157db:	83 ec 0c             	sub    $0xc,%esp
f01157de:	68 4f a4 12 f0       	push   $0xf012a44f
f01157e3:	e8 84 b7 fe ff       	call   f0100f6c <cprintf>
f01157e8:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f01157eb:	83 ec 08             	sub    $0x8,%esp
f01157ee:	ff 75 e4             	pushl  -0x1c(%ebp)
f01157f1:	68 e8 b3 12 f0       	push   $0xf012b3e8
f01157f6:	e8 71 b7 fe ff       	call   f0100f6c <cprintf>
f01157fb:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01157fe:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0115802:	75 10                	jne    f0115814 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0115804:	83 ec 0c             	sub    $0xc,%esp
f0115807:	68 28 b4 12 f0       	push   $0xf012b428
f011580c:	e8 5b b7 fe ff       	call   f0100f6c <cprintf>
f0115811:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115814:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f0115819:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011581c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011581f:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0115822:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115827:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011582a:	5b                   	pop    %ebx
f011582b:	5e                   	pop    %esi
f011582c:	5f                   	pop    %edi
f011582d:	5d                   	pop    %ebp
f011582e:	c3                   	ret    

f011582f <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f011582f:	55                   	push   %ebp
f0115830:	89 e5                	mov    %esp,%ebp
f0115832:	57                   	push   %edi
f0115833:	56                   	push   %esi
f0115834:	53                   	push   %ebx
f0115835:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011583b:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011583e:	bb c4 a1 12 f0       	mov    $0xf012a1c4,%ebx
f0115843:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115848:	89 c7                	mov    %eax,%edi
f011584a:	89 de                	mov    %ebx,%esi
f011584c:	89 d1                	mov    %edx,%ecx
f011584e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0115850:	8d 55 9d             	lea    -0x63(%ebp),%edx
f0115853:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115858:	b0 00                	mov    $0x0,%al
f011585a:	89 d7                	mov    %edx,%edi
f011585c:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011585e:	6a 00                	push   $0x0
f0115860:	6a 0a                	push   $0xa
f0115862:	6a 14                	push   $0x14
f0115864:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115867:	50                   	push   %eax
f0115868:	e8 04 3f ff ff       	call   f0109771 <env_create>
f011586d:	83 c4 10             	add    $0x10,%esp
f0115870:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0115873:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115876:	8b 40 64             	mov    0x64(%eax),%eax
f0115879:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011587c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011587f:	8b 40 68             	mov    0x68(%eax),%eax
f0115882:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0115885:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115888:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011588b:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0115892:	75 70 20 
f0115895:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011589c:	00 00 00 
f011589f:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01158a2:	b9 03 00 00 00       	mov    $0x3,%ecx
f01158a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01158ac:	89 d7                	mov    %edx,%edi
f01158ae:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01158b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01158b3:	8b 40 10             	mov    0x10(%eax),%eax
f01158b6:	83 ec 08             	sub    $0x8,%esp
f01158b9:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01158bf:	52                   	push   %edx
f01158c0:	50                   	push   %eax
f01158c1:	e8 13 b1 00 00       	call   f01209d9 <ltostr>
f01158c6:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01158c9:	83 ec 04             	sub    $0x4,%esp
f01158cc:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158d2:	50                   	push   %eax
f01158d3:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01158d9:	50                   	push   %eax
f01158da:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01158e0:	50                   	push   %eax
f01158e1:	e8 cc b1 00 00       	call   f0120ab2 <strcconcat>
f01158e6:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f01158e9:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f01158f0:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f01158f7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f01158fe:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0115902:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115909:	00 00 00 
	uint32 num_tables = 0;
f011590c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115913:	00 00 00 
	ClearUserSpace(proc_directory);
f0115916:	83 ec 0c             	sub    $0xc,%esp
f0115919:	ff 75 d8             	pushl  -0x28(%ebp)
f011591c:	e8 d8 11 00 00       	call   f0116af9 <ClearUserSpace>
f0115921:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115924:	83 ec 0c             	sub    $0xc,%esp
f0115927:	68 08 b3 12 f0       	push   $0xf012b308
f011592c:	e8 3b b6 fe ff       	call   f0100f6c <cprintf>
f0115931:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115934:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115937:	c1 e0 03             	shl    $0x3,%eax
f011593a:	89 c2                	mov    %eax,%edx
f011593c:	83 ec 0c             	sub    $0xc,%esp
f011593f:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115945:	50                   	push   %eax
f0115946:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011594c:	50                   	push   %eax
f011594d:	52                   	push   %edx
f011594e:	6a 00                	push   $0x0
f0115950:	ff 75 d8             	pushl  -0x28(%ebp)
f0115953:	e8 e1 3a ff ff       	call   f0109439 <calculate_allocated_space>
f0115958:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011595b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115961:	85 c0                	test   %eax,%eax
f0115963:	74 27                	je     f011598c <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115965:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011596b:	83 ec 0c             	sub    $0xc,%esp
f011596e:	6a 00                	push   $0x0
f0115970:	50                   	push   %eax
f0115971:	68 74 b4 12 f0       	push   $0xf012b474
f0115976:	68 0b 07 00 00       	push   $0x70b
f011597b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115980:	e8 32 ab fe ff       	call   f01004b7 <_warn>
f0115985:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115988:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011598c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115992:	85 c0                	test   %eax,%eax
f0115994:	74 27                	je     f01159bd <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115996:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011599c:	83 ec 0c             	sub    $0xc,%esp
f011599f:	6a 00                	push   $0x0
f01159a1:	50                   	push   %eax
f01159a2:	68 d4 b4 12 f0       	push   $0xf012b4d4
f01159a7:	68 10 07 00 00       	push   $0x710
f01159ac:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01159b1:	e8 01 ab fe ff       	call   f01004b7 <_warn>
f01159b6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159b9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159bd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159c1:	74 04                	je     f01159c7 <test_calculate_allocated_space+0x198>
f01159c3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159c7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f01159cb:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01159d2:	00 00 00 
		num_pages = 0;
f01159d5:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01159dc:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f01159df:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01159e2:	c1 e0 02             	shl    $0x2,%eax
f01159e5:	89 c2                	mov    %eax,%edx
f01159e7:	83 ec 0c             	sub    $0xc,%esp
f01159ea:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01159f0:	50                   	push   %eax
f01159f1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01159f7:	50                   	push   %eax
f01159f8:	52                   	push   %edx
f01159f9:	6a 00                	push   $0x0
f01159fb:	ff 75 d8             	pushl  -0x28(%ebp)
f01159fe:	e8 36 3a ff ff       	call   f0109439 <calculate_allocated_space>
f0115a03:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115a06:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a0c:	85 c0                	test   %eax,%eax
f0115a0e:	74 27                	je     f0115a37 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115a10:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115a16:	83 ec 0c             	sub    $0xc,%esp
f0115a19:	6a 00                	push   $0x0
f0115a1b:	50                   	push   %eax
f0115a1c:	68 74 b4 12 f0       	push   $0xf012b474
f0115a21:	68 1c 07 00 00       	push   $0x71c
f0115a26:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115a2b:	e8 87 aa fe ff       	call   f01004b7 <_warn>
f0115a30:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a33:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115a37:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a3d:	85 c0                	test   %eax,%eax
f0115a3f:	74 27                	je     f0115a68 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115a41:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115a47:	83 ec 0c             	sub    $0xc,%esp
f0115a4a:	6a 00                	push   $0x0
f0115a4c:	50                   	push   %eax
f0115a4d:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115a52:	68 21 07 00 00       	push   $0x721
f0115a57:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115a5c:	e8 56 aa fe ff       	call   f01004b7 <_warn>
f0115a61:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a64:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a68:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a6c:	74 04                	je     f0115a72 <test_calculate_allocated_space+0x243>
f0115a6e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a72:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0115a76:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115a7d:	00 00 00 
		num_pages = 0;
f0115a80:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115a87:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0115a8a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a8d:	c1 e0 0a             	shl    $0xa,%eax
f0115a90:	89 c2                	mov    %eax,%edx
f0115a92:	83 ec 0c             	sub    $0xc,%esp
f0115a95:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115a9b:	50                   	push   %eax
f0115a9c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115aa2:	50                   	push   %eax
f0115aa3:	52                   	push   %edx
f0115aa4:	6a 00                	push   $0x0
f0115aa6:	ff 75 d8             	pushl  -0x28(%ebp)
f0115aa9:	e8 8b 39 ff ff       	call   f0109439 <calculate_allocated_space>
f0115aae:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115ab1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ab7:	85 c0                	test   %eax,%eax
f0115ab9:	74 27                	je     f0115ae2 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115abb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ac1:	83 ec 0c             	sub    $0xc,%esp
f0115ac4:	6a 00                	push   $0x0
f0115ac6:	50                   	push   %eax
f0115ac7:	68 74 b4 12 f0       	push   $0xf012b474
f0115acc:	68 2d 07 00 00       	push   $0x72d
f0115ad1:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115ad6:	e8 dc a9 fe ff       	call   f01004b7 <_warn>
f0115adb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ade:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115ae2:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ae8:	85 c0                	test   %eax,%eax
f0115aea:	74 27                	je     f0115b13 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115aec:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115af2:	83 ec 0c             	sub    $0xc,%esp
f0115af5:	6a 00                	push   $0x0
f0115af7:	50                   	push   %eax
f0115af8:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115afd:	68 32 07 00 00       	push   $0x732
f0115b02:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115b07:	e8 ab a9 fe ff       	call   f01004b7 <_warn>
f0115b0c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b0f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b13:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b17:	74 04                	je     f0115b1d <test_calculate_allocated_space+0x2ee>
f0115b19:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b1d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f0115b21:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115b28:	00 00 00 
		num_pages = 0;
f0115b2b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115b32:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f0115b35:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115b38:	89 d0                	mov    %edx,%eax
f0115b3a:	01 c0                	add    %eax,%eax
f0115b3c:	01 d0                	add    %edx,%eax
f0115b3e:	01 c0                	add    %eax,%eax
f0115b40:	05 00 10 00 00       	add    $0x1000,%eax
f0115b45:	89 c2                	mov    %eax,%edx
f0115b47:	83 ec 0c             	sub    $0xc,%esp
f0115b4a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115b50:	50                   	push   %eax
f0115b51:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115b57:	50                   	push   %eax
f0115b58:	52                   	push   %edx
f0115b59:	68 00 10 00 00       	push   $0x1000
f0115b5e:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b61:	e8 d3 38 ff ff       	call   f0109439 <calculate_allocated_space>
f0115b66:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115b69:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b6f:	85 c0                	test   %eax,%eax
f0115b71:	74 27                	je     f0115b9a <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115b73:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115b79:	83 ec 0c             	sub    $0xc,%esp
f0115b7c:	6a 00                	push   $0x0
f0115b7e:	50                   	push   %eax
f0115b7f:	68 74 b4 12 f0       	push   $0xf012b474
f0115b84:	68 3f 07 00 00       	push   $0x73f
f0115b89:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115b8e:	e8 24 a9 fe ff       	call   f01004b7 <_warn>
f0115b93:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b96:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115b9a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115ba0:	85 c0                	test   %eax,%eax
f0115ba2:	74 27                	je     f0115bcb <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115ba4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115baa:	83 ec 0c             	sub    $0xc,%esp
f0115bad:	6a 00                	push   $0x0
f0115baf:	50                   	push   %eax
f0115bb0:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115bb5:	68 44 07 00 00       	push   $0x744
f0115bba:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115bbf:	e8 f3 a8 fe ff       	call   f01004b7 <_warn>
f0115bc4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115bc7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115bcb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bcf:	74 04                	je     f0115bd5 <test_calculate_allocated_space+0x3a6>
f0115bd1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115bd5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0115bd9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115be0:	00 00 00 
		num_pages = 0;
f0115be3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115bea:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0115bed:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115bf0:	89 c2                	mov    %eax,%edx
f0115bf2:	01 d2                	add    %edx,%edx
f0115bf4:	01 d0                	add    %edx,%eax
f0115bf6:	05 00 18 00 00       	add    $0x1800,%eax
f0115bfb:	89 c2                	mov    %eax,%edx
f0115bfd:	83 ec 0c             	sub    $0xc,%esp
f0115c00:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115c06:	50                   	push   %eax
f0115c07:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115c0d:	50                   	push   %eax
f0115c0e:	52                   	push   %edx
f0115c0f:	68 00 18 00 00       	push   $0x1800
f0115c14:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c17:	e8 1d 38 ff ff       	call   f0109439 <calculate_allocated_space>
f0115c1c:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115c1f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c25:	85 c0                	test   %eax,%eax
f0115c27:	74 27                	je     f0115c50 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115c29:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115c2f:	83 ec 0c             	sub    $0xc,%esp
f0115c32:	6a 00                	push   $0x0
f0115c34:	50                   	push   %eax
f0115c35:	68 74 b4 12 f0       	push   $0xf012b474
f0115c3a:	68 50 07 00 00       	push   $0x750
f0115c3f:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115c44:	e8 6e a8 fe ff       	call   f01004b7 <_warn>
f0115c49:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c4c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115c50:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c56:	85 c0                	test   %eax,%eax
f0115c58:	74 27                	je     f0115c81 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115c5a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115c60:	83 ec 0c             	sub    $0xc,%esp
f0115c63:	6a 00                	push   $0x0
f0115c65:	50                   	push   %eax
f0115c66:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115c6b:	68 55 07 00 00       	push   $0x755
f0115c70:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115c75:	e8 3d a8 fe ff       	call   f01004b7 <_warn>
f0115c7a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c7d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115c81:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c85:	74 04                	je     f0115c8b <test_calculate_allocated_space+0x45c>
f0115c87:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115c8b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f0115c8f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115c96:	00 00 00 
		num_pages = 0;
f0115c99:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115ca0:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0115ca3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115ca6:	89 d0                	mov    %edx,%eax
f0115ca8:	c1 e0 02             	shl    $0x2,%eax
f0115cab:	01 d0                	add    %edx,%eax
f0115cad:	01 c0                	add    %eax,%eax
f0115caf:	05 00 00 40 00       	add    $0x400000,%eax
f0115cb4:	89 c2                	mov    %eax,%edx
f0115cb6:	83 ec 0c             	sub    $0xc,%esp
f0115cb9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115cbf:	50                   	push   %eax
f0115cc0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115cc6:	50                   	push   %eax
f0115cc7:	52                   	push   %edx
f0115cc8:	68 00 00 40 00       	push   $0x400000
f0115ccd:	ff 75 d8             	pushl  -0x28(%ebp)
f0115cd0:	e8 64 37 ff ff       	call   f0109439 <calculate_allocated_space>
f0115cd5:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115cd8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115cde:	85 c0                	test   %eax,%eax
f0115ce0:	74 27                	je     f0115d09 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115ce2:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115ce8:	83 ec 0c             	sub    $0xc,%esp
f0115ceb:	6a 00                	push   $0x0
f0115ced:	50                   	push   %eax
f0115cee:	68 74 b4 12 f0       	push   $0xf012b474
f0115cf3:	68 61 07 00 00       	push   $0x761
f0115cf8:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115cfd:	e8 b5 a7 fe ff       	call   f01004b7 <_warn>
f0115d02:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d05:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115d09:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d0f:	85 c0                	test   %eax,%eax
f0115d11:	74 27                	je     f0115d3a <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115d13:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115d19:	83 ec 0c             	sub    $0xc,%esp
f0115d1c:	6a 00                	push   $0x0
f0115d1e:	50                   	push   %eax
f0115d1f:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115d24:	68 66 07 00 00       	push   $0x766
f0115d29:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115d2e:	e8 84 a7 fe ff       	call   f01004b7 <_warn>
f0115d33:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d36:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115d3a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115d3e:	74 04                	je     f0115d44 <test_calculate_allocated_space+0x515>
f0115d40:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115d44:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f0115d48:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115d4f:	00 00 00 
		num_pages = 0;
f0115d52:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115d59:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0115d5c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d5f:	05 00 00 38 00       	add    $0x380000,%eax
f0115d64:	01 c0                	add    %eax,%eax
f0115d66:	89 c2                	mov    %eax,%edx
f0115d68:	83 ec 0c             	sub    $0xc,%esp
f0115d6b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115d71:	50                   	push   %eax
f0115d72:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115d78:	50                   	push   %eax
f0115d79:	52                   	push   %edx
f0115d7a:	68 00 00 70 00       	push   $0x700000
f0115d7f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d82:	e8 b2 36 ff ff       	call   f0109439 <calculate_allocated_space>
f0115d87:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115d8a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d90:	85 c0                	test   %eax,%eax
f0115d92:	74 27                	je     f0115dbb <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115d94:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115d9a:	83 ec 0c             	sub    $0xc,%esp
f0115d9d:	6a 00                	push   $0x0
f0115d9f:	50                   	push   %eax
f0115da0:	68 74 b4 12 f0       	push   $0xf012b474
f0115da5:	68 73 07 00 00       	push   $0x773
f0115daa:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115daf:	e8 03 a7 fe ff       	call   f01004b7 <_warn>
f0115db4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115db7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115dbb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115dc1:	85 c0                	test   %eax,%eax
f0115dc3:	74 27                	je     f0115dec <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115dc5:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115dcb:	83 ec 0c             	sub    $0xc,%esp
f0115dce:	6a 00                	push   $0x0
f0115dd0:	50                   	push   %eax
f0115dd1:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115dd6:	68 78 07 00 00       	push   $0x778
f0115ddb:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115de0:	e8 d2 a6 fe ff       	call   f01004b7 <_warn>
f0115de5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115de8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115dec:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115df0:	74 04                	je     f0115df6 <test_calculate_allocated_space+0x5c7>
f0115df2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115df6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f0115dfa:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115e01:	00 00 00 
		num_pages = 0;
f0115e04:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115e0b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0115e0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e11:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0115e16:	89 c2                	mov    %eax,%edx
f0115e18:	83 ec 0c             	sub    $0xc,%esp
f0115e1b:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115e21:	50                   	push   %eax
f0115e22:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115e28:	50                   	push   %eax
f0115e29:	52                   	push   %edx
f0115e2a:	68 ff ff 3f 00       	push   $0x3fffff
f0115e2f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e32:	e8 02 36 ff ff       	call   f0109439 <calculate_allocated_space>
f0115e37:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0115e3a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e40:	85 c0                	test   %eax,%eax
f0115e42:	74 27                	je     f0115e6b <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0115e44:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115e4a:	83 ec 0c             	sub    $0xc,%esp
f0115e4d:	6a 00                	push   $0x0
f0115e4f:	50                   	push   %eax
f0115e50:	68 74 b4 12 f0       	push   $0xf012b474
f0115e55:	68 84 07 00 00       	push   $0x784
f0115e5a:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115e5f:	e8 53 a6 fe ff       	call   f01004b7 <_warn>
f0115e64:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e67:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0115e6b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e71:	85 c0                	test   %eax,%eax
f0115e73:	74 27                	je     f0115e9c <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0115e75:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115e7b:	83 ec 0c             	sub    $0xc,%esp
f0115e7e:	6a 00                	push   $0x0
f0115e80:	50                   	push   %eax
f0115e81:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115e86:	68 89 07 00 00       	push   $0x789
f0115e8b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115e90:	e8 22 a6 fe ff       	call   f01004b7 <_warn>
f0115e95:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e98:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115e9c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ea0:	74 04                	je     f0115ea6 <test_calculate_allocated_space+0x677>
f0115ea2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115ea6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115eaa:	83 ec 0c             	sub    $0xc,%esp
f0115ead:	68 75 ae 12 f0       	push   $0xf012ae75
f0115eb2:	e8 b5 b0 fe ff       	call   f0100f6c <cprintf>
f0115eb7:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115eba:	83 ec 0c             	sub    $0xc,%esp
f0115ebd:	68 94 b3 12 f0       	push   $0xf012b394
f0115ec2:	e8 a5 b0 fe ff       	call   f0100f6c <cprintf>
f0115ec7:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115eca:	83 ec 04             	sub    $0x4,%esp
f0115ecd:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115ed3:	50                   	push   %eax
f0115ed4:	68 2e a2 12 f0       	push   $0xf012a22e
f0115ed9:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115edf:	50                   	push   %eax
f0115ee0:	e8 cd ab 00 00       	call   f0120ab2 <strcconcat>
f0115ee5:	83 c4 10             	add    $0x10,%esp
f0115ee8:	83 ec 0c             	sub    $0xc,%esp
f0115eeb:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0115ef1:	50                   	push   %eax
f0115ef2:	e8 e5 bf fe ff       	call   f0101edc <execute_command>
f0115ef7:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f0115efa:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0115f01:	00 00 00 
		num_pages = 0;
f0115f04:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0115f0b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f0115f0e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115f11:	c1 e0 03             	shl    $0x3,%eax
f0115f14:	89 c2                	mov    %eax,%edx
f0115f16:	83 ec 0c             	sub    $0xc,%esp
f0115f19:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0115f1f:	50                   	push   %eax
f0115f20:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0115f26:	50                   	push   %eax
f0115f27:	52                   	push   %edx
f0115f28:	6a 00                	push   $0x0
f0115f2a:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f2d:	e8 07 35 ff ff       	call   f0109439 <calculate_allocated_space>
f0115f32:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0115f35:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f0115f3c:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0115f43:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f49:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115f4c:	74 28                	je     f0115f76 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0115f4e:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0115f54:	83 ec 0c             	sub    $0xc,%esp
f0115f57:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f5a:	50                   	push   %eax
f0115f5b:	68 74 b4 12 f0       	push   $0xf012b474
f0115f60:	68 a0 07 00 00       	push   $0x7a0
f0115f65:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115f6a:	e8 48 a5 fe ff       	call   f01004b7 <_warn>
f0115f6f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f72:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0115f76:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f7c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115f7f:	74 28                	je     f0115fa9 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0115f81:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0115f87:	83 ec 0c             	sub    $0xc,%esp
f0115f8a:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115f8d:	50                   	push   %eax
f0115f8e:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0115f93:	68 a5 07 00 00       	push   $0x7a5
f0115f98:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0115f9d:	e8 15 a5 fe ff       	call   f01004b7 <_warn>
f0115fa2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115fa5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115fa9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115fad:	74 04                	je     f0115fb3 <test_calculate_allocated_space+0x784>
f0115faf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115fb3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115fb7:	83 ec 04             	sub    $0x4,%esp
f0115fba:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115fc0:	50                   	push   %eax
f0115fc1:	68 3b a2 12 f0       	push   $0xf012a23b
f0115fc6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115fcc:	50                   	push   %eax
f0115fcd:	e8 e0 aa 00 00       	call   f0120ab2 <strcconcat>
f0115fd2:	83 c4 10             	add    $0x10,%esp
f0115fd5:	83 ec 0c             	sub    $0xc,%esp
f0115fd8:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0115fde:	50                   	push   %eax
f0115fdf:	e8 f8 be fe ff       	call   f0101edc <execute_command>
f0115fe4:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115fe7:	83 ec 04             	sub    $0x4,%esp
f0115fea:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0115ff0:	50                   	push   %eax
f0115ff1:	68 c8 b3 12 f0       	push   $0xf012b3c8
f0115ff6:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115ffc:	50                   	push   %eax
f0115ffd:	e8 b0 aa 00 00       	call   f0120ab2 <strcconcat>
f0116002:	83 c4 10             	add    $0x10,%esp
f0116005:	83 ec 0c             	sub    $0xc,%esp
f0116008:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011600e:	50                   	push   %eax
f011600f:	e8 c8 be fe ff       	call   f0101edc <execute_command>
f0116014:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f0116017:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011601e:	00 00 00 
		num_pages = 0;
f0116021:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116028:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f011602b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011602e:	c1 e0 03             	shl    $0x3,%eax
f0116031:	89 c2                	mov    %eax,%edx
f0116033:	83 ec 0c             	sub    $0xc,%esp
f0116036:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011603c:	50                   	push   %eax
f011603d:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116043:	50                   	push   %eax
f0116044:	52                   	push   %edx
f0116045:	6a 00                	push   $0x0
f0116047:	ff 75 d8             	pushl  -0x28(%ebp)
f011604a:	e8 ea 33 ff ff       	call   f0109439 <calculate_allocated_space>
f011604f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f0116052:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f0116059:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116060:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116066:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116069:	74 28                	je     f0116093 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011606b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116071:	83 ec 0c             	sub    $0xc,%esp
f0116074:	ff 75 c8             	pushl  -0x38(%ebp)
f0116077:	50                   	push   %eax
f0116078:	68 74 b4 12 f0       	push   $0xf012b474
f011607d:	68 b6 07 00 00       	push   $0x7b6
f0116082:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116087:	e8 2b a4 fe ff       	call   f01004b7 <_warn>
f011608c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011608f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116093:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116099:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011609c:	74 28                	je     f01160c6 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011609e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01160a4:	83 ec 0c             	sub    $0xc,%esp
f01160a7:	ff 75 c4             	pushl  -0x3c(%ebp)
f01160aa:	50                   	push   %eax
f01160ab:	68 d4 b4 12 f0       	push   $0xf012b4d4
f01160b0:	68 bb 07 00 00       	push   $0x7bb
f01160b5:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01160ba:	e8 f8 a3 fe ff       	call   f01004b7 <_warn>
f01160bf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01160c2:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01160c6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01160ca:	74 04                	je     f01160d0 <test_calculate_allocated_space+0x8a1>
f01160cc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01160d0:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f01160d4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01160db:	00 00 00 
		num_pages = 0;
f01160de:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01160e5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f01160e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01160eb:	c1 e0 0a             	shl    $0xa,%eax
f01160ee:	89 c2                	mov    %eax,%edx
f01160f0:	83 ec 0c             	sub    $0xc,%esp
f01160f3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01160f9:	50                   	push   %eax
f01160fa:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116100:	50                   	push   %eax
f0116101:	52                   	push   %edx
f0116102:	6a 00                	push   $0x0
f0116104:	ff 75 d8             	pushl  -0x28(%ebp)
f0116107:	e8 2d 33 ff ff       	call   f0109439 <calculate_allocated_space>
f011610c:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f011610f:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f0116116:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f011611d:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116123:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116126:	74 28                	je     f0116150 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116128:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011612e:	83 ec 0c             	sub    $0xc,%esp
f0116131:	ff 75 c8             	pushl  -0x38(%ebp)
f0116134:	50                   	push   %eax
f0116135:	68 74 b4 12 f0       	push   $0xf012b474
f011613a:	68 c9 07 00 00       	push   $0x7c9
f011613f:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116144:	e8 6e a3 fe ff       	call   f01004b7 <_warn>
f0116149:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011614c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116150:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116156:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116159:	74 28                	je     f0116183 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011615b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116161:	83 ec 0c             	sub    $0xc,%esp
f0116164:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116167:	50                   	push   %eax
f0116168:	68 d4 b4 12 f0       	push   $0xf012b4d4
f011616d:	68 ce 07 00 00       	push   $0x7ce
f0116172:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116177:	e8 3b a3 fe ff       	call   f01004b7 <_warn>
f011617c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011617f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116183:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116187:	74 04                	je     f011618d <test_calculate_allocated_space+0x95e>
f0116189:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011618d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116191:	83 ec 04             	sub    $0x4,%esp
f0116194:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011619a:	50                   	push   %eax
f011619b:	68 d4 b3 12 f0       	push   $0xf012b3d4
f01161a0:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01161a6:	50                   	push   %eax
f01161a7:	e8 06 a9 00 00       	call   f0120ab2 <strcconcat>
f01161ac:	83 c4 10             	add    $0x10,%esp
f01161af:	83 ec 0c             	sub    $0xc,%esp
f01161b2:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01161b8:	50                   	push   %eax
f01161b9:	e8 1e bd fe ff       	call   f0101edc <execute_command>
f01161be:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f01161c1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01161c8:	00 00 00 
		num_pages = 0;
f01161cb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01161d2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f01161d5:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01161d8:	89 c2                	mov    %eax,%edx
f01161da:	01 d2                	add    %edx,%edx
f01161dc:	01 d0                	add    %edx,%eax
f01161de:	05 00 18 00 00       	add    $0x1800,%eax
f01161e3:	89 c2                	mov    %eax,%edx
f01161e5:	83 ec 0c             	sub    $0xc,%esp
f01161e8:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01161ee:	50                   	push   %eax
f01161ef:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01161f5:	50                   	push   %eax
f01161f6:	52                   	push   %edx
f01161f7:	68 00 18 00 00       	push   $0x1800
f01161fc:	ff 75 d8             	pushl  -0x28(%ebp)
f01161ff:	e8 35 32 ff ff       	call   f0109439 <calculate_allocated_space>
f0116204:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116207:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f011620e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116215:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011621b:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011621e:	74 28                	je     f0116248 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116220:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116226:	83 ec 0c             	sub    $0xc,%esp
f0116229:	ff 75 c8             	pushl  -0x38(%ebp)
f011622c:	50                   	push   %eax
f011622d:	68 74 b4 12 f0       	push   $0xf012b474
f0116232:	68 df 07 00 00       	push   $0x7df
f0116237:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011623c:	e8 76 a2 fe ff       	call   f01004b7 <_warn>
f0116241:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116244:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116248:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011624e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116251:	74 28                	je     f011627b <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116253:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116259:	83 ec 0c             	sub    $0xc,%esp
f011625c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011625f:	50                   	push   %eax
f0116260:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0116265:	68 e4 07 00 00       	push   $0x7e4
f011626a:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011626f:	e8 43 a2 fe ff       	call   f01004b7 <_warn>
f0116274:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116277:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011627b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011627f:	74 04                	je     f0116285 <test_calculate_allocated_space+0xa56>
f0116281:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116285:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116289:	83 ec 04             	sub    $0x4,%esp
f011628c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116292:	50                   	push   %eax
f0116293:	68 94 a4 12 f0       	push   $0xf012a494
f0116298:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011629e:	50                   	push   %eax
f011629f:	e8 0e a8 00 00       	call   f0120ab2 <strcconcat>
f01162a4:	83 c4 10             	add    $0x10,%esp
f01162a7:	83 ec 0c             	sub    $0xc,%esp
f01162aa:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01162b0:	50                   	push   %eax
f01162b1:	e8 26 bc fe ff       	call   f0101edc <execute_command>
f01162b6:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f01162b9:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01162c0:	00 00 00 
		num_pages = 0;
f01162c3:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01162ca:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f01162cd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01162d0:	89 d0                	mov    %edx,%eax
f01162d2:	c1 e0 02             	shl    $0x2,%eax
f01162d5:	01 d0                	add    %edx,%eax
f01162d7:	01 c0                	add    %eax,%eax
f01162d9:	05 00 00 40 00       	add    $0x400000,%eax
f01162de:	89 c2                	mov    %eax,%edx
f01162e0:	83 ec 0c             	sub    $0xc,%esp
f01162e3:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01162e9:	50                   	push   %eax
f01162ea:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01162f0:	50                   	push   %eax
f01162f1:	52                   	push   %edx
f01162f2:	68 00 00 40 00       	push   $0x400000
f01162f7:	ff 75 d8             	pushl  -0x28(%ebp)
f01162fa:	e8 3a 31 ff ff       	call   f0109439 <calculate_allocated_space>
f01162ff:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116302:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116309:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116310:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116316:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116319:	74 28                	je     f0116343 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011631b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116321:	83 ec 0c             	sub    $0xc,%esp
f0116324:	ff 75 c8             	pushl  -0x38(%ebp)
f0116327:	50                   	push   %eax
f0116328:	68 74 b4 12 f0       	push   $0xf012b474
f011632d:	68 f4 07 00 00       	push   $0x7f4
f0116332:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116337:	e8 7b a1 fe ff       	call   f01004b7 <_warn>
f011633c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011633f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116343:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116349:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011634c:	74 28                	je     f0116376 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011634e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116354:	83 ec 0c             	sub    $0xc,%esp
f0116357:	ff 75 c4             	pushl  -0x3c(%ebp)
f011635a:	50                   	push   %eax
f011635b:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0116360:	68 f9 07 00 00       	push   $0x7f9
f0116365:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011636a:	e8 48 a1 fe ff       	call   f01004b7 <_warn>
f011636f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116372:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116376:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011637a:	74 04                	je     f0116380 <test_calculate_allocated_space+0xb51>
f011637c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116380:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116384:	83 ec 04             	sub    $0x4,%esp
f0116387:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011638d:	50                   	push   %eax
f011638e:	68 9e a4 12 f0       	push   $0xf012a49e
f0116393:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116399:	50                   	push   %eax
f011639a:	e8 13 a7 00 00       	call   f0120ab2 <strcconcat>
f011639f:	83 c4 10             	add    $0x10,%esp
f01163a2:	83 ec 0c             	sub    $0xc,%esp
f01163a5:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f01163ab:	50                   	push   %eax
f01163ac:	e8 2b bb fe ff       	call   f0101edc <execute_command>
f01163b1:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f01163b4:	83 ec 04             	sub    $0x4,%esp
f01163b7:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01163bd:	50                   	push   %eax
f01163be:	68 dc b3 12 f0       	push   $0xf012b3dc
f01163c3:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01163c9:	50                   	push   %eax
f01163ca:	e8 e3 a6 00 00       	call   f0120ab2 <strcconcat>
f01163cf:	83 c4 10             	add    $0x10,%esp
f01163d2:	83 ec 0c             	sub    $0xc,%esp
f01163d5:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f01163db:	50                   	push   %eax
f01163dc:	e8 fb ba fe ff       	call   f0101edc <execute_command>
f01163e1:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f01163e4:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01163eb:	00 00 00 
		num_pages = 0;
f01163ee:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01163f5:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01163f8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01163fb:	05 00 00 38 00       	add    $0x380000,%eax
f0116400:	01 c0                	add    %eax,%eax
f0116402:	89 c2                	mov    %eax,%edx
f0116404:	83 ec 0c             	sub    $0xc,%esp
f0116407:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011640d:	50                   	push   %eax
f011640e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116414:	50                   	push   %eax
f0116415:	52                   	push   %edx
f0116416:	68 00 00 70 00       	push   $0x700000
f011641b:	ff 75 d8             	pushl  -0x28(%ebp)
f011641e:	e8 16 30 ff ff       	call   f0109439 <calculate_allocated_space>
f0116423:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116426:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f011642d:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116434:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011643a:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f011643d:	74 28                	je     f0116467 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f011643f:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116445:	83 ec 0c             	sub    $0xc,%esp
f0116448:	ff 75 c8             	pushl  -0x38(%ebp)
f011644b:	50                   	push   %eax
f011644c:	68 74 b4 12 f0       	push   $0xf012b474
f0116451:	68 0b 08 00 00       	push   $0x80b
f0116456:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011645b:	e8 57 a0 fe ff       	call   f01004b7 <_warn>
f0116460:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116463:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116467:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011646d:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116470:	74 28                	je     f011649a <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116472:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116478:	83 ec 0c             	sub    $0xc,%esp
f011647b:	ff 75 c4             	pushl  -0x3c(%ebp)
f011647e:	50                   	push   %eax
f011647f:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0116484:	68 10 08 00 00       	push   $0x810
f0116489:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011648e:	e8 24 a0 fe ff       	call   f01004b7 <_warn>
f0116493:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116496:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011649a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011649e:	74 04                	je     f01164a4 <test_calculate_allocated_space+0xc75>
f01164a0:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01164a4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f01164a8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01164af:	00 00 00 
		num_pages = 0;
f01164b2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01164b9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f01164bc:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01164bf:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01164c4:	89 c2                	mov    %eax,%edx
f01164c6:	83 ec 0c             	sub    $0xc,%esp
f01164c9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01164cf:	50                   	push   %eax
f01164d0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01164d6:	50                   	push   %eax
f01164d7:	52                   	push   %edx
f01164d8:	68 ff ff 3f 00       	push   $0x3fffff
f01164dd:	ff 75 d8             	pushl  -0x28(%ebp)
f01164e0:	e8 54 2f ff ff       	call   f0109439 <calculate_allocated_space>
f01164e5:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f01164e8:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f01164ef:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01164f6:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164fc:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01164ff:	74 28                	je     f0116529 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116501:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116507:	83 ec 0c             	sub    $0xc,%esp
f011650a:	ff 75 c8             	pushl  -0x38(%ebp)
f011650d:	50                   	push   %eax
f011650e:	68 74 b4 12 f0       	push   $0xf012b474
f0116513:	68 1e 08 00 00       	push   $0x81e
f0116518:	68 c2 9a 12 f0       	push   $0xf0129ac2
f011651d:	e8 95 9f fe ff       	call   f01004b7 <_warn>
f0116522:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116525:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116529:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011652f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116532:	74 28                	je     f011655c <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116534:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011653a:	83 ec 0c             	sub    $0xc,%esp
f011653d:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116540:	50                   	push   %eax
f0116541:	68 d4 b4 12 f0       	push   $0xf012b4d4
f0116546:	68 23 08 00 00       	push   $0x823
f011654b:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116550:	e8 62 9f fe ff       	call   f01004b7 <_warn>
f0116555:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116558:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011655c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116560:	74 04                	je     f0116566 <test_calculate_allocated_space+0xd37>
f0116562:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116566:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011656a:	83 ec 0c             	sub    $0xc,%esp
f011656d:	68 4f a4 12 f0       	push   $0xf012a44f
f0116572:	e8 f5 a9 fe ff       	call   f0100f6c <cprintf>
f0116577:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f011657a:	83 ec 08             	sub    $0x8,%esp
f011657d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116580:	68 30 b5 12 f0       	push   $0xf012b530
f0116585:	e8 e2 a9 fe ff       	call   f0100f6c <cprintf>
f011658a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011658d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116591:	75 10                	jne    f01165a3 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116593:	83 ec 0c             	sub    $0xc,%esp
f0116596:	68 70 b5 12 f0       	push   $0xf012b570
f011659b:	e8 cc a9 fe ff       	call   f0100f6c <cprintf>
f01165a0:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01165a3:	a1 e4 51 55 f0       	mov    0xf05551e4,%eax
f01165a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01165ab:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01165ae:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01165b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01165b6:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01165b9:	5b                   	pop    %ebx
f01165ba:	5e                   	pop    %esi
f01165bb:	5f                   	pop    %edi
f01165bc:	5d                   	pop    %ebp
f01165bd:	c3                   	ret    

f01165be <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f01165be:	55                   	push   %ebp
f01165bf:	89 e5                	mov    %esp,%ebp
f01165c1:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f01165c4:	8b 45 10             	mov    0x10(%ebp),%eax
f01165c7:	ba 01 00 00 00       	mov    $0x1,%edx
f01165cc:	88 c1                	mov    %al,%cl
f01165ce:	d3 e2                	shl    %cl,%edx
f01165d0:	89 d0                	mov    %edx,%eax
f01165d2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01165d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01165d8:	c1 e8 16             	shr    $0x16,%eax
f01165db:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01165e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01165e5:	01 d0                	add    %edx,%eax
f01165e7:	8b 00                	mov    (%eax),%eax
f01165e9:	83 e0 01             	and    $0x1,%eax
f01165ec:	85 c0                	test   %eax,%eax
f01165ee:	75 07                	jne    f01165f7 <CB+0x39>
f01165f0:	b8 00 00 00 00       	mov    $0x0,%eax
f01165f5:	eb 76                	jmp    f011666d <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01165f7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01165fa:	c1 e8 16             	shr    $0x16,%eax
f01165fd:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116604:	8b 45 08             	mov    0x8(%ebp),%eax
f0116607:	01 d0                	add    %edx,%eax
f0116609:	8b 00                	mov    (%eax),%eax
f011660b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116610:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116613:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116616:	c1 e8 0c             	shr    $0xc,%eax
f0116619:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011661c:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0116621:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116624:	72 17                	jb     f011663d <CB+0x7f>
f0116626:	ff 75 f0             	pushl  -0x10(%ebp)
f0116629:	68 bc b5 12 f0       	push   $0xf012b5bc
f011662e:	68 3e 08 00 00       	push   $0x83e
f0116633:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116638:	e8 dd 9c fe ff       	call   f010031a <_panic>
f011663d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116640:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116645:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116648:	8b 45 0c             	mov    0xc(%ebp),%eax
f011664b:	c1 e8 0c             	shr    $0xc,%eax
f011664e:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116653:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011665a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011665d:	01 d0                	add    %edx,%eax
f011665f:	8b 00                	mov    (%eax),%eax
f0116661:	23 45 f4             	and    -0xc(%ebp),%eax
f0116664:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116667:	0f 94 c0             	sete   %al
f011666a:	0f b6 c0             	movzbl %al,%eax
}
f011666d:	c9                   	leave  
f011666e:	c3                   	ret    

f011666f <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f011666f:	55                   	push   %ebp
f0116670:	89 e5                	mov    %esp,%ebp
f0116672:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116675:	8b 45 10             	mov    0x10(%ebp),%eax
f0116678:	ba 01 00 00 00       	mov    $0x1,%edx
f011667d:	88 c1                	mov    %al,%cl
f011667f:	d3 e2                	shl    %cl,%edx
f0116681:	89 d0                	mov    %edx,%eax
f0116683:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116686:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116689:	c1 e8 16             	shr    $0x16,%eax
f011668c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116693:	8b 45 08             	mov    0x8(%ebp),%eax
f0116696:	01 d0                	add    %edx,%eax
f0116698:	8b 00                	mov    (%eax),%eax
f011669a:	83 e0 01             	and    $0x1,%eax
f011669d:	85 c0                	test   %eax,%eax
f011669f:	75 0a                	jne    f01166ab <SB+0x3c>
f01166a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01166a6:	e9 cd 00 00 00       	jmp    f0116778 <SB+0x109>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01166ab:	8b 45 0c             	mov    0xc(%ebp),%eax
f01166ae:	c1 e8 16             	shr    $0x16,%eax
f01166b1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01166b8:	8b 45 08             	mov    0x8(%ebp),%eax
f01166bb:	01 d0                	add    %edx,%eax
f01166bd:	8b 00                	mov    (%eax),%eax
f01166bf:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01166c4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01166c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01166ca:	c1 e8 0c             	shr    $0xc,%eax
f01166cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01166d0:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01166d5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01166d8:	72 17                	jb     f01166f1 <SB+0x82>
f01166da:	ff 75 f0             	pushl  -0x10(%ebp)
f01166dd:	68 bc b5 12 f0       	push   $0xf012b5bc
f01166e2:	68 46 08 00 00       	push   $0x846
f01166e7:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01166ec:	e8 29 9c fe ff       	call   f010031a <_panic>
f01166f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01166f4:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01166f9:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
f01166fc:	83 7d 14 ff          	cmpl   $0xffffffff,0x14(%ebp)
f0116700:	74 3c                	je     f011673e <SB+0xcf>
f0116702:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116705:	c1 e8 0c             	shr    $0xc,%eax
f0116708:	25 ff 03 00 00       	and    $0x3ff,%eax
f011670d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116714:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116717:	01 d0                	add    %edx,%eax
f0116719:	8b 55 0c             	mov    0xc(%ebp),%edx
f011671c:	c1 ea 0c             	shr    $0xc,%edx
f011671f:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116725:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f011672c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011672f:	01 ca                	add    %ecx,%edx
f0116731:	8b 12                	mov    (%edx),%edx
f0116733:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0116736:	f7 d1                	not    %ecx
f0116738:	21 ca                	and    %ecx,%edx
f011673a:	89 10                	mov    %edx,(%eax)
f011673c:	eb 35                	jmp    f0116773 <SB+0x104>
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
f011673e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116741:	c1 e8 0c             	shr    $0xc,%eax
f0116744:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116749:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116750:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116753:	01 c2                	add    %eax,%edx
f0116755:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116758:	c1 e8 0c             	shr    $0xc,%eax
f011675b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116760:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0116767:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011676a:	01 c8                	add    %ecx,%eax
f011676c:	8b 00                	mov    (%eax),%eax
f011676e:	0b 45 f4             	or     -0xc(%ebp),%eax
f0116771:	89 02                	mov    %eax,(%edx)
	return 0;
f0116773:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116778:	c9                   	leave  
f0116779:	c3                   	ret    

f011677a <CPs>:
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f011677a:	55                   	push   %ebp
f011677b:	89 e5                	mov    %esp,%ebp
f011677d:	83 ec 28             	sub    $0x28,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116780:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116783:	c1 e8 16             	shr    $0x16,%eax
f0116786:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011678d:	8b 45 08             	mov    0x8(%ebp),%eax
f0116790:	01 d0                	add    %edx,%eax
f0116792:	8b 00                	mov    (%eax),%eax
f0116794:	83 e0 01             	and    $0x1,%eax
f0116797:	85 c0                	test   %eax,%eax
f0116799:	75 0a                	jne    f01167a5 <CPs+0x2b>
f011679b:	b8 00 00 00 00       	mov    $0x0,%eax
f01167a0:	e9 b8 00 00 00       	jmp    f011685d <CPs+0xe3>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f01167a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01167a8:	c1 e8 16             	shr    $0x16,%eax
f01167ab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01167b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01167b5:	01 d0                	add    %edx,%eax
f01167b7:	8b 00                	mov    (%eax),%eax
f01167b9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01167be:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01167c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01167c4:	c1 e8 0c             	shr    $0xc,%eax
f01167c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01167ca:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01167cf:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01167d2:	72 17                	jb     f01167eb <CPs+0x71>
f01167d4:	ff 75 f0             	pushl  -0x10(%ebp)
f01167d7:	68 bc b5 12 f0       	push   $0xf012b5bc
f01167dc:	68 4f 08 00 00       	push   $0x84f
f01167e1:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01167e6:	e8 2f 9b fe ff       	call   f010031a <_panic>
f01167eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01167ee:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01167f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	for (int i = 0 ; i < 12 ; i++)
f01167f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01167fd:	eb 53                	jmp    f0116852 <CPs+0xd8>
	{
		uint32 mask = 1<<i;
f01167ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116802:	ba 01 00 00 00       	mov    $0x1,%edx
f0116807:	88 c1                	mov    %al,%cl
f0116809:	d3 e2                	shl    %cl,%edx
f011680b:	89 d0                	mov    %edx,%eax
f011680d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (!(which & mask))	continue ;
f0116810:	8b 45 14             	mov    0x14(%ebp),%eax
f0116813:	23 45 e4             	and    -0x1c(%ebp),%eax
f0116816:	85 c0                	test   %eax,%eax
f0116818:	74 34                	je     f011684e <CPs+0xd4>
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
f011681a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011681d:	c1 e8 0c             	shr    $0xc,%eax
f0116820:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116825:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011682c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011682f:	01 d0                	add    %edx,%eax
f0116831:	8b 00                	mov    (%eax),%eax
f0116833:	33 45 10             	xor    0x10(%ebp),%eax
f0116836:	23 45 e4             	and    -0x1c(%ebp),%eax
f0116839:	85 c0                	test   %eax,%eax
f011683b:	0f 94 c0             	sete   %al
f011683e:	88 45 e3             	mov    %al,-0x1d(%ebp)
		if (!c) return 0;
f0116841:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116845:	75 08                	jne    f011684f <CPs+0xd5>
f0116847:	b8 00 00 00 00       	mov    $0x0,%eax
f011684c:	eb 0f                	jmp    f011685d <CPs+0xe3>
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
	{
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
f011684e:	90                   	nop
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	for (int i = 0 ; i < 12 ; i++)
f011684f:	ff 45 f4             	incl   -0xc(%ebp)
f0116852:	83 7d f4 0b          	cmpl   $0xb,-0xc(%ebp)
f0116856:	7e a7                	jle    f01167ff <CPs+0x85>
		uint32 mask = 1<<i;
		if (!(which & mask))	continue ;
		uint8 c = (table[((((uint32) (va)) >> 12) & 0x3FF)] & mask) == (perms & mask) ? 1 :  0;
		if (!c) return 0;
	}
	return 1;
f0116858:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011685d:	c9                   	leave  
f011685e:	c3                   	ret    

f011685f <CA>:

int CA(uint32 *ptr_dir, uint32 va)
{
f011685f:	55                   	push   %ebp
f0116860:	89 e5                	mov    %esp,%ebp
f0116862:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116865:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116868:	c1 e8 16             	shr    $0x16,%eax
f011686b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116872:	8b 45 08             	mov    0x8(%ebp),%eax
f0116875:	01 d0                	add    %edx,%eax
f0116877:	8b 00                	mov    (%eax),%eax
f0116879:	83 e0 01             	and    $0x1,%eax
f011687c:	85 c0                	test   %eax,%eax
f011687e:	75 07                	jne    f0116887 <CA+0x28>
f0116880:	b8 00 00 00 00       	mov    $0x0,%eax
f0116885:	eb 6f                	jmp    f01168f6 <CA+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116887:	8b 45 0c             	mov    0xc(%ebp),%eax
f011688a:	c1 e8 16             	shr    $0x16,%eax
f011688d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116894:	8b 45 08             	mov    0x8(%ebp),%eax
f0116897:	01 d0                	add    %edx,%eax
f0116899:	8b 00                	mov    (%eax),%eax
f011689b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01168a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01168a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01168a6:	c1 e8 0c             	shr    $0xc,%eax
f01168a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01168ac:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01168b1:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f01168b4:	72 17                	jb     f01168cd <CA+0x6e>
f01168b6:	ff 75 f4             	pushl  -0xc(%ebp)
f01168b9:	68 bc b5 12 f0       	push   $0xf012b5bc
f01168be:	68 5e 08 00 00       	push   $0x85e
f01168c3:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01168c8:	e8 4d 9a fe ff       	call   f010031a <_panic>
f01168cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01168d0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01168d5:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF;
f01168d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01168db:	c1 e8 0c             	shr    $0xc,%eax
f01168de:	25 ff 03 00 00       	and    $0x3ff,%eax
f01168e3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01168ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01168ed:	01 d0                	add    %edx,%eax
f01168ef:	8b 00                	mov    (%eax),%eax
f01168f1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f01168f6:	c9                   	leave  
f01168f7:	c3                   	ret    

f01168f8 <CE>:

int CE(uint32 *_d, uint32 va)
{
f01168f8:	55                   	push   %ebp
f01168f9:	89 e5                	mov    %esp,%ebp
f01168fb:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f01168fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116901:	c1 e8 16             	shr    $0x16,%eax
f0116904:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011690b:	8b 45 08             	mov    0x8(%ebp),%eax
f011690e:	01 d0                	add    %edx,%eax
f0116910:	8b 00                	mov    (%eax),%eax
f0116912:	83 e0 01             	and    $0x1,%eax
f0116915:	85 c0                	test   %eax,%eax
f0116917:	75 07                	jne    f0116920 <CE+0x28>
f0116919:	b8 00 00 00 00       	mov    $0x0,%eax
f011691e:	eb 7a                	jmp    f011699a <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116920:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116923:	c1 e8 16             	shr    $0x16,%eax
f0116926:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011692d:	8b 45 08             	mov    0x8(%ebp),%eax
f0116930:	01 d0                	add    %edx,%eax
f0116932:	8b 00                	mov    (%eax),%eax
f0116934:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116939:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011693c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011693f:	c1 e8 0c             	shr    $0xc,%eax
f0116942:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116945:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011694a:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f011694d:	72 17                	jb     f0116966 <CE+0x6e>
f011694f:	ff 75 f4             	pushl  -0xc(%ebp)
f0116952:	68 bc b5 12 f0       	push   $0xf012b5bc
f0116957:	68 65 08 00 00       	push   $0x865
f011695c:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116961:	e8 b4 99 fe ff       	call   f010031a <_panic>
f0116966:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116969:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011696e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116971:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116974:	c1 e8 0c             	shr    $0xc,%eax
f0116977:	25 ff 03 00 00       	and    $0x3ff,%eax
f011697c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116983:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116986:	01 d0                	add    %edx,%eax
f0116988:	8b 00                	mov    (%eax),%eax
f011698a:	85 c0                	test   %eax,%eax
f011698c:	74 07                	je     f0116995 <CE+0x9d>
f011698e:	b8 00 00 00 00       	mov    $0x0,%eax
f0116993:	eb 05                	jmp    f011699a <CE+0xa2>
	return 1;
f0116995:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011699a:	c9                   	leave  
f011699b:	c3                   	ret    

f011699c <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f011699c:	55                   	push   %ebp
f011699d:	89 e5                	mov    %esp,%ebp
f011699f:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	uint32 pd_entry = pd[((((uint32) (va)) >> 22) & 0x3FF)];
f01169a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01169a5:	c1 e8 16             	shr    $0x16,%eax
f01169a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01169af:	8b 45 08             	mov    0x8(%ebp),%eax
f01169b2:	01 d0                	add    %edx,%eax
f01169b4:	8b 00                	mov    (%eax),%eax
f01169b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if ( (pd_entry & 1) == 1)
f01169b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01169bc:	83 e0 01             	and    $0x1,%eax
f01169bf:	85 c0                	test   %eax,%eax
f01169c1:	0f 84 92 00 00 00    	je     f0116a59 <CP+0xbd>
	{
		uint32 *t = NULL;
f01169c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		t = (STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(pd_entry)));
f01169ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01169d1:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01169d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01169d9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01169dc:	c1 e8 0c             	shr    $0xc,%eax
f01169df:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01169e2:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f01169e7:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f01169ea:	72 17                	jb     f0116a03 <CP+0x67>
f01169ec:	ff 75 ec             	pushl  -0x14(%ebp)
f01169ef:	68 bc b5 12 f0       	push   $0xf012b5bc
f01169f4:	68 71 08 00 00       	push   $0x871
f01169f9:	68 c2 9a 12 f0       	push   $0xf0129ac2
f01169fe:	e8 17 99 fe ff       	call   f010031a <_panic>
f0116a03:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116a06:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116a0b:	89 45 f0             	mov    %eax,-0x10(%ebp)
		//cprintf("va =%x, ENTRY after PERM = %x, perm to set = %x, perm to clear = %x\n", va, t[PTX(va)]&0x00000FFF, ps, pc);

		if (((t[((((uint32) (va)) >> 12) & 0x3FF)]&ps) == ps)&&((~(t[((((uint32) (va)) >> 12) & 0x3FF)])&pc) == pc))
f0116a0e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a11:	c1 e8 0c             	shr    $0xc,%eax
f0116a14:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116a19:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a20:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116a23:	01 d0                	add    %edx,%eax
f0116a25:	8b 00                	mov    (%eax),%eax
f0116a27:	23 45 10             	and    0x10(%ebp),%eax
f0116a2a:	3b 45 10             	cmp    0x10(%ebp),%eax
f0116a2d:	75 2a                	jne    f0116a59 <CP+0xbd>
f0116a2f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a32:	c1 e8 0c             	shr    $0xc,%eax
f0116a35:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116a3a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a41:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116a44:	01 d0                	add    %edx,%eax
f0116a46:	8b 00                	mov    (%eax),%eax
f0116a48:	f7 d0                	not    %eax
f0116a4a:	23 45 14             	and    0x14(%ebp),%eax
f0116a4d:	3b 45 14             	cmp    0x14(%ebp),%eax
f0116a50:	75 07                	jne    f0116a59 <CP+0xbd>
			return 1;
f0116a52:	b8 01 00 00 00       	mov    $0x1,%eax
f0116a57:	eb 05                	jmp    f0116a5e <CP+0xc2>
	}
	return 0;
f0116a59:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116a5e:	c9                   	leave  
f0116a5f:	c3                   	ret    

f0116a60 <GP>:

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f0116a60:	55                   	push   %ebp
f0116a61:	89 e5                	mov    %esp,%ebp
f0116a63:	83 ec 18             	sub    $0x18,%esp
	assert(USE_KHEAP == 0) ;
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116a66:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a69:	c1 e8 16             	shr    $0x16,%eax
f0116a6c:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a73:	8b 45 08             	mov    0x8(%ebp),%eax
f0116a76:	01 d0                	add    %edx,%eax
f0116a78:	8b 00                	mov    (%eax),%eax
f0116a7a:	83 e0 01             	and    $0x1,%eax
f0116a7d:	85 c0                	test   %eax,%eax
f0116a7f:	75 07                	jne    f0116a88 <GP+0x28>
f0116a81:	b8 00 00 00 00       	mov    $0x0,%eax
f0116a86:	eb 6f                	jmp    f0116af7 <GP+0x97>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116a88:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116a8b:	c1 e8 16             	shr    $0x16,%eax
f0116a8e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116a95:	8b 45 08             	mov    0x8(%ebp),%eax
f0116a98:	01 d0                	add    %edx,%eax
f0116a9a:	8b 00                	mov    (%eax),%eax
f0116a9c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116aa7:	c1 e8 0c             	shr    $0xc,%eax
f0116aaa:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116aad:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f0116ab2:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116ab5:	72 17                	jb     f0116ace <GP+0x6e>
f0116ab7:	ff 75 f4             	pushl  -0xc(%ebp)
f0116aba:	68 bc b5 12 f0       	push   $0xf012b5bc
f0116abf:	68 7e 08 00 00       	push   $0x87e
f0116ac4:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116ac9:	e8 4c 98 fe ff       	call   f010031a <_panic>
f0116ace:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116ad1:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116ad6:	89 45 ec             	mov    %eax,-0x14(%ebp)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
f0116ad9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116adc:	c1 e8 0c             	shr    $0xc,%eax
f0116adf:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116ae4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116aeb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116aee:	01 d0                	add    %edx,%eax
f0116af0:	8b 00                	mov    (%eax),%eax
f0116af2:	25 ff 0f 00 00       	and    $0xfff,%eax
}
f0116af7:	c9                   	leave  
f0116af8:	c3                   	ret    

f0116af9 <ClearUserSpace>:

void ClearUserSpace(uint32 *ptr_dir)
{
f0116af9:	55                   	push   %ebp
f0116afa:	89 e5                	mov    %esp,%ebp
f0116afc:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116aff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0116b06:	eb 18                	jmp    f0116b20 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f0116b08:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116b0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116b12:	8b 45 08             	mov    0x8(%ebp),%eax
f0116b15:	01 d0                	add    %edx,%eax
f0116b17:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0116b1d:	ff 45 fc             	incl   -0x4(%ebp)
f0116b20:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0116b23:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f0116b28:	76 de                	jbe    f0116b08 <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f0116b2a:	90                   	nop
f0116b2b:	c9                   	leave  
f0116b2c:	c3                   	ret    

f0116b2d <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0116b2d:	55                   	push   %ebp
f0116b2e:	89 e5                	mov    %esp,%ebp
f0116b30:	83 ec 38             	sub    $0x38,%esp
f0116b33:	8b 45 2c             	mov    0x2c(%ebp),%eax
f0116b36:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f0116b39:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116b3c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116b41:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0116b44:	8b 45 10             	mov    0x10(%ebp),%eax
f0116b47:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116b4c:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116b4f:	e9 ea 01 00 00       	jmp    f0116d3e <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0116b54:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116b58:	74 44                	je     f0116b9e <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f0116b5a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116b5d:	83 ec 04             	sub    $0x4,%esp
f0116b60:	8d 55 dc             	lea    -0x24(%ebp),%edx
f0116b63:	52                   	push   %edx
f0116b64:	50                   	push   %eax
f0116b65:	ff 75 08             	pushl  0x8(%ebp)
f0116b68:	e8 5e 18 ff ff       	call   f01083cb <get_frame_info>
f0116b6d:	83 c4 10             	add    $0x10,%esp
f0116b70:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f0116b73:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116b76:	85 c0                	test   %eax,%eax
f0116b78:	75 24                	jne    f0116b9e <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f0116b7a:	83 ec 04             	sub    $0x4,%esp
f0116b7d:	68 ec b5 12 f0       	push   $0xf012b5ec
f0116b82:	68 99 08 00 00       	push   $0x899
f0116b87:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116b8c:	e8 26 99 fe ff       	call   f01004b7 <_warn>
f0116b91:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116b94:	b8 00 00 00 00       	mov    $0x0,%eax
f0116b99:	e9 b6 01 00 00       	jmp    f0116d54 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f0116b9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116ba1:	83 ec 04             	sub    $0x4,%esp
f0116ba4:	8d 55 d8             	lea    -0x28(%ebp),%edx
f0116ba7:	52                   	push   %edx
f0116ba8:	50                   	push   %eax
f0116ba9:	ff 75 08             	pushl  0x8(%ebp)
f0116bac:	e8 1a 18 ff ff       	call   f01083cb <get_frame_info>
f0116bb1:	83 c4 10             	add    $0x10,%esp
f0116bb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f0116bb7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116bba:	85 c0                	test   %eax,%eax
f0116bbc:	75 24                	jne    f0116be2 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0116bbe:	83 ec 04             	sub    $0x4,%esp
f0116bc1:	68 18 b6 12 f0       	push   $0xf012b618
f0116bc6:	68 a0 08 00 00       	push   $0x8a0
f0116bcb:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116bd0:	e8 e2 98 fe ff       	call   f01004b7 <_warn>
f0116bd5:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116bd8:	b8 00 00 00 00       	mov    $0x0,%eax
f0116bdd:	e9 72 01 00 00       	jmp    f0116d54 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0116be2:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f0116be6:	75 70                	jne    f0116c58 <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f0116be8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116beb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0116bee:	c1 ea 0c             	shr    $0xc,%edx
f0116bf1:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116bf7:	c1 e2 02             	shl    $0x2,%edx
f0116bfa:	01 d0                	add    %edx,%eax
f0116bfc:	8b 00                	mov    (%eax),%eax
f0116bfe:	c1 e8 0c             	shr    $0xc,%eax
f0116c01:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0116c04:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0116c07:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0116c0a:	c1 ea 0c             	shr    $0xc,%edx
f0116c0d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0116c13:	c1 e2 02             	shl    $0x2,%edx
f0116c16:	01 d0                	add    %edx,%eax
f0116c18:	8b 00                	mov    (%eax),%eax
f0116c1a:	c1 e8 0c             	shr    $0xc,%eax
f0116c1d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0116c20:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116c23:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0116c26:	74 30                	je     f0116c58 <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f0116c28:	83 ec 04             	sub    $0x4,%esp
f0116c2b:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116c2e:	ff 75 e8             	pushl  -0x18(%ebp)
f0116c31:	ff 75 f0             	pushl  -0x10(%ebp)
f0116c34:	ff 75 f4             	pushl  -0xc(%ebp)
f0116c37:	68 44 b6 12 f0       	push   $0xf012b644
f0116c3c:	68 aa 08 00 00       	push   $0x8aa
f0116c41:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116c46:	e8 6c 98 fe ff       	call   f01004b7 <_warn>
f0116c4b:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116c4e:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c53:	e9 fc 00 00 00       	jmp    f0116d54 <CCP+0x227>
			}
		}
		if (ref != -1)
f0116c58:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f0116c5c:	74 52                	je     f0116cb0 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f0116c5e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116c62:	74 0e                	je     f0116c72 <CCP+0x145>
f0116c64:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c67:	8b 40 08             	mov    0x8(%eax),%eax
f0116c6a:	0f b7 c0             	movzwl %ax,%eax
f0116c6d:	3b 45 18             	cmp    0x18(%ebp),%eax
f0116c70:	74 3e                	je     f0116cb0 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f0116c72:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0116c76:	74 0b                	je     f0116c83 <CCP+0x156>
f0116c78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116c7b:	8b 40 08             	mov    0x8(%eax),%eax
f0116c7e:	0f b7 c0             	movzwl %ax,%eax
f0116c81:	eb 05                	jmp    f0116c88 <CCP+0x15b>
f0116c83:	b8 00 00 00 00       	mov    $0x0,%eax
f0116c88:	83 ec 0c             	sub    $0xc,%esp
f0116c8b:	50                   	push   %eax
f0116c8c:	ff 75 f0             	pushl  -0x10(%ebp)
f0116c8f:	68 a0 b6 12 f0       	push   $0xf012b6a0
f0116c94:	68 b2 08 00 00       	push   $0x8b2
f0116c99:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116c9e:	e8 14 98 fe ff       	call   f01004b7 <_warn>
f0116ca3:	83 c4 20             	add    $0x20,%esp
				return 0;
f0116ca6:	b8 00 00 00 00       	mov    $0x0,%eax
f0116cab:	e9 a4 00 00 00       	jmp    f0116d54 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f0116cb0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116cb3:	ff 75 20             	pushl  0x20(%ebp)
f0116cb6:	ff 75 1c             	pushl  0x1c(%ebp)
f0116cb9:	50                   	push   %eax
f0116cba:	ff 75 08             	pushl  0x8(%ebp)
f0116cbd:	e8 b8 fa ff ff       	call   f011677a <CPs>
f0116cc2:	83 c4 10             	add    $0x10,%esp
f0116cc5:	85 c0                	test   %eax,%eax
f0116cc7:	7f 21                	jg     f0116cea <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f0116cc9:	83 ec 04             	sub    $0x4,%esp
f0116ccc:	68 10 b7 12 f0       	push   $0xf012b710
f0116cd1:	68 b8 08 00 00       	push   $0x8b8
f0116cd6:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116cdb:	e8 d7 97 fe ff       	call   f01004b7 <_warn>
f0116ce0:	83 c4 10             	add    $0x10,%esp
			return 0;
f0116ce3:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ce8:	eb 6a                	jmp    f0116d54 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f0116cea:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116cee:	74 3a                	je     f0116d2a <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0116cf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116cf3:	ff 75 28             	pushl  0x28(%ebp)
f0116cf6:	ff 75 24             	pushl  0x24(%ebp)
f0116cf9:	50                   	push   %eax
f0116cfa:	ff 75 08             	pushl  0x8(%ebp)
f0116cfd:	e8 78 fa ff ff       	call   f011677a <CPs>
f0116d02:	83 c4 10             	add    $0x10,%esp
f0116d05:	85 c0                	test   %eax,%eax
f0116d07:	7f 21                	jg     f0116d2a <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f0116d09:	83 ec 04             	sub    $0x4,%esp
f0116d0c:	68 58 b7 12 f0       	push   $0xf012b758
f0116d11:	68 bf 08 00 00       	push   $0x8bf
f0116d16:	68 c2 9a 12 f0       	push   $0xf0129ac2
f0116d1b:	e8 97 97 fe ff       	call   f01004b7 <_warn>
f0116d20:	83 c4 10             	add    $0x10,%esp
				return 0;
f0116d23:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d28:	eb 2a                	jmp    f0116d54 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f0116d2a:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0116d2e:	74 07                	je     f0116d37 <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0116d30:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0116d37:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0116d3e:	8b 55 10             	mov    0x10(%ebp),%edx
f0116d41:	8b 45 14             	mov    0x14(%ebp),%eax
f0116d44:	01 d0                	add    %edx,%eax
f0116d46:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0116d49:	0f 87 05 fe ff ff    	ja     f0116b54 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0116d4f:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116d54:	c9                   	leave  
f0116d55:	c3                   	ret    

f0116d56 <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f0116d56:	55                   	push   %ebp
f0116d57:	89 e5                	mov    %esp,%ebp
f0116d59:	57                   	push   %edi
f0116d5a:	56                   	push   %esi
f0116d5b:	53                   	push   %ebx
f0116d5c:	81 ec 4c 03 00 00    	sub    $0x34c,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f0116d62:	a0 94 9d 17 f0       	mov    0xf0179d94,%al
f0116d67:	84 c0                	test   %al,%al
f0116d69:	0f 84 38 0a 00 00    	je     f01177a7 <test_priority_normal_and_higher+0xa51>
		uint32 fact_WS[15];
		uint32 fact_TimeStamp[15];
		uint32 hello_WS[10];
		uint32 hello_TimeStamp[10];

		firstTime = 0;
f0116d6f:	c6 05 94 9d 17 f0 00 	movb   $0x0,0xf0179d94
		char command[100] = "load fos_add 20";
f0116d76:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0116d7c:	bb 14 ba 12 f0       	mov    $0xf012ba14,%ebx
f0116d81:	ba 04 00 00 00       	mov    $0x4,%edx
f0116d86:	89 c7                	mov    %eax,%edi
f0116d88:	89 de                	mov    %ebx,%esi
f0116d8a:	89 d1                	mov    %edx,%ecx
f0116d8c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0116d8e:	8d 95 24 fe ff ff    	lea    -0x1dc(%ebp),%edx
f0116d94:	b9 15 00 00 00       	mov    $0x15,%ecx
f0116d99:	b8 00 00 00 00       	mov    $0x0,%eax
f0116d9e:	89 d7                	mov    %edx,%edi
f0116da0:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f0116da2:	83 ec 0c             	sub    $0xc,%esp
f0116da5:	8d 85 14 fe ff ff    	lea    -0x1ec(%ebp),%eax
f0116dab:	50                   	push   %eax
f0116dac:	e8 2b b1 fe ff       	call   f0101edc <execute_command>
f0116db1:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 15";
f0116db4:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0116dba:	bb 78 ba 12 f0       	mov    $0xf012ba78,%ebx
f0116dbf:	ba 0d 00 00 00       	mov    $0xd,%edx
f0116dc4:	89 c7                	mov    %eax,%edi
f0116dc6:	89 de                	mov    %ebx,%esi
f0116dc8:	89 d1                	mov    %edx,%ecx
f0116dca:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116dcc:	8d 95 85 fe ff ff    	lea    -0x17b(%ebp),%edx
f0116dd2:	b9 57 00 00 00       	mov    $0x57,%ecx
f0116dd7:	b0 00                	mov    $0x0,%al
f0116dd9:	89 d7                	mov    %edx,%edi
f0116ddb:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f0116ddd:	83 ec 0c             	sub    $0xc,%esp
f0116de0:	8d 85 78 fe ff ff    	lea    -0x188(%ebp),%eax
f0116de6:	50                   	push   %eax
f0116de7:	e8 f0 b0 fe ff       	call   f0101edc <execute_command>
f0116dec:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 10";
f0116def:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0116df5:	bb dc ba 12 f0       	mov    $0xf012badc,%ebx
f0116dfa:	ba 17 00 00 00       	mov    $0x17,%edx
f0116dff:	89 c7                	mov    %eax,%edi
f0116e01:	89 de                	mov    %ebx,%esi
f0116e03:	89 d1                	mov    %edx,%ecx
f0116e05:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0116e07:	8d 95 f3 fe ff ff    	lea    -0x10d(%ebp),%edx
f0116e0d:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f0116e12:	b0 00                	mov    $0x0,%al
f0116e14:	89 d7                	mov    %edx,%edi
f0116e16:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f0116e18:	83 ec 0c             	sub    $0xc,%esp
f0116e1b:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f0116e21:	50                   	push   %eax
f0116e22:	e8 b5 b0 fe ff       	call   f0101edc <execute_command>
f0116e27:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(16, &addEnv, 0);
f0116e2a:	83 ec 04             	sub    $0x4,%esp
f0116e2d:	6a 00                	push   $0x0
f0116e2f:	8d 45 ac             	lea    -0x54(%ebp),%eax
f0116e32:	50                   	push   %eax
f0116e33:	6a 10                	push   $0x10
f0116e35:	e8 87 36 ff ff       	call   f010a4c1 <envid2env>
f0116e3a:	83 c4 10             	add    $0x10,%esp
		envid2env(17, &factEnv, 0);
f0116e3d:	83 ec 04             	sub    $0x4,%esp
f0116e40:	6a 00                	push   $0x0
f0116e42:	8d 45 a8             	lea    -0x58(%ebp),%eax
f0116e45:	50                   	push   %eax
f0116e46:	6a 11                	push   $0x11
f0116e48:	e8 74 36 ff ff       	call   f010a4c1 <envid2env>
f0116e4d:	83 c4 10             	add    $0x10,%esp
		envid2env(18, &helloEnv, 0);
f0116e50:	83 ec 04             	sub    $0x4,%esp
f0116e53:	6a 00                	push   $0x0
f0116e55:	8d 45 a4             	lea    -0x5c(%ebp),%eax
f0116e58:	50                   	push   %eax
f0116e59:	6a 12                	push   $0x12
f0116e5b:	e8 61 36 ff ff       	call   f010a4c1 <envid2env>
f0116e60:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f0116e63:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116e66:	85 c0                	test   %eax,%eax
f0116e68:	74 0e                	je     f0116e78 <test_priority_normal_and_higher+0x122>
f0116e6a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116e6d:	85 c0                	test   %eax,%eax
f0116e6f:	74 07                	je     f0116e78 <test_priority_normal_and_higher+0x122>
f0116e71:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116e74:	85 c0                	test   %eax,%eax
f0116e76:	75 14                	jne    f0116e8c <test_priority_normal_and_higher+0x136>
			panic("Loading programs failed\n");
f0116e78:	83 ec 04             	sub    $0x4,%esp
f0116e7b:	68 98 b7 12 f0       	push   $0xf012b798
f0116e80:	6a 29                	push   $0x29
f0116e82:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0116e87:	e8 8e 94 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0116e8c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116e8f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116e95:	83 f8 14             	cmp    $0x14,%eax
f0116e98:	75 1c                	jne    f0116eb6 <test_priority_normal_and_higher+0x160>
f0116e9a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116e9d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116ea3:	83 f8 0f             	cmp    $0xf,%eax
f0116ea6:	75 0e                	jne    f0116eb6 <test_priority_normal_and_higher+0x160>
f0116ea8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116eab:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116eb1:	83 f8 0a             	cmp    $0xa,%eax
f0116eb4:	74 32                	je     f0116ee8 <test_priority_normal_and_higher+0x192>
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );
f0116eb6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0116eb9:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0116ebf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0116ec2:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f0116ec8:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116ecb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0116ed1:	83 ec 08             	sub    $0x8,%esp
f0116ed4:	51                   	push   %ecx
f0116ed5:	52                   	push   %edx
f0116ed6:	50                   	push   %eax
f0116ed7:	68 cc b7 12 f0       	push   $0xf012b7cc
f0116edc:	6a 2c                	push   $0x2c
f0116ede:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0116ee3:	e8 32 94 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f0116ee8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0116eef:	eb 47                	jmp    f0116f38 <test_priority_normal_and_higher+0x1e2>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f0116ef1:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0116ef4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0116ef7:	89 d0                	mov    %edx,%eax
f0116ef9:	01 c0                	add    %eax,%eax
f0116efb:	01 d0                	add    %edx,%eax
f0116efd:	c1 e0 03             	shl    $0x3,%eax
f0116f00:	01 c8                	add    %ecx,%eax
f0116f02:	05 88 00 00 00       	add    $0x88,%eax
f0116f07:	8b 10                	mov    (%eax),%edx
f0116f09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116f0c:	89 94 85 74 fd ff ff 	mov    %edx,-0x28c(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f0116f13:	8b 4d ac             	mov    -0x54(%ebp),%ecx
f0116f16:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0116f19:	89 d0                	mov    %edx,%eax
f0116f1b:	01 c0                	add    %eax,%eax
f0116f1d:	01 d0                	add    %edx,%eax
f0116f1f:	c1 e0 03             	shl    $0x3,%eax
f0116f22:	01 c8                	add    %ecx,%eax
f0116f24:	05 90 00 00 00       	add    $0x90,%eax
f0116f29:	8b 10                	mov    (%eax),%edx
f0116f2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0116f2e:	89 94 85 c4 fd ff ff 	mov    %edx,-0x23c(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs should be initially loaded with the given working set size. add: %d, fact: %d, hello: %d\n", addEnv->page_WS_max_size , factEnv->page_WS_max_size , helloEnv->page_WS_max_size );

		for(int i = 0; i < 20; i++)
f0116f35:	ff 45 e4             	incl   -0x1c(%ebp)
f0116f38:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f0116f3c:	7e b3                	jle    f0116ef1 <test_priority_normal_and_higher+0x19b>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0116f3e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0116f45:	eb 47                	jmp    f0116f8e <test_priority_normal_and_higher+0x238>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f0116f47:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0116f4a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116f4d:	89 d0                	mov    %edx,%eax
f0116f4f:	01 c0                	add    %eax,%eax
f0116f51:	01 d0                	add    %edx,%eax
f0116f53:	c1 e0 03             	shl    $0x3,%eax
f0116f56:	01 c8                	add    %ecx,%eax
f0116f58:	05 88 00 00 00       	add    $0x88,%eax
f0116f5d:	8b 10                	mov    (%eax),%edx
f0116f5f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0116f62:	89 94 85 fc fc ff ff 	mov    %edx,-0x304(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f0116f69:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0116f6c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0116f6f:	89 d0                	mov    %edx,%eax
f0116f71:	01 c0                	add    %eax,%eax
f0116f73:	01 d0                	add    %edx,%eax
f0116f75:	c1 e0 03             	shl    $0x3,%eax
f0116f78:	01 c8                	add    %ecx,%eax
f0116f7a:	05 90 00 00 00       	add    $0x90,%eax
f0116f7f:	8b 10                	mov    (%eax),%edx
f0116f81:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0116f84:	89 94 85 38 fd ff ff 	mov    %edx,-0x2c8(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 15; i++)
f0116f8b:	ff 45 e0             	incl   -0x20(%ebp)
f0116f8e:	83 7d e0 0e          	cmpl   $0xe,-0x20(%ebp)
f0116f92:	7e b3                	jle    f0116f47 <test_priority_normal_and_higher+0x1f1>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0116f94:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0116f9b:	eb 47                	jmp    f0116fe4 <test_priority_normal_and_higher+0x28e>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f0116f9d:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0116fa0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0116fa3:	89 d0                	mov    %edx,%eax
f0116fa5:	01 c0                	add    %eax,%eax
f0116fa7:	01 d0                	add    %edx,%eax
f0116fa9:	c1 e0 03             	shl    $0x3,%eax
f0116fac:	01 c8                	add    %ecx,%eax
f0116fae:	05 88 00 00 00       	add    $0x88,%eax
f0116fb3:	8b 10                	mov    (%eax),%edx
f0116fb5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116fb8:	89 94 85 ac fc ff ff 	mov    %edx,-0x354(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f0116fbf:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f0116fc2:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0116fc5:	89 d0                	mov    %edx,%eax
f0116fc7:	01 c0                	add    %eax,%eax
f0116fc9:	01 d0                	add    %edx,%eax
f0116fcb:	c1 e0 03             	shl    $0x3,%eax
f0116fce:	01 c8                	add    %ecx,%eax
f0116fd0:	05 90 00 00 00       	add    $0x90,%eax
f0116fd5:	8b 10                	mov    (%eax),%edx
f0116fd7:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116fda:	89 94 85 d4 fc ff ff 	mov    %edx,-0x32c(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 10; i++)
f0116fe1:	ff 45 dc             	incl   -0x24(%ebp)
f0116fe4:	83 7d dc 09          	cmpl   $0x9,-0x24(%ebp)
f0116fe8:	7e b3                	jle    f0116f9d <test_priority_normal_and_higher+0x247>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f0116fea:	e8 1a 67 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0116fef:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		int freeDiskFrames = pf_calculate_free_frames();
f0116ff2:	e8 4a d5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0116ff7:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f0116ffa:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0116ffd:	83 ec 08             	sub    $0x8,%esp
f0117000:	6a 03                	push   $0x3
f0117002:	50                   	push   %eax
f0117003:	e8 a8 4b ff ff       	call   f010bbb0 <set_program_priority>
f0117008:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f011700b:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011700e:	83 ec 08             	sub    $0x8,%esp
f0117011:	6a 03                	push   $0x3
f0117013:	50                   	push   %eax
f0117014:	e8 97 4b ff ff       	call   f010bbb0 <set_program_priority>
f0117019:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f011701c:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011701f:	83 ec 08             	sub    $0x8,%esp
f0117022:	6a 03                	push   $0x3
f0117024:	50                   	push   %eax
f0117025:	e8 86 4b ff ff       	call   f010bbb0 <set_program_priority>
f011702a:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f011702d:	e8 0f d5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117032:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117035:	74 14                	je     f011704b <test_priority_normal_and_higher+0x2f5>
f0117037:	83 ec 04             	sub    $0x4,%esp
f011703a:	68 34 b8 12 f0       	push   $0xf012b834
f011703f:	6a 48                	push   $0x48
f0117041:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117046:	e8 cf 92 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f011704b:	e8 b9 66 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117050:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117053:	74 14                	je     f0117069 <test_priority_normal_and_higher+0x313>
f0117055:	83 ec 04             	sub    $0x4,%esp
f0117058:	68 34 b8 12 f0       	push   $0xf012b834
f011705d:	6a 49                	push   $0x49
f011705f:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117064:	e8 b1 92 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0117069:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011706c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117072:	83 f8 14             	cmp    $0x14,%eax
f0117075:	75 1c                	jne    f0117093 <test_priority_normal_and_higher+0x33d>
f0117077:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011707a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117080:	83 f8 0f             	cmp    $0xf,%eax
f0117083:	75 0e                	jne    f0117093 <test_priority_normal_and_higher+0x33d>
f0117085:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117088:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011708e:	83 f8 0a             	cmp    $0xa,%eax
f0117091:	74 14                	je     f01170a7 <test_priority_normal_and_higher+0x351>
			panic("The programs' working set size should not change after setting priority to normal\n");
f0117093:	83 ec 04             	sub    $0x4,%esp
f0117096:	68 60 b8 12 f0       	push   $0xf012b860
f011709b:	6a 4c                	push   $0x4c
f011709d:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01170a2:	e8 73 92 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f01170a7:	e8 5d 66 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01170ac:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01170af:	e8 8d d4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01170b4:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set Priority To Above Normal // Should change only helloWorld as none of the rest is full
		set_program_priority(addEnv, 4);
f01170b7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01170ba:	83 ec 08             	sub    $0x8,%esp
f01170bd:	6a 04                	push   $0x4
f01170bf:	50                   	push   %eax
f01170c0:	e8 eb 4a ff ff       	call   f010bbb0 <set_program_priority>
f01170c5:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 4);
f01170c8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01170cb:	83 ec 08             	sub    $0x8,%esp
f01170ce:	6a 04                	push   $0x4
f01170d0:	50                   	push   %eax
f01170d1:	e8 da 4a ff ff       	call   f010bbb0 <set_program_priority>
f01170d6:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f01170d9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01170dc:	83 ec 08             	sub    $0x8,%esp
f01170df:	6a 04                	push   $0x4
f01170e1:	50                   	push   %eax
f01170e2:	e8 c9 4a ff ff       	call   f010bbb0 <set_program_priority>
f01170e7:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01170ea:	e8 52 d4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01170ef:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01170f2:	74 14                	je     f0117108 <test_priority_normal_and_higher+0x3b2>
f01170f4:	83 ec 04             	sub    $0x4,%esp
f01170f7:	68 34 b8 12 f0       	push   $0xf012b834
f01170fc:	6a 56                	push   $0x56
f01170fe:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117103:	e8 12 92 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly%x\n");
f0117108:	e8 fc 65 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011710d:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117110:	74 14                	je     f0117126 <test_priority_normal_and_higher+0x3d0>
f0117112:	83 ec 04             	sub    $0x4,%esp
f0117115:	68 b4 b8 12 f0       	push   $0xf012b8b4
f011711a:	6a 57                	push   $0x57
f011711c:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117121:	e8 f4 91 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0117126:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117129:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011712f:	83 f8 14             	cmp    $0x14,%eax
f0117132:	75 1c                	jne    f0117150 <test_priority_normal_and_higher+0x3fa>
f0117134:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117137:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011713d:	83 f8 0f             	cmp    $0xf,%eax
f0117140:	75 0e                	jne    f0117150 <test_priority_normal_and_higher+0x3fa>
f0117142:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117145:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011714b:	83 f8 14             	cmp    $0x14,%eax
f011714e:	74 14                	je     f0117164 <test_priority_normal_and_higher+0x40e>
			panic("The programs' working set size should be doubled only if it is full\n");
f0117150:	83 ec 04             	sub    $0x4,%esp
f0117153:	68 e4 b8 12 f0       	push   $0xf012b8e4
f0117158:	6a 5a                	push   $0x5a
f011715a:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011715f:	e8 b6 91 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0117164:	e8 a0 65 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117169:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011716c:	e8 d0 d3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117171:	89 45 b0             	mov    %eax,-0x50(%ebp)

		// Set priority to above normal --> nothing should change (1 time only)
		set_program_priority(helloEnv, 4);
f0117174:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117177:	83 ec 08             	sub    $0x8,%esp
f011717a:	6a 04                	push   $0x4
f011717c:	50                   	push   %eax
f011717d:	e8 2e 4a ff ff       	call   f010bbb0 <set_program_priority>
f0117182:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117185:	e8 b7 d3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011718a:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011718d:	74 14                	je     f01171a3 <test_priority_normal_and_higher+0x44d>
f011718f:	83 ec 04             	sub    $0x4,%esp
f0117192:	68 34 b8 12 f0       	push   $0xf012b834
f0117197:	6a 62                	push   $0x62
f0117199:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011719e:	e8 77 91 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f01171a3:	e8 61 65 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01171a8:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f01171ab:	74 14                	je     f01171c1 <test_priority_normal_and_higher+0x46b>
f01171ad:	83 ec 04             	sub    $0x4,%esp
f01171b0:	68 34 b8 12 f0       	push   $0xf012b834
f01171b5:	6a 63                	push   $0x63
f01171b7:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01171bc:	e8 59 91 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f01171c1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01171c4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01171ca:	83 f8 14             	cmp    $0x14,%eax
f01171cd:	75 1c                	jne    f01171eb <test_priority_normal_and_higher+0x495>
f01171cf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01171d2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01171d8:	83 f8 0f             	cmp    $0xf,%eax
f01171db:	75 0e                	jne    f01171eb <test_priority_normal_and_higher+0x495>
f01171dd:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01171e0:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01171e6:	83 f8 14             	cmp    $0x14,%eax
f01171e9:	74 14                	je     f01171ff <test_priority_normal_and_higher+0x4a9>
			panic("The programs' working set size should be doubled only once\n");
f01171eb:	83 ec 04             	sub    $0x4,%esp
f01171ee:	68 2c b9 12 f0       	push   $0xf012b92c
f01171f3:	6a 66                	push   $0x66
f01171f5:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01171fa:	e8 1b 91 fe ff       	call   f010031a <_panic>


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f01171ff:	c7 45 d8 0a 00 00 00 	movl   $0xa,-0x28(%ebp)
f0117206:	eb 1c                	jmp    f0117224 <test_priority_normal_and_higher+0x4ce>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f0117208:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f011720b:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011720e:	89 d0                	mov    %edx,%eax
f0117210:	01 c0                	add    %eax,%eax
f0117212:	01 d0                	add    %edx,%eax
f0117214:	c1 e0 03             	shl    $0x3,%eax
f0117217:	01 c8                	add    %ecx,%eax
f0117219:	05 8c 00 00 00       	add    $0x8c,%eax
f011721e:	c6 00 00             	movb   $0x0,(%eax)
		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");


		// Manipulate WS to seem as full
		for(int i = 10; i < 20; i++)
f0117221:	ff 45 d8             	incl   -0x28(%ebp)
f0117224:	83 7d d8 13          	cmpl   $0x13,-0x28(%ebp)
f0117228:	7e de                	jle    f0117208 <test_priority_normal_and_higher+0x4b2>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f011722a:	e8 da 64 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011722f:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117232:	e8 0a d3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117237:	89 45 b0             	mov    %eax,-0x50(%ebp)

		set_program_priority(helloEnv, 4);
f011723a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011723d:	83 ec 08             	sub    $0x8,%esp
f0117240:	6a 04                	push   $0x4
f0117242:	50                   	push   %eax
f0117243:	e8 68 49 ff ff       	call   f010bbb0 <set_program_priority>
f0117248:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f011724b:	e8 f1 d2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117250:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0117253:	74 14                	je     f0117269 <test_priority_normal_and_higher+0x513>
f0117255:	83 ec 04             	sub    $0x4,%esp
f0117258:	68 34 b8 12 f0       	push   $0xf012b834
f011725d:	6a 73                	push   $0x73
f011725f:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117264:	e8 b1 90 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117269:	e8 9b 64 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011726e:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0117271:	74 14                	je     f0117287 <test_priority_normal_and_higher+0x531>
f0117273:	83 ec 04             	sub    $0x4,%esp
f0117276:	68 34 b8 12 f0       	push   $0xf012b834
f011727b:	6a 74                	push   $0x74
f011727d:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117282:	e8 93 90 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0117287:	8b 45 ac             	mov    -0x54(%ebp),%eax
f011728a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117290:	83 f8 14             	cmp    $0x14,%eax
f0117293:	75 1c                	jne    f01172b1 <test_priority_normal_and_higher+0x55b>
f0117295:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117298:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011729e:	83 f8 0f             	cmp    $0xf,%eax
f01172a1:	75 0e                	jne    f01172b1 <test_priority_normal_and_higher+0x55b>
f01172a3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01172a6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01172ac:	83 f8 14             	cmp    $0x14,%eax
f01172af:	74 14                	je     f01172c5 <test_priority_normal_and_higher+0x56f>
			panic("The programs' working set size should be doubled only once\n");
f01172b1:	83 ec 04             	sub    $0x4,%esp
f01172b4:	68 2c b9 12 f0       	push   $0xf012b92c
f01172b9:	6a 77                	push   $0x77
f01172bb:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01172c0:	e8 55 90 fe ff       	call   f010031a <_panic>

		for(int i = 10; i < 15; i++)
f01172c5:	c7 45 d4 0a 00 00 00 	movl   $0xa,-0x2c(%ebp)
f01172cc:	eb 1c                	jmp    f01172ea <test_priority_normal_and_higher+0x594>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f01172ce:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f01172d1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01172d4:	89 d0                	mov    %edx,%eax
f01172d6:	01 c0                	add    %eax,%eax
f01172d8:	01 d0                	add    %edx,%eax
f01172da:	c1 e0 03             	shl    $0x3,%eax
f01172dd:	01 c8                	add    %ecx,%eax
f01172df:	05 8c 00 00 00       	add    $0x8c,%eax
f01172e4:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
			panic("The programs' working set size should be doubled only once\n");

		for(int i = 10; i < 15; i++)
f01172e7:	ff 45 d4             	incl   -0x2c(%ebp)
f01172ea:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f01172ee:	7e de                	jle    f01172ce <test_priority_normal_and_higher+0x578>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f01172f0:	e8 14 64 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01172f5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01172f8:	e8 44 d2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01172fd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f0117300:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117303:	83 ec 08             	sub    $0x8,%esp
f0117306:	6a 05                	push   $0x5
f0117308:	50                   	push   %eax
f0117309:	e8 a2 48 ff ff       	call   f010bbb0 <set_program_priority>
f011730e:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 5);
f0117311:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117314:	83 ec 08             	sub    $0x8,%esp
f0117317:	6a 05                	push   $0x5
f0117319:	50                   	push   %eax
f011731a:	e8 91 48 ff ff       	call   f010bbb0 <set_program_priority>
f011731f:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117322:	e8 1a d2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117327:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011732a:	74 17                	je     f0117343 <test_priority_normal_and_higher+0x5ed>
f011732c:	83 ec 04             	sub    $0x4,%esp
f011732f:	68 34 b8 12 f0       	push   $0xf012b834
f0117334:	68 82 00 00 00       	push   $0x82
f0117339:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011733e:	e8 d7 8f fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117343:	e8 c1 63 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117348:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011734b:	74 17                	je     f0117364 <test_priority_normal_and_higher+0x60e>
f011734d:	83 ec 04             	sub    $0x4,%esp
f0117350:	68 34 b8 12 f0       	push   $0xf012b834
f0117355:	68 83 00 00 00       	push   $0x83
f011735a:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011735f:	e8 b6 8f fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117364:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117367:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011736d:	83 f8 14             	cmp    $0x14,%eax
f0117370:	75 1c                	jne    f011738e <test_priority_normal_and_higher+0x638>
f0117372:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117375:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011737b:	83 f8 1e             	cmp    $0x1e,%eax
f011737e:	75 0e                	jne    f011738e <test_priority_normal_and_higher+0x638>
f0117380:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117383:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117389:	83 f8 28             	cmp    $0x28,%eax
f011738c:	74 17                	je     f01173a5 <test_priority_normal_and_higher+0x64f>
			panic("The programs' working set size should be doubled if full\n");
f011738e:	83 ec 04             	sub    $0x4,%esp
f0117391:	68 68 b9 12 f0       	push   $0xf012b968
f0117396:	68 86 00 00 00       	push   $0x86
f011739b:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01173a0:	e8 75 8f fe ff       	call   f010031a <_panic>

		for(int i = 20; i < 40; i++)
f01173a5:	c7 45 d0 14 00 00 00 	movl   $0x14,-0x30(%ebp)
f01173ac:	eb 1c                	jmp    f01173ca <test_priority_normal_and_higher+0x674>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
f01173ae:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f01173b1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01173b4:	89 d0                	mov    %edx,%eax
f01173b6:	01 c0                	add    %eax,%eax
f01173b8:	01 d0                	add    %edx,%eax
f01173ba:	c1 e0 03             	shl    $0x3,%eax
f01173bd:	01 c8                	add    %ecx,%eax
f01173bf:	05 8c 00 00 00       	add    $0x8c,%eax
f01173c4:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 20; i < 40; i++)
f01173c7:	ff 45 d0             	incl   -0x30(%ebp)
f01173ca:	83 7d d0 27          	cmpl   $0x27,-0x30(%ebp)
f01173ce:	7e de                	jle    f01173ae <test_priority_normal_and_higher+0x658>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f01173d0:	e8 34 63 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01173d5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01173d8:	e8 64 d1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01173dd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f01173e0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01173e3:	83 ec 08             	sub    $0x8,%esp
f01173e6:	6a 05                	push   $0x5
f01173e8:	50                   	push   %eax
f01173e9:	e8 c2 47 ff ff       	call   f010bbb0 <set_program_priority>
f01173ee:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f01173f1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01173f4:	83 ec 08             	sub    $0x8,%esp
f01173f7:	6a 04                	push   $0x4
f01173f9:	50                   	push   %eax
f01173fa:	e8 b1 47 ff ff       	call   f010bbb0 <set_program_priority>
f01173ff:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117402:	e8 3a d1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117407:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011740a:	74 17                	je     f0117423 <test_priority_normal_and_higher+0x6cd>
f011740c:	83 ec 04             	sub    $0x4,%esp
f011740f:	68 34 b8 12 f0       	push   $0xf012b834
f0117414:	68 91 00 00 00       	push   $0x91
f0117419:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011741e:	e8 f7 8e fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117423:	e8 e1 62 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117428:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011742b:	74 17                	je     f0117444 <test_priority_normal_and_higher+0x6ee>
f011742d:	83 ec 04             	sub    $0x4,%esp
f0117430:	68 34 b8 12 f0       	push   $0xf012b834
f0117435:	68 92 00 00 00       	push   $0x92
f011743a:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011743f:	e8 d6 8e fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117444:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117447:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011744d:	83 f8 14             	cmp    $0x14,%eax
f0117450:	75 1c                	jne    f011746e <test_priority_normal_and_higher+0x718>
f0117452:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117455:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011745b:	83 f8 1e             	cmp    $0x1e,%eax
f011745e:	75 0e                	jne    f011746e <test_priority_normal_and_higher+0x718>
f0117460:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117463:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117469:	83 f8 28             	cmp    $0x28,%eax
f011746c:	74 17                	je     f0117485 <test_priority_normal_and_higher+0x72f>
			panic("The programs' working set size should be doubled if full\n");
f011746e:	83 ec 04             	sub    $0x4,%esp
f0117471:	68 68 b9 12 f0       	push   $0xf012b968
f0117476:	68 95 00 00 00       	push   $0x95
f011747b:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117480:	e8 95 8e fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 30; i++)
f0117485:	c7 45 cc 0f 00 00 00 	movl   $0xf,-0x34(%ebp)
f011748c:	eb 1c                	jmp    f01174aa <test_priority_normal_and_higher+0x754>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
f011748e:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0117491:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117494:	89 d0                	mov    %edx,%eax
f0117496:	01 c0                	add    %eax,%eax
f0117498:	01 d0                	add    %edx,%eax
f011749a:	c1 e0 03             	shl    $0x3,%eax
f011749d:	01 c8                	add    %ecx,%eax
f011749f:	05 8c 00 00 00       	add    $0x8c,%eax
f01174a4:	c6 00 00             	movb   $0x0,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 30; i++)
f01174a7:	ff 45 cc             	incl   -0x34(%ebp)
f01174aa:	83 7d cc 1d          	cmpl   $0x1d,-0x34(%ebp)
f01174ae:	7e de                	jle    f011748e <test_priority_normal_and_higher+0x738>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 0;
		}

		freeFrames = sys_calculate_free_frames();
f01174b0:	e8 54 62 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01174b5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f01174b8:	e8 84 d0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01174bd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		set_program_priority(factEnv, 5);
f01174c0:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01174c3:	83 ec 08             	sub    $0x8,%esp
f01174c6:	6a 05                	push   $0x5
f01174c8:	50                   	push   %eax
f01174c9:	e8 e2 46 ff ff       	call   f010bbb0 <set_program_priority>
f01174ce:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 4);
f01174d1:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01174d4:	83 ec 08             	sub    $0x8,%esp
f01174d7:	6a 04                	push   $0x4
f01174d9:	50                   	push   %eax
f01174da:	e8 d1 46 ff ff       	call   f010bbb0 <set_program_priority>
f01174df:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f01174e2:	e8 5a d0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01174e7:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f01174ea:	74 17                	je     f0117503 <test_priority_normal_and_higher+0x7ad>
f01174ec:	83 ec 04             	sub    $0x4,%esp
f01174ef:	68 34 b8 12 f0       	push   $0xf012b834
f01174f4:	68 a0 00 00 00       	push   $0xa0
f01174f9:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01174fe:	e8 17 8e fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117503:	e8 01 62 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117508:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f011750b:	74 17                	je     f0117524 <test_priority_normal_and_higher+0x7ce>
f011750d:	83 ec 04             	sub    $0x4,%esp
f0117510:	68 34 b8 12 f0       	push   $0xf012b834
f0117515:	68 a1 00 00 00       	push   $0xa1
f011751a:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011751f:	e8 f6 8d fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
f0117524:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0117527:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011752d:	83 f8 14             	cmp    $0x14,%eax
f0117530:	75 1c                	jne    f011754e <test_priority_normal_and_higher+0x7f8>
f0117532:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0117535:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011753b:	83 f8 3c             	cmp    $0x3c,%eax
f011753e:	75 0e                	jne    f011754e <test_priority_normal_and_higher+0x7f8>
f0117540:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0117543:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117549:	83 f8 28             	cmp    $0x28,%eax
f011754c:	74 17                	je     f0117565 <test_priority_normal_and_higher+0x80f>
			panic("The programs' working set size should be doubled if full\n");
f011754e:	83 ec 04             	sub    $0x4,%esp
f0117551:	68 68 b9 12 f0       	push   $0xf012b968
f0117556:	68 a4 00 00 00       	push   $0xa4
f011755b:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117560:	e8 b5 8d fe ff       	call   f010031a <_panic>

		for(int i = 15; i < 60; i++)
f0117565:	c7 45 c8 0f 00 00 00 	movl   $0xf,-0x38(%ebp)
f011756c:	eb 1c                	jmp    f011758a <test_priority_normal_and_higher+0x834>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
f011756e:	8b 4d a8             	mov    -0x58(%ebp),%ecx
f0117571:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0117574:	89 d0                	mov    %edx,%eax
f0117576:	01 c0                	add    %eax,%eax
f0117578:	01 d0                	add    %edx,%eax
f011757a:	c1 e0 03             	shl    $0x3,%eax
f011757d:	01 c8                	add    %ecx,%eax
f011757f:	05 8c 00 00 00       	add    $0x8c,%eax
f0117584:	c6 00 01             	movb   $0x1,(%eax)
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 60 || helloEnv->page_WS_max_size != 40)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 15; i < 60; i++)
f0117587:	ff 45 c8             	incl   -0x38(%ebp)
f011758a:	83 7d c8 3b          	cmpl   $0x3b,-0x38(%ebp)
f011758e:	7e de                	jle    f011756e <test_priority_normal_and_higher+0x818>
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f0117590:	c7 45 c4 0a 00 00 00 	movl   $0xa,-0x3c(%ebp)
f0117597:	eb 1c                	jmp    f01175b5 <test_priority_normal_and_higher+0x85f>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
f0117599:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
f011759c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011759f:	89 d0                	mov    %edx,%eax
f01175a1:	01 c0                	add    %eax,%eax
f01175a3:	01 d0                	add    %edx,%eax
f01175a5:	c1 e0 03             	shl    $0x3,%eax
f01175a8:	01 c8                	add    %ecx,%eax
f01175aa:	05 8c 00 00 00       	add    $0x8c,%eax
f01175af:	c6 00 01             	movb   $0x1,(%eax)

		for(int i = 15; i < 60; i++)
		{
			factEnv->ptr_pageWorkingSet[i].empty = 1;
		}
		for(int i = 10; i < 40; i++)
f01175b2:	ff 45 c4             	incl   -0x3c(%ebp)
f01175b5:	83 7d c4 27          	cmpl   $0x27,-0x3c(%ebp)
f01175b9:	7e de                	jle    f0117599 <test_priority_normal_and_higher+0x843>
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f01175bb:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f01175c2:	eb 7d                	jmp    f0117641 <test_priority_normal_and_higher+0x8eb>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f01175c4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01175c7:	8b 8c 85 74 fd ff ff 	mov    -0x28c(%ebp,%eax,4),%ecx
f01175ce:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f01175d1:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01175d4:	89 d0                	mov    %edx,%eax
f01175d6:	01 c0                	add    %eax,%eax
f01175d8:	01 d0                	add    %edx,%eax
f01175da:	c1 e0 03             	shl    $0x3,%eax
f01175dd:	01 d8                	add    %ebx,%eax
f01175df:	05 88 00 00 00       	add    $0x88,%eax
f01175e4:	8b 00                	mov    (%eax),%eax
f01175e6:	39 c1                	cmp    %eax,%ecx
f01175e8:	74 17                	je     f0117601 <test_priority_normal_and_higher+0x8ab>
				panic("Working set should be moved properly to the new one");
f01175ea:	83 ec 04             	sub    $0x4,%esp
f01175ed:	68 a4 b9 12 f0       	push   $0xf012b9a4
f01175f2:	68 b2 00 00 00       	push   $0xb2
f01175f7:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01175fc:	e8 19 8d fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0117601:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0117604:	8b 8c 85 c4 fd ff ff 	mov    -0x23c(%ebp,%eax,4),%ecx
f011760b:	8b 5d ac             	mov    -0x54(%ebp),%ebx
f011760e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117611:	89 d0                	mov    %edx,%eax
f0117613:	01 c0                	add    %eax,%eax
f0117615:	01 d0                	add    %edx,%eax
f0117617:	c1 e0 03             	shl    $0x3,%eax
f011761a:	01 d8                	add    %ebx,%eax
f011761c:	05 90 00 00 00       	add    $0x90,%eax
f0117621:	8b 00                	mov    (%eax),%eax
f0117623:	39 c1                	cmp    %eax,%ecx
f0117625:	74 17                	je     f011763e <test_priority_normal_and_higher+0x8e8>
				panic("Working set should be moved properly to the new one");
f0117627:	83 ec 04             	sub    $0x4,%esp
f011762a:	68 a4 b9 12 f0       	push   $0xf012b9a4
f011762f:	68 b5 00 00 00       	push   $0xb5
f0117634:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117639:	e8 dc 8c fe ff       	call   f010031a <_panic>
		for(int i = 10; i < 40; i++)
		{
			helloEnv->ptr_pageWorkingSet[i].empty = 1;
		}

		for(int i = 0; i < 20; i++)
f011763e:	ff 45 c0             	incl   -0x40(%ebp)
f0117641:	83 7d c0 13          	cmpl   $0x13,-0x40(%ebp)
f0117645:	0f 8e 79 ff ff ff    	jle    f01175c4 <test_priority_normal_and_higher+0x86e>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f011764b:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f0117652:	eb 7d                	jmp    f01176d1 <test_priority_normal_and_higher+0x97b>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0117654:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117657:	8b 8c 85 fc fc ff ff 	mov    -0x304(%ebp,%eax,4),%ecx
f011765e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0117661:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0117664:	89 d0                	mov    %edx,%eax
f0117666:	01 c0                	add    %eax,%eax
f0117668:	01 d0                	add    %edx,%eax
f011766a:	c1 e0 03             	shl    $0x3,%eax
f011766d:	01 d8                	add    %ebx,%eax
f011766f:	05 88 00 00 00       	add    $0x88,%eax
f0117674:	8b 00                	mov    (%eax),%eax
f0117676:	39 c1                	cmp    %eax,%ecx
f0117678:	74 17                	je     f0117691 <test_priority_normal_and_higher+0x93b>
				panic("Working set should be moved properly to the new one");
f011767a:	83 ec 04             	sub    $0x4,%esp
f011767d:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117682:	68 bb 00 00 00       	push   $0xbb
f0117687:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011768c:	e8 89 8c fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f0117691:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0117694:	8b 8c 85 38 fd ff ff 	mov    -0x2c8(%ebp,%eax,4),%ecx
f011769b:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011769e:	8b 55 bc             	mov    -0x44(%ebp),%edx
f01176a1:	89 d0                	mov    %edx,%eax
f01176a3:	01 c0                	add    %eax,%eax
f01176a5:	01 d0                	add    %edx,%eax
f01176a7:	c1 e0 03             	shl    $0x3,%eax
f01176aa:	01 d8                	add    %ebx,%eax
f01176ac:	05 90 00 00 00       	add    $0x90,%eax
f01176b1:	8b 00                	mov    (%eax),%eax
f01176b3:	39 c1                	cmp    %eax,%ecx
f01176b5:	74 17                	je     f01176ce <test_priority_normal_and_higher+0x978>
				panic("Working set should be moved properly to the new one");
f01176b7:	83 ec 04             	sub    $0x4,%esp
f01176ba:	68 a4 b9 12 f0       	push   $0xf012b9a4
f01176bf:	68 be 00 00 00       	push   $0xbe
f01176c4:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01176c9:	e8 4c 8c fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f01176ce:	ff 45 bc             	incl   -0x44(%ebp)
f01176d1:	83 7d bc 0e          	cmpl   $0xe,-0x44(%ebp)
f01176d5:	0f 8e 79 ff ff ff    	jle    f0117654 <test_priority_normal_and_higher+0x8fe>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f01176db:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f01176e2:	eb 7d                	jmp    f0117761 <test_priority_normal_and_higher+0xa0b>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f01176e4:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01176e7:	8b 8c 85 ac fc ff ff 	mov    -0x354(%ebp,%eax,4),%ecx
f01176ee:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f01176f1:	8b 55 b8             	mov    -0x48(%ebp),%edx
f01176f4:	89 d0                	mov    %edx,%eax
f01176f6:	01 c0                	add    %eax,%eax
f01176f8:	01 d0                	add    %edx,%eax
f01176fa:	c1 e0 03             	shl    $0x3,%eax
f01176fd:	01 d8                	add    %ebx,%eax
f01176ff:	05 88 00 00 00       	add    $0x88,%eax
f0117704:	8b 00                	mov    (%eax),%eax
f0117706:	39 c1                	cmp    %eax,%ecx
f0117708:	74 17                	je     f0117721 <test_priority_normal_and_higher+0x9cb>
				panic("Working set should be moved properly to the new one");
f011770a:	83 ec 04             	sub    $0x4,%esp
f011770d:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117712:	68 c4 00 00 00       	push   $0xc4
f0117717:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011771c:	e8 f9 8b fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0117721:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117724:	8b 8c 85 d4 fc ff ff 	mov    -0x32c(%ebp,%eax,4),%ecx
f011772b:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f011772e:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0117731:	89 d0                	mov    %edx,%eax
f0117733:	01 c0                	add    %eax,%eax
f0117735:	01 d0                	add    %edx,%eax
f0117737:	c1 e0 03             	shl    $0x3,%eax
f011773a:	01 d8                	add    %ebx,%eax
f011773c:	05 90 00 00 00       	add    $0x90,%eax
f0117741:	8b 00                	mov    (%eax),%eax
f0117743:	39 c1                	cmp    %eax,%ecx
f0117745:	74 17                	je     f011775e <test_priority_normal_and_higher+0xa08>
				panic("Working set should be moved properly to the new one");
f0117747:	83 ec 04             	sub    $0x4,%esp
f011774a:	68 a4 b9 12 f0       	push   $0xf012b9a4
f011774f:	68 c7 00 00 00       	push   $0xc7
f0117754:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117759:	e8 bc 8b fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f011775e:	ff 45 b8             	incl   -0x48(%ebp)
f0117761:	83 7d b8 09          	cmpl   $0x9,-0x48(%ebp)
f0117765:	0f 8e 79 ff ff ff    	jle    f01176e4 <test_priority_normal_and_higher+0x98e>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		char command4[100] = "runall";
f011776b:	c7 85 40 ff ff ff 72 	movl   $0x616e7572,-0xc0(%ebp)
f0117772:	75 6e 61 
f0117775:	c7 85 44 ff ff ff 6c 	movl   $0x6c6c,-0xbc(%ebp)
f011777c:	6c 00 00 
f011777f:	8d 95 48 ff ff ff    	lea    -0xb8(%ebp),%edx
f0117785:	b9 17 00 00 00       	mov    $0x17,%ecx
f011778a:	b8 00 00 00 00       	mov    $0x0,%eax
f011778f:	89 d7                	mov    %edx,%edi
f0117791:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f0117793:	83 ec 0c             	sub    $0xc,%esp
f0117796:	8d 85 40 ff ff ff    	lea    -0xc0(%ebp),%eax
f011779c:	50                   	push   %eax
f011779d:	e8 3a a7 fe ff       	call   f0101edc <execute_command>
f01177a2:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
	}
#endif
}
f01177a5:	eb 10                	jmp    f01177b7 <test_priority_normal_and_higher+0xa61>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 1 completed successfully.\n");
f01177a7:	83 ec 0c             	sub    $0xc,%esp
f01177aa:	68 d8 b9 12 f0       	push   $0xf012b9d8
f01177af:	e8 b8 97 fe ff       	call   f0100f6c <cprintf>
f01177b4:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f01177b7:	90                   	nop
f01177b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01177bb:	5b                   	pop    %ebx
f01177bc:	5e                   	pop    %esi
f01177bd:	5f                   	pop    %edi
f01177be:	5d                   	pop    %ebp
f01177bf:	c3                   	ret    

f01177c0 <test_priority_normal_and_lower>:

void test_priority_normal_and_lower()
{
f01177c0:	55                   	push   %ebp
f01177c1:	89 e5                	mov    %esp,%ebp
f01177c3:	57                   	push   %edi
f01177c4:	56                   	push   %esi
f01177c5:	53                   	push   %ebx
f01177c6:	81 ec ac 04 00 00    	sub    $0x4ac,%esp
#if USE_KHEAP
	panic("not handled yet");
#else
	if(firstTime)
f01177cc:	a0 94 9d 17 f0       	mov    0xf0179d94,%al
f01177d1:	84 c0                	test   %al,%al
f01177d3:	0f 84 1b 0a 00 00    	je     f01181f4 <test_priority_normal_and_lower+0xa34>
		uint32 fact_WS[30];
		uint32 fact_TimeStamp[30];
		uint32 hello_WS[40];
		uint32 hello_TimeStamp[40];

		firstTime = 0;
f01177d9:	c6 05 94 9d 17 f0 00 	movb   $0x0,0xf0179d94
		char command[100] = "load fos_add 20";
f01177e0:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f01177e6:	bb 14 ba 12 f0       	mov    $0xf012ba14,%ebx
f01177eb:	ba 04 00 00 00       	mov    $0x4,%edx
f01177f0:	89 c7                	mov    %eax,%edi
f01177f2:	89 de                	mov    %ebx,%esi
f01177f4:	89 d1                	mov    %edx,%ecx
f01177f6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01177f8:	8d 95 00 fc ff ff    	lea    -0x400(%ebp),%edx
f01177fe:	b9 15 00 00 00       	mov    $0x15,%ecx
f0117803:	b8 00 00 00 00       	mov    $0x0,%eax
f0117808:	89 d7                	mov    %edx,%edi
f011780a:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command);
f011780c:	83 ec 0c             	sub    $0xc,%esp
f011780f:	8d 85 f0 fb ff ff    	lea    -0x410(%ebp),%eax
f0117815:	50                   	push   %eax
f0117816:	e8 c1 a6 fe ff       	call   f0101edc <execute_command>
f011781b:	83 c4 10             	add    $0x10,%esp
		char command2[100] = "load fact 30";
f011781e:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f0117824:	bb 1c bd 12 f0       	mov    $0xf012bd1c,%ebx
f0117829:	ba 0d 00 00 00       	mov    $0xd,%edx
f011782e:	89 c7                	mov    %eax,%edi
f0117830:	89 de                	mov    %ebx,%esi
f0117832:	89 d1                	mov    %edx,%ecx
f0117834:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117836:	8d 95 61 fc ff ff    	lea    -0x39f(%ebp),%edx
f011783c:	b9 57 00 00 00       	mov    $0x57,%ecx
f0117841:	b0 00                	mov    $0x0,%al
f0117843:	89 d7                	mov    %edx,%edi
f0117845:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command2);
f0117847:	83 ec 0c             	sub    $0xc,%esp
f011784a:	8d 85 54 fc ff ff    	lea    -0x3ac(%ebp),%eax
f0117850:	50                   	push   %eax
f0117851:	e8 86 a6 fe ff       	call   f0101edc <execute_command>
f0117856:	83 c4 10             	add    $0x10,%esp
		char command3[100] = "load fos_helloWorld 40";
f0117859:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f011785f:	bb 80 bd 12 f0       	mov    $0xf012bd80,%ebx
f0117864:	ba 17 00 00 00       	mov    $0x17,%edx
f0117869:	89 c7                	mov    %eax,%edi
f011786b:	89 de                	mov    %ebx,%esi
f011786d:	89 d1                	mov    %edx,%ecx
f011786f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117871:	8d 95 cf fc ff ff    	lea    -0x331(%ebp),%edx
f0117877:	b9 4d 00 00 00       	mov    $0x4d,%ecx
f011787c:	b0 00                	mov    $0x0,%al
f011787e:	89 d7                	mov    %edx,%edi
f0117880:	f3 aa                	rep stos %al,%es:(%edi)
		execute_command(command3);
f0117882:	83 ec 0c             	sub    $0xc,%esp
f0117885:	8d 85 b8 fc ff ff    	lea    -0x348(%ebp),%eax
f011788b:	50                   	push   %eax
f011788c:	e8 4b a6 fe ff       	call   f0101edc <execute_command>
f0117891:	83 c4 10             	add    $0x10,%esp

		struct Env * addEnv;
		struct Env * factEnv;
		struct Env * helloEnv;
		envid2env(4096, &addEnv, 0);
f0117894:	83 ec 04             	sub    $0x4,%esp
f0117897:	6a 00                	push   $0x0
f0117899:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011789c:	50                   	push   %eax
f011789d:	68 00 10 00 00       	push   $0x1000
f01178a2:	e8 1a 2c ff ff       	call   f010a4c1 <envid2env>
f01178a7:	83 c4 10             	add    $0x10,%esp
		envid2env(4097, &factEnv, 0);
f01178aa:	83 ec 04             	sub    $0x4,%esp
f01178ad:	6a 00                	push   $0x0
f01178af:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f01178b2:	50                   	push   %eax
f01178b3:	68 01 10 00 00       	push   $0x1001
f01178b8:	e8 04 2c ff ff       	call   f010a4c1 <envid2env>
f01178bd:	83 c4 10             	add    $0x10,%esp
		envid2env(4098, &helloEnv, 0);
f01178c0:	83 ec 04             	sub    $0x4,%esp
f01178c3:	6a 00                	push   $0x0
f01178c5:	8d 45 b0             	lea    -0x50(%ebp),%eax
f01178c8:	50                   	push   %eax
f01178c9:	68 02 10 00 00       	push   $0x1002
f01178ce:	e8 ee 2b ff ff       	call   f010a4c1 <envid2env>
f01178d3:	83 c4 10             	add    $0x10,%esp

		if(addEnv == NULL || factEnv == NULL || helloEnv == NULL)
f01178d6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01178d9:	85 c0                	test   %eax,%eax
f01178db:	74 0e                	je     f01178eb <test_priority_normal_and_lower+0x12b>
f01178dd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01178e0:	85 c0                	test   %eax,%eax
f01178e2:	74 07                	je     f01178eb <test_priority_normal_and_lower+0x12b>
f01178e4:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01178e7:	85 c0                	test   %eax,%eax
f01178e9:	75 17                	jne    f0117902 <test_priority_normal_and_lower+0x142>
			panic("Loading programs failed\n");
f01178eb:	83 ec 04             	sub    $0x4,%esp
f01178ee:	68 98 b7 12 f0       	push   $0xf012b798
f01178f3:	68 f2 00 00 00       	push   $0xf2
f01178f8:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01178fd:	e8 18 8a fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117902:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117905:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011790b:	83 f8 14             	cmp    $0x14,%eax
f011790e:	75 1c                	jne    f011792c <test_priority_normal_and_lower+0x16c>
f0117910:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117913:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117919:	83 f8 1e             	cmp    $0x1e,%eax
f011791c:	75 0e                	jne    f011792c <test_priority_normal_and_lower+0x16c>
f011791e:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117921:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117927:	83 f8 28             	cmp    $0x28,%eax
f011792a:	74 17                	je     f0117943 <test_priority_normal_and_lower+0x183>
			panic("The programs should be initially loaded with the given working set size\n");
f011792c:	83 ec 04             	sub    $0x4,%esp
f011792f:	68 40 bb 12 f0       	push   $0xf012bb40
f0117934:	68 f5 00 00 00       	push   $0xf5
f0117939:	68 b1 b7 12 f0       	push   $0xf012b7b1
f011793e:	e8 d7 89 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 20; i++)
f0117943:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011794a:	eb 47                	jmp    f0117993 <test_priority_normal_and_lower+0x1d3>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
f011794c:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f011794f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117952:	89 d0                	mov    %edx,%eax
f0117954:	01 c0                	add    %eax,%eax
f0117956:	01 d0                	add    %edx,%eax
f0117958:	c1 e0 03             	shl    $0x3,%eax
f011795b:	01 c8                	add    %ecx,%eax
f011795d:	05 88 00 00 00       	add    $0x88,%eax
f0117962:	8b 10                	mov    (%eax),%edx
f0117964:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117967:	89 94 85 50 fb ff ff 	mov    %edx,-0x4b0(%ebp,%eax,4)
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
f011796e:	8b 4d b8             	mov    -0x48(%ebp),%ecx
f0117971:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0117974:	89 d0                	mov    %edx,%eax
f0117976:	01 c0                	add    %eax,%eax
f0117978:	01 d0                	add    %edx,%eax
f011797a:	c1 e0 03             	shl    $0x3,%eax
f011797d:	01 c8                	add    %ecx,%eax
f011797f:	05 90 00 00 00       	add    $0x90,%eax
f0117984:	8b 10                	mov    (%eax),%edx
f0117986:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117989:	89 94 85 a0 fb ff ff 	mov    %edx,-0x460(%ebp,%eax,4)
			panic("Loading programs failed\n");

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
			panic("The programs should be initially loaded with the given working set size\n");

		for(int i = 0; i < 20; i++)
f0117990:	ff 45 e4             	incl   -0x1c(%ebp)
f0117993:	83 7d e4 13          	cmpl   $0x13,-0x1c(%ebp)
f0117997:	7e b3                	jle    f011794c <test_priority_normal_and_lower+0x18c>
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f0117999:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f01179a0:	eb 47                	jmp    f01179e9 <test_priority_normal_and_lower+0x229>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
f01179a2:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f01179a5:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01179a8:	89 d0                	mov    %edx,%eax
f01179aa:	01 c0                	add    %eax,%eax
f01179ac:	01 d0                	add    %edx,%eax
f01179ae:	c1 e0 03             	shl    $0x3,%eax
f01179b1:	01 c8                	add    %ecx,%eax
f01179b3:	05 88 00 00 00       	add    $0x88,%eax
f01179b8:	8b 10                	mov    (%eax),%edx
f01179ba:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01179bd:	89 94 85 80 fd ff ff 	mov    %edx,-0x280(%ebp,%eax,4)
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
f01179c4:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
f01179c7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01179ca:	89 d0                	mov    %edx,%eax
f01179cc:	01 c0                	add    %eax,%eax
f01179ce:	01 d0                	add    %edx,%eax
f01179d0:	c1 e0 03             	shl    $0x3,%eax
f01179d3:	01 c8                	add    %ecx,%eax
f01179d5:	05 90 00 00 00       	add    $0x90,%eax
f01179da:	8b 10                	mov    (%eax),%edx
f01179dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01179df:	89 94 85 f8 fd ff ff 	mov    %edx,-0x208(%ebp,%eax,4)
		{
			add_WS[i] = addEnv->ptr_pageWorkingSet[i].virtual_address;
			add_TimeStamp[i] = addEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 30; i++)
f01179e6:	ff 45 e0             	incl   -0x20(%ebp)
f01179e9:	83 7d e0 1d          	cmpl   $0x1d,-0x20(%ebp)
f01179ed:	7e b3                	jle    f01179a2 <test_priority_normal_and_lower+0x1e2>
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f01179ef:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f01179f6:	eb 47                	jmp    f0117a3f <test_priority_normal_and_lower+0x27f>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
f01179f8:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f01179fb:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01179fe:	89 d0                	mov    %edx,%eax
f0117a00:	01 c0                	add    %eax,%eax
f0117a02:	01 d0                	add    %edx,%eax
f0117a04:	c1 e0 03             	shl    $0x3,%eax
f0117a07:	01 c8                	add    %ecx,%eax
f0117a09:	05 88 00 00 00       	add    $0x88,%eax
f0117a0e:	8b 10                	mov    (%eax),%edx
f0117a10:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117a13:	89 94 85 70 fe ff ff 	mov    %edx,-0x190(%ebp,%eax,4)
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
f0117a1a:	8b 4d b0             	mov    -0x50(%ebp),%ecx
f0117a1d:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0117a20:	89 d0                	mov    %edx,%eax
f0117a22:	01 c0                	add    %eax,%eax
f0117a24:	01 d0                	add    %edx,%eax
f0117a26:	c1 e0 03             	shl    $0x3,%eax
f0117a29:	01 c8                	add    %ecx,%eax
f0117a2b:	05 90 00 00 00       	add    $0x90,%eax
f0117a30:	8b 10                	mov    (%eax),%edx
f0117a32:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117a35:	89 94 85 10 ff ff ff 	mov    %edx,-0xf0(%ebp,%eax,4)
		{
			fact_WS[i] = factEnv->ptr_pageWorkingSet[i].virtual_address;
			fact_TimeStamp[i] = factEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		for(int i = 0; i < 40; i++)
f0117a3c:	ff 45 dc             	incl   -0x24(%ebp)
f0117a3f:	83 7d dc 27          	cmpl   $0x27,-0x24(%ebp)
f0117a43:	7e b3                	jle    f01179f8 <test_priority_normal_and_lower+0x238>
		{
			hello_WS[i] = helloEnv->ptr_pageWorkingSet[i].virtual_address;
			hello_TimeStamp[i] = helloEnv->ptr_pageWorkingSet[i].time_stamp;
		}

		int freeFrames = sys_calculate_free_frames();
f0117a45:	e8 bf 5c ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117a4a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f0117a4d:	e8 ef ca fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117a52:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Normal // Should change nothing
		set_program_priority(addEnv, 3);
f0117a55:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117a58:	83 ec 08             	sub    $0x8,%esp
f0117a5b:	6a 03                	push   $0x3
f0117a5d:	50                   	push   %eax
f0117a5e:	e8 4d 41 ff ff       	call   f010bbb0 <set_program_priority>
f0117a63:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 3);
f0117a66:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117a69:	83 ec 08             	sub    $0x8,%esp
f0117a6c:	6a 03                	push   $0x3
f0117a6e:	50                   	push   %eax
f0117a6f:	e8 3c 41 ff ff       	call   f010bbb0 <set_program_priority>
f0117a74:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 3);
f0117a77:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117a7a:	83 ec 08             	sub    $0x8,%esp
f0117a7d:	6a 03                	push   $0x3
f0117a7f:	50                   	push   %eax
f0117a80:	e8 2b 41 ff ff       	call   f010bbb0 <set_program_priority>
f0117a85:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117a88:	e8 b4 ca fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117a8d:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117a90:	74 17                	je     f0117aa9 <test_priority_normal_and_lower+0x2e9>
f0117a92:	83 ec 04             	sub    $0x4,%esp
f0117a95:	68 34 b8 12 f0       	push   $0xf012b834
f0117a9a:	68 11 01 00 00       	push   $0x111
f0117a9f:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117aa4:	e8 71 88 fe ff       	call   f010031a <_panic>
		if ((freeFrames - sys_calculate_free_frames()) != 0) panic("Old working set should be removed properly\n");
f0117aa9:	e8 5b 5c ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117aae:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0117ab1:	74 17                	je     f0117aca <test_priority_normal_and_lower+0x30a>
f0117ab3:	83 ec 04             	sub    $0x4,%esp
f0117ab6:	68 34 b8 12 f0       	push   $0xf012b834
f0117abb:	68 12 01 00 00       	push   $0x112
f0117ac0:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117ac5:	e8 50 88 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 20 || factEnv->page_WS_max_size != 30 || helloEnv->page_WS_max_size != 40)
f0117aca:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117acd:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117ad3:	83 f8 14             	cmp    $0x14,%eax
f0117ad6:	75 1c                	jne    f0117af4 <test_priority_normal_and_lower+0x334>
f0117ad8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117adb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117ae1:	83 f8 1e             	cmp    $0x1e,%eax
f0117ae4:	75 0e                	jne    f0117af4 <test_priority_normal_and_lower+0x334>
f0117ae6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117ae9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117aef:	83 f8 28             	cmp    $0x28,%eax
f0117af2:	74 17                	je     f0117b0b <test_priority_normal_and_lower+0x34b>
			panic("The programs' working set size should not change after setting priority to normal\n");
f0117af4:	83 ec 04             	sub    $0x4,%esp
f0117af7:	68 60 b8 12 f0       	push   $0xf012b860
f0117afc:	68 15 01 00 00       	push   $0x115
f0117b01:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117b06:	e8 0f 88 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0117b0b:	e8 f9 5b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117b10:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117b13:	e8 29 ca fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117b18:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0117b1b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117b1e:	83 ec 08             	sub    $0x8,%esp
f0117b21:	6a 02                	push   $0x2
f0117b23:	50                   	push   %eax
f0117b24:	e8 87 40 ff ff       	call   f010bbb0 <set_program_priority>
f0117b29:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0117b2c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117b2f:	83 ec 08             	sub    $0x8,%esp
f0117b32:	6a 02                	push   $0x2
f0117b34:	50                   	push   %eax
f0117b35:	e8 76 40 ff ff       	call   f010bbb0 <set_program_priority>
f0117b3a:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f0117b3d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117b40:	83 ec 08             	sub    $0x8,%esp
f0117b43:	6a 02                	push   $0x2
f0117b45:	50                   	push   %eax
f0117b46:	e8 65 40 ff ff       	call   f010bbb0 <set_program_priority>
f0117b4b:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117b4e:	e8 ee c9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117b53:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117b56:	74 17                	je     f0117b6f <test_priority_normal_and_lower+0x3af>
f0117b58:	83 ec 04             	sub    $0x4,%esp
f0117b5b:	68 34 b8 12 f0       	push   $0xf012b834
f0117b60:	68 1f 01 00 00       	push   $0x11f
f0117b65:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117b6a:	e8 ab 87 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0117b6f:	e8 95 5b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117b74:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0117b77:	74 21                	je     f0117b9a <test_priority_normal_and_lower+0x3da>
f0117b79:	e8 8b 5b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117b7e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117b81:	29 c2                	sub    %eax,%edx
f0117b83:	89 d0                	mov    %edx,%eax
f0117b85:	50                   	push   %eax
f0117b86:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117b8b:	68 20 01 00 00       	push   $0x120
f0117b90:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117b95:	e8 80 87 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 20)
f0117b9a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117b9d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117ba3:	83 f8 0a             	cmp    $0xa,%eax
f0117ba6:	75 1c                	jne    f0117bc4 <test_priority_normal_and_lower+0x404>
f0117ba8:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117bab:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117bb1:	83 f8 0f             	cmp    $0xf,%eax
f0117bb4:	75 0e                	jne    f0117bc4 <test_priority_normal_and_lower+0x404>
f0117bb6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117bb9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117bbf:	83 f8 14             	cmp    $0x14,%eax
f0117bc2:	74 17                	je     f0117bdb <test_priority_normal_and_lower+0x41b>
			panic("The programs' working set size should be doubled only if it is full\n");
f0117bc4:	83 ec 04             	sub    $0x4,%esp
f0117bc7:	68 e4 b8 12 f0       	push   $0xf012b8e4
f0117bcc:	68 23 01 00 00       	push   $0x123
f0117bd1:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117bd6:	e8 3f 87 fe ff       	call   f010031a <_panic>

		freeFrames = sys_calculate_free_frames();
f0117bdb:	e8 29 5b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117be0:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117be3:	e8 59 c9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117be8:	89 45 bc             	mov    %eax,-0x44(%ebp)

		// Set Priority To Below Normal // Should change only if half is free
		set_program_priority(addEnv, 2);
f0117beb:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117bee:	83 ec 08             	sub    $0x8,%esp
f0117bf1:	6a 02                	push   $0x2
f0117bf3:	50                   	push   %eax
f0117bf4:	e8 b7 3f ff ff       	call   f010bbb0 <set_program_priority>
f0117bf9:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 2);
f0117bfc:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117bff:	83 ec 08             	sub    $0x8,%esp
f0117c02:	6a 02                	push   $0x2
f0117c04:	50                   	push   %eax
f0117c05:	e8 a6 3f ff ff       	call   f010bbb0 <set_program_priority>
f0117c0a:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 2);
f0117c0d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117c10:	83 ec 08             	sub    $0x8,%esp
f0117c13:	6a 02                	push   $0x2
f0117c15:	50                   	push   %eax
f0117c16:	e8 95 3f ff ff       	call   f010bbb0 <set_program_priority>
f0117c1b:	83 c4 10             	add    $0x10,%esp

		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117c1e:	e8 1e c9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117c23:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117c26:	74 17                	je     f0117c3f <test_priority_normal_and_lower+0x47f>
f0117c28:	83 ec 04             	sub    $0x4,%esp
f0117c2b:	68 34 b8 12 f0       	push   $0xf012b834
f0117c30:	68 2d 01 00 00       	push   $0x12d
f0117c35:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117c3a:	e8 db 86 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));
f0117c3f:	e8 c5 5a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117c44:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f0117c47:	74 21                	je     f0117c6a <test_priority_normal_and_lower+0x4aa>
f0117c49:	e8 bb 5a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117c4e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0117c51:	29 c2                	sub    %eax,%edx
f0117c53:	89 d0                	mov    %edx,%eax
f0117c55:	50                   	push   %eax
f0117c56:	68 b4 b8 12 f0       	push   $0xf012b8b4
f0117c5b:	68 2e 01 00 00       	push   $0x12e
f0117c60:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117c65:	e8 b0 86 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
f0117c6a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117c6d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117c73:	83 f8 0a             	cmp    $0xa,%eax
f0117c76:	75 1c                	jne    f0117c94 <test_priority_normal_and_lower+0x4d4>
f0117c78:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117c7b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117c81:	83 f8 0f             	cmp    $0xf,%eax
f0117c84:	75 0e                	jne    f0117c94 <test_priority_normal_and_lower+0x4d4>
f0117c86:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117c89:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117c8f:	83 f8 0a             	cmp    $0xa,%eax
f0117c92:	74 17                	je     f0117cab <test_priority_normal_and_lower+0x4eb>
			panic("The programs' working set size should be doubled only if it is full\n");
f0117c94:	83 ec 04             	sub    $0x4,%esp
f0117c97:	68 e4 b8 12 f0       	push   $0xf012b8e4
f0117c9c:	68 31 01 00 00       	push   $0x131
f0117ca1:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117ca6:	e8 6f 86 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 10; i++)
f0117cab:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0117cb2:	eb 7d                	jmp    f0117d31 <test_priority_normal_and_lower+0x571>
		{
			if(add_WS[i] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0117cb4:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0117cb7:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0117cbe:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0117cc1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0117cc4:	89 d0                	mov    %edx,%eax
f0117cc6:	01 c0                	add    %eax,%eax
f0117cc8:	01 d0                	add    %edx,%eax
f0117cca:	c1 e0 03             	shl    $0x3,%eax
f0117ccd:	01 d8                	add    %ebx,%eax
f0117ccf:	05 88 00 00 00       	add    $0x88,%eax
f0117cd4:	8b 00                	mov    (%eax),%eax
f0117cd6:	39 c1                	cmp    %eax,%ecx
f0117cd8:	74 17                	je     f0117cf1 <test_priority_normal_and_lower+0x531>
				panic("Working set should be moved properly to the new one");
f0117cda:	83 ec 04             	sub    $0x4,%esp
f0117cdd:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117ce2:	68 36 01 00 00       	push   $0x136
f0117ce7:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117cec:	e8 29 86 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0117cf1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0117cf4:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0117cfb:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0117cfe:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0117d01:	89 d0                	mov    %edx,%eax
f0117d03:	01 c0                	add    %eax,%eax
f0117d05:	01 d0                	add    %edx,%eax
f0117d07:	c1 e0 03             	shl    $0x3,%eax
f0117d0a:	01 d8                	add    %ebx,%eax
f0117d0c:	05 90 00 00 00       	add    $0x90,%eax
f0117d11:	8b 00                	mov    (%eax),%eax
f0117d13:	39 c1                	cmp    %eax,%ecx
f0117d15:	74 17                	je     f0117d2e <test_priority_normal_and_lower+0x56e>
				panic("Working set should be moved properly to the new one");
f0117d17:	83 ec 04             	sub    $0x4,%esp
f0117d1a:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117d1f:	68 39 01 00 00       	push   $0x139
f0117d24:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117d29:	e8 ec 85 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 0) panic("Old working set should be removed properly%x\n", (freeFrames - sys_calculate_free_frames()));

		if(addEnv->page_WS_max_size != 10 || factEnv->page_WS_max_size != 15 || helloEnv->page_WS_max_size != 10)
			panic("The programs' working set size should be doubled only if it is full\n");

		for(int i = 0; i < 10; i++)
f0117d2e:	ff 45 d8             	incl   -0x28(%ebp)
f0117d31:	83 7d d8 09          	cmpl   $0x9,-0x28(%ebp)
f0117d35:	0f 8e 79 ff ff ff    	jle    f0117cb4 <test_priority_normal_and_lower+0x4f4>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0117d3b:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0117d42:	eb 7d                	jmp    f0117dc1 <test_priority_normal_and_lower+0x601>
		{
			if(fact_WS[i] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0117d44:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117d47:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f0117d4e:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0117d51:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0117d54:	89 d0                	mov    %edx,%eax
f0117d56:	01 c0                	add    %eax,%eax
f0117d58:	01 d0                	add    %edx,%eax
f0117d5a:	c1 e0 03             	shl    $0x3,%eax
f0117d5d:	01 d8                	add    %ebx,%eax
f0117d5f:	05 88 00 00 00       	add    $0x88,%eax
f0117d64:	8b 00                	mov    (%eax),%eax
f0117d66:	39 c1                	cmp    %eax,%ecx
f0117d68:	74 17                	je     f0117d81 <test_priority_normal_and_lower+0x5c1>
				panic("Working set should be moved properly to the new one");
f0117d6a:	83 ec 04             	sub    $0x4,%esp
f0117d6d:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117d72:	68 3f 01 00 00       	push   $0x13f
f0117d77:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117d7c:	e8 99 85 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f0117d81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0117d84:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f0117d8b:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0117d8e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0117d91:	89 d0                	mov    %edx,%eax
f0117d93:	01 c0                	add    %eax,%eax
f0117d95:	01 d0                	add    %edx,%eax
f0117d97:	c1 e0 03             	shl    $0x3,%eax
f0117d9a:	01 d8                	add    %ebx,%eax
f0117d9c:	05 90 00 00 00       	add    $0x90,%eax
f0117da1:	8b 00                	mov    (%eax),%eax
f0117da3:	39 c1                	cmp    %eax,%ecx
f0117da5:	74 17                	je     f0117dbe <test_priority_normal_and_lower+0x5fe>
				panic("Working set should be moved properly to the new one");
f0117da7:	83 ec 04             	sub    $0x4,%esp
f0117daa:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117daf:	68 42 01 00 00       	push   $0x142
f0117db4:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117db9:	e8 5c 85 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 15; i++)
f0117dbe:	ff 45 d4             	incl   -0x2c(%ebp)
f0117dc1:	83 7d d4 0e          	cmpl   $0xe,-0x2c(%ebp)
f0117dc5:	0f 8e 79 ff ff ff    	jle    f0117d44 <test_priority_normal_and_lower+0x584>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0117dcb:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f0117dd2:	eb 7d                	jmp    f0117e51 <test_priority_normal_and_lower+0x691>
		{
			if(hello_WS[i] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0117dd4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117dd7:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0117dde:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0117de1:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117de4:	89 d0                	mov    %edx,%eax
f0117de6:	01 c0                	add    %eax,%eax
f0117de8:	01 d0                	add    %edx,%eax
f0117dea:	c1 e0 03             	shl    $0x3,%eax
f0117ded:	01 d8                	add    %ebx,%eax
f0117def:	05 88 00 00 00       	add    $0x88,%eax
f0117df4:	8b 00                	mov    (%eax),%eax
f0117df6:	39 c1                	cmp    %eax,%ecx
f0117df8:	74 17                	je     f0117e11 <test_priority_normal_and_lower+0x651>
				panic("Working set should be moved properly to the new one");
f0117dfa:	83 ec 04             	sub    $0x4,%esp
f0117dfd:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117e02:	68 48 01 00 00       	push   $0x148
f0117e07:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117e0c:	e8 09 85 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0117e11:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117e14:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0117e1b:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0117e1e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0117e21:	89 d0                	mov    %edx,%eax
f0117e23:	01 c0                	add    %eax,%eax
f0117e25:	01 d0                	add    %edx,%eax
f0117e27:	c1 e0 03             	shl    $0x3,%eax
f0117e2a:	01 d8                	add    %ebx,%eax
f0117e2c:	05 90 00 00 00       	add    $0x90,%eax
f0117e31:	8b 00                	mov    (%eax),%eax
f0117e33:	39 c1                	cmp    %eax,%ecx
f0117e35:	74 17                	je     f0117e4e <test_priority_normal_and_lower+0x68e>
				panic("Working set should be moved properly to the new one");
f0117e37:	83 ec 04             	sub    $0x4,%esp
f0117e3a:	68 a4 b9 12 f0       	push   $0xf012b9a4
f0117e3f:	68 4b 01 00 00       	push   $0x14b
f0117e44:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117e49:	e8 cc 84 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		for(int i = 0; i < 10; i++)
f0117e4e:	ff 45 d0             	incl   -0x30(%ebp)
f0117e51:	83 7d d0 09          	cmpl   $0x9,-0x30(%ebp)
f0117e55:	0f 8e 79 ff ff ff    	jle    f0117dd4 <test_priority_normal_and_lower+0x614>
			if(hello_TimeStamp[i] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one");
		}

		// Set priority to low
		freeFrames = sys_calculate_free_frames();
f0117e5b:	e8 a9 58 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117e60:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117e63:	e8 d9 c6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117e68:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0117e6b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117e6e:	83 ec 08             	sub    $0x8,%esp
f0117e71:	6a 01                	push   $0x1
f0117e73:	50                   	push   %eax
f0117e74:	e8 37 3d ff ff       	call   f010bbb0 <set_program_priority>
f0117e79:	83 c4 10             	add    $0x10,%esp
		set_program_priority(factEnv, 1);
f0117e7c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117e7f:	83 ec 08             	sub    $0x8,%esp
f0117e82:	6a 01                	push   $0x1
f0117e84:	50                   	push   %eax
f0117e85:	e8 26 3d ff ff       	call   f010bbb0 <set_program_priority>
f0117e8a:	83 c4 10             	add    $0x10,%esp
		set_program_priority(helloEnv, 1);
f0117e8d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117e90:	83 ec 08             	sub    $0x8,%esp
f0117e93:	6a 01                	push   $0x1
f0117e95:	50                   	push   %eax
f0117e96:	e8 15 3d ff ff       	call   f010bbb0 <set_program_priority>
f0117e9b:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117e9e:	e8 9e c6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117ea3:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117ea6:	74 17                	je     f0117ebf <test_priority_normal_and_lower+0x6ff>
f0117ea8:	83 ec 04             	sub    $0x4,%esp
f0117eab:	68 34 b8 12 f0       	push   $0xf012b834
f0117eb0:	68 54 01 00 00       	push   $0x154
f0117eb5:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117eba:	e8 5b 84 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != (5+3+5)) panic("Old working set and extra pages in WS should be removed properly %d\n");
f0117ebf:	e8 45 58 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117ec4:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0117ec7:	83 f8 0d             	cmp    $0xd,%eax
f0117eca:	74 17                	je     f0117ee3 <test_priority_normal_and_lower+0x723>
f0117ecc:	83 ec 04             	sub    $0x4,%esp
f0117ecf:	68 8c bb 12 f0       	push   $0xf012bb8c
f0117ed4:	68 55 01 00 00       	push   $0x155
f0117ed9:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117ede:	e8 37 84 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 5 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0117ee3:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117ee6:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117eec:	83 f8 05             	cmp    $0x5,%eax
f0117eef:	75 1c                	jne    f0117f0d <test_priority_normal_and_lower+0x74d>
f0117ef1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117ef4:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117efa:	83 f8 07             	cmp    $0x7,%eax
f0117efd:	75 0e                	jne    f0117f0d <test_priority_normal_and_lower+0x74d>
f0117eff:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117f02:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117f08:	83 f8 05             	cmp    $0x5,%eax
f0117f0b:	74 17                	je     f0117f24 <test_priority_normal_and_lower+0x764>
			panic("The programs' working set size should be half\n");
f0117f0d:	83 ec 04             	sub    $0x4,%esp
f0117f10:	68 d4 bb 12 f0       	push   $0xf012bbd4
f0117f15:	68 58 01 00 00       	push   $0x158
f0117f1a:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117f1f:	e8 f6 83 fe ff       	call   f010031a <_panic>


		freeFrames = sys_calculate_free_frames();
f0117f24:	e8 e0 57 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117f29:	89 45 c0             	mov    %eax,-0x40(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f0117f2c:	e8 10 c6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117f31:	89 45 bc             	mov    %eax,-0x44(%ebp)
		set_program_priority(addEnv, 1);
f0117f34:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117f37:	83 ec 08             	sub    $0x8,%esp
f0117f3a:	6a 01                	push   $0x1
f0117f3c:	50                   	push   %eax
f0117f3d:	e8 6e 3c ff ff       	call   f010bbb0 <set_program_priority>
f0117f42:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) panic("Old working set should be removed properly\n");
f0117f45:	e8 f7 c5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0117f4a:	3b 45 bc             	cmp    -0x44(%ebp),%eax
f0117f4d:	74 17                	je     f0117f66 <test_priority_normal_and_lower+0x7a6>
f0117f4f:	83 ec 04             	sub    $0x4,%esp
f0117f52:	68 34 b8 12 f0       	push   $0xf012b834
f0117f57:	68 5e 01 00 00       	push   $0x15e
f0117f5c:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117f61:	e8 b4 83 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");
f0117f66:	e8 9e 57 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0117f6b:	2b 45 c0             	sub    -0x40(%ebp),%eax
f0117f6e:	83 f8 03             	cmp    $0x3,%eax
f0117f71:	74 17                	je     f0117f8a <test_priority_normal_and_lower+0x7ca>
f0117f73:	83 ec 04             	sub    $0x4,%esp
f0117f76:	68 34 b8 12 f0       	push   $0xf012b834
f0117f7b:	68 5f 01 00 00       	push   $0x15f
f0117f80:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117f85:	e8 90 83 fe ff       	call   f010031a <_panic>

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
f0117f8a:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0117f8d:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117f93:	83 f8 02             	cmp    $0x2,%eax
f0117f96:	75 1c                	jne    f0117fb4 <test_priority_normal_and_lower+0x7f4>
f0117f98:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0117f9b:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117fa1:	83 f8 07             	cmp    $0x7,%eax
f0117fa4:	75 0e                	jne    f0117fb4 <test_priority_normal_and_lower+0x7f4>
f0117fa6:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0117fa9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0117faf:	83 f8 05             	cmp    $0x5,%eax
f0117fb2:	74 17                	je     f0117fcb <test_priority_normal_and_lower+0x80b>
			panic("The programs' working set size should be doubled if full\n");
f0117fb4:	83 ec 04             	sub    $0x4,%esp
f0117fb7:	68 68 b9 12 f0       	push   $0xf012b968
f0117fbc:	68 62 01 00 00       	push   $0x162
f0117fc1:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0117fc6:	e8 4f 83 fe ff       	call   f010031a <_panic>

		for(int i = 0; i < 2; i++)
f0117fcb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f0117fd2:	e9 83 00 00 00       	jmp    f011805a <test_priority_normal_and_lower+0x89a>
		{
			if(add_WS[i+8] != addEnv->ptr_pageWorkingSet[i].virtual_address)
f0117fd7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0117fda:	83 c0 08             	add    $0x8,%eax
f0117fdd:	8b 8c 85 50 fb ff ff 	mov    -0x4b0(%ebp,%eax,4),%ecx
f0117fe4:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0117fe7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0117fea:	89 d0                	mov    %edx,%eax
f0117fec:	01 c0                	add    %eax,%eax
f0117fee:	01 d0                	add    %edx,%eax
f0117ff0:	c1 e0 03             	shl    $0x3,%eax
f0117ff3:	01 d8                	add    %ebx,%eax
f0117ff5:	05 88 00 00 00       	add    $0x88,%eax
f0117ffa:	8b 00                	mov    (%eax),%eax
f0117ffc:	39 c1                	cmp    %eax,%ecx
f0117ffe:	74 17                	je     f0118017 <test_priority_normal_and_lower+0x857>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0118000:	83 ec 04             	sub    $0x4,%esp
f0118003:	68 04 bc 12 f0       	push   $0xf012bc04
f0118008:	68 67 01 00 00       	push   $0x167
f011800d:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0118012:	e8 03 83 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
f0118017:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011801a:	83 c0 08             	add    $0x8,%eax
f011801d:	8b 8c 85 a0 fb ff ff 	mov    -0x460(%ebp,%eax,4),%ecx
f0118024:	8b 5d b8             	mov    -0x48(%ebp),%ebx
f0118027:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011802a:	89 d0                	mov    %edx,%eax
f011802c:	01 c0                	add    %eax,%eax
f011802e:	01 d0                	add    %edx,%eax
f0118030:	c1 e0 03             	shl    $0x3,%eax
f0118033:	01 d8                	add    %ebx,%eax
f0118035:	05 90 00 00 00       	add    $0x90,%eax
f011803a:	8b 00                	mov    (%eax),%eax
f011803c:	39 c1                	cmp    %eax,%ecx
f011803e:	74 17                	je     f0118057 <test_priority_normal_and_lower+0x897>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0118040:	83 ec 04             	sub    $0x4,%esp
f0118043:	68 04 bc 12 f0       	push   $0xf012bc04
f0118048:	68 6a 01 00 00       	push   $0x16a
f011804d:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0118052:	e8 c3 82 fe ff       	call   f010031a <_panic>
		if ((sys_calculate_free_frames() - freeFrames) != 3) panic("Old working set should be removed properly\n");

		if(addEnv->page_WS_max_size != 2 || factEnv->page_WS_max_size != 7 || helloEnv->page_WS_max_size != 5)
			panic("The programs' working set size should be doubled if full\n");

		for(int i = 0; i < 2; i++)
f0118057:	ff 45 cc             	incl   -0x34(%ebp)
f011805a:	83 7d cc 01          	cmpl   $0x1,-0x34(%ebp)
f011805e:	0f 8e 73 ff ff ff    	jle    f0117fd7 <test_priority_normal_and_lower+0x817>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f0118064:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f011806b:	e9 83 00 00 00       	jmp    f01180f3 <test_priority_normal_and_lower+0x933>
		{
			if(fact_WS[i+3] != factEnv->ptr_pageWorkingSet[i].virtual_address)
f0118070:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0118073:	83 c0 03             	add    $0x3,%eax
f0118076:	8b 8c 85 80 fd ff ff 	mov    -0x280(%ebp,%eax,4),%ecx
f011807d:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f0118080:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0118083:	89 d0                	mov    %edx,%eax
f0118085:	01 c0                	add    %eax,%eax
f0118087:	01 d0                	add    %edx,%eax
f0118089:	c1 e0 03             	shl    $0x3,%eax
f011808c:	01 d8                	add    %ebx,%eax
f011808e:	05 88 00 00 00       	add    $0x88,%eax
f0118093:	8b 00                	mov    (%eax),%eax
f0118095:	39 c1                	cmp    %eax,%ecx
f0118097:	74 17                	je     f01180b0 <test_priority_normal_and_lower+0x8f0>
				panic("%d Working set should be moved properly to the new one, removed pages are chosen based on replacement policy", i);
f0118099:	ff 75 c8             	pushl  -0x38(%ebp)
f011809c:	68 70 bc 12 f0       	push   $0xf012bc70
f01180a1:	68 70 01 00 00       	push   $0x170
f01180a6:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01180ab:	e8 6a 82 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
f01180b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01180b3:	83 c0 03             	add    $0x3,%eax
f01180b6:	8b 8c 85 f8 fd ff ff 	mov    -0x208(%ebp,%eax,4),%ecx
f01180bd:	8b 5d b4             	mov    -0x4c(%ebp),%ebx
f01180c0:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01180c3:	89 d0                	mov    %edx,%eax
f01180c5:	01 c0                	add    %eax,%eax
f01180c7:	01 d0                	add    %edx,%eax
f01180c9:	c1 e0 03             	shl    $0x3,%eax
f01180cc:	01 d8                	add    %ebx,%eax
f01180ce:	05 90 00 00 00       	add    $0x90,%eax
f01180d3:	8b 00                	mov    (%eax),%eax
f01180d5:	39 c1                	cmp    %eax,%ecx
f01180d7:	74 17                	je     f01180f0 <test_priority_normal_and_lower+0x930>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f01180d9:	83 ec 04             	sub    $0x4,%esp
f01180dc:	68 04 bc 12 f0       	push   $0xf012bc04
f01180e1:	68 73 01 00 00       	push   $0x173
f01180e6:	68 b1 b7 12 f0       	push   $0xf012b7b1
f01180eb:	e8 2a 82 fe ff       	call   f010031a <_panic>

			if(add_TimeStamp[i+8] != addEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 7; i++)
f01180f0:	ff 45 c8             	incl   -0x38(%ebp)
f01180f3:	83 7d c8 06          	cmpl   $0x6,-0x38(%ebp)
f01180f7:	0f 8e 73 ff ff ff    	jle    f0118070 <test_priority_normal_and_lower+0x8b0>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f01180fd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f0118104:	e9 83 00 00 00       	jmp    f011818c <test_priority_normal_and_lower+0x9cc>
		{
			if(hello_WS[i+5] != helloEnv->ptr_pageWorkingSet[i].virtual_address)
f0118109:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011810c:	83 c0 05             	add    $0x5,%eax
f011810f:	8b 8c 85 70 fe ff ff 	mov    -0x190(%ebp,%eax,4),%ecx
f0118116:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0118119:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011811c:	89 d0                	mov    %edx,%eax
f011811e:	01 c0                	add    %eax,%eax
f0118120:	01 d0                	add    %edx,%eax
f0118122:	c1 e0 03             	shl    $0x3,%eax
f0118125:	01 d8                	add    %ebx,%eax
f0118127:	05 88 00 00 00       	add    $0x88,%eax
f011812c:	8b 00                	mov    (%eax),%eax
f011812e:	39 c1                	cmp    %eax,%ecx
f0118130:	74 17                	je     f0118149 <test_priority_normal_and_lower+0x989>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0118132:	83 ec 04             	sub    $0x4,%esp
f0118135:	68 04 bc 12 f0       	push   $0xf012bc04
f011813a:	68 79 01 00 00       	push   $0x179
f011813f:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0118144:	e8 d1 81 fe ff       	call   f010031a <_panic>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
f0118149:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011814c:	83 c0 05             	add    $0x5,%eax
f011814f:	8b 8c 85 10 ff ff ff 	mov    -0xf0(%ebp,%eax,4),%ecx
f0118156:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f0118159:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011815c:	89 d0                	mov    %edx,%eax
f011815e:	01 c0                	add    %eax,%eax
f0118160:	01 d0                	add    %edx,%eax
f0118162:	c1 e0 03             	shl    $0x3,%eax
f0118165:	01 d8                	add    %ebx,%eax
f0118167:	05 90 00 00 00       	add    $0x90,%eax
f011816c:	8b 00                	mov    (%eax),%eax
f011816e:	39 c1                	cmp    %eax,%ecx
f0118170:	74 17                	je     f0118189 <test_priority_normal_and_lower+0x9c9>
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
f0118172:	83 ec 04             	sub    $0x4,%esp
f0118175:	68 04 bc 12 f0       	push   $0xf012bc04
f011817a:	68 7c 01 00 00       	push   $0x17c
f011817f:	68 b1 b7 12 f0       	push   $0xf012b7b1
f0118184:	e8 91 81 fe ff       	call   f010031a <_panic>

			if(fact_TimeStamp[i+3] != factEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		for(int i = 0; i < 5; i++)
f0118189:	ff 45 c4             	incl   -0x3c(%ebp)
f011818c:	83 7d c4 04          	cmpl   $0x4,-0x3c(%ebp)
f0118190:	0f 8e 73 ff ff ff    	jle    f0118109 <test_priority_normal_and_lower+0x949>

			if(hello_TimeStamp[i+5] != helloEnv->ptr_pageWorkingSet[i].time_stamp)
				panic("Working set should be moved properly to the new one, removed pages are chosen based on replacement policy");
		}

		set_program_priority(addEnv, 5);
f0118196:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118199:	83 ec 08             	sub    $0x8,%esp
f011819c:	6a 05                	push   $0x5
f011819e:	50                   	push   %eax
f011819f:	e8 0c 3a ff ff       	call   f010bbb0 <set_program_priority>
f01181a4:	83 c4 10             	add    $0x10,%esp
		set_program_priority(addEnv, 5);
f01181a7:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01181aa:	83 ec 08             	sub    $0x8,%esp
f01181ad:	6a 05                	push   $0x5
f01181af:	50                   	push   %eax
f01181b0:	e8 fb 39 ff ff       	call   f010bbb0 <set_program_priority>
f01181b5:	83 c4 10             	add    $0x10,%esp

		char command4[100] = "runall";
f01181b8:	c7 85 1c fd ff ff 72 	movl   $0x616e7572,-0x2e4(%ebp)
f01181bf:	75 6e 61 
f01181c2:	c7 85 20 fd ff ff 6c 	movl   $0x6c6c,-0x2e0(%ebp)
f01181c9:	6c 00 00 
f01181cc:	8d 95 24 fd ff ff    	lea    -0x2dc(%ebp),%edx
f01181d2:	b9 17 00 00 00       	mov    $0x17,%ecx
f01181d7:	b8 00 00 00 00       	mov    $0x0,%eax
f01181dc:	89 d7                	mov    %edx,%edi
f01181de:	f3 ab                	rep stos %eax,%es:(%edi)
		execute_command(command4);
f01181e0:	83 ec 0c             	sub    $0xc,%esp
f01181e3:	8d 85 1c fd ff ff    	lea    -0x2e4(%ebp),%eax
f01181e9:	50                   	push   %eax
f01181ea:	e8 ed 9c fe ff       	call   f0101edc <execute_command>
f01181ef:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
	}
#endif
}
f01181f2:	eb 10                	jmp    f0118204 <test_priority_normal_and_lower+0xa44>
		char command4[100] = "runall";
		execute_command(command4);
	}
	else
	{
		cprintf("\nCongratulations!! test priority 2 completed successfully.\n");
f01181f4:	83 ec 0c             	sub    $0xc,%esp
f01181f7:	68 e0 bc 12 f0       	push   $0xf012bce0
f01181fc:	e8 6b 8d fe ff       	call   f0100f6c <cprintf>
f0118201:	83 c4 10             	add    $0x10,%esp
	}
#endif
}
f0118204:	90                   	nop
f0118205:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0118208:	5b                   	pop    %ebx
f0118209:	5e                   	pop    %esi
f011820a:	5f                   	pop    %edi
f011820b:	5d                   	pop    %ebp
f011820c:	c3                   	ret    

f011820d <test_kmalloc>:
	int c;
};

uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;
int test_kmalloc()
{
f011820d:	55                   	push   %ebp
f011820e:	89 e5                	mov    %esp,%ebp
f0118210:	57                   	push   %edi
f0118211:	53                   	push   %ebx
f0118212:	81 ec d0 00 00 00    	sub    $0xd0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118218:	83 ec 0c             	sub    $0xc,%esp
f011821b:	68 00 be 12 f0       	push   $0xf012be00
f0118220:	e8 47 8d fe ff       	call   f0100f6c <cprintf>
f0118225:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118228:	83 ec 0c             	sub    $0xc,%esp
f011822b:	68 30 be 12 f0       	push   $0xf012be30
f0118230:	e8 37 8d fe ff       	call   f0100f6c <cprintf>
f0118235:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118238:	83 ec 0c             	sub    $0xc,%esp
f011823b:	68 00 be 12 f0       	push   $0xf012be00
f0118240:	e8 27 8d fe ff       	call   f0100f6c <cprintf>
f0118245:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f0118248:	c6 45 eb 80          	movb   $0x80,-0x15(%ebp)
	char maxByte = 0x7F;
f011824c:	c6 45 ea 7f          	movb   $0x7f,-0x16(%ebp)
	short minShort = 1<<15 ;
f0118250:	66 c7 45 e8 00 80    	movw   $0x8000,-0x18(%ebp)
	short maxShort = 0x7FFF;
f0118256:	66 c7 45 e6 ff 7f    	movw   $0x7fff,-0x1a(%ebp)
	int minInt = 1<<31 ;
f011825c:	c7 45 e0 00 00 00 80 	movl   $0x80000000,-0x20(%ebp)
	int maxInt = 0x7FFFFFFF;
f0118263:	c7 45 dc ff ff ff 7f 	movl   $0x7fffffff,-0x24(%ebp)
	char *byteArr, *byteArr2, *byteArr3 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfByte3, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = (int)sys_calculate_free_frames() ;
f011826a:	e8 9a 54 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011826f:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int eval = 0;
f0118272:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118279:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	int freeFrames, freeDiskFrames;
	uint32 sizeOfKHeap;
	void* ptr_allocations[20] = {0};
f0118280:	8d 95 38 ff ff ff    	lea    -0xc8(%ebp),%edx
f0118286:	b9 14 00 00 00       	mov    $0x14,%ecx
f011828b:	b8 00 00 00 00       	mov    $0x0,%eax
f0118290:	89 d7                	mov    %edx,%edi
f0118292:	f3 ab                	rep stos %eax,%es:(%edi)
	correct = 1 ;
f0118294:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//Insufficient space
		freeFrames = (int)sys_calculate_free_frames() ;
f011829b:	e8 69 54 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01182a0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01182a3:	e8 99 c2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01182a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
		sizeOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 1) ;
f01182ab:	c7 45 cc 01 e0 ff 07 	movl   $0x7ffe001,-0x34(%ebp)
		ptr_allocations[0] = kmalloc(sizeOfKHeap);
f01182b2:	83 ec 0c             	sub    $0xc,%esp
f01182b5:	ff 75 cc             	pushl  -0x34(%ebp)
f01182b8:	e8 fa 04 ff ff       	call   f01087b7 <kmalloc>
f01182bd:	83 c4 10             	add    $0x10,%esp
f01182c0:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f01182c6:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f01182cc:	85 c0                	test   %eax,%eax
f01182ce:	74 17                	je     f01182e7 <test_kmalloc+0xda>
f01182d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182d7:	83 ec 0c             	sub    $0xc,%esp
f01182da:	68 8c be 12 f0       	push   $0xf012be8c
f01182df:	e8 88 8c fe ff       	call   f0100f6c <cprintf>
f01182e4:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01182e7:	e8 55 c2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01182ec:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01182ef:	74 17                	je     f0118308 <test_kmalloc+0xfb>
f01182f1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01182f8:	83 ec 0c             	sub    $0xc,%esp
f01182fb:	68 c0 be 12 f0       	push   $0xf012bec0
f0118300:	e8 67 8c fe ff       	call   f0100f6c <cprintf>
f0118305:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118308:	e8 fc 53 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011830d:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0118310:	74 17                	je     f0118329 <test_kmalloc+0x11c>
f0118312:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118319:	83 ec 0c             	sub    $0xc,%esp
f011831c:	68 2c bf 12 f0       	push   $0xf012bf2c
f0118321:	e8 46 8c fe ff       	call   f0100f6c <cprintf>
f0118326:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118329:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011832d:	74 04                	je     f0118333 <test_kmalloc+0x126>
f011832f:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118333:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011833a:	e8 ca 53 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011833f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118342:	e8 fa c1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118347:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011834a:	83 ec 0c             	sub    $0xc,%esp
f011834d:	68 00 fc 1f 00       	push   $0x1ffc00
f0118352:	e8 60 04 ff ff       	call   f01087b7 <kmalloc>
f0118357:	83 c4 10             	add    $0x10,%esp
f011835a:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118360:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0118366:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011836b:	74 17                	je     f0118384 <test_kmalloc+0x177>
f011836d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118374:	83 ec 0c             	sub    $0xc,%esp
f0118377:	68 70 bf 12 f0       	push   $0xf012bf70
f011837c:	e8 eb 8b fe ff       	call   f0100f6c <cprintf>
f0118381:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118384:	e8 b8 c1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118389:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011838c:	74 17                	je     f01183a5 <test_kmalloc+0x198>
f011838e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118395:	83 ec 0c             	sub    $0xc,%esp
f0118398:	68 c0 be 12 f0       	push   $0xf012bec0
f011839d:	e8 ca 8b fe ff       	call   f0100f6c <cprintf>
f01183a2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01183a5:	e8 5f 53 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01183aa:	89 c2                	mov    %eax,%edx
f01183ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01183af:	29 d0                	sub    %edx,%eax
f01183b1:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01183b6:	7f 17                	jg     f01183cf <test_kmalloc+0x1c2>
f01183b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01183bf:	83 ec 0c             	sub    $0xc,%esp
f01183c2:	68 2c bf 12 f0       	push   $0xf012bf2c
f01183c7:	e8 a0 8b fe ff       	call   f0100f6c <cprintf>
f01183cc:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01183cf:	e8 35 53 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01183d4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01183d7:	e8 65 c1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01183dc:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01183df:	83 ec 0c             	sub    $0xc,%esp
f01183e2:	68 00 fc 1f 00       	push   $0x1ffc00
f01183e7:	e8 cb 03 ff ff       	call   f01087b7 <kmalloc>
f01183ec:	83 c4 10             	add    $0x10,%esp
f01183ef:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01183f5:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f01183fb:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118400:	74 17                	je     f0118419 <test_kmalloc+0x20c>
f0118402:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118409:	83 ec 0c             	sub    $0xc,%esp
f011840c:	68 70 bf 12 f0       	push   $0xf012bf70
f0118411:	e8 56 8b fe ff       	call   f0100f6c <cprintf>
f0118416:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118419:	e8 23 c1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011841e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118421:	74 17                	je     f011843a <test_kmalloc+0x22d>
f0118423:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011842a:	83 ec 0c             	sub    $0xc,%esp
f011842d:	68 c0 be 12 f0       	push   $0xf012bec0
f0118432:	e8 35 8b fe ff       	call   f0100f6c <cprintf>
f0118437:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011843a:	e8 ca 52 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011843f:	89 c2                	mov    %eax,%edx
f0118441:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118444:	29 d0                	sub    %edx,%eax
f0118446:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011844b:	7f 17                	jg     f0118464 <test_kmalloc+0x257>
f011844d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118454:	83 ec 0c             	sub    $0xc,%esp
f0118457:	68 2c bf 12 f0       	push   $0xf012bf2c
f011845c:	e8 0b 8b fe ff       	call   f0100f6c <cprintf>
f0118461:	83 c4 10             	add    $0x10,%esp

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0118464:	e8 a0 52 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118469:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011846c:	e8 d0 c0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118471:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[2] = kmalloc(2*kilo-1);
f0118474:	83 ec 0c             	sub    $0xc,%esp
f0118477:	68 ff 07 00 00       	push   $0x7ff
f011847c:	e8 36 03 ff ff       	call   f01087b7 <kmalloc>
f0118481:	83 c4 10             	add    $0x10,%esp
f0118484:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011848a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0118490:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118495:	76 28                	jbe    f01184bf <test_kmalloc+0x2b2>
f0118497:	8b 9d 40 ff ff ff    	mov    -0xc0(%ebp),%ebx
f011849d:	83 ec 0c             	sub    $0xc,%esp
f01184a0:	6a 00                	push   $0x0
f01184a2:	e8 06 03 ff ff       	call   f01087ad <sbrk>
f01184a7:	83 c4 10             	add    $0x10,%esp
f01184aa:	39 c3                	cmp    %eax,%ebx
f01184ac:	73 11                	jae    f01184bf <test_kmalloc+0x2b2>
f01184ae:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f01184b4:	89 c2                	mov    %eax,%edx
f01184b6:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f01184bb:	39 c2                	cmp    %eax,%edx
f01184bd:	72 17                	jb     f01184d6 <test_kmalloc+0x2c9>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01184bf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184c6:	83 ec 0c             	sub    $0xc,%esp
f01184c9:	68 c0 bf 12 f0       	push   $0xf012bfc0
f01184ce:	e8 99 8a fe ff       	call   f0100f6c <cprintf>
f01184d3:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01184d6:	e8 66 c0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01184db:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01184de:	74 17                	je     f01184f7 <test_kmalloc+0x2ea>
f01184e0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01184e7:	83 ec 0c             	sub    $0xc,%esp
f01184ea:	68 c0 be 12 f0       	push   $0xf012bec0
f01184ef:	e8 78 8a fe ff       	call   f0100f6c <cprintf>
f01184f4:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB - 1 (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f01184f7:	e8 0d 52 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01184fc:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01184ff:	e8 3d c0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118504:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo-1);
f0118507:	83 ec 0c             	sub    $0xc,%esp
f011850a:	68 ff 07 00 00       	push   $0x7ff
f011850f:	e8 a3 02 ff ff       	call   f01087b7 <kmalloc>
f0118514:	83 c4 10             	add    $0x10,%esp
f0118517:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011851d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0118523:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0118528:	76 28                	jbe    f0118552 <test_kmalloc+0x345>
f011852a:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f0118530:	83 ec 0c             	sub    $0xc,%esp
f0118533:	6a 00                	push   $0x0
f0118535:	e8 73 02 ff ff       	call   f01087ad <sbrk>
f011853a:	83 c4 10             	add    $0x10,%esp
f011853d:	39 c3                	cmp    %eax,%ebx
f011853f:	73 11                	jae    f0118552 <test_kmalloc+0x345>
f0118541:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f0118547:	89 c2                	mov    %eax,%edx
f0118549:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011854e:	39 c2                	cmp    %eax,%edx
f0118550:	72 17                	jb     f0118569 <test_kmalloc+0x35c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0118552:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118559:	83 ec 0c             	sub    $0xc,%esp
f011855c:	68 c0 bf 12 f0       	push   $0xf012bfc0
f0118561:	e8 06 8a fe ff       	call   f0100f6c <cprintf>
f0118566:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118569:	e8 d3 bf fe ff       	call   f0104541 <pf_calculate_free_frames>
f011856e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118571:	74 17                	je     f011858a <test_kmalloc+0x37d>
f0118573:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011857a:	83 ec 0c             	sub    $0xc,%esp
f011857d:	68 c0 be 12 f0       	push   $0xf012bec0
f0118582:	e8 e5 89 fe ff       	call   f0100f6c <cprintf>
f0118587:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) panic("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011858a:	e8 7a 51 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011858f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118592:	e8 aa bf fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118597:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[4] = kmalloc(7*kilo);
f011859a:	83 ec 0c             	sub    $0xc,%esp
f011859d:	68 00 1c 00 00       	push   $0x1c00
f01185a2:	e8 10 02 ff ff       	call   f01087b7 <kmalloc>
f01185a7:	83 c4 10             	add    $0x10,%esp
f01185aa:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01185b0:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01185b6:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f01185bb:	74 17                	je     f01185d4 <test_kmalloc+0x3c7>
f01185bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185c4:	83 ec 0c             	sub    $0xc,%esp
f01185c7:	68 70 bf 12 f0       	push   $0xf012bf70
f01185cc:	e8 9b 89 fe ff       	call   f0100f6c <cprintf>
f01185d1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01185d4:	e8 68 bf fe ff       	call   f0104541 <pf_calculate_free_frames>
f01185d9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f01185dc:	74 17                	je     f01185f5 <test_kmalloc+0x3e8>
f01185de:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01185e5:	83 ec 0c             	sub    $0xc,%esp
f01185e8:	68 c0 be 12 f0       	push   $0xf012bec0
f01185ed:	e8 7a 89 fe ff       	call   f0100f6c <cprintf>
f01185f2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01185f5:	e8 0f 51 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01185fa:	89 c2                	mov    %eax,%edx
f01185fc:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01185ff:	29 d0                	sub    %edx,%eax
f0118601:	83 f8 01             	cmp    $0x1,%eax
f0118604:	7f 17                	jg     f011861d <test_kmalloc+0x410>
f0118606:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011860d:	83 ec 0c             	sub    $0xc,%esp
f0118610:	68 2c bf 12 f0       	push   $0xf012bf2c
f0118615:	e8 52 89 fe ff       	call   f0100f6c <cprintf>
f011861a:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011861d:	e8 e7 50 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118622:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118625:	e8 17 bf fe ff       	call   f0104541 <pf_calculate_free_frames>
f011862a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011862d:	83 ec 0c             	sub    $0xc,%esp
f0118630:	68 00 fc 2f 00       	push   $0x2ffc00
f0118635:	e8 7d 01 ff ff       	call   f01087b7 <kmalloc>
f011863a:	83 c4 10             	add    $0x10,%esp
f011863d:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f0118643:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f0118649:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011864e:	74 17                	je     f0118667 <test_kmalloc+0x45a>
f0118650:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118657:	83 ec 0c             	sub    $0xc,%esp
f011865a:	68 70 bf 12 f0       	push   $0xf012bf70
f011865f:	e8 08 89 fe ff       	call   f0100f6c <cprintf>
f0118664:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118667:	e8 d5 be fe ff       	call   f0104541 <pf_calculate_free_frames>
f011866c:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011866f:	74 17                	je     f0118688 <test_kmalloc+0x47b>
f0118671:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118678:	83 ec 0c             	sub    $0xc,%esp
f011867b:	68 c0 be 12 f0       	push   $0xf012bec0
f0118680:	e8 e7 88 fe ff       	call   f0100f6c <cprintf>
f0118685:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118688:	e8 7c 50 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011868d:	89 c2                	mov    %eax,%edx
f011868f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118692:	29 d0                	sub    %edx,%eax
f0118694:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0118699:	7f 17                	jg     f01186b2 <test_kmalloc+0x4a5>
f011869b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186a2:	83 ec 0c             	sub    $0xc,%esp
f01186a5:	68 2c bf 12 f0       	push   $0xf012bf2c
f01186aa:	e8 bd 88 fe ff       	call   f0100f6c <cprintf>
f01186af:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01186b2:	e8 52 50 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01186b7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01186ba:	e8 82 be fe ff       	call   f0104541 <pf_calculate_free_frames>
f01186bf:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[6] = kmalloc(6*Mega-kilo);
f01186c2:	83 ec 0c             	sub    $0xc,%esp
f01186c5:	68 00 fc 5f 00       	push   $0x5ffc00
f01186ca:	e8 e8 00 ff ff       	call   f01087b7 <kmalloc>
f01186cf:	83 c4 10             	add    $0x10,%esp
f01186d2:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f01186d8:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f01186de:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f01186e3:	74 17                	je     f01186fc <test_kmalloc+0x4ef>
f01186e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01186ec:	83 ec 0c             	sub    $0xc,%esp
f01186ef:	68 70 bf 12 f0       	push   $0xf012bf70
f01186f4:	e8 73 88 fe ff       	call   f0100f6c <cprintf>
f01186f9:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01186fc:	e8 40 be fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118701:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118704:	74 17                	je     f011871d <test_kmalloc+0x510>
f0118706:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011870d:	83 ec 0c             	sub    $0xc,%esp
f0118710:	68 c0 be 12 f0       	push   $0xf012bec0
f0118715:	e8 52 88 fe ff       	call   f0100f6c <cprintf>
f011871a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011871d:	e8 e7 4f ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118722:	89 c2                	mov    %eax,%edx
f0118724:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0118727:	29 d0                	sub    %edx,%eax
f0118729:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011872e:	7f 17                	jg     f0118747 <test_kmalloc+0x53a>
f0118730:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118737:	83 ec 0c             	sub    $0xc,%esp
f011873a:	68 2c bf 12 f0       	push   $0xf012bf2c
f011873f:	e8 28 88 fe ff       	call   f0100f6c <cprintf>
f0118744:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118747:	e8 bd 4f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011874c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011874f:	e8 ed bd fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118754:	89 45 d0             	mov    %eax,-0x30(%ebp)
		ptr_allocations[7] = kmalloc(14*kilo);
f0118757:	83 ec 0c             	sub    $0xc,%esp
f011875a:	68 00 38 00 00       	push   $0x3800
f011875f:	e8 53 00 ff ff       	call   f01087b7 <kmalloc>
f0118764:	83 c4 10             	add    $0x10,%esp
f0118767:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011876d:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0118773:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f0118778:	74 17                	je     f0118791 <test_kmalloc+0x584>
f011877a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118781:	83 ec 0c             	sub    $0xc,%esp
f0118784:	68 70 bf 12 f0       	push   $0xf012bf70
f0118789:	e8 de 87 fe ff       	call   f0100f6c <cprintf>
f011878e:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118791:	e8 ab bd fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118796:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118799:	74 17                	je     f01187b2 <test_kmalloc+0x5a5>
f011879b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187a2:	83 ec 0c             	sub    $0xc,%esp
f01187a5:	68 c0 be 12 f0       	push   $0xf012bec0
f01187aa:	e8 bd 87 fe ff       	call   f0100f6c <cprintf>
f01187af:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f01187b2:	e8 52 4f ff ff       	call   f010d709 <sys_calculate_free_frames>
f01187b7:	89 c2                	mov    %eax,%edx
f01187b9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01187bc:	29 d0                	sub    %edx,%eax
f01187be:	83 f8 03             	cmp    $0x3,%eax
f01187c1:	7f 17                	jg     f01187da <test_kmalloc+0x5cd>
f01187c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01187ca:	83 ec 0c             	sub    $0xc,%esp
f01187cd:	68 2c bf 12 f0       	push   $0xf012bf2c
f01187d2:	e8 95 87 fe ff       	call   f0100f6c <cprintf>
f01187d7:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f01187da:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01187de:	74 04                	je     f01187e4 <test_kmalloc+0x5d7>
f01187e0:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f01187e4:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Checking read/write on the allocated spaces
	{

		freeFrames = (int)sys_calculate_free_frames() ;
f01187eb:	e8 19 4f ff ff       	call   f010d709 <sys_calculate_free_frames>
f01187f0:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01187f3:	e8 49 bd fe ff       	call   f0104541 <pf_calculate_free_frames>
f01187f8:	89 45 d0             	mov    %eax,-0x30(%ebp)

		//Write values
		//In 1st 2 MB
		lastIndexOfByte = (2*Mega-kilo)/sizeof(char) - 1;
f01187fb:	c7 45 c8 ff fb 1f 00 	movl   $0x1ffbff,-0x38(%ebp)
		byteArr = (char *) ptr_allocations[0];
f0118802:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f0118808:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		byteArr[0] = minByte ;
f011880b:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011880e:	8a 55 eb             	mov    -0x15(%ebp),%dl
f0118811:	88 10                	mov    %dl,(%eax)
		byteArr[lastIndexOfByte] = maxByte ;
f0118813:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0118816:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118819:	01 c2                	add    %eax,%edx
f011881b:	8a 45 ea             	mov    -0x16(%ebp),%al
f011881e:	88 02                	mov    %al,(%edx)

		//In 2nd 2 MB
		shortArr = (short *) ptr_allocations[1];
f0118820:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118826:	89 45 c0             	mov    %eax,-0x40(%ebp)
		lastIndexOfShort = (2*Mega-kilo)/sizeof(short) - 1;
f0118829:	c7 45 bc ff fd 0f 00 	movl   $0xffdff,-0x44(%ebp)
		shortArr[0] = minShort;
f0118830:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0118833:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118836:	66 89 02             	mov    %ax,(%edx)
		shortArr[lastIndexOfShort] = maxShort;
f0118839:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011883c:	01 c0                	add    %eax,%eax
f011883e:	89 c2                	mov    %eax,%edx
f0118840:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0118843:	01 c2                	add    %eax,%edx
f0118845:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0118849:	66 89 02             	mov    %ax,(%edx)

		//In Dynamic Allocator Area
		{
			//In 2 KB - 1
			intArr = (int *) ptr_allocations[2];
f011884c:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f0118852:	89 45 b8             	mov    %eax,-0x48(%ebp)
			lastIndexOfInt = (2*kilo-1)/sizeof(int) - 1;
f0118855:	c7 45 b4 fe 01 00 00 	movl   $0x1fe,-0x4c(%ebp)
			intArr[0] = minInt;
f011885c:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011885f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118862:	89 10                	mov    %edx,(%eax)
			intArr[lastIndexOfInt] = maxInt;
f0118864:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0118867:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011886e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0118871:	01 c2                	add    %eax,%edx
f0118873:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118876:	89 02                	mov    %eax,(%edx)

			//In 2 KB - 1
			byteArr2 = (char *) ptr_allocations[3];
f0118878:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011887e:	89 45 b0             	mov    %eax,-0x50(%ebp)
			lastIndexOfByte2 = (2*kilo-1)/sizeof(char) - 1;
f0118881:	c7 45 ac fe 07 00 00 	movl   $0x7fe,-0x54(%ebp)
			byteArr2[0] = minByte;
f0118888:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011888b:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011888e:	88 10                	mov    %dl,(%eax)
			byteArr2[lastIndexOfByte2] = maxByte;
f0118890:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0118893:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118896:	01 c2                	add    %eax,%edx
f0118898:	8a 45 ea             	mov    -0x16(%ebp),%al
f011889b:	88 02                	mov    %al,(%edx)
		}

		//In 7 KB
		structArr = (struct MyStruct *) ptr_allocations[4];
f011889d:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f01188a3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		lastIndexOfStruct = (7*kilo)/sizeof(struct MyStruct) - 1;
f01188a6:	c7 45 a4 7f 03 00 00 	movl   $0x37f,-0x5c(%ebp)
		structArr[0].a = minByte; structArr[0].b = minShort; structArr[0].c = minInt;
f01188ad:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188b0:	8a 55 eb             	mov    -0x15(%ebp),%dl
f01188b3:	88 10                	mov    %dl,(%eax)
f01188b5:	8b 55 a8             	mov    -0x58(%ebp),%edx
f01188b8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01188bb:	66 89 42 02          	mov    %ax,0x2(%edx)
f01188bf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01188c5:	89 50 04             	mov    %edx,0x4(%eax)
		structArr[lastIndexOfStruct].a = maxByte; structArr[lastIndexOfStruct].b = maxShort; structArr[lastIndexOfStruct].c = maxInt;
f01188c8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01188cb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01188d2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188d5:	01 c2                	add    %eax,%edx
f01188d7:	8a 45 ea             	mov    -0x16(%ebp),%al
f01188da:	88 02                	mov    %al,(%edx)
f01188dc:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01188df:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01188e6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01188e9:	01 c2                	add    %eax,%edx
f01188eb:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f01188ef:	66 89 42 02          	mov    %ax,0x2(%edx)
f01188f3:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01188f6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01188fd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118900:	01 c2                	add    %eax,%edx
f0118902:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0118905:	89 42 04             	mov    %eax,0x4(%edx)

		//In 6 MB
		lastIndexOfByte3 = (6*Mega-kilo)/sizeof(char) - 1;
f0118908:	c7 45 a0 ff fb 5f 00 	movl   $0x5ffbff,-0x60(%ebp)
		byteArr3 = (char *) ptr_allocations[6];
f011890f:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f0118915:	89 45 9c             	mov    %eax,-0x64(%ebp)
		byteArr3[0] = minByte ;
f0118918:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011891b:	8a 55 eb             	mov    -0x15(%ebp),%dl
f011891e:	88 10                	mov    %dl,(%eax)
		byteArr3[lastIndexOfByte3 / 2] = maxByte / 2;
f0118920:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118923:	89 c2                	mov    %eax,%edx
f0118925:	c1 ea 1f             	shr    $0x1f,%edx
f0118928:	01 d0                	add    %edx,%eax
f011892a:	d1 f8                	sar    %eax
f011892c:	89 c2                	mov    %eax,%edx
f011892e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118931:	01 c2                	add    %eax,%edx
f0118933:	8a 45 ea             	mov    -0x16(%ebp),%al
f0118936:	88 c1                	mov    %al,%cl
f0118938:	c0 e9 07             	shr    $0x7,%cl
f011893b:	01 c8                	add    %ecx,%eax
f011893d:	d0 f8                	sar    %al
f011893f:	88 02                	mov    %al,(%edx)
		byteArr3[lastIndexOfByte3] = maxByte ;
f0118941:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118944:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118947:	01 c2                	add    %eax,%edx
f0118949:	8a 45 ea             	mov    -0x16(%ebp),%al
f011894c:	88 02                	mov    %al,(%edx)

		//In 14 KB
		shortArr2 = (short *) ptr_allocations[7];
f011894e:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0118954:	89 45 98             	mov    %eax,-0x68(%ebp)
		lastIndexOfShort2 = (14*kilo)/sizeof(short) - 1;
f0118957:	c7 45 94 ff 1b 00 00 	movl   $0x1bff,-0x6c(%ebp)
		shortArr2[0] = minShort;
f011895e:	8b 55 98             	mov    -0x68(%ebp),%edx
f0118961:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118964:	66 89 02             	mov    %ax,(%edx)
		shortArr2[lastIndexOfShort2] = maxShort;
f0118967:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011896a:	01 c0                	add    %eax,%eax
f011896c:	89 c2                	mov    %eax,%edx
f011896e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118971:	01 c2                	add    %eax,%edx
f0118973:	66 8b 45 e6          	mov    -0x1a(%ebp),%ax
f0118977:	66 89 02             	mov    %ax,(%edx)

		//Read values: check that the values are successfully written
		if (byteArr[0] 	!= minByte 	|| byteArr[lastIndexOfByte] 	!= maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f011897a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011897d:	8a 00                	mov    (%eax),%al
f011897f:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118982:	75 0f                	jne    f0118993 <test_kmalloc+0x786>
f0118984:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0118987:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011898a:	01 d0                	add    %edx,%eax
f011898c:	8a 00                	mov    (%eax),%al
f011898e:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118991:	74 17                	je     f01189aa <test_kmalloc+0x79d>
f0118993:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011899a:	83 ec 0c             	sub    $0xc,%esp
f011899d:	68 48 c0 12 f0       	push   $0xf012c048
f01189a2:	e8 c5 85 fe ff       	call   f0100f6c <cprintf>
f01189a7:	83 c4 10             	add    $0x10,%esp
		if (shortArr[0] != minShort || shortArr[lastIndexOfShort] 	!= maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01189aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01189ad:	66 8b 00             	mov    (%eax),%ax
f01189b0:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f01189b4:	75 15                	jne    f01189cb <test_kmalloc+0x7be>
f01189b6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01189b9:	01 c0                	add    %eax,%eax
f01189bb:	89 c2                	mov    %eax,%edx
f01189bd:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01189c0:	01 d0                	add    %edx,%eax
f01189c2:	66 8b 00             	mov    (%eax),%ax
f01189c5:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f01189c9:	74 17                	je     f01189e2 <test_kmalloc+0x7d5>
f01189cb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01189d2:	83 ec 0c             	sub    $0xc,%esp
f01189d5:	68 48 c0 12 f0       	push   $0xf012c048
f01189da:	e8 8d 85 fe ff       	call   f0100f6c <cprintf>
f01189df:	83 c4 10             	add    $0x10,%esp
		if (intArr[0] 	!= minInt 	|| intArr[lastIndexOfInt] 		!= maxInt) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f01189e2:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01189e5:	8b 00                	mov    (%eax),%eax
f01189e7:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f01189ea:	75 16                	jne    f0118a02 <test_kmalloc+0x7f5>
f01189ec:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01189ef:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01189f6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01189f9:	01 d0                	add    %edx,%eax
f01189fb:	8b 00                	mov    (%eax),%eax
f01189fd:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0118a00:	74 17                	je     f0118a19 <test_kmalloc+0x80c>
f0118a02:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a09:	83 ec 0c             	sub    $0xc,%esp
f0118a0c:	68 48 c0 12 f0       	push   $0xf012c048
f0118a11:	e8 56 85 fe ff       	call   f0100f6c <cprintf>
f0118a16:	83 c4 10             	add    $0x10,%esp
		if (byteArr2[0] != minByte || byteArr2[lastIndexOfByte2] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a19:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118a1c:	8a 00                	mov    (%eax),%al
f0118a1e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118a21:	75 0f                	jne    f0118a32 <test_kmalloc+0x825>
f0118a23:	8b 55 ac             	mov    -0x54(%ebp),%edx
f0118a26:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0118a29:	01 d0                	add    %edx,%eax
f0118a2b:	8a 00                	mov    (%eax),%al
f0118a2d:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118a30:	74 17                	je     f0118a49 <test_kmalloc+0x83c>
f0118a32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a39:	83 ec 0c             	sub    $0xc,%esp
f0118a3c:	68 48 c0 12 f0       	push   $0xf012c048
f0118a41:	e8 26 85 fe ff       	call   f0100f6c <cprintf>
f0118a46:	83 c4 10             	add    $0x10,%esp

		if (structArr[0].a != minByte 	|| structArr[lastIndexOfStruct].a != maxByte) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a49:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a4c:	8a 00                	mov    (%eax),%al
f0118a4e:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118a51:	75 16                	jne    f0118a69 <test_kmalloc+0x85c>
f0118a53:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118a56:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118a5d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a60:	01 d0                	add    %edx,%eax
f0118a62:	8a 00                	mov    (%eax),%al
f0118a64:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118a67:	74 17                	je     f0118a80 <test_kmalloc+0x873>
f0118a69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118a70:	83 ec 0c             	sub    $0xc,%esp
f0118a73:	68 48 c0 12 f0       	push   $0xf012c048
f0118a78:	e8 ef 84 fe ff       	call   f0100f6c <cprintf>
f0118a7d:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].b != minShort 	|| structArr[lastIndexOfStruct].b != maxShort) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118a80:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a83:	66 8b 40 02          	mov    0x2(%eax),%ax
f0118a87:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0118a8b:	75 19                	jne    f0118aa6 <test_kmalloc+0x899>
f0118a8d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118a90:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118a97:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118a9a:	01 d0                	add    %edx,%eax
f0118a9c:	66 8b 40 02          	mov    0x2(%eax),%ax
f0118aa0:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0118aa4:	74 17                	je     f0118abd <test_kmalloc+0x8b0>
f0118aa6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118aad:	83 ec 0c             	sub    $0xc,%esp
f0118ab0:	68 48 c0 12 f0       	push   $0xf012c048
f0118ab5:	e8 b2 84 fe ff       	call   f0100f6c <cprintf>
f0118aba:	83 c4 10             	add    $0x10,%esp
		if (structArr[0].c != minInt 	|| structArr[lastIndexOfStruct].c != maxInt) 	{ correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118abd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ac0:	8b 40 04             	mov    0x4(%eax),%eax
f0118ac3:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0118ac6:	75 17                	jne    f0118adf <test_kmalloc+0x8d2>
f0118ac8:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118acb:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f0118ad2:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118ad5:	01 d0                	add    %edx,%eax
f0118ad7:	8b 40 04             	mov    0x4(%eax),%eax
f0118ada:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0118add:	74 17                	je     f0118af6 <test_kmalloc+0x8e9>
f0118adf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ae6:	83 ec 0c             	sub    $0xc,%esp
f0118ae9:	68 48 c0 12 f0       	push   $0xf012c048
f0118aee:	e8 79 84 fe ff       	call   f0100f6c <cprintf>
f0118af3:	83 c4 10             	add    $0x10,%esp

		if (byteArr3[0] != minByte || byteArr3[lastIndexOfByte3/2] != maxByte/2 || byteArr3[lastIndexOfByte3] != maxByte) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118af6:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118af9:	8a 00                	mov    (%eax),%al
f0118afb:	3a 45 eb             	cmp    -0x15(%ebp),%al
f0118afe:	75 34                	jne    f0118b34 <test_kmalloc+0x927>
f0118b00:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118b03:	89 c2                	mov    %eax,%edx
f0118b05:	c1 ea 1f             	shr    $0x1f,%edx
f0118b08:	01 d0                	add    %edx,%eax
f0118b0a:	d1 f8                	sar    %eax
f0118b0c:	89 c2                	mov    %eax,%edx
f0118b0e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118b11:	01 d0                	add    %edx,%eax
f0118b13:	8a 10                	mov    (%eax),%dl
f0118b15:	8a 45 ea             	mov    -0x16(%ebp),%al
f0118b18:	88 c1                	mov    %al,%cl
f0118b1a:	c0 e9 07             	shr    $0x7,%cl
f0118b1d:	01 c8                	add    %ecx,%eax
f0118b1f:	d0 f8                	sar    %al
f0118b21:	38 c2                	cmp    %al,%dl
f0118b23:	75 0f                	jne    f0118b34 <test_kmalloc+0x927>
f0118b25:	8b 55 a0             	mov    -0x60(%ebp),%edx
f0118b28:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118b2b:	01 d0                	add    %edx,%eax
f0118b2d:	8a 00                	mov    (%eax),%al
f0118b2f:	3a 45 ea             	cmp    -0x16(%ebp),%al
f0118b32:	74 17                	je     f0118b4b <test_kmalloc+0x93e>
f0118b34:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b3b:	83 ec 0c             	sub    $0xc,%esp
f0118b3e:	68 48 c0 12 f0       	push   $0xf012c048
f0118b43:	e8 24 84 fe ff       	call   f0100f6c <cprintf>
f0118b48:	83 c4 10             	add    $0x10,%esp
		if (shortArr2[0] != minShort || shortArr2[lastIndexOfShort2] != maxShort) { correct = 0; cprintf("Wrong allocation: stored values are wrongly changed!\n"); }
f0118b4b:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118b4e:	66 8b 00             	mov    (%eax),%ax
f0118b51:	66 3b 45 e8          	cmp    -0x18(%ebp),%ax
f0118b55:	75 15                	jne    f0118b6c <test_kmalloc+0x95f>
f0118b57:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0118b5a:	01 c0                	add    %eax,%eax
f0118b5c:	89 c2                	mov    %eax,%edx
f0118b5e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118b61:	01 d0                	add    %edx,%eax
f0118b63:	66 8b 00             	mov    (%eax),%ax
f0118b66:	66 3b 45 e6          	cmp    -0x1a(%ebp),%ax
f0118b6a:	74 17                	je     f0118b83 <test_kmalloc+0x976>
f0118b6c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b73:	83 ec 0c             	sub    $0xc,%esp
f0118b76:	68 48 c0 12 f0       	push   $0xf012c048
f0118b7b:	e8 ec 83 fe ff       	call   f0100f6c <cprintf>
f0118b80:	83 c4 10             	add    $0x10,%esp

		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118b83:	e8 81 4b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118b88:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0118b8b:	74 17                	je     f0118ba4 <test_kmalloc+0x997>
f0118b8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118b94:	83 ec 0c             	sub    $0xc,%esp
f0118b97:	68 2c bf 12 f0       	push   $0xf012bf2c
f0118b9c:	e8 cb 83 fe ff       	call   f0100f6c <cprintf>
f0118ba1:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ba4:	e8 98 b9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118ba9:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118bac:	74 17                	je     f0118bc5 <test_kmalloc+0x9b8>
f0118bae:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118bb5:	83 ec 0c             	sub    $0xc,%esp
f0118bb8:	68 c0 be 12 f0       	push   $0xf012bec0
f0118bbd:	e8 aa 83 fe ff       	call   f0100f6c <cprintf>
f0118bc2:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=30 ;
f0118bc5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118bc9:	74 04                	je     f0118bcf <test_kmalloc+0x9c2>
f0118bcb:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	correct = 1 ;
f0118bcf:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//Insufficient space again
	{
		freeFrames = (int)sys_calculate_free_frames() ;
f0118bd6:	e8 2e 4b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118bdb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118bde:	e8 5e b9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118be3:	89 45 d0             	mov    %eax,-0x30(%ebp)
		uint32 restOfKHeap = (KERNEL_HEAP_MAX - ACTUAL_START + 2*PAGE_SIZE) - (2*Mega+2*Mega+/*4*kilo+4*kilo+*/8*kilo+3*Mega+6*Mega+16*kilo) ;
f0118be6:	c7 45 90 00 a0 2f 07 	movl   $0x72fa000,-0x70(%ebp)
		ptr_allocations[8] = kmalloc(restOfKHeap);
f0118bed:	83 ec 0c             	sub    $0xc,%esp
f0118bf0:	ff 75 90             	pushl  -0x70(%ebp)
f0118bf3:	e8 bf fb fe ff       	call   f01087b7 <kmalloc>
f0118bf8:	83 c4 10             	add    $0x10,%esp
f0118bfb:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
		if (ptr_allocations[8] != NULL) { correct = 0; cprintf("Allocating insufficient space: should return NULL\n"); }
f0118c01:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0118c07:	85 c0                	test   %eax,%eax
f0118c09:	74 17                	je     f0118c22 <test_kmalloc+0xa15>
f0118c0b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c12:	83 ec 0c             	sub    $0xc,%esp
f0118c15:	68 8c be 12 f0       	push   $0xf012be8c
f0118c1a:	e8 4d 83 fe ff       	call   f0100f6c <cprintf>
f0118c1f:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118c22:	e8 1a b9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118c27:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0118c2a:	74 17                	je     f0118c43 <test_kmalloc+0xa36>
f0118c2c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c33:	83 ec 0c             	sub    $0xc,%esp
f0118c36:	68 c0 be 12 f0       	push   $0xf012bec0
f0118c3b:	e8 2c 83 fe ff       	call   f0100f6c <cprintf>
f0118c40:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f0118c43:	e8 c1 4a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118c48:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0118c4b:	74 17                	je     f0118c64 <test_kmalloc+0xa57>
f0118c4d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c54:	83 ec 0c             	sub    $0xc,%esp
f0118c57:	68 2c bf 12 f0       	push   $0xf012bf2c
f0118c5c:	e8 0b 83 fe ff       	call   f0100f6c <cprintf>
f0118c61:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0118c64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118c68:	74 04                	je     f0118c6e <test_kmalloc+0xa61>
f0118c6a:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0118c6e:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
f0118c75:	8b 85 54 ff ff ff    	mov    -0xac(%ebp),%eax
f0118c7b:	05 00 40 00 00       	add    $0x4000,%eax
f0118c80:	89 45 8c             	mov    %eax,-0x74(%ebp)
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0118c83:	c7 45 ec 00 10 00 f8 	movl   $0xf8001000,-0x14(%ebp)
f0118c8a:	eb 6a                	jmp    f0118cf6 <test_kmalloc+0xae9>
		{
			unsigned int * table;
			get_page_table(ptr_page_directory, va, &table);
f0118c8c:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f0118c91:	83 ec 04             	sub    $0x4,%esp
f0118c94:	8d 95 34 ff ff ff    	lea    -0xcc(%ebp),%edx
f0118c9a:	52                   	push   %edx
f0118c9b:	ff 75 ec             	pushl  -0x14(%ebp)
f0118c9e:	50                   	push   %eax
f0118c9f:	e8 6a f4 fe ff       	call   f010810e <get_page_table>
f0118ca4:	83 c4 10             	add    $0x10,%esp
			uint32 perm = table[PTX(va)] & 0xFFF;
f0118ca7:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f0118cad:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118cb0:	c1 ea 0c             	shr    $0xc,%edx
f0118cb3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0118cb9:	c1 e2 02             	shl    $0x2,%edx
f0118cbc:	01 d0                	add    %edx,%eax
f0118cbe:	8b 00                	mov    (%eax),%eax
f0118cc0:	25 ff 0f 00 00       	and    $0xfff,%eax
f0118cc5:	89 45 88             	mov    %eax,-0x78(%ebp)
			if ((perm & PERM_USER) == PERM_USER)
f0118cc8:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118ccb:	83 e0 04             	and    $0x4,%eax
f0118cce:	85 c0                	test   %eax,%eax
f0118cd0:	74 1d                	je     f0118cef <test_kmalloc+0xae2>
			{
				if (correct)
f0118cd2:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118cd6:	74 17                	je     f0118cef <test_kmalloc+0xae2>
				{
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
f0118cd8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118cdf:	83 ec 0c             	sub    $0xc,%esp
f0118ce2:	68 80 c0 12 f0       	push   $0xf012c080
f0118ce7:	e8 80 82 fe ff       	call   f0100f6c <cprintf>
f0118cec:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//permissions
	{
		uint32 lastAllocAddress = (uint32)ptr_allocations[7] + 16*kilo ;
		uint32 va;
		for (va = ACTUAL_START; va < lastAllocAddress; va+=PAGE_SIZE)
f0118cef:	81 45 ec 00 10 00 00 	addl   $0x1000,-0x14(%ebp)
f0118cf6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118cf9:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f0118cfc:	72 8e                	jb     f0118c8c <test_kmalloc+0xa7f>
					correct = 0; cprintf("Wrong permissions: pages should be mapped with Supervisor permission only\n");
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f0118cfe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0118d02:	74 04                	je     f0118d08 <test_kmalloc+0xafb>
f0118d04:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("\ntest kmalloc completed. Evaluation = %d%\n", eval);
f0118d08:	83 ec 08             	sub    $0x8,%esp
f0118d0b:	ff 75 f4             	pushl  -0xc(%ebp)
f0118d0e:	68 cc c0 12 f0       	push   $0xf012c0cc
f0118d13:	e8 54 82 fe ff       	call   f0100f6c <cprintf>
f0118d18:	83 c4 10             	add    $0x10,%esp

	return 1;
f0118d1b:	b8 01 00 00 00       	mov    $0x1,%eax

}
f0118d20:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0118d23:	5b                   	pop    %ebx
f0118d24:	5f                   	pop    %edi
f0118d25:	5d                   	pop    %ebp
f0118d26:	c3                   	ret    

f0118d27 <test_kmalloc_firstfit1>:


int test_kmalloc_firstfit1()
{
f0118d27:	55                   	push   %ebp
f0118d28:	89 e5                	mov    %esp,%ebp
f0118d2a:	57                   	push   %edi
f0118d2b:	83 ec 64             	sub    $0x64,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f0118d2e:	83 ec 0c             	sub    $0xc,%esp
f0118d31:	68 00 be 12 f0       	push   $0xf012be00
f0118d36:	e8 31 82 fe ff       	call   f0100f6c <cprintf>
f0118d3b:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f0118d3e:	83 ec 0c             	sub    $0xc,%esp
f0118d41:	68 30 be 12 f0       	push   $0xf012be30
f0118d46:	e8 21 82 fe ff       	call   f0100f6c <cprintf>
f0118d4b:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f0118d4e:	83 ec 0c             	sub    $0xc,%esp
f0118d51:	68 00 be 12 f0       	push   $0xf012be00
f0118d56:	e8 11 82 fe ff       	call   f0100f6c <cprintf>
f0118d5b:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f0118d5e:	8d 55 98             	lea    -0x68(%ebp),%edx
f0118d61:	b9 14 00 00 00       	mov    $0x14,%ecx
f0118d66:	b8 00 00 00 00       	mov    $0x0,%eax
f0118d6b:	89 d7                	mov    %edx,%edi
f0118d6d:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f0118d6f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f0118d76:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0118d7d:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Allocate all
	{
		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118d84:	e8 80 49 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118d89:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118d8c:	e8 b0 b7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118d91:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(1*Mega-kilo);
f0118d94:	83 ec 0c             	sub    $0xc,%esp
f0118d97:	68 00 fc 0f 00       	push   $0xffc00
f0118d9c:	e8 16 fa fe ff       	call   f01087b7 <kmalloc>
f0118da1:	83 c4 10             	add    $0x10,%esp
f0118da4:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118da7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0118daa:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0118daf:	74 17                	je     f0118dc8 <test_kmalloc_firstfit1+0xa1>
f0118db1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118db8:	83 ec 0c             	sub    $0xc,%esp
f0118dbb:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0118dc0:	e8 a7 81 fe ff       	call   f0100f6c <cprintf>
f0118dc5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118dc8:	e8 74 b7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118dcd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118dd0:	74 17                	je     f0118de9 <test_kmalloc_firstfit1+0xc2>
f0118dd2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118dd9:	83 ec 0c             	sub    $0xc,%esp
f0118ddc:	68 c0 be 12 f0       	push   $0xf012bec0
f0118de1:	e8 86 81 fe ff       	call   f0100f6c <cprintf>
f0118de6:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118de9:	e8 1b 49 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118dee:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118df1:	29 c2                	sub    %eax,%edx
f0118df3:	89 d0                	mov    %edx,%eax
f0118df5:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118dfa:	77 17                	ja     f0118e13 <test_kmalloc_firstfit1+0xec>
f0118dfc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e03:	83 ec 0c             	sub    $0xc,%esp
f0118e06:	68 29 c1 12 f0       	push   $0xf012c129
f0118e0b:	e8 5c 81 fe ff       	call   f0100f6c <cprintf>
f0118e10:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118e13:	e8 f1 48 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118e18:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118e1b:	e8 21 b7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118e20:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(1*Mega-kilo);
f0118e23:	83 ec 0c             	sub    $0xc,%esp
f0118e26:	68 00 fc 0f 00       	push   $0xffc00
f0118e2b:	e8 87 f9 fe ff       	call   f01087b7 <kmalloc>
f0118e30:	83 c4 10             	add    $0x10,%esp
f0118e33:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118e36:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0118e39:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f0118e3e:	74 17                	je     f0118e57 <test_kmalloc_firstfit1+0x130>
f0118e40:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e47:	83 ec 0c             	sub    $0xc,%esp
f0118e4a:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0118e4f:	e8 18 81 fe ff       	call   f0100f6c <cprintf>
f0118e54:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118e57:	e8 e5 b6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118e5c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118e5f:	74 17                	je     f0118e78 <test_kmalloc_firstfit1+0x151>
f0118e61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e68:	83 ec 0c             	sub    $0xc,%esp
f0118e6b:	68 c0 be 12 f0       	push   $0xf012bec0
f0118e70:	e8 f7 80 fe ff       	call   f0100f6c <cprintf>
f0118e75:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118e78:	e8 8c 48 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118e7d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118e80:	29 c2                	sub    %eax,%edx
f0118e82:	89 d0                	mov    %edx,%eax
f0118e84:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118e89:	77 17                	ja     f0118ea2 <test_kmalloc_firstfit1+0x17b>
f0118e8b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118e92:	83 ec 0c             	sub    $0xc,%esp
f0118e95:	68 29 c1 12 f0       	push   $0xf012c129
f0118e9a:	e8 cd 80 fe ff       	call   f0100f6c <cprintf>
f0118e9f:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118ea2:	e8 62 48 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118ea7:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118eaa:	e8 92 b6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118eaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*Mega-kilo);
f0118eb2:	83 ec 0c             	sub    $0xc,%esp
f0118eb5:	68 00 fc 0f 00       	push   $0xffc00
f0118eba:	e8 f8 f8 fe ff       	call   f01087b7 <kmalloc>
f0118ebf:	83 c4 10             	add    $0x10,%esp
f0118ec2:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118ec5:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118ec8:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0118ecd:	74 17                	je     f0118ee6 <test_kmalloc_firstfit1+0x1bf>
f0118ecf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ed6:	83 ec 0c             	sub    $0xc,%esp
f0118ed9:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0118ede:	e8 89 80 fe ff       	call   f0100f6c <cprintf>
f0118ee3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118ee6:	e8 56 b6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118eeb:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118eee:	74 17                	je     f0118f07 <test_kmalloc_firstfit1+0x1e0>
f0118ef0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ef7:	83 ec 0c             	sub    $0xc,%esp
f0118efa:	68 c0 be 12 f0       	push   $0xf012bec0
f0118eff:	e8 68 80 fe ff       	call   f0100f6c <cprintf>
f0118f04:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118f07:	e8 fd 47 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118f0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118f0f:	29 c2                	sub    %eax,%edx
f0118f11:	89 d0                	mov    %edx,%eax
f0118f13:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118f18:	77 17                	ja     f0118f31 <test_kmalloc_firstfit1+0x20a>
f0118f1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f21:	83 ec 0c             	sub    $0xc,%esp
f0118f24:	68 29 c1 12 f0       	push   $0xf012c129
f0118f29:	e8 3e 80 fe ff       	call   f0100f6c <cprintf>
f0118f2e:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118f31:	e8 d3 47 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118f36:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118f39:	e8 03 b6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118f3e:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(1*Mega-kilo);
f0118f41:	83 ec 0c             	sub    $0xc,%esp
f0118f44:	68 00 fc 0f 00       	push   $0xffc00
f0118f49:	e8 69 f8 fe ff       	call   f01087b7 <kmalloc>
f0118f4e:	83 c4 10             	add    $0x10,%esp
f0118f51:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] != (ACTUAL_START + 3*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118f54:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0118f57:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f0118f5c:	74 17                	je     f0118f75 <test_kmalloc_firstfit1+0x24e>
f0118f5e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f65:	83 ec 0c             	sub    $0xc,%esp
f0118f68:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0118f6d:	e8 fa 7f fe ff       	call   f0100f6c <cprintf>
f0118f72:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0118f75:	e8 c7 b5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118f7a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0118f7d:	74 17                	je     f0118f96 <test_kmalloc_firstfit1+0x26f>
f0118f7f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118f86:	83 ec 0c             	sub    $0xc,%esp
f0118f89:	68 c0 be 12 f0       	push   $0xf012bec0
f0118f8e:	e8 d9 7f fe ff       	call   f0100f6c <cprintf>
f0118f93:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0118f96:	e8 6e 47 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118f9b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0118f9e:	29 c2                	sub    %eax,%edx
f0118fa0:	89 d0                	mov    %edx,%eax
f0118fa2:	3d ff 00 00 00       	cmp    $0xff,%eax
f0118fa7:	77 17                	ja     f0118fc0 <test_kmalloc_firstfit1+0x299>
f0118fa9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118fb0:	83 ec 0c             	sub    $0xc,%esp
f0118fb3:	68 29 c1 12 f0       	push   $0xf012c129
f0118fb8:	e8 af 7f fe ff       	call   f0100f6c <cprintf>
f0118fbd:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0118fc0:	e8 44 47 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0118fc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0118fc8:	e8 74 b5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0118fcd:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(2*Mega-kilo);
f0118fd0:	83 ec 0c             	sub    $0xc,%esp
f0118fd3:	68 00 fc 1f 00       	push   $0x1ffc00
f0118fd8:	e8 da f7 fe ff       	call   f01087b7 <kmalloc>
f0118fdd:	83 c4 10             	add    $0x10,%esp
f0118fe0:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0118fe3:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fe6:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0118feb:	74 17                	je     f0119004 <test_kmalloc_firstfit1+0x2dd>
f0118fed:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118ff4:	83 ec 0c             	sub    $0xc,%esp
f0118ff7:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0118ffc:	e8 6b 7f fe ff       	call   f0100f6c <cprintf>
f0119001:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119004:	e8 38 b5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119009:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011900c:	74 17                	je     f0119025 <test_kmalloc_firstfit1+0x2fe>
f011900e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119015:	83 ec 0c             	sub    $0xc,%esp
f0119018:	68 c0 be 12 f0       	push   $0xf012bec0
f011901d:	e8 4a 7f fe ff       	call   f0100f6c <cprintf>
f0119022:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119025:	e8 df 46 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011902a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011902d:	29 c2                	sub    %eax,%edx
f011902f:	89 d0                	mov    %edx,%eax
f0119031:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119036:	77 17                	ja     f011904f <test_kmalloc_firstfit1+0x328>
f0119038:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011903f:	83 ec 0c             	sub    $0xc,%esp
f0119042:	68 29 c1 12 f0       	push   $0xf012c129
f0119047:	e8 20 7f fe ff       	call   f0100f6c <cprintf>
f011904c:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011904f:	e8 b5 46 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119054:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119057:	e8 e5 b4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011905c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(2*Mega-kilo);
f011905f:	83 ec 0c             	sub    $0xc,%esp
f0119062:	68 00 fc 1f 00       	push   $0x1ffc00
f0119067:	e8 4b f7 fe ff       	call   f01087b7 <kmalloc>
f011906c:	83 c4 10             	add    $0x10,%esp
f011906f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 6*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119072:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119075:	3d 00 10 60 f8       	cmp    $0xf8601000,%eax
f011907a:	74 17                	je     f0119093 <test_kmalloc_firstfit1+0x36c>
f011907c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119083:	83 ec 0c             	sub    $0xc,%esp
f0119086:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011908b:	e8 dc 7e fe ff       	call   f0100f6c <cprintf>
f0119090:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119093:	e8 a9 b4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119098:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011909b:	74 17                	je     f01190b4 <test_kmalloc_firstfit1+0x38d>
f011909d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190a4:	83 ec 0c             	sub    $0xc,%esp
f01190a7:	68 c0 be 12 f0       	push   $0xf012bec0
f01190ac:	e8 bb 7e fe ff       	call   f0100f6c <cprintf>
f01190b1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f01190b4:	e8 50 46 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01190b9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01190bc:	29 c2                	sub    %eax,%edx
f01190be:	89 d0                	mov    %edx,%eax
f01190c0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01190c5:	77 17                	ja     f01190de <test_kmalloc_firstfit1+0x3b7>
f01190c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01190ce:	83 ec 0c             	sub    $0xc,%esp
f01190d1:	68 29 c1 12 f0       	push   $0xf012c129
f01190d6:	e8 91 7e fe ff       	call   f0100f6c <cprintf>
f01190db:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01190de:	e8 26 46 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01190e3:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01190e6:	e8 56 b4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01190eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f01190ee:	83 ec 0c             	sub    $0xc,%esp
f01190f1:	68 00 fc 2f 00       	push   $0x2ffc00
f01190f6:	e8 bc f6 fe ff       	call   f01087b7 <kmalloc>
f01190fb:	83 c4 10             	add    $0x10,%esp
f01190fe:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] !=  (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119101:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119104:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0119109:	74 17                	je     f0119122 <test_kmalloc_firstfit1+0x3fb>
f011910b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119112:	83 ec 0c             	sub    $0xc,%esp
f0119115:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011911a:	e8 4d 7e fe ff       	call   f0100f6c <cprintf>
f011911f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119122:	e8 1a b4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119127:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011912a:	74 17                	je     f0119143 <test_kmalloc_firstfit1+0x41c>
f011912c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119133:	83 ec 0c             	sub    $0xc,%esp
f0119136:	68 c0 be 12 f0       	push   $0xf012bec0
f011913b:	e8 2c 7e fe ff       	call   f0100f6c <cprintf>
f0119140:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119143:	e8 c1 45 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119148:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011914b:	29 c2                	sub    %eax,%edx
f011914d:	89 d0                	mov    %edx,%eax
f011914f:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119154:	77 17                	ja     f011916d <test_kmalloc_firstfit1+0x446>
f0119156:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011915d:	83 ec 0c             	sub    $0xc,%esp
f0119160:	68 29 c1 12 f0       	push   $0xf012c129
f0119165:	e8 02 7e fe ff       	call   f0100f6c <cprintf>
f011916a:	83 c4 10             	add    $0x10,%esp

		//Allocate 3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011916d:	e8 97 45 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119172:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119175:	e8 c7 b3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011917a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(3*Mega-kilo);
f011917d:	83 ec 0c             	sub    $0xc,%esp
f0119180:	68 00 fc 2f 00       	push   $0x2ffc00
f0119185:	e8 2d f6 fe ff       	call   f01087b7 <kmalloc>
f011918a:	83 c4 10             	add    $0x10,%esp
f011918d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 11*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119190:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119193:	3d 00 10 b0 f8       	cmp    $0xf8b01000,%eax
f0119198:	74 17                	je     f01191b1 <test_kmalloc_firstfit1+0x48a>
f011919a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191a1:	83 ec 0c             	sub    $0xc,%esp
f01191a4:	68 f8 c0 12 f0       	push   $0xf012c0f8
f01191a9:	e8 be 7d fe ff       	call   f0100f6c <cprintf>
f01191ae:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01191b1:	e8 8b b3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01191b6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01191b9:	74 17                	je     f01191d2 <test_kmalloc_firstfit1+0x4ab>
f01191bb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191c2:	83 ec 0c             	sub    $0xc,%esp
f01191c5:	68 c0 be 12 f0       	push   $0xf012bec0
f01191ca:	e8 9d 7d fe ff       	call   f0100f6c <cprintf>
f01191cf:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: \n"); }
f01191d2:	e8 32 45 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01191d7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01191da:	29 c2                	sub    %eax,%edx
f01191dc:	89 d0                	mov    %edx,%eax
f01191de:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f01191e3:	77 17                	ja     f01191fc <test_kmalloc_firstfit1+0x4d5>
f01191e5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01191ec:	83 ec 0c             	sub    $0xc,%esp
f01191ef:	68 29 c1 12 f0       	push   $0xf012c129
f01191f4:	e8 73 7d fe ff       	call   f0100f6c <cprintf>
f01191f9:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01191fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119200:	74 04                	je     f0119206 <test_kmalloc_firstfit1+0x4df>
f0119202:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119206:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Free some to create holes
	{
		//1 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011920d:	e8 f7 44 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119212:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119215:	e8 27 b3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011921a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f011921d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0119220:	83 ec 0c             	sub    $0xc,%esp
f0119223:	50                   	push   %eax
f0119224:	e8 a8 f5 fe ff       	call   f01087d1 <kfree>
f0119229:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011922c:	e8 10 b3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119231:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119234:	74 17                	je     f011924d <test_kmalloc_firstfit1+0x526>
f0119236:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011923d:	83 ec 0c             	sub    $0xc,%esp
f0119240:	68 c0 be 12 f0       	push   $0xf012bec0
f0119245:	e8 22 7d fe ff       	call   f0100f6c <cprintf>
f011924a:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f011924d:	e8 b7 44 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119252:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119255:	3d ff 00 00 00       	cmp    $0xff,%eax
f011925a:	77 17                	ja     f0119273 <test_kmalloc_firstfit1+0x54c>
f011925c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119263:	83 ec 0c             	sub    $0xc,%esp
f0119266:	68 3d c1 12 f0       	push   $0xf012c13d
f011926b:	e8 fc 7c fe ff       	call   f0100f6c <cprintf>
f0119270:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119273:	e8 91 44 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119278:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011927b:	e8 c1 b2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119280:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[4]);
f0119283:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119286:	83 ec 0c             	sub    $0xc,%esp
f0119289:	50                   	push   %eax
f011928a:	e8 42 f5 fe ff       	call   f01087d1 <kfree>
f011928f:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119292:	e8 aa b2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119297:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011929a:	74 17                	je     f01192b3 <test_kmalloc_firstfit1+0x58c>
f011929c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01192a3:	83 ec 0c             	sub    $0xc,%esp
f01192a6:	68 c0 be 12 f0       	push   $0xf012bec0
f01192ab:	e8 bc 7c fe ff       	call   f0100f6c <cprintf>
f01192b0:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f01192b3:	e8 51 44 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01192b8:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01192bb:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01192c0:	77 17                	ja     f01192d9 <test_kmalloc_firstfit1+0x5b2>
f01192c2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01192c9:	83 ec 0c             	sub    $0xc,%esp
f01192cc:	68 3d c1 12 f0       	push   $0xf012c13d
f01192d1:	e8 96 7c fe ff       	call   f0100f6c <cprintf>
f01192d6:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01192d9:	e8 2b 44 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01192de:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01192e1:	e8 5b b2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01192e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f01192e9:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01192ec:	83 ec 0c             	sub    $0xc,%esp
f01192ef:	50                   	push   %eax
f01192f0:	e8 dc f4 fe ff       	call   f01087d1 <kfree>
f01192f5:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01192f8:	e8 44 b2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01192fd:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119300:	74 17                	je     f0119319 <test_kmalloc_firstfit1+0x5f2>
f0119302:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119309:	83 ec 0c             	sub    $0xc,%esp
f011930c:	68 c0 be 12 f0       	push   $0xf012bec0
f0119311:	e8 56 7c fe ff       	call   f0100f6c <cprintf>
f0119316:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f0119319:	e8 eb 43 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011931e:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119321:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119326:	77 17                	ja     f011933f <test_kmalloc_firstfit1+0x618>
f0119328:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011932f:	83 ec 0c             	sub    $0xc,%esp
f0119332:	68 3d c1 12 f0       	push   $0xf012c13d
f0119337:	e8 30 7c fe ff       	call   f0100f6c <cprintf>
f011933c:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011933f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119343:	74 04                	je     f0119349 <test_kmalloc_firstfit1+0x622>
f0119345:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119349:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[3] Allocate again [test first fit]
	{
		//Allocate 512 KB - should be placed in 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119350:	e8 b4 43 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119355:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119358:	e8 e4 b1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011935d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(512*kilo - kilo);
f0119360:	83 ec 0c             	sub    $0xc,%esp
f0119363:	68 00 fc 07 00       	push   $0x7fc00
f0119368:	e8 4a f4 fe ff       	call   f01087b7 <kmalloc>
f011936d:	83 c4 10             	add    $0x10,%esp
f0119370:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 1*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119373:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119376:	3d 00 10 10 f8       	cmp    $0xf8101000,%eax
f011937b:	74 17                	je     f0119394 <test_kmalloc_firstfit1+0x66d>
f011937d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119384:	83 ec 0c             	sub    $0xc,%esp
f0119387:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011938c:	e8 db 7b fe ff       	call   f0100f6c <cprintf>
f0119391:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119394:	e8 a8 b1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119399:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011939c:	74 17                	je     f01193b5 <test_kmalloc_firstfit1+0x68e>
f011939e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193a5:	83 ec 0c             	sub    $0xc,%esp
f01193a8:	68 c0 be 12 f0       	push   $0xf012bec0
f01193ad:	e8 ba 7b fe ff       	call   f0100f6c <cprintf>
f01193b2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 128) { correct = 0; cprintf("Wrong allocation: \n"); }
f01193b5:	e8 4f 43 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01193ba:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01193bd:	29 c2                	sub    %eax,%edx
f01193bf:	89 d0                	mov    %edx,%eax
f01193c1:	83 f8 7f             	cmp    $0x7f,%eax
f01193c4:	77 17                	ja     f01193dd <test_kmalloc_firstfit1+0x6b6>
f01193c6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01193cd:	83 ec 0c             	sub    $0xc,%esp
f01193d0:	68 29 c1 12 f0       	push   $0xf012c129
f01193d5:	e8 92 7b fe ff       	call   f0100f6c <cprintf>
f01193da:	83 c4 10             	add    $0x10,%esp

		//Allocate 1 MB - should be placed in 2nd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01193dd:	e8 27 43 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01193e2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01193e5:	e8 57 b1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01193ea:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(1*Mega - kilo);
f01193ed:	83 ec 0c             	sub    $0xc,%esp
f01193f0:	68 00 fc 0f 00       	push   $0xffc00
f01193f5:	e8 bd f3 fe ff       	call   f01087b7 <kmalloc>
f01193fa:	83 c4 10             	add    $0x10,%esp
f01193fd:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START + 4*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119400:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119403:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119408:	74 17                	je     f0119421 <test_kmalloc_firstfit1+0x6fa>
f011940a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119411:	83 ec 0c             	sub    $0xc,%esp
f0119414:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119419:	e8 4e 7b fe ff       	call   f0100f6c <cprintf>
f011941e:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119421:	e8 1b b1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119426:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119429:	74 17                	je     f0119442 <test_kmalloc_firstfit1+0x71b>
f011942b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119432:	83 ec 0c             	sub    $0xc,%esp
f0119435:	68 c0 be 12 f0       	push   $0xf012bec0
f011943a:	e8 2d 7b fe ff       	call   f0100f6c <cprintf>
f011943f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119442:	e8 c2 42 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119447:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011944a:	29 c2                	sub    %eax,%edx
f011944c:	89 d0                	mov    %edx,%eax
f011944e:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119453:	77 17                	ja     f011946c <test_kmalloc_firstfit1+0x745>
f0119455:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011945c:	83 ec 0c             	sub    $0xc,%esp
f011945f:	68 29 c1 12 f0       	push   $0xf012c129
f0119464:	e8 03 7b fe ff       	call   f0100f6c <cprintf>
f0119469:	83 c4 10             	add    $0x10,%esp


		//Allocate 256 KB - should be placed in remaining of 1st hole
		freeFrames = (int)sys_calculate_free_frames() ;
f011946c:	e8 98 42 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119471:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119474:	e8 c8 b0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119479:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(256*kilo - kilo);
f011947c:	83 ec 0c             	sub    $0xc,%esp
f011947f:	68 00 fc 03 00       	push   $0x3fc00
f0119484:	e8 2e f3 fe ff       	call   f01087b7 <kmalloc>
f0119489:	83 c4 10             	add    $0x10,%esp
f011948c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 1*Mega + 512*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011948f:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119492:	3d 00 10 18 f8       	cmp    $0xf8181000,%eax
f0119497:	74 17                	je     f01194b0 <test_kmalloc_firstfit1+0x789>
f0119499:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01194a0:	83 ec 0c             	sub    $0xc,%esp
f01194a3:	68 f8 c0 12 f0       	push   $0xf012c0f8
f01194a8:	e8 bf 7a fe ff       	call   f0100f6c <cprintf>
f01194ad:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01194b0:	e8 8c b0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f01194b5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01194b8:	74 17                	je     f01194d1 <test_kmalloc_firstfit1+0x7aa>
f01194ba:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01194c1:	83 ec 0c             	sub    $0xc,%esp
f01194c4:	68 c0 be 12 f0       	push   $0xf012bec0
f01194c9:	e8 9e 7a fe ff       	call   f0100f6c <cprintf>
f01194ce:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 64) { correct = 0; cprintf("Wrong allocation: \n"); }
f01194d1:	e8 33 42 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01194d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01194d9:	29 c2                	sub    %eax,%edx
f01194db:	89 d0                	mov    %edx,%eax
f01194dd:	83 f8 3f             	cmp    $0x3f,%eax
f01194e0:	77 17                	ja     f01194f9 <test_kmalloc_firstfit1+0x7d2>
f01194e2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01194e9:	83 ec 0c             	sub    $0xc,%esp
f01194ec:	68 29 c1 12 f0       	push   $0xf012c129
f01194f1:	e8 76 7a fe ff       	call   f0100f6c <cprintf>
f01194f6:	83 c4 10             	add    $0x10,%esp

		//Allocate 2 MB - should be placed in 3rd hole
		freeFrames = (int)sys_calculate_free_frames() ;
f01194f9:	e8 0b 42 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01194fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119501:	e8 3b b0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119506:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(2*Mega);
f0119509:	83 ec 0c             	sub    $0xc,%esp
f011950c:	68 00 00 20 00       	push   $0x200000
f0119511:	e8 a1 f2 fe ff       	call   f01087b7 <kmalloc>
f0119516:	83 c4 10             	add    $0x10,%esp
f0119519:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((uint32) ptr_allocations[11] != (ACTUAL_START + 8*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011951c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011951f:	3d 00 10 80 f8       	cmp    $0xf8801000,%eax
f0119524:	74 17                	je     f011953d <test_kmalloc_firstfit1+0x816>
f0119526:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011952d:	83 ec 0c             	sub    $0xc,%esp
f0119530:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119535:	e8 32 7a fe ff       	call   f0100f6c <cprintf>
f011953a:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011953d:	e8 c7 41 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119542:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119545:	29 c2                	sub    %eax,%edx
f0119547:	89 d0                	mov    %edx,%eax
f0119549:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011954e:	77 17                	ja     f0119567 <test_kmalloc_firstfit1+0x840>
f0119550:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119557:	83 ec 0c             	sub    $0xc,%esp
f011955a:	68 29 c1 12 f0       	push   $0xf012c129
f011955f:	e8 08 7a fe ff       	call   f0100f6c <cprintf>
f0119564:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119567:	e8 d5 af fe ff       	call   f0104541 <pf_calculate_free_frames>
f011956c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011956f:	74 17                	je     f0119588 <test_kmalloc_firstfit1+0x861>
f0119571:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119578:	83 ec 0c             	sub    $0xc,%esp
f011957b:	68 c0 be 12 f0       	push   $0xf012bec0
f0119580:	e8 e7 79 fe ff       	call   f0100f6c <cprintf>
f0119585:	83 c4 10             	add    $0x10,%esp


		//Allocate 4 MB - should be placed in end of all allocations
		freeFrames = (int)sys_calculate_free_frames() ;
f0119588:	e8 7c 41 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011958d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119590:	e8 ac af fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119595:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(4*Mega - kilo);
f0119598:	83 ec 0c             	sub    $0xc,%esp
f011959b:	68 00 fc 3f 00       	push   $0x3ffc00
f01195a0:	e8 12 f2 fe ff       	call   f01087b7 <kmalloc>
f01195a5:	83 c4 10             	add    $0x10,%esp
f01195a8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((uint32) ptr_allocations[12] != (ACTUAL_START + 14*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f01195ab:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01195ae:	3d 00 10 e0 f8       	cmp    $0xf8e01000,%eax
f01195b3:	74 17                	je     f01195cc <test_kmalloc_firstfit1+0x8a5>
f01195b5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01195bc:	83 ec 0c             	sub    $0xc,%esp
f01195bf:	68 f8 c0 12 f0       	push   $0xf012c0f8
f01195c4:	e8 a3 79 fe ff       	call   f0100f6c <cprintf>
f01195c9:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01195cc:	e8 70 af fe ff       	call   f0104541 <pf_calculate_free_frames>
f01195d1:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01195d4:	74 17                	je     f01195ed <test_kmalloc_firstfit1+0x8c6>
f01195d6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01195dd:	83 ec 0c             	sub    $0xc,%esp
f01195e0:	68 c0 be 12 f0       	push   $0xf012bec0
f01195e5:	e8 82 79 fe ff       	call   f0100f6c <cprintf>
f01195ea:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1024) { correct = 0; cprintf("Wrong allocation: \n"); }
f01195ed:	e8 17 41 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01195f2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01195f5:	29 c2                	sub    %eax,%edx
f01195f7:	89 d0                	mov    %edx,%eax
f01195f9:	3d ff 03 00 00       	cmp    $0x3ff,%eax
f01195fe:	77 17                	ja     f0119617 <test_kmalloc_firstfit1+0x8f0>
f0119600:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119607:	83 ec 0c             	sub    $0xc,%esp
f011960a:	68 29 c1 12 f0       	push   $0xf012c129
f011960f:	e8 58 79 fe ff       	call   f0100f6c <cprintf>
f0119614:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=40 ;
f0119617:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011961b:	74 04                	je     f0119621 <test_kmalloc_firstfit1+0x8fa>
f011961d:	83 45 f4 28          	addl   $0x28,-0xc(%ebp)

	correct = 1 ;
f0119621:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[4] Free contiguous allocations
	{
		//1 MB Hole appended to previous 256 KB hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119628:	e8 dc 40 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011962d:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119630:	e8 0c af fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119635:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0119638:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011963b:	83 ec 0c             	sub    $0xc,%esp
f011963e:	50                   	push   %eax
f011963f:	e8 8d f1 fe ff       	call   f01087d1 <kfree>
f0119644:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119647:	e8 f5 ae fe ff       	call   f0104541 <pf_calculate_free_frames>
f011964c:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011964f:	74 17                	je     f0119668 <test_kmalloc_firstfit1+0x941>
f0119651:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119658:	83 ec 0c             	sub    $0xc,%esp
f011965b:	68 c0 be 12 f0       	push   $0xf012bec0
f0119660:	e8 07 79 fe ff       	call   f0100f6c <cprintf>
f0119665:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f0119668:	e8 9c 40 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011966d:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119670:	3d ff 00 00 00       	cmp    $0xff,%eax
f0119675:	77 17                	ja     f011968e <test_kmalloc_firstfit1+0x967>
f0119677:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011967e:	83 ec 0c             	sub    $0xc,%esp
f0119681:	68 3d c1 12 f0       	push   $0xf012c13d
f0119686:	e8 e1 78 fe ff       	call   f0100f6c <cprintf>
f011968b:	83 c4 10             	add    $0x10,%esp

		//Next 1 MB Hole appended also
		freeFrames = (int)sys_calculate_free_frames() ;
f011968e:	e8 76 40 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119693:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119696:	e8 a6 ae fe ff       	call   f0104541 <pf_calculate_free_frames>
f011969b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f011969e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01196a1:	83 ec 0c             	sub    $0xc,%esp
f01196a4:	50                   	push   %eax
f01196a5:	e8 27 f1 fe ff       	call   f01087d1 <kfree>
f01196aa:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01196ad:	e8 8f ae fe ff       	call   f0104541 <pf_calculate_free_frames>
f01196b2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01196b5:	74 17                	je     f01196ce <test_kmalloc_firstfit1+0x9a7>
f01196b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01196be:	83 ec 0c             	sub    $0xc,%esp
f01196c1:	68 c0 be 12 f0       	push   $0xf012bec0
f01196c6:	e8 a1 78 fe ff       	call   f0100f6c <cprintf>
f01196cb:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 256) { correct = 0; cprintf("Wrong free: \n"); }
f01196ce:	e8 36 40 ff ff       	call   f010d709 <sys_calculate_free_frames>
f01196d3:	2b 45 ec             	sub    -0x14(%ebp),%eax
f01196d6:	3d ff 00 00 00       	cmp    $0xff,%eax
f01196db:	77 17                	ja     f01196f4 <test_kmalloc_firstfit1+0x9cd>
f01196dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01196e4:	83 ec 0c             	sub    $0xc,%esp
f01196e7:	68 3d c1 12 f0       	push   $0xf012c13d
f01196ec:	e8 7b 78 fe ff       	call   f0100f6c <cprintf>
f01196f1:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f01196f4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01196f8:	74 04                	je     f01196fe <test_kmalloc_firstfit1+0x9d7>
f01196fa:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f01196fe:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[5] Allocate again [test first fit]
	{
		//[FIRST FIT Case]
		//Allocate 1 MB - should be placed in the contiguous hole (256 KB + 2 MB)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119705:	e8 ff 3f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011970a:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011970d:	e8 2f ae fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119712:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[13] = kmalloc(1*Mega);
f0119715:	83 ec 0c             	sub    $0xc,%esp
f0119718:	68 00 00 10 00       	push   $0x100000
f011971d:	e8 95 f0 fe ff       	call   f01087b7 <kmalloc>
f0119722:	83 c4 10             	add    $0x10,%esp
f0119725:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((uint32) ptr_allocations[13] != (ACTUAL_START + 1*Mega + 768*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119728:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011972b:	3d 00 10 1c f8       	cmp    $0xf81c1000,%eax
f0119730:	74 17                	je     f0119749 <test_kmalloc_firstfit1+0xa22>
f0119732:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119739:	83 ec 0c             	sub    $0xc,%esp
f011973c:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119741:	e8 26 78 fe ff       	call   f0100f6c <cprintf>
f0119746:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119749:	e8 f3 ad fe ff       	call   f0104541 <pf_calculate_free_frames>
f011974e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119751:	74 17                	je     f011976a <test_kmalloc_firstfit1+0xa43>
f0119753:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011975a:	83 ec 0c             	sub    $0xc,%esp
f011975d:	68 c0 be 12 f0       	push   $0xf012bec0
f0119762:	e8 05 78 fe ff       	call   f0100f6c <cprintf>
f0119767:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: \n"); }
f011976a:	e8 9a 3f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011976f:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119772:	29 c2                	sub    %eax,%edx
f0119774:	89 d0                	mov    %edx,%eax
f0119776:	3d ff 00 00 00       	cmp    $0xff,%eax
f011977b:	77 17                	ja     f0119794 <test_kmalloc_firstfit1+0xa6d>
f011977d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119784:	83 ec 0c             	sub    $0xc,%esp
f0119787:	68 29 c1 12 f0       	push   $0xf012c129
f011978c:	e8 db 77 fe ff       	call   f0100f6c <cprintf>
f0119791:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f0119794:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119798:	74 04                	je     f011979e <test_kmalloc_firstfit1+0xa77>
f011979a:	83 45 f4 1e          	addl   $0x1e,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (1) completed. Eval = %d%\n", eval);
f011979e:	83 ec 08             	sub    $0x8,%esp
f01197a1:	ff 75 f4             	pushl  -0xc(%ebp)
f01197a4:	68 4c c1 12 f0       	push   $0xf012c14c
f01197a9:	e8 be 77 fe ff       	call   f0100f6c <cprintf>
f01197ae:	83 c4 10             	add    $0x10,%esp

	return 1;
f01197b1:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01197b6:	8b 7d fc             	mov    -0x4(%ebp),%edi
f01197b9:	c9                   	leave  
f01197ba:	c3                   	ret    

f01197bb <test_kmalloc_firstfit2>:

int test_kmalloc_firstfit2()
{
f01197bb:	55                   	push   %ebp
f01197bc:	89 e5                	mov    %esp,%ebp
f01197be:	57                   	push   %edi
f01197bf:	53                   	push   %ebx
f01197c0:	83 ec 60             	sub    $0x60,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f01197c3:	83 ec 0c             	sub    $0xc,%esp
f01197c6:	68 00 be 12 f0       	push   $0xf012be00
f01197cb:	e8 9c 77 fe ff       	call   f0100f6c <cprintf>
f01197d0:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f01197d3:	83 ec 0c             	sub    $0xc,%esp
f01197d6:	68 30 be 12 f0       	push   $0xf012be30
f01197db:	e8 8c 77 fe ff       	call   f0100f6c <cprintf>
f01197e0:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f01197e3:	83 ec 0c             	sub    $0xc,%esp
f01197e6:	68 00 be 12 f0       	push   $0xf012be00
f01197eb:	e8 7c 77 fe ff       	call   f0100f6c <cprintf>
f01197f0:	83 c4 10             	add    $0x10,%esp

	void* ptr_allocations[20] = {0};
f01197f3:	8d 55 98             	lea    -0x68(%ebp),%edx
f01197f6:	b9 14 00 00 00       	mov    $0x14,%ecx
f01197fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0119800:	89 d7                	mov    %edx,%edi
f0119802:	f3 ab                	rep stos %eax,%es:(%edi)
	uint32 freeFrames;
	uint32 freeDiskFrames;
	int eval = 0;
f0119804:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool correct = 1 ;
f011980b:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	correct = 1 ;
f0119812:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[1] Attempt to allocate more than heap size
	{
		ptr_allocations[0] = kmalloc(KERNEL_HEAP_MAX - ACTUAL_START + 1);
f0119819:	83 ec 0c             	sub    $0xc,%esp
f011981c:	68 01 e0 ff 07       	push   $0x7ffe001
f0119821:	e8 91 ef fe ff       	call   f01087b7 <kmalloc>
f0119826:	83 c4 10             	add    $0x10,%esp
f0119829:	89 45 98             	mov    %eax,-0x68(%ebp)
		if (ptr_allocations[0] != NULL) { correct = 0; cprintf("kmalloc: Attempt to allocate more than heap size, should return NULL\n"); }
f011982c:	8b 45 98             	mov    -0x68(%ebp),%eax
f011982f:	85 c0                	test   %eax,%eax
f0119831:	74 17                	je     f011984a <test_kmalloc_firstfit2+0x8f>
f0119833:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011983a:	83 ec 0c             	sub    $0xc,%esp
f011983d:	68 84 c1 12 f0       	push   $0xf012c184
f0119842:	e8 25 77 fe ff       	call   f0100f6c <cprintf>
f0119847:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011984a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011984e:	74 04                	je     f0119854 <test_kmalloc_firstfit2+0x99>
f0119850:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119854:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//[2] Attempt to allocate space more than any available fragment
	//	a) Create Fragments
	{
		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f011985b:	e8 a9 3e ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119860:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119863:	e8 d9 ac fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119868:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011986b:	83 ec 0c             	sub    $0xc,%esp
f011986e:	68 00 fc 1f 00       	push   $0x1ffc00
f0119873:	e8 3f ef fe ff       	call   f01087b7 <kmalloc>
f0119878:	83 c4 10             	add    $0x10,%esp
f011987b:	89 45 98             	mov    %eax,-0x68(%ebp)
		if ((uint32) ptr_allocations[0] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011987e:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119881:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119886:	74 17                	je     f011989f <test_kmalloc_firstfit2+0xe4>
f0119888:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011988f:	83 ec 0c             	sub    $0xc,%esp
f0119892:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119897:	e8 d0 76 fe ff       	call   f0100f6c <cprintf>
f011989c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011989f:	e8 9d ac fe ff       	call   f0104541 <pf_calculate_free_frames>
f01198a4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01198a7:	74 17                	je     f01198c0 <test_kmalloc_firstfit2+0x105>
f01198a9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198b0:	83 ec 0c             	sub    $0xc,%esp
f01198b3:	68 c0 be 12 f0       	push   $0xf012bec0
f01198b8:	e8 af 76 fe ff       	call   f0100f6c <cprintf>
f01198bd:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f01198c0:	e8 44 3e ff ff       	call   f010d709 <sys_calculate_free_frames>
f01198c5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01198c8:	29 c2                	sub    %eax,%edx
f01198ca:	89 d0                	mov    %edx,%eax
f01198cc:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f01198d1:	77 17                	ja     f01198ea <test_kmalloc_firstfit2+0x12f>
f01198d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01198da:	83 ec 0c             	sub    $0xc,%esp
f01198dd:	68 29 c1 12 f0       	push   $0xf012c129
f01198e2:	e8 85 76 fe ff       	call   f0100f6c <cprintf>
f01198e7:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f01198ea:	e8 1a 3e ff ff       	call   f010d709 <sys_calculate_free_frames>
f01198ef:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f01198f2:	e8 4a ac fe ff       	call   f0104541 <pf_calculate_free_frames>
f01198f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f01198fa:	83 ec 0c             	sub    $0xc,%esp
f01198fd:	68 00 fc 1f 00       	push   $0x1ffc00
f0119902:	e8 b0 ee fe ff       	call   f01087b7 <kmalloc>
f0119907:	83 c4 10             	add    $0x10,%esp
f011990a:	89 45 9c             	mov    %eax,-0x64(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011990d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0119910:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f0119915:	74 17                	je     f011992e <test_kmalloc_firstfit2+0x173>
f0119917:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011991e:	83 ec 0c             	sub    $0xc,%esp
f0119921:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119926:	e8 41 76 fe ff       	call   f0100f6c <cprintf>
f011992b:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011992e:	e8 0e ac fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119933:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119936:	74 17                	je     f011994f <test_kmalloc_firstfit2+0x194>
f0119938:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011993f:	83 ec 0c             	sub    $0xc,%esp
f0119942:	68 c0 be 12 f0       	push   $0xf012bec0
f0119947:	e8 20 76 fe ff       	call   f0100f6c <cprintf>
f011994c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: \n"); }
f011994f:	e8 b5 3d ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119954:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119957:	29 c2                	sub    %eax,%edx
f0119959:	89 d0                	mov    %edx,%eax
f011995b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119960:	77 17                	ja     f0119979 <test_kmalloc_firstfit2+0x1be>
f0119962:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119969:	83 ec 0c             	sub    $0xc,%esp
f011996c:	68 29 c1 12 f0       	push   $0xf012c129
f0119971:	e8 f6 75 fe ff       	call   f0100f6c <cprintf>
f0119976:	83 c4 10             	add    $0x10,%esp

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119979:	e8 8b 3d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011997e:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119981:	e8 bb ab fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119986:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[2] = kmalloc(1*kilo);
f0119989:	83 ec 0c             	sub    $0xc,%esp
f011998c:	68 00 04 00 00       	push   $0x400
f0119991:	e8 21 ee fe ff       	call   f01087b7 <kmalloc>
f0119996:	83 c4 10             	add    $0x10,%esp
f0119999:	89 45 a0             	mov    %eax,-0x60(%ebp)
		if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011999c:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011999f:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f01199a4:	76 22                	jbe    f01199c8 <test_kmalloc_firstfit2+0x20d>
f01199a6:	8b 5d a0             	mov    -0x60(%ebp),%ebx
f01199a9:	83 ec 0c             	sub    $0xc,%esp
f01199ac:	6a 00                	push   $0x0
f01199ae:	e8 fa ed fe ff       	call   f01087ad <sbrk>
f01199b3:	83 c4 10             	add    $0x10,%esp
f01199b6:	39 c3                	cmp    %eax,%ebx
f01199b8:	73 0e                	jae    f01199c8 <test_kmalloc_firstfit2+0x20d>
f01199ba:	8b 45 a0             	mov    -0x60(%ebp),%eax
f01199bd:	89 c2                	mov    %eax,%edx
f01199bf:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f01199c4:	39 c2                	cmp    %eax,%edx
f01199c6:	72 17                	jb     f01199df <test_kmalloc_firstfit2+0x224>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f01199c8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01199cf:	83 ec 0c             	sub    $0xc,%esp
f01199d2:	68 c0 bf 12 f0       	push   $0xf012bfc0
f01199d7:	e8 90 75 fe ff       	call   f0100f6c <cprintf>
f01199dc:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f01199df:	e8 5d ab fe ff       	call   f0104541 <pf_calculate_free_frames>
f01199e4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01199e7:	74 17                	je     f0119a00 <test_kmalloc_firstfit2+0x245>
f01199e9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01199f0:	83 ec 0c             	sub    $0xc,%esp
f01199f3:	68 c0 be 12 f0       	push   $0xf012bec0
f01199f8:	e8 6f 75 fe ff       	call   f0100f6c <cprintf>
f01199fd:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//2 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119a00:	e8 04 3d ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119a05:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119a08:	e8 34 ab fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119a0d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[3] = kmalloc(2*kilo);
f0119a10:	83 ec 0c             	sub    $0xc,%esp
f0119a13:	68 00 08 00 00       	push   $0x800
f0119a18:	e8 9a ed fe ff       	call   f01087b7 <kmalloc>
f0119a1d:	83 c4 10             	add    $0x10,%esp
f0119a20:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f0119a23:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119a26:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119a2b:	76 22                	jbe    f0119a4f <test_kmalloc_firstfit2+0x294>
f0119a2d:	8b 5d a4             	mov    -0x5c(%ebp),%ebx
f0119a30:	83 ec 0c             	sub    $0xc,%esp
f0119a33:	6a 00                	push   $0x0
f0119a35:	e8 73 ed fe ff       	call   f01087ad <sbrk>
f0119a3a:	83 c4 10             	add    $0x10,%esp
f0119a3d:	39 c3                	cmp    %eax,%ebx
f0119a3f:	73 0e                	jae    f0119a4f <test_kmalloc_firstfit2+0x294>
f0119a41:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119a44:	89 c2                	mov    %eax,%edx
f0119a46:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f0119a4b:	39 c2                	cmp    %eax,%edx
f0119a4d:	72 17                	jb     f0119a66 <test_kmalloc_firstfit2+0x2ab>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119a4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119a56:	83 ec 0c             	sub    $0xc,%esp
f0119a59:	68 c0 bf 12 f0       	push   $0xf012bfc0
f0119a5e:	e8 09 75 fe ff       	call   f0100f6c <cprintf>
f0119a63:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119a66:	e8 d6 aa fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119a6b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119a6e:	74 17                	je     f0119a87 <test_kmalloc_firstfit2+0x2cc>
f0119a70:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119a77:	83 ec 0c             	sub    $0xc,%esp
f0119a7a:	68 c0 be 12 f0       	push   $0xf012bec0
f0119a7f:	e8 e8 74 fe ff       	call   f0100f6c <cprintf>
f0119a84:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB (should be allocated by dynamic allocator not page allocator)
		freeFrames = (int)sys_calculate_free_frames() ;
f0119a87:	e8 7d 3c ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119a8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119a8f:	e8 ad aa fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119a94:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[4] = kmalloc(1*kilo);
f0119a97:	83 ec 0c             	sub    $0xc,%esp
f0119a9a:	68 00 04 00 00       	push   $0x400
f0119a9f:	e8 13 ed fe ff       	call   f01087b7 <kmalloc>
f0119aa4:	83 c4 10             	add    $0x10,%esp
f0119aa7:	89 45 a8             	mov    %eax,-0x58(%ebp)
		if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f0119aaa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119aad:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f0119ab2:	76 22                	jbe    f0119ad6 <test_kmalloc_firstfit2+0x31b>
f0119ab4:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f0119ab7:	83 ec 0c             	sub    $0xc,%esp
f0119aba:	6a 00                	push   $0x0
f0119abc:	e8 ec ec fe ff       	call   f01087ad <sbrk>
f0119ac1:	83 c4 10             	add    $0x10,%esp
f0119ac4:	39 c3                	cmp    %eax,%ebx
f0119ac6:	73 0e                	jae    f0119ad6 <test_kmalloc_firstfit2+0x31b>
f0119ac8:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119acb:	89 c2                	mov    %eax,%edx
f0119acd:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f0119ad2:	39 c2                	cmp    %eax,%edx
f0119ad4:	72 17                	jb     f0119aed <test_kmalloc_firstfit2+0x332>
		{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f0119ad6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119add:	83 ec 0c             	sub    $0xc,%esp
f0119ae0:	68 c0 bf 12 f0       	push   $0xf012bfc0
f0119ae5:	e8 82 74 fe ff       	call   f0100f6c <cprintf>
f0119aea:	83 c4 10             	add    $0x10,%esp
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119aed:	e8 4f aa fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119af2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119af5:	74 17                	je     f0119b0e <test_kmalloc_firstfit2+0x353>
f0119af7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119afe:	83 ec 0c             	sub    $0xc,%esp
f0119b01:	68 c0 be 12 f0       	push   $0xf012bec0
f0119b06:	e8 61 74 fe ff       	call   f0100f6c <cprintf>
f0119b0b:	83 c4 10             	add    $0x10,%esp
		//if ((freeFrames - (int)sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

		//1 KB Hole in Dynamic Allocator Area
		freeFrames = (int)sys_calculate_free_frames() ;
f0119b0e:	e8 f6 3b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119b13:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119b16:	e8 26 aa fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119b1b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[2]);
f0119b1e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0119b21:	83 ec 0c             	sub    $0xc,%esp
f0119b24:	50                   	push   %eax
f0119b25:	e8 a7 ec fe ff       	call   f01087d1 <kfree>
f0119b2a:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119b2d:	e8 0f aa fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119b32:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119b35:	74 17                	je     f0119b4e <test_kmalloc_firstfit2+0x393>
f0119b37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119b3e:	83 ec 0c             	sub    $0xc,%esp
f0119b41:	68 c0 be 12 f0       	push   $0xf012bec0
f0119b46:	e8 21 74 fe ff       	call   f0100f6c <cprintf>
f0119b4b:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119b4e:	e8 b6 3b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119b53:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119b56:	74 17                	je     f0119b6f <test_kmalloc_firstfit2+0x3b4>
f0119b58:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119b5f:	83 ec 0c             	sub    $0xc,%esp
f0119b62:	68 cc c1 12 f0       	push   $0xf012c1cc
f0119b67:	e8 00 74 fe ff       	call   f0100f6c <cprintf>
f0119b6c:	83 c4 10             	add    $0x10,%esp

		//7 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119b6f:	e8 95 3b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119b74:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119b77:	e8 c5 a9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119b7c:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f0119b7f:	83 ec 0c             	sub    $0xc,%esp
f0119b82:	68 00 1c 00 00       	push   $0x1c00
f0119b87:	e8 2b ec fe ff       	call   f01087b7 <kmalloc>
f0119b8c:	83 c4 10             	add    $0x10,%esp
f0119b8f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119b92:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119b95:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f0119b9a:	74 17                	je     f0119bb3 <test_kmalloc_firstfit2+0x3f8>
f0119b9c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119ba3:	83 ec 0c             	sub    $0xc,%esp
f0119ba6:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119bab:	e8 bc 73 fe ff       	call   f0100f6c <cprintf>
f0119bb0:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119bb3:	e8 89 a9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119bb8:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119bbb:	74 17                	je     f0119bd4 <test_kmalloc_firstfit2+0x419>
f0119bbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119bc4:	83 ec 0c             	sub    $0xc,%esp
f0119bc7:	68 c0 be 12 f0       	push   $0xf012bec0
f0119bcc:	e8 9b 73 fe ff       	call   f0100f6c <cprintf>
f0119bd1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119bd4:	e8 30 3b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119bd9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119bdc:	29 c2                	sub    %eax,%edx
f0119bde:	89 d0                	mov    %edx,%eax
f0119be0:	83 f8 01             	cmp    $0x1,%eax
f0119be3:	77 17                	ja     f0119bfc <test_kmalloc_firstfit2+0x441>
f0119be5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119bec:	83 ec 0c             	sub    $0xc,%esp
f0119bef:	68 29 c1 12 f0       	push   $0xf012c129
f0119bf4:	e8 73 73 fe ff       	call   f0100f6c <cprintf>
f0119bf9:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119bfc:	e8 08 3b ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119c01:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119c04:	e8 38 a9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119c09:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[0]);
f0119c0c:	8b 45 98             	mov    -0x68(%ebp),%eax
f0119c0f:	83 ec 0c             	sub    $0xc,%esp
f0119c12:	50                   	push   %eax
f0119c13:	e8 b9 eb fe ff       	call   f01087d1 <kfree>
f0119c18:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119c1b:	e8 21 a9 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119c20:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119c23:	74 17                	je     f0119c3c <test_kmalloc_firstfit2+0x481>
f0119c25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119c2c:	83 ec 0c             	sub    $0xc,%esp
f0119c2f:	68 c0 be 12 f0       	push   $0xf012bec0
f0119c34:	e8 33 73 fe ff       	call   f0100f6c <cprintf>
f0119c39:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f0119c3c:	e8 c8 3a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119c41:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119c44:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119c49:	77 17                	ja     f0119c62 <test_kmalloc_firstfit2+0x4a7>
f0119c4b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119c52:	83 ec 0c             	sub    $0xc,%esp
f0119c55:	68 3d c1 12 f0       	push   $0xf012c13d
f0119c5a:	e8 0d 73 fe ff       	call   f0100f6c <cprintf>
f0119c5f:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119c62:	e8 a2 3a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119c67:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119c6a:	e8 d2 a8 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119c6f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f0119c72:	83 ec 0c             	sub    $0xc,%esp
f0119c75:	68 00 fc 2f 00       	push   $0x2ffc00
f0119c7a:	e8 38 eb fe ff       	call   f01087b7 <kmalloc>
f0119c7f:	83 c4 10             	add    $0x10,%esp
f0119c82:	89 45 b0             	mov    %eax,-0x50(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119c85:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119c88:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f0119c8d:	74 17                	je     f0119ca6 <test_kmalloc_firstfit2+0x4eb>
f0119c8f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119c96:	83 ec 0c             	sub    $0xc,%esp
f0119c99:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119c9e:	e8 c9 72 fe ff       	call   f0100f6c <cprintf>
f0119ca3:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ca6:	e8 96 a8 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119cab:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119cae:	74 17                	je     f0119cc7 <test_kmalloc_firstfit2+0x50c>
f0119cb0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119cb7:	83 ec 0c             	sub    $0xc,%esp
f0119cba:	68 c0 be 12 f0       	push   $0xf012bec0
f0119cbf:	e8 a8 72 fe ff       	call   f0100f6c <cprintf>
f0119cc4:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  3*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119cc7:	e8 3d 3a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119ccc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119ccf:	29 c2                	sub    %eax,%edx
f0119cd1:	89 d0                	mov    %edx,%eax
f0119cd3:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119cd8:	77 17                	ja     f0119cf1 <test_kmalloc_firstfit2+0x536>
f0119cda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119ce1:	83 ec 0c             	sub    $0xc,%esp
f0119ce4:	68 29 c1 12 f0       	push   $0xf012c129
f0119ce9:	e8 7e 72 fe ff       	call   f0100f6c <cprintf>
f0119cee:	83 c4 10             	add    $0x10,%esp

		//2 MB + 6 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119cf1:	e8 13 3a ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119cf6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119cf9:	e8 43 a8 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119cfe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[7] = kmalloc(2*Mega + 6*kilo);
f0119d01:	83 ec 0c             	sub    $0xc,%esp
f0119d04:	68 00 18 20 00       	push   $0x201800
f0119d09:	e8 a9 ea fe ff       	call   f01087b7 <kmalloc>
f0119d0e:	83 c4 10             	add    $0x10,%esp
f0119d11:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119d14:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0119d17:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f0119d1c:	74 17                	je     f0119d35 <test_kmalloc_firstfit2+0x57a>
f0119d1e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119d25:	83 ec 0c             	sub    $0xc,%esp
f0119d28:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119d2d:	e8 3a 72 fe ff       	call   f0100f6c <cprintf>
f0119d32:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d35:	e8 07 a8 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119d3a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119d3d:	74 17                	je     f0119d56 <test_kmalloc_firstfit2+0x59b>
f0119d3f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119d46:	83 ec 0c             	sub    $0xc,%esp
f0119d49:	68 c0 be 12 f0       	push   $0xf012bec0
f0119d4e:	e8 19 72 fe ff       	call   f0100f6c <cprintf>
f0119d53:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  514) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119d56:	e8 ae 39 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119d5b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119d5e:	29 c2                	sub    %eax,%edx
f0119d60:	89 d0                	mov    %edx,%eax
f0119d62:	3d 01 02 00 00       	cmp    $0x201,%eax
f0119d67:	77 17                	ja     f0119d80 <test_kmalloc_firstfit2+0x5c5>
f0119d69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119d70:	83 ec 0c             	sub    $0xc,%esp
f0119d73:	68 29 c1 12 f0       	push   $0xf012c129
f0119d78:	e8 ef 71 fe ff       	call   f0100f6c <cprintf>
f0119d7d:	83 c4 10             	add    $0x10,%esp

		//3 MB Hole
		freeFrames = (int)sys_calculate_free_frames() ;
f0119d80:	e8 84 39 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119d85:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119d88:	e8 b4 a7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119d8d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[6]);
f0119d90:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0119d93:	83 ec 0c             	sub    $0xc,%esp
f0119d96:	50                   	push   %eax
f0119d97:	e8 35 ea fe ff       	call   f01087d1 <kfree>
f0119d9c:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119d9f:	e8 9d a7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119da4:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119da7:	74 17                	je     f0119dc0 <test_kmalloc_firstfit2+0x605>
f0119da9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119db0:	83 ec 0c             	sub    $0xc,%esp
f0119db3:	68 c0 be 12 f0       	push   $0xf012bec0
f0119db8:	e8 af 71 fe ff       	call   f0100f6c <cprintf>
f0119dbd:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 768) { correct = 0; cprintf("Wrong free: \n"); }
f0119dc0:	e8 44 39 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119dc5:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119dc8:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f0119dcd:	77 17                	ja     f0119de6 <test_kmalloc_firstfit2+0x62b>
f0119dcf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119dd6:	83 ec 0c             	sub    $0xc,%esp
f0119dd9:	68 3d c1 12 f0       	push   $0xf012c13d
f0119dde:	e8 89 71 fe ff       	call   f0100f6c <cprintf>
f0119de3:	83 c4 10             	add    $0x10,%esp

		//2 KB Hole in Dynamic Allocator Area [Resulting Hole = 1 KB + 2 KB = 3 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0119de6:	e8 1e 39 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119deb:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119dee:	e8 4e a7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119df3:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[3]);
f0119df6:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0119df9:	83 ec 0c             	sub    $0xc,%esp
f0119dfc:	50                   	push   %eax
f0119dfd:	e8 cf e9 fe ff       	call   f01087d1 <kfree>
f0119e02:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e05:	e8 37 a7 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119e0a:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119e0d:	74 17                	je     f0119e26 <test_kmalloc_firstfit2+0x66b>
f0119e0f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e16:	83 ec 0c             	sub    $0xc,%esp
f0119e19:	68 c0 be 12 f0       	push   $0xf012bec0
f0119e1e:	e8 49 71 fe ff       	call   f0100f6c <cprintf>
f0119e23:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f0119e26:	e8 de 38 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119e2b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119e2e:	74 17                	je     f0119e47 <test_kmalloc_firstfit2+0x68c>
f0119e30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e37:	83 ec 0c             	sub    $0xc,%esp
f0119e3a:	68 cc c1 12 f0       	push   $0xf012c1cc
f0119e3f:	e8 28 71 fe ff       	call   f0100f6c <cprintf>
f0119e44:	83 c4 10             	add    $0x10,%esp

		//2 MB Hole [Resulting Hole = 2 MB + 2 MB = 4 MB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0119e47:	e8 bd 38 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119e4c:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119e4f:	e8 ed a6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119e54:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[1]);
f0119e57:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0119e5a:	83 ec 0c             	sub    $0xc,%esp
f0119e5d:	50                   	push   %eax
f0119e5e:	e8 6e e9 fe ff       	call   f01087d1 <kfree>
f0119e63:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong free: \n"); }
f0119e66:	e8 9e 38 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119e6b:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119e6e:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f0119e73:	77 17                	ja     f0119e8c <test_kmalloc_firstfit2+0x6d1>
f0119e75:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e7c:	83 ec 0c             	sub    $0xc,%esp
f0119e7f:	68 3d c1 12 f0       	push   $0xf012c13d
f0119e84:	e8 e3 70 fe ff       	call   f0100f6c <cprintf>
f0119e89:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119e8c:	e8 b0 a6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119e91:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119e94:	74 17                	je     f0119ead <test_kmalloc_firstfit2+0x6f2>
f0119e96:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119e9d:	83 ec 0c             	sub    $0xc,%esp
f0119ea0:	68 c0 be 12 f0       	push   $0xf012bec0
f0119ea5:	e8 c2 70 fe ff       	call   f0100f6c <cprintf>
f0119eaa:	83 c4 10             	add    $0x10,%esp

		//5 MB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119ead:	e8 57 38 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119eb2:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119eb5:	e8 87 a6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119eba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[8] = kmalloc(5*Mega-kilo);
f0119ebd:	83 ec 0c             	sub    $0xc,%esp
f0119ec0:	68 00 fc 4f 00       	push   $0x4ffc00
f0119ec5:	e8 ed e8 fe ff       	call   f01087b7 <kmalloc>
f0119eca:	83 c4 10             	add    $0x10,%esp
f0119ecd:	89 45 b8             	mov    %eax,-0x48(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 9*Mega + 16*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119ed0:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0119ed3:	3d 00 50 90 f8       	cmp    $0xf8905000,%eax
f0119ed8:	74 17                	je     f0119ef1 <test_kmalloc_firstfit2+0x736>
f0119eda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119ee1:	83 ec 0c             	sub    $0xc,%esp
f0119ee4:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119ee9:	e8 7e 70 fe ff       	call   f0100f6c <cprintf>
f0119eee:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ef1:	e8 4b a6 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119ef6:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119ef9:	74 17                	je     f0119f12 <test_kmalloc_firstfit2+0x757>
f0119efb:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f02:	83 ec 0c             	sub    $0xc,%esp
f0119f05:	68 c0 be 12 f0       	push   $0xf012bec0
f0119f0a:	e8 5d 70 fe ff       	call   f0100f6c <cprintf>
f0119f0f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <   5*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f0119f12:	e8 f2 37 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119f17:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119f1a:	29 c2                	sub    %eax,%edx
f0119f1c:	89 d0                	mov    %edx,%eax
f0119f1e:	3d ff 04 00 00       	cmp    $0x4ff,%eax
f0119f23:	77 17                	ja     f0119f3c <test_kmalloc_firstfit2+0x781>
f0119f25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f2c:	83 ec 0c             	sub    $0xc,%esp
f0119f2f:	68 29 c1 12 f0       	push   $0xf012c129
f0119f34:	e8 33 70 fe ff       	call   f0100f6c <cprintf>
f0119f39:	83 c4 10             	add    $0x10,%esp

		//8 KB Hole [Resulting Hole = 2 MB + 2 MB + 8 KB + 3 MB = 7 MB + 8 KB]
		freeFrames = (int)sys_calculate_free_frames() ;
f0119f3c:	e8 c8 37 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119f41:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119f44:	e8 f8 a5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119f49:	89 45 e8             	mov    %eax,-0x18(%ebp)
		kfree(ptr_allocations[5]);
f0119f4c:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0119f4f:	83 ec 0c             	sub    $0xc,%esp
f0119f52:	50                   	push   %eax
f0119f53:	e8 79 e8 fe ff       	call   f01087d1 <kfree>
f0119f58:	83 c4 10             	add    $0x10,%esp
		if(((int)pf_calculate_free_frames() - freeDiskFrames) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119f5b:	e8 e1 a5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119f60:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119f63:	74 17                	je     f0119f7c <test_kmalloc_firstfit2+0x7c1>
f0119f65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f6c:	83 ec 0c             	sub    $0xc,%esp
f0119f6f:	68 c0 be 12 f0       	push   $0xf012bec0
f0119f74:	e8 f3 6f fe ff       	call   f0100f6c <cprintf>
f0119f79:	83 c4 10             	add    $0x10,%esp
		if (((int)sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong free: \n"); }
f0119f7c:	e8 88 37 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119f81:	2b 45 ec             	sub    -0x14(%ebp),%eax
f0119f84:	83 f8 01             	cmp    $0x1,%eax
f0119f87:	77 17                	ja     f0119fa0 <test_kmalloc_firstfit2+0x7e5>
f0119f89:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119f90:	83 ec 0c             	sub    $0xc,%esp
f0119f93:	68 3d c1 12 f0       	push   $0xf012c13d
f0119f98:	e8 cf 6f fe ff       	call   f0100f6c <cprintf>
f0119f9d:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f0119fa0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119fa4:	74 04                	je     f0119faa <test_kmalloc_firstfit2+0x7ef>
f0119fa6:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	correct = 1 ;
f0119faa:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#1] Should be allocated in the resulting hole inside Page Allocator Area
		//7 MB + 1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f0119fb1:	e8 53 37 ff ff       	call   f010d709 <sys_calculate_free_frames>
f0119fb6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f0119fb9:	e8 83 a5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119fbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[9] = kmalloc(7*Mega+kilo);
f0119fc1:	83 ec 0c             	sub    $0xc,%esp
f0119fc4:	68 00 04 70 00       	push   $0x700400
f0119fc9:	e8 e9 e7 fe ff       	call   f01087b7 <kmalloc>
f0119fce:	83 c4 10             	add    $0x10,%esp
f0119fd1:	89 45 bc             	mov    %eax,-0x44(%ebp)
		if ((uint32) ptr_allocations[9] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f0119fd4:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0119fd7:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f0119fdc:	74 17                	je     f0119ff5 <test_kmalloc_firstfit2+0x83a>
f0119fde:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0119fe5:	83 ec 0c             	sub    $0xc,%esp
f0119fe8:	68 f8 c0 12 f0       	push   $0xf012c0f8
f0119fed:	e8 7a 6f fe ff       	call   f0100f6c <cprintf>
f0119ff2:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f0119ff5:	e8 47 a5 fe ff       	call   f0104541 <pf_calculate_free_frames>
f0119ffa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119ffd:	74 17                	je     f011a016 <test_kmalloc_firstfit2+0x85b>
f0119fff:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a006:	83 ec 0c             	sub    $0xc,%esp
f011a009:	68 c0 be 12 f0       	push   $0xf012bec0
f011a00e:	e8 59 6f fe ff       	call   f0100f6c <cprintf>
f011a013:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) <  (7*Mega+4*kilo)/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a016:	e8 ee 36 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a01b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011a01e:	29 c2                	sub    %eax,%edx
f011a020:	89 d0                	mov    %edx,%eax
f011a022:	3d 00 07 00 00       	cmp    $0x700,%eax
f011a027:	77 17                	ja     f011a040 <test_kmalloc_firstfit2+0x885>
f011a029:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a030:	83 ec 0c             	sub    $0xc,%esp
f011a033:	68 29 c1 12 f0       	push   $0xf012c129
f011a038:	e8 2f 6f fe ff       	call   f0100f6c <cprintf>
f011a03d:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#2] Should be allocated in the remaining area of resulting hole inside Page Allocator Area
		//3 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a040:	e8 c4 36 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a045:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a048:	e8 f4 a4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a04d:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[10] = kmalloc(3*kilo);
f011a050:	83 ec 0c             	sub    $0xc,%esp
f011a053:	68 00 0c 00 00       	push   $0xc00
f011a058:	e8 5a e7 fe ff       	call   f01087b7 <kmalloc>
f011a05d:	83 c4 10             	add    $0x10,%esp
f011a060:	89 45 c0             	mov    %eax,-0x40(%ebp)
		if ((uint32)ptr_allocations[10] != (ACTUAL_START + 7*Mega + 4*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011a063:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a066:	3d 00 20 70 f8       	cmp    $0xf8702000,%eax
f011a06b:	74 17                	je     f011a084 <test_kmalloc_firstfit2+0x8c9>
f011a06d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a074:	83 ec 0c             	sub    $0xc,%esp
f011a077:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011a07c:	e8 eb 6e fe ff       	call   f0100f6c <cprintf>
f011a081:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a084:	e8 b8 a4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a089:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a08c:	74 17                	je     f011a0a5 <test_kmalloc_firstfit2+0x8ea>
f011a08e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a095:	83 ec 0c             	sub    $0xc,%esp
f011a098:	68 c0 be 12 f0       	push   $0xf012bec0
f011a09d:	e8 ca 6e fe ff       	call   f0100f6c <cprintf>
f011a0a2:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) < 1) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a0a5:	e8 5f 36 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a0aa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011a0ad:	75 17                	jne    f011a0c6 <test_kmalloc_firstfit2+0x90b>
f011a0af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a0b6:	83 ec 0c             	sub    $0xc,%esp
f011a0b9:	68 29 c1 12 f0       	push   $0xf012c129
f011a0be:	e8 a9 6e fe ff       	call   f0100f6c <cprintf>
f011a0c3:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=35 ;
f011a0c6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a0ca:	74 04                	je     f011a0d0 <test_kmalloc_firstfit2+0x915>
f011a0cc:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011a0d0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	{
		//[FIRST FIT Case#3] Should be allocated in the resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a0d7:	e8 2d 36 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a0dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a0df:	e8 5d a4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a0e4:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011a0e7:	83 ec 0c             	sub    $0xc,%esp
f011a0ea:	68 00 04 00 00       	push   $0x400
f011a0ef:	e8 c3 e6 fe ff       	call   f01087b7 <kmalloc>
f011a0f4:	83 c4 10             	add    $0x10,%esp
f011a0f7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011a0fa:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011a0fd:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011a100:	39 c2                	cmp    %eax,%edx
f011a102:	72 10                	jb     f011a114 <test_kmalloc_firstfit2+0x959>
f011a104:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011a107:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a10a:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a110:	39 d0                	cmp    %edx,%eax
f011a112:	76 17                	jbe    f011a12b <test_kmalloc_firstfit2+0x970>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011a114:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a11b:	83 ec 0c             	sub    $0xc,%esp
f011a11e:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011a123:	e8 44 6e fe ff       	call   f0100f6c <cprintf>
f011a128:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a12b:	e8 11 a4 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a130:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a133:	74 17                	je     f011a14c <test_kmalloc_firstfit2+0x991>
f011a135:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a13c:	83 ec 0c             	sub    $0xc,%esp
f011a13f:	68 c0 be 12 f0       	push   $0xf012bec0
f011a144:	e8 23 6e fe ff       	call   f0100f6c <cprintf>
f011a149:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a14c:	e8 b8 35 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a151:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011a154:	74 17                	je     f011a16d <test_kmalloc_firstfit2+0x9b2>
f011a156:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a15d:	83 ec 0c             	sub    $0xc,%esp
f011a160:	68 29 c1 12 f0       	push   $0xf012c129
f011a165:	e8 02 6e fe ff       	call   f0100f6c <cprintf>
f011a16a:	83 c4 10             	add    $0x10,%esp

		//[FIRST FIT Case#4] Should be allocated in the remaining of resulting hole inside DYNAMIC Allocator Area
		//1 KB
		freeFrames = (int)sys_calculate_free_frames() ;
f011a16d:	e8 97 35 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a172:	89 45 ec             	mov    %eax,-0x14(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames() ;
f011a175:	e8 c7 a3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a17a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		ptr_allocations[12] = kmalloc(1*kilo);
f011a17d:	83 ec 0c             	sub    $0xc,%esp
f011a180:	68 00 04 00 00       	push   $0x400
f011a185:	e8 2d e6 fe ff       	call   f01087b7 <kmalloc>
f011a18a:	83 c4 10             	add    $0x10,%esp
f011a18d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011a190:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a193:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a196:	81 c2 00 04 00 00    	add    $0x400,%edx
f011a19c:	39 d0                	cmp    %edx,%eax
f011a19e:	72 10                	jb     f011a1b0 <test_kmalloc_firstfit2+0x9f5>
f011a1a0:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011a1a3:	8b 55 a0             	mov    -0x60(%ebp),%edx
f011a1a6:	81 c2 00 08 00 00    	add    $0x800,%edx
f011a1ac:	39 d0                	cmp    %edx,%eax
f011a1ae:	76 17                	jbe    f011a1c7 <test_kmalloc_firstfit2+0xa0c>
		{ correct = 0; cprintf("Wrong start address for the allocated space... \n"); }
f011a1b0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1b7:	83 ec 0c             	sub    $0xc,%esp
f011a1ba:	68 f8 c0 12 f0       	push   $0xf012c0f8
f011a1bf:	e8 a8 6d fe ff       	call   f0100f6c <cprintf>
f011a1c4:	83 c4 10             	add    $0x10,%esp
		if((freeDiskFrames - (int)pf_calculate_free_frames()) !=  0)  { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a1c7:	e8 75 a3 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a1cc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011a1cf:	74 17                	je     f011a1e8 <test_kmalloc_firstfit2+0xa2d>
f011a1d1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1d8:	83 ec 0c             	sub    $0xc,%esp
f011a1db:	68 c0 be 12 f0       	push   $0xf012bec0
f011a1e0:	e8 87 6d fe ff       	call   f0100f6c <cprintf>
f011a1e5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: \n"); }
f011a1e8:	e8 1c 35 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a1ed:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011a1f0:	74 17                	je     f011a209 <test_kmalloc_firstfit2+0xa4e>
f011a1f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a1f9:	83 ec 0c             	sub    $0xc,%esp
f011a1fc:	68 29 c1 12 f0       	push   $0xf012c129
f011a201:	e8 66 6d fe ff       	call   f0100f6c <cprintf>
f011a206:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=35 ;
f011a209:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a20d:	74 04                	je     f011a213 <test_kmalloc_firstfit2+0xa58>
f011a20f:	83 45 f4 23          	addl   $0x23,-0xc(%ebp)

	correct = 1 ;
f011a213:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	//	b) Attempt to allocate large segment with no suitable fragment to fit on
	{
		//Large Allocation
		ptr_allocations[13] = kmalloc((KERNEL_HEAP_MAX - ACTUAL_START - 14*Mega));
f011a21a:	83 ec 0c             	sub    $0xc,%esp
f011a21d:	68 00 e0 1f 07       	push   $0x71fe000
f011a222:	e8 90 e5 fe ff       	call   f01087b7 <kmalloc>
f011a227:	83 c4 10             	add    $0x10,%esp
f011a22a:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if (ptr_allocations[13] != NULL) { correct = 0; cprintf("Kmalloc: Attempt to allocate large segment with no suitable fragment to fit on, should return NULL\n"); }
f011a22d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011a230:	85 c0                	test   %eax,%eax
f011a232:	74 17                	je     f011a24b <test_kmalloc_firstfit2+0xa90>
f011a234:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011a23b:	83 ec 0c             	sub    $0xc,%esp
f011a23e:	68 28 c2 12 f0       	push   $0xf012c228
f011a243:	e8 24 6d fe ff       	call   f0100f6c <cprintf>
f011a248:	83 c4 10             	add    $0x10,%esp

	}
	if (correct)	eval+=10 ;
f011a24b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a24f:	74 04                	je     f011a255 <test_kmalloc_firstfit2+0xa9a>
f011a251:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	cprintf("test FIRST FIT allocation (2) completed. Eval = %d%\n", eval);
f011a255:	83 ec 08             	sub    $0x8,%esp
f011a258:	ff 75 f4             	pushl  -0xc(%ebp)
f011a25b:	68 8c c2 12 f0       	push   $0xf012c28c
f011a260:	e8 07 6d fe ff       	call   f0100f6c <cprintf>
f011a265:	83 c4 10             	add    $0x10,%esp

	return 1;
f011a268:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011a26d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a270:	5b                   	pop    %ebx
f011a271:	5f                   	pop    %edi
f011a272:	5d                   	pop    %ebp
f011a273:	c3                   	ret    

f011a274 <test_kfree_bestfirstfit>:


int test_kfree_bestfirstfit()
{
f011a274:	55                   	push   %ebp
f011a275:	89 e5                	mov    %esp,%ebp
f011a277:	57                   	push   %edi
f011a278:	53                   	push   %ebx
f011a279:	81 ec 40 01 00 00    	sub    $0x140,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011a27f:	83 ec 0c             	sub    $0xc,%esp
f011a282:	68 00 be 12 f0       	push   $0xf012be00
f011a287:	e8 e0 6c fe ff       	call   f0100f6c <cprintf>
f011a28c:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011a28f:	83 ec 0c             	sub    $0xc,%esp
f011a292:	68 30 be 12 f0       	push   $0xf012be30
f011a297:	e8 d0 6c fe ff       	call   f0100f6c <cprintf>
f011a29c:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011a29f:	83 ec 0c             	sub    $0xc,%esp
f011a2a2:	68 00 be 12 f0       	push   $0xf012be00
f011a2a7:	e8 c0 6c fe ff       	call   f0100f6c <cprintf>
f011a2ac:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011a2af:	c6 45 df 80          	movb   $0x80,-0x21(%ebp)
	char maxByte = 0x7F;
f011a2b3:	c6 45 de 7f          	movb   $0x7f,-0x22(%ebp)
	short minShort = 1<<15 ;
f011a2b7:	66 c7 45 dc 00 80    	movw   $0x8000,-0x24(%ebp)
	short maxShort = 0x7FFF;
f011a2bd:	66 c7 45 da ff 7f    	movw   $0x7fff,-0x26(%ebp)
	int minInt = 1<<31 ;
f011a2c3:	c7 45 d4 00 00 00 80 	movl   $0x80000000,-0x2c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011a2ca:	c7 45 d0 ff ff ff 7f 	movl   $0x7fffffff,-0x30(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011a2d1:	e8 33 34 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a2d6:	89 45 cc             	mov    %eax,-0x34(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011a2d9:	8d 95 68 ff ff ff    	lea    -0x98(%ebp),%edx
f011a2df:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a2e4:	b8 00 00 00 00       	mov    $0x0,%eax
f011a2e9:	89 d7                	mov    %edx,%edi
f011a2eb:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011a2ed:	8d 95 18 ff ff ff    	lea    -0xe8(%ebp),%edx
f011a2f3:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a2f8:	b8 00 00 00 00       	mov    $0x0,%eax
f011a2fd:	89 d7                	mov    %edx,%edi
f011a2ff:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011a301:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011a308:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	correct = 1;
f011a30f:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011a316:	8d 95 c8 fe ff ff    	lea    -0x138(%ebp),%edx
f011a31c:	b9 14 00 00 00       	mov    $0x14,%ecx
f011a321:	b8 00 00 00 00       	mov    $0x0,%eax
f011a326:	89 d7                	mov    %edx,%edi
f011a328:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//[BLOCK ALLOCATOR]
		{
			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a32a:	e8 da 33 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a32f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a332:	e8 0a a2 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a337:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[2] = kmalloc(2*kilo);
f011a33a:	83 ec 0c             	sub    $0xc,%esp
f011a33d:	68 00 08 00 00       	push   $0x800
f011a342:	e8 70 e4 fe ff       	call   f01087b7 <kmalloc>
f011a347:	83 c4 10             	add    $0x10,%esp
f011a34a:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011a350:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a356:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a35b:	76 28                	jbe    f011a385 <test_kfree_bestfirstfit+0x111>
f011a35d:	8b 9d d0 fe ff ff    	mov    -0x130(%ebp),%ebx
f011a363:	83 ec 0c             	sub    $0xc,%esp
f011a366:	6a 00                	push   $0x0
f011a368:	e8 40 e4 fe ff       	call   f01087ad <sbrk>
f011a36d:	83 c4 10             	add    $0x10,%esp
f011a370:	39 c3                	cmp    %eax,%ebx
f011a372:	73 11                	jae    f011a385 <test_kfree_bestfirstfit+0x111>
f011a374:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a37a:	89 c2                	mov    %eax,%edx
f011a37c:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011a381:	39 c2                	cmp    %eax,%edx
f011a383:	72 17                	jb     f011a39c <test_kfree_bestfirstfit+0x128>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a385:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a38c:	83 ec 0c             	sub    $0xc,%esp
f011a38f:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011a394:	e8 d3 6b fe ff       	call   f0100f6c <cprintf>
f011a399:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a39c:	e8 a0 a1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a3a1:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a3a4:	74 17                	je     f011a3bd <test_kfree_bestfirstfit+0x149>
f011a3a6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a3ad:	83 ec 0c             	sub    $0xc,%esp
f011a3b0:	68 c0 be 12 f0       	push   $0xf012bec0
f011a3b5:	e8 b2 6b fe ff       	call   f0100f6c <cprintf>
f011a3ba:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
f011a3bd:	c7 85 70 ff ff ff ff 	movl   $0x7ff,-0x90(%ebp)
f011a3c4:	07 00 00 
			ptr = (char*)ptr_allocations[2];
f011a3c7:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a3cd:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[2]; ++i)
f011a3d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a3d7:	eb 0e                	jmp    f011a3e7 <test_kfree_bestfirstfit+0x173>
			{
				ptr[i] = 2 ;
f011a3d9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a3dc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a3df:	01 d0                	add    %edx,%eax
f011a3e1:	c6 00 02             	movb   $0x2,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[2] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[2];
			for (i = 0; i < lastIndices[2]; ++i)
f011a3e4:	ff 45 f4             	incl   -0xc(%ebp)
f011a3e7:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011a3ed:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a3f0:	7f e7                	jg     f011a3d9 <test_kfree_bestfirstfit+0x165>
			{
				ptr[i] = 2 ;
			}

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011a3f2:	e8 12 33 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a3f7:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a3fa:	e8 42 a1 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a3ff:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011a402:	83 ec 0c             	sub    $0xc,%esp
f011a405:	68 00 08 00 00       	push   $0x800
f011a40a:	e8 a8 e3 fe ff       	call   f01087b7 <kmalloc>
f011a40f:	83 c4 10             	add    $0x10,%esp
f011a412:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011a418:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a41e:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011a423:	76 28                	jbe    f011a44d <test_kfree_bestfirstfit+0x1d9>
f011a425:	8b 9d d4 fe ff ff    	mov    -0x12c(%ebp),%ebx
f011a42b:	83 ec 0c             	sub    $0xc,%esp
f011a42e:	6a 00                	push   $0x0
f011a430:	e8 78 e3 fe ff       	call   f01087ad <sbrk>
f011a435:	83 c4 10             	add    $0x10,%esp
f011a438:	39 c3                	cmp    %eax,%ebx
f011a43a:	73 11                	jae    f011a44d <test_kfree_bestfirstfit+0x1d9>
f011a43c:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a442:	89 c2                	mov    %eax,%edx
f011a444:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011a449:	39 c2                	cmp    %eax,%edx
f011a44b:	72 17                	jb     f011a464 <test_kfree_bestfirstfit+0x1f0>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011a44d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a454:	83 ec 0c             	sub    $0xc,%esp
f011a457:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011a45c:	e8 0b 6b fe ff       	call   f0100f6c <cprintf>
f011a461:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a464:	e8 d8 a0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a469:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a46c:	74 17                	je     f011a485 <test_kfree_bestfirstfit+0x211>
f011a46e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a475:	83 ec 0c             	sub    $0xc,%esp
f011a478:	68 c0 be 12 f0       	push   $0xf012bec0
f011a47d:	e8 ea 6a fe ff       	call   f0100f6c <cprintf>
f011a482:	83 c4 10             	add    $0x10,%esp
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
f011a485:	c7 85 74 ff ff ff ff 	movl   $0x7ff,-0x8c(%ebp)
f011a48c:	07 00 00 
			ptr = (char*)ptr_allocations[3];
f011a48f:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011a495:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[3]; ++i)
f011a498:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a49f:	eb 0e                	jmp    f011a4af <test_kfree_bestfirstfit+0x23b>
			{
				ptr[i] = 3 ;
f011a4a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a4a4:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a4a7:	01 d0                	add    %edx,%eax
f011a4a9:	c6 00 03             	movb   $0x3,(%eax)
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			//		if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[3] = (2*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[3];
			for (i = 0; i < lastIndices[3]; ++i)
f011a4ac:	ff 45 f4             	incl   -0xc(%ebp)
f011a4af:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011a4b5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a4b8:	7f e7                	jg     f011a4a1 <test_kfree_bestfirstfit+0x22d>
		}

		//[PAGE ALLOCATOR]
		{
			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011a4ba:	e8 4a 32 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a4bf:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a4c2:	e8 7a a0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a4c7:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011a4ca:	83 ec 0c             	sub    $0xc,%esp
f011a4cd:	68 00 fc 1f 00       	push   $0x1ffc00
f011a4d2:	e8 e0 e2 fe ff       	call   f01087b7 <kmalloc>
f011a4d7:	83 c4 10             	add    $0x10,%esp
f011a4da:	89 85 c8 fe ff ff    	mov    %eax,-0x138(%ebp)
			if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a4e0:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a4e6:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011a4eb:	74 17                	je     f011a504 <test_kfree_bestfirstfit+0x290>
f011a4ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a4f4:	83 ec 0c             	sub    $0xc,%esp
f011a4f7:	68 70 bf 12 f0       	push   $0xf012bf70
f011a4fc:	e8 6b 6a fe ff       	call   f0100f6c <cprintf>
f011a501:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a504:	e8 38 a0 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a509:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a50c:	74 17                	je     f011a525 <test_kfree_bestfirstfit+0x2b1>
f011a50e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a515:	83 ec 0c             	sub    $0xc,%esp
f011a518:	68 c0 be 12 f0       	push   $0xf012bec0
f011a51d:	e8 4a 6a fe ff       	call   f0100f6c <cprintf>
f011a522:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a525:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a528:	e8 dc 31 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a52d:	29 c3                	sub    %eax,%ebx
f011a52f:	89 d8                	mov    %ebx,%eax
f011a531:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a536:	77 17                	ja     f011a54f <test_kfree_bestfirstfit+0x2db>
f011a538:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a53f:	83 ec 0c             	sub    $0xc,%esp
f011a542:	68 2c bf 12 f0       	push   $0xf012bf2c
f011a547:	e8 20 6a fe ff       	call   f0100f6c <cprintf>
f011a54c:	83 c4 10             	add    $0x10,%esp
			lastIndices[0] = (2*Mega-kilo)/sizeof(char) - 1;
f011a54f:	c7 85 68 ff ff ff ff 	movl   $0x1ffbff,-0x98(%ebp)
f011a556:	fb 1f 00 

			//2 MB
			freeFrames = sys_calculate_free_frames() ;
f011a559:	e8 ab 31 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a55e:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a561:	e8 db 9f fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a566:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011a569:	83 ec 0c             	sub    $0xc,%esp
f011a56c:	68 00 fc 1f 00       	push   $0x1ffc00
f011a571:	e8 41 e2 fe ff       	call   f01087b7 <kmalloc>
f011a576:	83 c4 10             	add    $0x10,%esp
f011a579:	89 85 cc fe ff ff    	mov    %eax,-0x134(%ebp)
			if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a57f:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a585:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011a58a:	74 17                	je     f011a5a3 <test_kfree_bestfirstfit+0x32f>
f011a58c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a593:	83 ec 0c             	sub    $0xc,%esp
f011a596:	68 70 bf 12 f0       	push   $0xf012bf70
f011a59b:	e8 cc 69 fe ff       	call   f0100f6c <cprintf>
f011a5a0:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a5a3:	e8 99 9f fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a5a8:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a5ab:	74 17                	je     f011a5c4 <test_kfree_bestfirstfit+0x350>
f011a5ad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5b4:	83 ec 0c             	sub    $0xc,%esp
f011a5b7:	68 c0 be 12 f0       	push   $0xf012bec0
f011a5bc:	e8 ab 69 fe ff       	call   f0100f6c <cprintf>
f011a5c1:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a5c4:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a5c7:	e8 3d 31 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a5cc:	29 c3                	sub    %eax,%ebx
f011a5ce:	89 d8                	mov    %ebx,%eax
f011a5d0:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a5d5:	77 17                	ja     f011a5ee <test_kfree_bestfirstfit+0x37a>
f011a5d7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a5de:	83 ec 0c             	sub    $0xc,%esp
f011a5e1:	68 2c bf 12 f0       	push   $0xf012bf2c
f011a5e6:	e8 81 69 fe ff       	call   f0100f6c <cprintf>
f011a5eb:	83 c4 10             	add    $0x10,%esp
			lastIndices[1] = (2*Mega-kilo)/sizeof(char) - 1;
f011a5ee:	c7 85 6c ff ff ff ff 	movl   $0x1ffbff,-0x94(%ebp)
f011a5f5:	fb 1f 00 


			//7 KB
			freeFrames = sys_calculate_free_frames() ;
f011a5f8:	e8 0c 31 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a5fd:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a600:	e8 3c 9f fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a605:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[4] = kmalloc(7*kilo);
f011a608:	83 ec 0c             	sub    $0xc,%esp
f011a60b:	68 00 1c 00 00       	push   $0x1c00
f011a610:	e8 a2 e1 fe ff       	call   f01087b7 <kmalloc>
f011a615:	83 c4 10             	add    $0x10,%esp
f011a618:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%ebp)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a61e:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a624:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011a629:	74 17                	je     f011a642 <test_kfree_bestfirstfit+0x3ce>
f011a62b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a632:	83 ec 0c             	sub    $0xc,%esp
f011a635:	68 70 bf 12 f0       	push   $0xf012bf70
f011a63a:	e8 2d 69 fe ff       	call   f0100f6c <cprintf>
f011a63f:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a642:	e8 fa 9e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a647:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a64a:	74 17                	je     f011a663 <test_kfree_bestfirstfit+0x3ef>
f011a64c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a653:	83 ec 0c             	sub    $0xc,%esp
f011a656:	68 c0 be 12 f0       	push   $0xf012bec0
f011a65b:	e8 0c 69 fe ff       	call   f0100f6c <cprintf>
f011a660:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a663:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a666:	e8 9e 30 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a66b:	29 c3                	sub    %eax,%ebx
f011a66d:	89 d8                	mov    %ebx,%eax
f011a66f:	83 f8 01             	cmp    $0x1,%eax
f011a672:	77 17                	ja     f011a68b <test_kfree_bestfirstfit+0x417>
f011a674:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a67b:	83 ec 0c             	sub    $0xc,%esp
f011a67e:	68 2c bf 12 f0       	push   $0xf012bf2c
f011a683:	e8 e4 68 fe ff       	call   f0100f6c <cprintf>
f011a688:	83 c4 10             	add    $0x10,%esp
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
f011a68b:	c7 85 78 ff ff ff ff 	movl   $0x1bff,-0x88(%ebp)
f011a692:	1b 00 00 
			ptr = (char*)ptr_allocations[4];
f011a695:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011a69b:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[4]; ++i)
f011a69e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a6a5:	eb 0e                	jmp    f011a6b5 <test_kfree_bestfirstfit+0x441>
			{
				ptr[i] = 4 ;
f011a6a7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a6aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a6ad:	01 d0                	add    %edx,%eax
f011a6af:	c6 00 04             	movb   $0x4,(%eax)
			if ((uint32) ptr_allocations[4] != (ACTUAL_START + 4*Mega /* + 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[4] = (7*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[4];
			for (i = 0; i < lastIndices[4]; ++i)
f011a6b2:	ff 45 f4             	incl   -0xc(%ebp)
f011a6b5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011a6bb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a6be:	7f e7                	jg     f011a6a7 <test_kfree_bestfirstfit+0x433>
			{
				ptr[i] = 4 ;
			}

			//3 MB
			freeFrames = sys_calculate_free_frames() ;
f011a6c0:	e8 44 30 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a6c5:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a6c8:	e8 74 9e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a6cd:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[5] = kmalloc(3*Mega-kilo);
f011a6d0:	83 ec 0c             	sub    $0xc,%esp
f011a6d3:	68 00 fc 2f 00       	push   $0x2ffc00
f011a6d8:	e8 da e0 fe ff       	call   f01087b7 <kmalloc>
f011a6dd:	83 c4 10             	add    $0x10,%esp
f011a6e0:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a6e6:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a6ec:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011a6f1:	74 17                	je     f011a70a <test_kfree_bestfirstfit+0x496>
f011a6f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a6fa:	83 ec 0c             	sub    $0xc,%esp
f011a6fd:	68 70 bf 12 f0       	push   $0xf012bf70
f011a702:	e8 65 68 fe ff       	call   f0100f6c <cprintf>
f011a707:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a70a:	e8 32 9e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a70f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a712:	74 17                	je     f011a72b <test_kfree_bestfirstfit+0x4b7>
f011a714:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a71b:	83 ec 0c             	sub    $0xc,%esp
f011a71e:	68 c0 be 12 f0       	push   $0xf012bec0
f011a723:	e8 44 68 fe ff       	call   f0100f6c <cprintf>
f011a728:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a72b:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a72e:	e8 d6 2f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a733:	29 c3                	sub    %eax,%ebx
f011a735:	89 d8                	mov    %ebx,%eax
f011a737:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011a73c:	77 17                	ja     f011a755 <test_kfree_bestfirstfit+0x4e1>
f011a73e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a745:	83 ec 0c             	sub    $0xc,%esp
f011a748:	68 2c bf 12 f0       	push   $0xf012bf2c
f011a74d:	e8 1a 68 fe ff       	call   f0100f6c <cprintf>
f011a752:	83 c4 10             	add    $0x10,%esp
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
f011a755:	c7 85 7c ff ff ff ff 	movl   $0x2ffbff,-0x84(%ebp)
f011a75c:	fb 2f 00 
			ptr = (char*)ptr_allocations[5];
f011a75f:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011a765:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[5]; ++i)
f011a768:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a76f:	eb 0e                	jmp    f011a77f <test_kfree_bestfirstfit+0x50b>
			{
				ptr[i] = 5 ;
f011a771:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a774:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a777:	01 d0                	add    %edx,%eax
f011a779:	c6 00 05             	movb   $0x5,(%eax)
			if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[5] = (3*Mega-kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[5];
			for (i = 0; i < lastIndices[5]; ++i)
f011a77c:	ff 45 f4             	incl   -0xc(%ebp)
f011a77f:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011a785:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a788:	7f e7                	jg     f011a771 <test_kfree_bestfirstfit+0x4fd>
			{
				ptr[i] = 5 ;
			}

			//6 MB
			freeFrames = sys_calculate_free_frames() ;
f011a78a:	e8 7a 2f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a78f:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a792:	e8 aa 9d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a797:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[6] = kmalloc(6*Mega-kilo);
f011a79a:	83 ec 0c             	sub    $0xc,%esp
f011a79d:	68 00 fc 5f 00       	push   $0x5ffc00
f011a7a2:	e8 10 e0 fe ff       	call   f01087b7 <kmalloc>
f011a7a7:	83 c4 10             	add    $0x10,%esp
f011a7aa:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%ebp)
			if ((uint32) ptr_allocations[6] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a7b0:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011a7b6:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011a7bb:	74 17                	je     f011a7d4 <test_kfree_bestfirstfit+0x560>
f011a7bd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7c4:	83 ec 0c             	sub    $0xc,%esp
f011a7c7:	68 70 bf 12 f0       	push   $0xf012bf70
f011a7cc:	e8 9b 67 fe ff       	call   f0100f6c <cprintf>
f011a7d1:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a7d4:	e8 68 9d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a7d9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a7dc:	74 17                	je     f011a7f5 <test_kfree_bestfirstfit+0x581>
f011a7de:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a7e5:	83 ec 0c             	sub    $0xc,%esp
f011a7e8:	68 c0 be 12 f0       	push   $0xf012bec0
f011a7ed:	e8 7a 67 fe ff       	call   f0100f6c <cprintf>
f011a7f2:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a7f5:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a7f8:	e8 0c 2f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a7fd:	29 c3                	sub    %eax,%ebx
f011a7ff:	89 d8                	mov    %ebx,%eax
f011a801:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011a806:	77 17                	ja     f011a81f <test_kfree_bestfirstfit+0x5ab>
f011a808:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a80f:	83 ec 0c             	sub    $0xc,%esp
f011a812:	68 2c bf 12 f0       	push   $0xf012bf2c
f011a817:	e8 50 67 fe ff       	call   f0100f6c <cprintf>
f011a81c:	83 c4 10             	add    $0x10,%esp
			lastIndices[6] = (6*Mega-kilo)/sizeof(char) - 1;
f011a81f:	c7 45 80 ff fb 5f 00 	movl   $0x5ffbff,-0x80(%ebp)

			//14 KB
			freeFrames = sys_calculate_free_frames() ;
f011a826:	e8 de 2e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a82b:	89 45 c8             	mov    %eax,-0x38(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011a82e:	e8 0e 9d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a833:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			ptr_allocations[7] = kmalloc(14*kilo);
f011a836:	83 ec 0c             	sub    $0xc,%esp
f011a839:	68 00 38 00 00       	push   $0x3800
f011a83e:	e8 74 df fe ff       	call   f01087b7 <kmalloc>
f011a843:	83 c4 10             	add    $0x10,%esp
f011a846:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%ebp)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011a84c:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a852:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011a857:	74 17                	je     f011a870 <test_kfree_bestfirstfit+0x5fc>
f011a859:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a860:	83 ec 0c             	sub    $0xc,%esp
f011a863:	68 70 bf 12 f0       	push   $0xf012bf70
f011a868:	e8 ff 66 fe ff       	call   f0100f6c <cprintf>
f011a86d:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a870:	e8 cc 9c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a875:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011a878:	74 17                	je     f011a891 <test_kfree_bestfirstfit+0x61d>
f011a87a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a881:	83 ec 0c             	sub    $0xc,%esp
f011a884:	68 c0 be 12 f0       	push   $0xf012bec0
f011a889:	e8 de 66 fe ff       	call   f0100f6c <cprintf>
f011a88e:	83 c4 10             	add    $0x10,%esp
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011a891:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011a894:	e8 70 2e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a899:	29 c3                	sub    %eax,%ebx
f011a89b:	89 d8                	mov    %ebx,%eax
f011a89d:	83 f8 03             	cmp    $0x3,%eax
f011a8a0:	77 17                	ja     f011a8b9 <test_kfree_bestfirstfit+0x645>
f011a8a2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a8a9:	83 ec 0c             	sub    $0xc,%esp
f011a8ac:	68 2c bf 12 f0       	push   $0xf012bf2c
f011a8b1:	e8 b6 66 fe ff       	call   f0100f6c <cprintf>
f011a8b6:	83 c4 10             	add    $0x10,%esp
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
f011a8b9:	c7 45 84 ff 37 00 00 	movl   $0x37ff,-0x7c(%ebp)
			ptr = (char*)ptr_allocations[7];
f011a8c0:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011a8c6:	89 45 c0             	mov    %eax,-0x40(%ebp)
			for (i = 0; i < lastIndices[7]; ++i)
f011a8c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a8d0:	eb 0e                	jmp    f011a8e0 <test_kfree_bestfirstfit+0x66c>
			{
				ptr[i] = 7 ;
f011a8d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a8d5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011a8d8:	01 d0                	add    %edx,%eax
f011a8da:	c6 00 07             	movb   $0x7,(%eax)
			if ((uint32) ptr_allocations[7] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
			if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
			lastIndices[7] = (14*kilo)/sizeof(char) - 1;
			ptr = (char*)ptr_allocations[7];
			for (i = 0; i < lastIndices[7]; ++i)
f011a8dd:	ff 45 f4             	incl   -0xc(%ebp)
f011a8e0:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011a8e3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a8e6:	7f ea                	jg     f011a8d2 <test_kfree_bestfirstfit+0x65e>
	}

	//kfree some of the allocated spaces [10%]
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011a8e8:	e8 1c 2e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a8ed:	89 45 bc             	mov    %eax,-0x44(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011a8f0:	e8 4c 9c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a8f5:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[0]);
f011a8f8:	8b 85 c8 fe ff ff    	mov    -0x138(%ebp),%eax
f011a8fe:	83 ec 0c             	sub    $0xc,%esp
f011a901:	50                   	push   %eax
f011a902:	e8 ca de fe ff       	call   f01087d1 <kfree>
f011a907:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a90a:	e8 32 9c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a90f:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a912:	74 17                	je     f011a92b <test_kfree_bestfirstfit+0x6b7>
f011a914:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a91b:	83 ec 0c             	sub    $0xc,%esp
f011a91e:	68 c0 be 12 f0       	push   $0xf012bec0
f011a923:	e8 44 66 fe ff       	call   f0100f6c <cprintf>
f011a928:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011a92b:	e8 d9 2d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a930:	89 c2                	mov    %eax,%edx
f011a932:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a935:	29 c2                	sub    %eax,%edx
f011a937:	89 d0                	mov    %edx,%eax
f011a939:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011a93e:	77 17                	ja     f011a957 <test_kfree_bestfirstfit+0x6e3>
f011a940:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a947:	83 ec 0c             	sub    $0xc,%esp
f011a94a:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011a94f:	e8 18 66 fe ff       	call   f0100f6c <cprintf>
f011a954:	83 c4 10             	add    $0x10,%esp

		//kfree 1st 2 KB
		freeFrames = sys_calculate_free_frames() ;
f011a957:	e8 ad 2d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a95c:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a95f:	e8 dd 9b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a964:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[2]);
f011a967:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011a96d:	83 ec 0c             	sub    $0xc,%esp
f011a970:	50                   	push   %eax
f011a971:	e8 5b de fe ff       	call   f01087d1 <kfree>
f011a976:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a979:	e8 c3 9b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a97e:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a981:	74 17                	je     f011a99a <test_kfree_bestfirstfit+0x726>
f011a983:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a98a:	83 ec 0c             	sub    $0xc,%esp
f011a98d:	68 c0 be 12 f0       	push   $0xf012bec0
f011a992:	e8 d5 65 fe ff       	call   f0100f6c <cprintf>
f011a997:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0 ) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011a99a:	e8 6a 2d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a99f:	89 c2                	mov    %eax,%edx
f011a9a1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011a9a4:	39 c2                	cmp    %eax,%edx
f011a9a6:	74 17                	je     f011a9bf <test_kfree_bestfirstfit+0x74b>
f011a9a8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9af:	83 ec 0c             	sub    $0xc,%esp
f011a9b2:	68 cc c1 12 f0       	push   $0xf012c1cc
f011a9b7:	e8 b0 65 fe ff       	call   f0100f6c <cprintf>
f011a9bc:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011a9bf:	e8 45 2d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011a9c4:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011a9c7:	e8 75 9b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a9cc:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[1]);
f011a9cf:	8b 85 cc fe ff ff    	mov    -0x134(%ebp),%eax
f011a9d5:	83 ec 0c             	sub    $0xc,%esp
f011a9d8:	50                   	push   %eax
f011a9d9:	e8 f3 dd fe ff       	call   f01087d1 <kfree>
f011a9de:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011a9e1:	e8 5b 9b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011a9e6:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011a9e9:	74 17                	je     f011aa02 <test_kfree_bestfirstfit+0x78e>
f011a9eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011a9f2:	83 ec 0c             	sub    $0xc,%esp
f011a9f5:	68 c0 be 12 f0       	push   $0xf012bec0
f011a9fa:	e8 6d 65 fe ff       	call   f0100f6c <cprintf>
f011a9ff:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011aa02:	e8 02 2d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011aa07:	89 c2                	mov    %eax,%edx
f011aa09:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011aa0c:	29 c2                	sub    %eax,%edx
f011aa0e:	89 d0                	mov    %edx,%eax
f011aa10:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011aa15:	77 17                	ja     f011aa2e <test_kfree_bestfirstfit+0x7ba>
f011aa17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa1e:	83 ec 0c             	sub    $0xc,%esp
f011aa21:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011aa26:	e8 41 65 fe ff       	call   f0100f6c <cprintf>
f011aa2b:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011aa2e:	e8 d6 2c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011aa33:	89 45 bc             	mov    %eax,-0x44(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aa36:	e8 06 9b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011aa3b:	89 45 b8             	mov    %eax,-0x48(%ebp)
		kfree(ptr_allocations[6]);
f011aa3e:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011aa44:	83 ec 0c             	sub    $0xc,%esp
f011aa47:	50                   	push   %eax
f011aa48:	e8 84 dd fe ff       	call   f01087d1 <kfree>
f011aa4d:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aa50:	e8 ec 9a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011aa55:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f011aa58:	74 17                	je     f011aa71 <test_kfree_bestfirstfit+0x7fd>
f011aa5a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa61:	83 ec 0c             	sub    $0xc,%esp
f011aa64:	68 c0 be 12 f0       	push   $0xf012bec0
f011aa69:	e8 fe 64 fe ff       	call   f0100f6c <cprintf>
f011aa6e:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011aa71:	e8 93 2c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011aa76:	89 c2                	mov    %eax,%edx
f011aa78:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011aa7b:	29 c2                	sub    %eax,%edx
f011aa7d:	89 d0                	mov    %edx,%eax
f011aa7f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011aa84:	77 17                	ja     f011aa9d <test_kfree_bestfirstfit+0x829>
f011aa86:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aa8d:	83 ec 0c             	sub    $0xc,%esp
f011aa90:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011aa95:	e8 d2 64 fe ff       	call   f0100f6c <cprintf>
f011aa9a:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011aa9d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aaa1:	74 04                	je     f011aaa7 <test_kfree_bestfirstfit+0x833>
f011aaa3:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011aaa7:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
f011aaae:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011aab4:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[3]; ++i)
f011aab7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aabe:	eb 1e                	jmp    f011aade <test_kfree_bestfirstfit+0x86a>
		{
			sums[3] += ptr[i] ;
f011aac0:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011aac6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011aac9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aacc:	01 c8                	add    %ecx,%eax
f011aace:	8a 00                	mov    (%eax),%al
f011aad0:	0f be c0             	movsbl %al,%eax
f011aad3:	01 d0                	add    %edx,%eax
f011aad5:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
	correct = 1 ;
	//Check memory access after kfree [10%]
	{
		//2 KB
		ptr = (char*)ptr_allocations[3];
		for (i = 0; i < lastIndices[3]; ++i)
f011aadb:	ff 45 f4             	incl   -0xc(%ebp)
f011aade:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011aae4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aae7:	7f d7                	jg     f011aac0 <test_kfree_bestfirstfit+0x84c>
		{
			sums[3] += ptr[i] ;
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011aae9:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f011aaef:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f011aaf5:	89 c1                	mov    %eax,%ecx
f011aaf7:	01 c9                	add    %ecx,%ecx
f011aaf9:	01 c8                	add    %ecx,%eax
f011aafb:	39 c2                	cmp    %eax,%edx
f011aafd:	74 17                	je     f011ab16 <test_kfree_bestfirstfit+0x8a2>
f011aaff:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab06:	83 ec 0c             	sub    $0xc,%esp
f011ab09:	68 fc c2 12 f0       	push   $0xf012c2fc
f011ab0e:	e8 59 64 fe ff       	call   f0100f6c <cprintf>
f011ab13:	83 c4 10             	add    $0x10,%esp

		//7 KB
		ptr = (char*)ptr_allocations[4];
f011ab16:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011ab1c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[4]; ++i)
f011ab1f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab26:	eb 1e                	jmp    f011ab46 <test_kfree_bestfirstfit+0x8d2>
		{
			sums[4] += ptr[i] ;
f011ab28:	8b 95 28 ff ff ff    	mov    -0xd8(%ebp),%edx
f011ab2e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab31:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab34:	01 c8                	add    %ecx,%eax
f011ab36:	8a 00                	mov    (%eax),%al
f011ab38:	0f be c0             	movsbl %al,%eax
f011ab3b:	01 d0                	add    %edx,%eax
f011ab3d:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%ebp)
		}
		if (sums[3] != 3*lastIndices[3])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//7 KB
		ptr = (char*)ptr_allocations[4];
		for (i = 0; i < lastIndices[4]; ++i)
f011ab43:	ff 45 f4             	incl   -0xc(%ebp)
f011ab46:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011ab4c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ab4f:	7f d7                	jg     f011ab28 <test_kfree_bestfirstfit+0x8b4>
		{
			sums[4] += ptr[i] ;
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011ab51:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011ab57:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f011ab5d:	c1 e2 02             	shl    $0x2,%edx
f011ab60:	39 d0                	cmp    %edx,%eax
f011ab62:	74 17                	je     f011ab7b <test_kfree_bestfirstfit+0x907>
f011ab64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ab6b:	83 ec 0c             	sub    $0xc,%esp
f011ab6e:	68 fc c2 12 f0       	push   $0xf012c2fc
f011ab73:	e8 f4 63 fe ff       	call   f0100f6c <cprintf>
f011ab78:	83 c4 10             	add    $0x10,%esp

		//3 MB
		ptr = (char*)ptr_allocations[5];
f011ab7b:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011ab81:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[5]; ++i)
f011ab84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ab8b:	eb 1e                	jmp    f011abab <test_kfree_bestfirstfit+0x937>
		{
			sums[5] += ptr[i] ;
f011ab8d:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011ab93:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011ab96:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ab99:	01 c8                	add    %ecx,%eax
f011ab9b:	8a 00                	mov    (%eax),%al
f011ab9d:	0f be c0             	movsbl %al,%eax
f011aba0:	01 d0                	add    %edx,%eax
f011aba2:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		}
		if (sums[4] != 4*lastIndices[4])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//3 MB
		ptr = (char*)ptr_allocations[5];
		for (i = 0; i < lastIndices[5]; ++i)
f011aba8:	ff 45 f4             	incl   -0xc(%ebp)
f011abab:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011abb1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011abb4:	7f d7                	jg     f011ab8d <test_kfree_bestfirstfit+0x919>
		{
			sums[5] += ptr[i] ;
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011abb6:	8b 8d 2c ff ff ff    	mov    -0xd4(%ebp),%ecx
f011abbc:	8b 95 7c ff ff ff    	mov    -0x84(%ebp),%edx
f011abc2:	89 d0                	mov    %edx,%eax
f011abc4:	c1 e0 02             	shl    $0x2,%eax
f011abc7:	01 d0                	add    %edx,%eax
f011abc9:	39 c1                	cmp    %eax,%ecx
f011abcb:	74 17                	je     f011abe4 <test_kfree_bestfirstfit+0x970>
f011abcd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011abd4:	83 ec 0c             	sub    $0xc,%esp
f011abd7:	68 fc c2 12 f0       	push   $0xf012c2fc
f011abdc:	e8 8b 63 fe ff       	call   f0100f6c <cprintf>
f011abe1:	83 c4 10             	add    $0x10,%esp

		//14 KB
		ptr = (char*)ptr_allocations[7];
f011abe4:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011abea:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[7]; ++i)
f011abed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011abf4:	eb 1e                	jmp    f011ac14 <test_kfree_bestfirstfit+0x9a0>
		{
			sums[7] += ptr[i] ;
f011abf6:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011abfc:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011abff:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ac02:	01 c8                	add    %ecx,%eax
f011ac04:	8a 00                	mov    (%eax),%al
f011ac06:	0f be c0             	movsbl %al,%eax
f011ac09:	01 d0                	add    %edx,%eax
f011ac0b:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		}
		if (sums[5] != 5*lastIndices[5])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }

		//14 KB
		ptr = (char*)ptr_allocations[7];
		for (i = 0; i < lastIndices[7]; ++i)
f011ac11:	ff 45 f4             	incl   -0xc(%ebp)
f011ac14:	8b 45 84             	mov    -0x7c(%ebp),%eax
f011ac17:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ac1a:	7f da                	jg     f011abf6 <test_kfree_bestfirstfit+0x982>
		{
			sums[7] += ptr[i] ;
		}
		if (sums[7] != 7*lastIndices[7])	{ correct = 0; cprintf("kfree: invalid read after freeing some allocations\n"); }
f011ac1c:	8b 8d 34 ff ff ff    	mov    -0xcc(%ebp),%ecx
f011ac22:	8b 55 84             	mov    -0x7c(%ebp),%edx
f011ac25:	89 d0                	mov    %edx,%eax
f011ac27:	01 c0                	add    %eax,%eax
f011ac29:	01 d0                	add    %edx,%eax
f011ac2b:	01 c0                	add    %eax,%eax
f011ac2d:	01 d0                	add    %edx,%eax
f011ac2f:	39 c1                	cmp    %eax,%ecx
f011ac31:	74 17                	je     f011ac4a <test_kfree_bestfirstfit+0x9d6>
f011ac33:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac3a:	83 ec 0c             	sub    $0xc,%esp
f011ac3d:	68 fc c2 12 f0       	push   $0xf012c2fc
f011ac42:	e8 25 63 fe ff       	call   f0100f6c <cprintf>
f011ac47:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=10 ;
f011ac4a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011ac4e:	74 04                	je     f011ac54 <test_kfree_bestfirstfit+0x9e0>
f011ac50:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011ac54:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Allocate after kfree [15%]
	{
		//Allocate in merged freed space
		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ac5b:	e8 a9 2a ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ac60:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ac63:	e8 d9 98 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ac68:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[8] = kmalloc(3*Mega);
f011ac6b:	83 ec 0c             	sub    $0xc,%esp
f011ac6e:	68 00 00 30 00       	push   $0x300000
f011ac73:	e8 3f db fe ff       	call   f01087b7 <kmalloc>
f011ac78:	83 c4 10             	add    $0x10,%esp
f011ac7b:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ac81:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011ac87:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011ac8c:	74 17                	je     f011aca5 <test_kfree_bestfirstfit+0xa31>
f011ac8e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ac95:	83 ec 0c             	sub    $0xc,%esp
f011ac98:	68 70 bf 12 f0       	push   $0xf012bf70
f011ac9d:	e8 ca 62 fe ff       	call   f0100f6c <cprintf>
f011aca2:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aca5:	e8 97 98 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011acaa:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011acad:	74 17                	je     f011acc6 <test_kfree_bestfirstfit+0xa52>
f011acaf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011acb6:	83 ec 0c             	sub    $0xc,%esp
f011acb9:	68 c0 be 12 f0       	push   $0xf012bec0
f011acbe:	e8 a9 62 fe ff       	call   f0100f6c <cprintf>
f011acc3:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011acc6:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011acc9:	e8 3b 2a ff ff       	call   f010d709 <sys_calculate_free_frames>
f011acce:	29 c3                	sub    %eax,%ebx
f011acd0:	89 d8                	mov    %ebx,%eax
f011acd2:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011acd7:	77 17                	ja     f011acf0 <test_kfree_bestfirstfit+0xa7c>
f011acd9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ace0:	83 ec 0c             	sub    $0xc,%esp
f011ace3:	68 2c bf 12 f0       	push   $0xf012bf2c
f011ace8:	e8 7f 62 fe ff       	call   f0100f6c <cprintf>
f011aced:	83 c4 10             	add    $0x10,%esp
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
f011acf0:	c7 45 88 ff ff 2f 00 	movl   $0x2fffff,-0x78(%ebp)
		ptr = (char*)ptr_allocations[8];
f011acf7:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011acfd:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[8]; ++i)
f011ad00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011ad07:	eb 0e                	jmp    f011ad17 <test_kfree_bestfirstfit+0xaa3>
		{
			ptr[i] = 8 ;
f011ad09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad0c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011ad0f:	01 d0                	add    %edx,%eax
f011ad11:	c6 00 08             	movb   $0x8,(%eax)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[8] = (3*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[8];
		for (i = 0; i < lastIndices[8]; ++i)
f011ad14:	ff 45 f4             	incl   -0xc(%ebp)
f011ad17:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ad1a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ad1d:	7f ea                	jg     f011ad09 <test_kfree_bestfirstfit+0xa95>
		{
			ptr[i] = 8 ;
		}

		//1 MB
		freeFrames = sys_calculate_free_frames() ;
f011ad1f:	e8 e5 29 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ad24:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ad27:	e8 15 98 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ad2c:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(1*Mega);
f011ad2f:	83 ec 0c             	sub    $0xc,%esp
f011ad32:	68 00 00 10 00       	push   $0x100000
f011ad37:	e8 7b da fe ff       	call   f01087b7 <kmalloc>
f011ad3c:	83 c4 10             	add    $0x10,%esp
f011ad3f:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ad45:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011ad4b:	3d 00 10 30 f8       	cmp    $0xf8301000,%eax
f011ad50:	74 17                	je     f011ad69 <test_kfree_bestfirstfit+0xaf5>
f011ad52:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad59:	83 ec 0c             	sub    $0xc,%esp
f011ad5c:	68 70 bf 12 f0       	push   $0xf012bf70
f011ad61:	e8 06 62 fe ff       	call   f0100f6c <cprintf>
f011ad66:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ad69:	e8 d3 97 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ad6e:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ad71:	74 17                	je     f011ad8a <test_kfree_bestfirstfit+0xb16>
f011ad73:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ad7a:	83 ec 0c             	sub    $0xc,%esp
f011ad7d:	68 c0 be 12 f0       	push   $0xf012bec0
f011ad82:	e8 e5 61 fe ff       	call   f0100f6c <cprintf>
f011ad87:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ad8a:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011ad8d:	e8 77 29 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ad92:	29 c3                	sub    %eax,%ebx
f011ad94:	89 d8                	mov    %ebx,%eax
f011ad96:	3d ff 00 00 00       	cmp    $0xff,%eax
f011ad9b:	77 17                	ja     f011adb4 <test_kfree_bestfirstfit+0xb40>
f011ad9d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ada4:	83 ec 0c             	sub    $0xc,%esp
f011ada7:	68 2c bf 12 f0       	push   $0xf012bf2c
f011adac:	e8 bb 61 fe ff       	call   f0100f6c <cprintf>
f011adb1:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
f011adb4:	c7 45 90 ff ff 0f 00 	movl   $0xfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011adbb:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011adc1:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011adc4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011adcb:	eb 0e                	jmp    f011addb <test_kfree_bestfirstfit+0xb67>
		{
			ptr[i] = 10 ;
f011adcd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011add0:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011add3:	01 d0                	add    %edx,%eax
f011add5:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START + 3*Mega /*+ 4*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 256) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (1*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011add8:	ff 45 f4             	incl   -0xc(%ebp)
f011addb:	8b 45 90             	mov    -0x70(%ebp),%eax
f011adde:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011ade1:	7f ea                	jg     f011adcd <test_kfree_bestfirstfit+0xb59>
		{
			ptr[i] = 10 ;
		}

		//1 KB [Should be allocated in 1st hole in the Dynamic Allocator]
		freeFrames = sys_calculate_free_frames() ;
f011ade3:	e8 21 29 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ade8:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011adeb:	e8 51 97 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011adf0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[9] = kmalloc(1*kilo);
f011adf3:	83 ec 0c             	sub    $0xc,%esp
f011adf6:	68 00 04 00 00       	push   $0x400
f011adfb:	e8 b7 d9 fe ff       	call   f01087b7 <kmalloc>
f011ae00:	83 c4 10             	add    $0x10,%esp
f011ae03:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
		if ((ptr_allocations[9] < ptr_allocations[2]) || (ptr_allocations[9] > (ptr_allocations[2] + 1*kilo)))
f011ae09:	8b 95 ec fe ff ff    	mov    -0x114(%ebp),%edx
f011ae0f:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011ae15:	39 c2                	cmp    %eax,%edx
f011ae17:	72 16                	jb     f011ae2f <test_kfree_bestfirstfit+0xbbb>
f011ae19:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ae1f:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011ae25:	81 c2 00 04 00 00    	add    $0x400,%edx
f011ae2b:	39 d0                	cmp    %edx,%eax
f011ae2d:	76 17                	jbe    f011ae46 <test_kfree_bestfirstfit+0xbd2>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ae2f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae36:	83 ec 0c             	sub    $0xc,%esp
f011ae39:	68 70 bf 12 f0       	push   $0xf012bf70
f011ae3e:	e8 29 61 fe ff       	call   f0100f6c <cprintf>
f011ae43:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ae46:	e8 f6 96 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ae4b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011ae4e:	74 17                	je     f011ae67 <test_kfree_bestfirstfit+0xbf3>
f011ae50:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae57:	83 ec 0c             	sub    $0xc,%esp
f011ae5a:	68 c0 be 12 f0       	push   $0xf012bec0
f011ae5f:	e8 08 61 fe ff       	call   f0100f6c <cprintf>
f011ae64:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011ae67:	e8 9d 28 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ae6c:	89 c2                	mov    %eax,%edx
f011ae6e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011ae71:	39 c2                	cmp    %eax,%edx
f011ae73:	74 17                	je     f011ae8c <test_kfree_bestfirstfit+0xc18>
f011ae75:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ae7c:	83 ec 0c             	sub    $0xc,%esp
f011ae7f:	68 30 c3 12 f0       	push   $0xf012c330
f011ae84:	e8 e3 60 fe ff       	call   f0100f6c <cprintf>
f011ae89:	83 c4 10             	add    $0x10,%esp
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
f011ae8c:	c7 45 8c ff 03 00 00 	movl   $0x3ff,-0x74(%ebp)
		ptr = (char*)ptr_allocations[9];
f011ae93:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011ae99:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[9]; ++i)
f011ae9c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011aea3:	eb 0e                	jmp    f011aeb3 <test_kfree_bestfirstfit+0xc3f>
		{
			ptr[i] = 9 ;
f011aea5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aea8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011aeab:	01 d0                	add    %edx,%eax
f011aead:	c6 00 09             	movb   $0x9,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[9] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[9];
		for (i = 0; i < lastIndices[9]; ++i)
f011aeb0:	ff 45 f4             	incl   -0xc(%ebp)
f011aeb3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011aeb6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011aeb9:	7f ea                	jg     f011aea5 <test_kfree_bestfirstfit+0xc31>
		{
			ptr[i] = 9 ;
		}

	}
	if (correct)	eval+=15 ;
f011aebb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aebf:	74 04                	je     f011aec5 <test_kfree_bestfirstfit+0xc51>
f011aec1:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011aec5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree remaining allocated spaces [15%]
	{
		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with NEXT 6 MB hole - total = 9MB]
		freeFrames = sys_calculate_free_frames() ;
f011aecc:	e8 38 28 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011aed1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011aed4:	e8 68 96 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011aed9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[5]);
f011aedc:	8b 85 dc fe ff ff    	mov    -0x124(%ebp),%eax
f011aee2:	83 ec 0c             	sub    $0xc,%esp
f011aee5:	50                   	push   %eax
f011aee6:	e8 e6 d8 fe ff       	call   f01087d1 <kfree>
f011aeeb:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011aeee:	e8 4e 96 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011aef3:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011aef6:	74 17                	je     f011af0f <test_kfree_bestfirstfit+0xc9b>
f011aef8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011aeff:	83 ec 0c             	sub    $0xc,%esp
f011af02:	68 c0 be 12 f0       	push   $0xf012bec0
f011af07:	e8 60 60 fe ff       	call   f0100f6c <cprintf>
f011af0c:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011af0f:	e8 f5 27 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011af14:	89 c2                	mov    %eax,%edx
f011af16:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011af19:	29 c2                	sub    %eax,%edx
f011af1b:	89 d0                	mov    %edx,%eax
f011af1d:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011af22:	77 17                	ja     f011af3b <test_kfree_bestfirstfit+0xcc7>
f011af24:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af2b:	83 ec 0c             	sub    $0xc,%esp
f011af2e:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011af33:	e8 34 60 fe ff       	call   f0100f6c <cprintf>
f011af38:	83 c4 10             	add    $0x10,%esp

		//kfree 7 KB [PAGE ALLOCATOR: Should be Merged with NEXT 9 MB hole - total = 9MB + 8KB]
		freeFrames = sys_calculate_free_frames() ;
f011af3b:	e8 c9 27 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011af40:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011af43:	e8 f9 95 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011af48:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[4]);
f011af4b:	8b 85 d8 fe ff ff    	mov    -0x128(%ebp),%eax
f011af51:	83 ec 0c             	sub    $0xc,%esp
f011af54:	50                   	push   %eax
f011af55:	e8 77 d8 fe ff       	call   f01087d1 <kfree>
f011af5a:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011af5d:	e8 df 95 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011af62:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011af65:	74 17                	je     f011af7e <test_kfree_bestfirstfit+0xd0a>
f011af67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af6e:	83 ec 0c             	sub    $0xc,%esp
f011af71:	68 c0 be 12 f0       	push   $0xf012bec0
f011af76:	e8 f1 5f fe ff       	call   f0100f6c <cprintf>
f011af7b:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 2) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011af7e:	e8 86 27 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011af83:	89 c2                	mov    %eax,%edx
f011af85:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011af88:	29 c2                	sub    %eax,%edx
f011af8a:	89 d0                	mov    %edx,%eax
f011af8c:	83 f8 01             	cmp    $0x1,%eax
f011af8f:	77 17                	ja     f011afa8 <test_kfree_bestfirstfit+0xd34>
f011af91:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011af98:	83 ec 0c             	sub    $0xc,%esp
f011af9b:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011afa0:	e8 c7 5f fe ff       	call   f0100f6c <cprintf>
f011afa5:	83 c4 10             	add    $0x10,%esp

		//kfree 1 KB [DYNAMIC ALLOCATOR]
		freeFrames = sys_calculate_free_frames() ;
f011afa8:	e8 5c 27 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011afad:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011afb0:	e8 8c 95 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011afb5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[9]);
f011afb8:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011afbe:	83 ec 0c             	sub    $0xc,%esp
f011afc1:	50                   	push   %eax
f011afc2:	e8 0a d8 fe ff       	call   f01087d1 <kfree>
f011afc7:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011afca:	e8 72 95 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011afcf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011afd2:	74 17                	je     f011afeb <test_kfree_bestfirstfit+0xd77>
f011afd4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011afdb:	83 ec 0c             	sub    $0xc,%esp
f011afde:	68 c0 be 12 f0       	push   $0xf012bec0
f011afe3:	e8 84 5f fe ff       	call   f0100f6c <cprintf>
f011afe8:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011afeb:	e8 19 27 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011aff0:	89 c2                	mov    %eax,%edx
f011aff2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011aff5:	39 c2                	cmp    %eax,%edx
f011aff7:	74 17                	je     f011b010 <test_kfree_bestfirstfit+0xd9c>
f011aff9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b000:	83 ec 0c             	sub    $0xc,%esp
f011b003:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011b008:	e8 5f 5f fe ff       	call   f0100f6c <cprintf>
f011b00d:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 KB [DYNAMIC ALLOCATOR: Should be Merged with PREV remaining area of 2KB & NEXT free space]
		freeFrames = sys_calculate_free_frames() ;
f011b010:	e8 f4 26 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b015:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b018:	e8 24 95 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b01d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[3]);
f011b020:	8b 85 d4 fe ff ff    	mov    -0x12c(%ebp),%eax
f011b026:	83 ec 0c             	sub    $0xc,%esp
f011b029:	50                   	push   %eax
f011b02a:	e8 a2 d7 fe ff       	call   f01087d1 <kfree>
f011b02f:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b032:	e8 0a 95 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b037:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b03a:	74 17                	je     f011b053 <test_kfree_bestfirstfit+0xddf>
f011b03c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b043:	83 ec 0c             	sub    $0xc,%esp
f011b046:	68 c0 be 12 f0       	push   $0xf012bec0
f011b04b:	e8 1c 5f fe ff       	call   f0100f6c <cprintf>
f011b050:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) != 0) { correct = 0; cprintf("Wrong free: freeing a block from the dynamic allocator should not affect the free frames\n"); }
f011b053:	e8 b1 26 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b058:	89 c2                	mov    %eax,%edx
f011b05a:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b05d:	39 c2                	cmp    %eax,%edx
f011b05f:	74 17                	je     f011b078 <test_kfree_bestfirstfit+0xe04>
f011b061:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b068:	83 ec 0c             	sub    $0xc,%esp
f011b06b:	68 cc c1 12 f0       	push   $0xf012c1cc
f011b070:	e8 f7 5e fe ff       	call   f0100f6c <cprintf>
f011b075:	83 c4 10             	add    $0x10,%esp

		//kfree 14 KB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 8KB hole - total = 9MB + 24KB]
		freeFrames = sys_calculate_free_frames() ;
f011b078:	e8 8c 26 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b07d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b080:	e8 bc 94 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b085:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[7]);
f011b088:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011b08e:	83 ec 0c             	sub    $0xc,%esp
f011b091:	50                   	push   %eax
f011b092:	e8 3a d7 fe ff       	call   f01087d1 <kfree>
f011b097:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b09a:	e8 a2 94 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b09f:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b0a2:	74 17                	je     f011b0bb <test_kfree_bestfirstfit+0xe47>
f011b0a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0ab:	83 ec 0c             	sub    $0xc,%esp
f011b0ae:	68 c0 be 12 f0       	push   $0xf012bec0
f011b0b3:	e8 b4 5e fe ff       	call   f0100f6c <cprintf>
f011b0b8:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 4) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b0bb:	e8 49 26 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b0c0:	89 c2                	mov    %eax,%edx
f011b0c2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b0c5:	29 c2                	sub    %eax,%edx
f011b0c7:	89 d0                	mov    %edx,%eax
f011b0c9:	83 f8 03             	cmp    $0x3,%eax
f011b0cc:	77 17                	ja     f011b0e5 <test_kfree_bestfirstfit+0xe71>
f011b0ce:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b0d5:	83 ec 0c             	sub    $0xc,%esp
f011b0d8:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011b0dd:	e8 8a 5e fe ff       	call   f0100f6c <cprintf>
f011b0e2:	83 c4 10             	add    $0x10,%esp

		//kfree 1 MB [PAGE ALLOCATOR: Should be Merged with NEXT remaining hole ]
		freeFrames = sys_calculate_free_frames() ;
f011b0e5:	e8 1f 26 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b0ea:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b0ed:	e8 4f 94 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b0f2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[10]);
f011b0f5:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b0fb:	83 ec 0c             	sub    $0xc,%esp
f011b0fe:	50                   	push   %eax
f011b0ff:	e8 cd d6 fe ff       	call   f01087d1 <kfree>
f011b104:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b107:	e8 35 94 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b10c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b10f:	74 17                	je     f011b128 <test_kfree_bestfirstfit+0xeb4>
f011b111:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b118:	83 ec 0c             	sub    $0xc,%esp
f011b11b:	68 c0 be 12 f0       	push   $0xf012bec0
f011b120:	e8 47 5e fe ff       	call   f0100f6c <cprintf>
f011b125:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 1*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b128:	e8 dc 25 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b12d:	89 c2                	mov    %eax,%edx
f011b12f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b132:	29 c2                	sub    %eax,%edx
f011b134:	89 d0                	mov    %edx,%eax
f011b136:	3d ff 00 00 00       	cmp    $0xff,%eax
f011b13b:	77 17                	ja     f011b154 <test_kfree_bestfirstfit+0xee0>
f011b13d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b144:	83 ec 0c             	sub    $0xc,%esp
f011b147:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011b14c:	e8 1b 5e fe ff       	call   f0100f6c <cprintf>
f011b151:	83 c4 10             	add    $0x10,%esp

		//kfree 3 MB [PAGE ALLOCATOR: Should be Merged with PREV 9MB + 24KB hole & NEXT remaining hole - total = ALL PAGE ALLOCATOR Space]
		freeFrames = sys_calculate_free_frames() ;
f011b154:	e8 b0 25 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b159:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b15c:	e8 e0 93 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b161:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		kfree(ptr_allocations[8]);
f011b164:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011b16a:	83 ec 0c             	sub    $0xc,%esp
f011b16d:	50                   	push   %eax
f011b16e:	e8 5e d6 fe ff       	call   f01087d1 <kfree>
f011b173:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b176:	e8 c6 93 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b17b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b17e:	74 17                	je     f011b197 <test_kfree_bestfirstfit+0xf23>
f011b180:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b187:	83 ec 0c             	sub    $0xc,%esp
f011b18a:	68 c0 be 12 f0       	push   $0xf012bec0
f011b18f:	e8 d8 5d fe ff       	call   f0100f6c <cprintf>
f011b194:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 3*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011b197:	e8 6d 25 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b19c:	89 c2                	mov    %eax,%edx
f011b19e:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b1a1:	29 c2                	sub    %eax,%edx
f011b1a3:	89 d0                	mov    %edx,%eax
f011b1a5:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011b1aa:	77 17                	ja     f011b1c3 <test_kfree_bestfirstfit+0xf4f>
f011b1ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b1b3:	83 ec 0c             	sub    $0xc,%esp
f011b1b6:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011b1bb:	e8 ac 5d fe ff       	call   f0100f6c <cprintf>
f011b1c0:	83 c4 10             	add    $0x10,%esp

		//				if(start_freeFrames != (sys_calculate_free_frames())) {{ correct = 0; cprintf("Wrong kfree: not all pages removed correctly at end\n"); }}
	}
	if (correct)	eval+=15 ;
f011b1c3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b1c7:	74 04                	je     f011b1cd <test_kfree_bestfirstfit+0xf59>
f011b1c9:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011b1cd:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//Check memory access after kfree [15%]
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);
f011b1d4:	83 ec 0c             	sub    $0xc,%esp
f011b1d7:	6a 03                	push   $0x3
f011b1d9:	e8 eb 28 ff ff       	call   f010dac9 <sys_bypassPageFault>
f011b1de:	83 c4 10             	add    $0x10,%esp

		for (i = 0; i <= 10; ++i)
f011b1e1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b1e8:	e9 af 00 00 00       	jmp    f011b29c <test_kfree_bestfirstfit+0x1028>
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
f011b1ed:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f011b1f1:	0f 84 a1 00 00 00    	je     f011b298 <test_kfree_bestfirstfit+0x1024>
f011b1f7:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
f011b1fb:	0f 84 97 00 00 00    	je     f011b298 <test_kfree_bestfirstfit+0x1024>
f011b201:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
f011b205:	0f 84 8d 00 00 00    	je     f011b298 <test_kfree_bestfirstfit+0x1024>
			{
				continue;
			}
			ptr = (char *) ptr_allocations[i];
f011b20b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b20e:	8b 84 85 c8 fe ff ff 	mov    -0x138(%ebp,%eax,4),%eax
f011b215:	89 45 c0             	mov    %eax,-0x40(%ebp)
			ptr[0] = 10;
f011b218:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b21b:	c6 00 0a             	movb   $0xa,(%eax)
			//cprintf("\n\ncr2 = %x, faulted addr = %x", sys_rcr2(), (uint32)&(ptr[0]));
			if (sys_rcr2() != (uint32)&(ptr[0]))
f011b21e:	e8 94 28 ff ff       	call   f010dab7 <sys_rcr2>
f011b223:	89 c2                	mov    %eax,%edx
f011b225:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b228:	39 c2                	cmp    %eax,%edx
f011b22a:	74 1d                	je     f011b249 <test_kfree_bestfirstfit+0xfd5>
				if (correct)
f011b22c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b230:	74 17                	je     f011b249 <test_kfree_bestfirstfit+0xfd5>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011b232:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b239:	83 ec 0c             	sub    $0xc,%esp
f011b23c:	68 a8 c3 12 f0       	push   $0xf012c3a8
f011b241:	e8 26 5d fe ff       	call   f0100f6c <cprintf>
f011b246:	83 c4 10             	add    $0x10,%esp
			ptr[lastIndices[i]] = 10;
f011b249:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b24c:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011b253:	89 c2                	mov    %eax,%edx
f011b255:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b258:	01 d0                	add    %edx,%eax
f011b25a:	c6 00 0a             	movb   $0xa,(%eax)
			if (sys_rcr2() != (uint32)&(ptr[lastIndices[i]]))
f011b25d:	e8 55 28 ff ff       	call   f010dab7 <sys_rcr2>
f011b262:	89 c2                	mov    %eax,%edx
f011b264:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b267:	8b 84 85 68 ff ff ff 	mov    -0x98(%ebp,%eax,4),%eax
f011b26e:	89 c1                	mov    %eax,%ecx
f011b270:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b273:	01 c8                	add    %ecx,%eax
f011b275:	39 c2                	cmp    %eax,%edx
f011b277:	74 20                	je     f011b299 <test_kfree_bestfirstfit+0x1025>
				if (correct)
f011b279:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b27d:	74 1a                	je     f011b299 <test_kfree_bestfirstfit+0x1025>
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
f011b27f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b286:	83 ec 0c             	sub    $0xc,%esp
f011b289:	68 a8 c3 12 f0       	push   $0xf012c3a8
f011b28e:	e8 d9 5c fe ff       	call   f0100f6c <cprintf>
f011b293:	83 c4 10             	add    $0x10,%esp
f011b296:	eb 01                	jmp    f011b299 <test_kfree_bestfirstfit+0x1025>
		for (i = 0; i <= 10; ++i)
		{
			//SKIP CHECKING THOSE IN DYNAMIC ALLOCATOR AREA
			if (i == 2 || i == 3 || i == 9)
			{
				continue;
f011b298:	90                   	nop
	{
		//Bypass the PAGE FAULT on <MOVB immediate, reg> instruction by setting its length
		//and continue executing the remaining code
		sys_bypassPageFault(3);

		for (i = 0; i <= 10; ++i)
f011b299:	ff 45 f4             	incl   -0xc(%ebp)
f011b29c:	83 7d f4 0a          	cmpl   $0xa,-0xc(%ebp)
f011b2a0:	0f 8e 47 ff ff ff    	jle    f011b1ed <test_kfree_bestfirstfit+0xf79>
				if (correct)
				{ correct = 0; cprintf("kfree: successful access to freed space!! it should not be succeeded\n"); }
		}

		//set it to 0 again to cancel the bypassing option
		sys_bypassPageFault(0);
f011b2a6:	83 ec 0c             	sub    $0xc,%esp
f011b2a9:	6a 00                	push   $0x0
f011b2ab:	e8 19 28 ff ff       	call   f010dac9 <sys_bypassPageFault>
f011b2b0:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=15 ;
f011b2b3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b2b7:	74 04                	je     f011b2bd <test_kfree_bestfirstfit+0x1049>
f011b2b9:	83 45 f0 0f          	addl   $0xf,-0x10(%ebp)

	correct = 1 ;
f011b2bd:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)

	//Allocate after kfree ALL [30%]
	{
		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1 KB
		freeFrames = sys_calculate_free_frames() ;
f011b2c4:	e8 40 24 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b2c9:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b2cc:	e8 70 92 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b2d1:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[11] = kmalloc(1*kilo);
f011b2d4:	83 ec 0c             	sub    $0xc,%esp
f011b2d7:	68 00 04 00 00       	push   $0x400
f011b2dc:	e8 d6 d4 fe ff       	call   f01087b7 <kmalloc>
f011b2e1:	83 c4 10             	add    $0x10,%esp
f011b2e4:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
		if ((ptr_allocations[11] < ptr_allocations[2]) || (ptr_allocations[11] > (ptr_allocations[2] + 1*kilo)))
f011b2ea:	8b 95 f4 fe ff ff    	mov    -0x10c(%ebp),%edx
f011b2f0:	8b 85 d0 fe ff ff    	mov    -0x130(%ebp),%eax
f011b2f6:	39 c2                	cmp    %eax,%edx
f011b2f8:	72 16                	jb     f011b310 <test_kfree_bestfirstfit+0x109c>
f011b2fa:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b300:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b306:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b30c:	39 d0                	cmp    %edx,%eax
f011b30e:	76 17                	jbe    f011b327 <test_kfree_bestfirstfit+0x10b3>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b310:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b317:	83 ec 0c             	sub    $0xc,%esp
f011b31a:	68 70 bf 12 f0       	push   $0xf012bf70
f011b31f:	e8 48 5c fe ff       	call   f0100f6c <cprintf>
f011b324:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b327:	e8 15 92 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b32c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b32f:	74 17                	je     f011b348 <test_kfree_bestfirstfit+0x10d4>
f011b331:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b338:	83 ec 0c             	sub    $0xc,%esp
f011b33b:	68 c0 be 12 f0       	push   $0xf012bec0
f011b340:	e8 27 5c fe ff       	call   f0100f6c <cprintf>
f011b345:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b348:	e8 bc 23 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b34d:	89 c2                	mov    %eax,%edx
f011b34f:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b352:	39 c2                	cmp    %eax,%edx
f011b354:	74 17                	je     f011b36d <test_kfree_bestfirstfit+0x10f9>
f011b356:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b35d:	83 ec 0c             	sub    $0xc,%esp
f011b360:	68 30 c3 12 f0       	push   $0xf012c330
f011b365:	e8 02 5c fe ff       	call   f0100f6c <cprintf>
f011b36a:	83 c4 10             	add    $0x10,%esp
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
f011b36d:	c7 45 94 ff 03 00 00 	movl   $0x3ff,-0x6c(%ebp)
		ptr = (char*)ptr_allocations[11];
f011b374:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b37a:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011b37d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b384:	eb 0e                	jmp    f011b394 <test_kfree_bestfirstfit+0x1120>
		{
			ptr[i] = 11 ;
f011b386:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b389:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b38c:	01 d0                	add    %edx,%eax
f011b38e:	c6 00 0b             	movb   $0xb,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[11] = (1*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011b391:	ff 45 f4             	incl   -0xc(%ebp)
f011b394:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b397:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b39a:	7f ea                	jg     f011b386 <test_kfree_bestfirstfit+0x1112>
			ptr[i] = 11 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//2 KB
		freeFrames = sys_calculate_free_frames() ;
f011b39c:	e8 68 23 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b3a1:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b3a4:	e8 98 91 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b3a9:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[12] = kmalloc(2*kilo);
f011b3ac:	83 ec 0c             	sub    $0xc,%esp
f011b3af:	68 00 08 00 00       	push   $0x800
f011b3b4:	e8 fe d3 fe ff       	call   f01087b7 <kmalloc>
f011b3b9:	83 c4 10             	add    $0x10,%esp
f011b3bc:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%ebp)
		//expected = ptr_allocations[2] + 1*kilo + sizeOfMetaData();
		//if (ptr_allocations[12] != expected)
		if ((ptr_allocations[12] < ptr_allocations[2] + 1*kilo) || (ptr_allocations[12] > (ptr_allocations[2] + 2*kilo)))
f011b3c2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b3c8:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b3ce:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b3d4:	39 d0                	cmp    %edx,%eax
f011b3d6:	72 16                	jb     f011b3ee <test_kfree_bestfirstfit+0x117a>
f011b3d8:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b3de:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b3e4:	81 c2 00 08 00 00    	add    $0x800,%edx
f011b3ea:	39 d0                	cmp    %edx,%eax
f011b3ec:	76 35                	jbe    f011b423 <test_kfree_bestfirstfit+0x11af>
		{
			correct = 0;
f011b3ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
			cprintf("Wrong start address for the allocated space... check return address of kmalloc. Expected [%x, %x], Actual %x\n", (ptr_allocations[2] + 1*kilo), (ptr_allocations[2] + 2*kilo), ptr_allocations[12]);
f011b3f5:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b3fb:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b401:	8d 8a 00 08 00 00    	lea    0x800(%edx),%ecx
f011b407:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b40d:	81 c2 00 04 00 00    	add    $0x400,%edx
f011b413:	50                   	push   %eax
f011b414:	51                   	push   %ecx
f011b415:	52                   	push   %edx
f011b416:	68 f0 c3 12 f0       	push   $0xf012c3f0
f011b41b:	e8 4c 5b fe ff       	call   f0100f6c <cprintf>
f011b420:	83 c4 10             	add    $0x10,%esp
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b423:	e8 19 91 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b428:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b42b:	74 17                	je     f011b444 <test_kfree_bestfirstfit+0x11d0>
f011b42d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b434:	83 ec 0c             	sub    $0xc,%esp
f011b437:	68 c0 be 12 f0       	push   $0xf012bec0
f011b43c:	e8 2b 5b fe ff       	call   f0100f6c <cprintf>
f011b441:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b444:	e8 c0 22 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b449:	89 c2                	mov    %eax,%edx
f011b44b:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b44e:	39 c2                	cmp    %eax,%edx
f011b450:	74 17                	je     f011b469 <test_kfree_bestfirstfit+0x11f5>
f011b452:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b459:	83 ec 0c             	sub    $0xc,%esp
f011b45c:	68 30 c3 12 f0       	push   $0xf012c330
f011b461:	e8 06 5b fe ff       	call   f0100f6c <cprintf>
f011b466:	83 c4 10             	add    $0x10,%esp
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
f011b469:	c7 45 98 ff 07 00 00 	movl   $0x7ff,-0x68(%ebp)
		ptr = (char*)ptr_allocations[12];
f011b470:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b476:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011b479:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b480:	eb 0e                	jmp    f011b490 <test_kfree_bestfirstfit+0x121c>
		{
			ptr[i] = 12 ;
f011b482:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b485:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b488:	01 d0                	add    %edx,%eax
f011b48a:	c6 00 0c             	movb   $0xc,(%eax)
		}
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[12] = (2*kilo)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011b48d:	ff 45 f4             	incl   -0xc(%ebp)
f011b490:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b493:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b496:	7f ea                	jg     f011b482 <test_kfree_bestfirstfit+0x120e>
			ptr[i] = 12 ;
		}

		//[DYNAMIC ALLOCATOR] Allocate in merged freed space
		//1.5 KB
		freeFrames = sys_calculate_free_frames() ;
f011b498:	e8 6c 22 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b49d:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b4a0:	e8 9c 90 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b4a5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[13] = kmalloc(3*kilo/2);
f011b4a8:	83 ec 0c             	sub    $0xc,%esp
f011b4ab:	68 00 06 00 00       	push   $0x600
f011b4b0:	e8 02 d3 fe ff       	call   f01087b7 <kmalloc>
f011b4b5:	83 c4 10             	add    $0x10,%esp
f011b4b8:	89 85 fc fe ff ff    	mov    %eax,-0x104(%ebp)
		//if (ptr_allocations[13] != ptr_allocations[12] + 2*kilo + sizeOfMetaData())
		if ((ptr_allocations[13] < ptr_allocations[2] + 3*kilo) || (ptr_allocations[13] > (ptr_allocations[2] + 4*kilo)))
f011b4be:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b4c4:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b4ca:	81 c2 00 0c 00 00    	add    $0xc00,%edx
f011b4d0:	39 d0                	cmp    %edx,%eax
f011b4d2:	72 16                	jb     f011b4ea <test_kfree_bestfirstfit+0x1276>
f011b4d4:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b4da:	8b 95 d0 fe ff ff    	mov    -0x130(%ebp),%edx
f011b4e0:	81 c2 00 10 00 00    	add    $0x1000,%edx
f011b4e6:	39 d0                	cmp    %edx,%eax
f011b4e8:	76 17                	jbe    f011b501 <test_kfree_bestfirstfit+0x128d>
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b4ea:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b4f1:	83 ec 0c             	sub    $0xc,%esp
f011b4f4:	68 70 bf 12 f0       	push   $0xf012bf70
f011b4f9:	e8 6e 5a fe ff       	call   f0100f6c <cprintf>
f011b4fe:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b501:	e8 3b 90 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b506:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b509:	74 17                	je     f011b522 <test_kfree_bestfirstfit+0x12ae>
f011b50b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b512:	83 ec 0c             	sub    $0xc,%esp
f011b515:	68 c0 be 12 f0       	push   $0xf012bec0
f011b51a:	e8 4d 5a fe ff       	call   f0100f6c <cprintf>
f011b51f:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
f011b522:	e8 e2 21 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b527:	89 c2                	mov    %eax,%edx
f011b529:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011b52c:	39 c2                	cmp    %eax,%edx
f011b52e:	74 17                	je     f011b547 <test_kfree_bestfirstfit+0x12d3>
f011b530:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b537:	83 ec 0c             	sub    $0xc,%esp
f011b53a:	68 30 c3 12 f0       	push   $0xf012c330
f011b53f:	e8 28 5a fe ff       	call   f0100f6c <cprintf>
f011b544:	83 c4 10             	add    $0x10,%esp
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
f011b547:	c7 45 9c ff 05 00 00 	movl   $0x5ff,-0x64(%ebp)
		ptr = (char*)ptr_allocations[13];
f011b54e:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b554:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011b557:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b55e:	eb 0e                	jmp    f011b56e <test_kfree_bestfirstfit+0x12fa>
		{
			ptr[i] = 13 ;
f011b560:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b563:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b566:	01 d0                	add    %edx,%eax
f011b568:	c6 00 0d             	movb   $0xd,(%eax)
		{ correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) != 0) { correct = 0; cprintf("Wrong allocation: it's allocated in a previously allocated block. Should not allocate any pages from physical memory\n"); }
		lastIndices[13] = (3*kilo/2)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011b56b:	ff 45 f4             	incl   -0xc(%ebp)
f011b56e:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b571:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b574:	7f ea                	jg     f011b560 <test_kfree_bestfirstfit+0x12ec>
			ptr[i] = 13 ;
		}

		//[PAGE ALLOCATOR] Allocate in merged freed space
		//30 MB
		freeFrames = sys_calculate_free_frames() ;
f011b576:	e8 8e 21 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b57b:	89 45 c8             	mov    %eax,-0x38(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b57e:	e8 be 8f fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b583:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		ptr_allocations[10] = kmalloc(30*Mega);
f011b586:	83 ec 0c             	sub    $0xc,%esp
f011b589:	68 00 00 e0 01       	push   $0x1e00000
f011b58e:	e8 24 d2 fe ff       	call   f01087b7 <kmalloc>
f011b593:	83 c4 10             	add    $0x10,%esp
f011b596:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b59c:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b5a2:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b5a7:	74 17                	je     f011b5c0 <test_kfree_bestfirstfit+0x134c>
f011b5a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5b0:	83 ec 0c             	sub    $0xc,%esp
f011b5b3:	68 70 bf 12 f0       	push   $0xf012bf70
f011b5b8:	e8 af 59 fe ff       	call   f0100f6c <cprintf>
f011b5bd:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b5c0:	e8 7c 8f fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b5c5:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011b5c8:	74 17                	je     f011b5e1 <test_kfree_bestfirstfit+0x136d>
f011b5ca:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5d1:	83 ec 0c             	sub    $0xc,%esp
f011b5d4:	68 c0 be 12 f0       	push   $0xf012bec0
f011b5d9:	e8 8e 59 fe ff       	call   f0100f6c <cprintf>
f011b5de:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b5e1:	8b 5d c8             	mov    -0x38(%ebp),%ebx
f011b5e4:	e8 20 21 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b5e9:	29 c3                	sub    %eax,%ebx
f011b5eb:	89 d8                	mov    %ebx,%eax
f011b5ed:	3d ff 1d 00 00       	cmp    $0x1dff,%eax
f011b5f2:	77 17                	ja     f011b60b <test_kfree_bestfirstfit+0x1397>
f011b5f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b5fb:	83 ec 0c             	sub    $0xc,%esp
f011b5fe:	68 2c bf 12 f0       	push   $0xf012bf2c
f011b603:	e8 64 59 fe ff       	call   f0100f6c <cprintf>
f011b608:	83 c4 10             	add    $0x10,%esp
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
f011b60b:	c7 45 90 ff ff df 01 	movl   $0x1dfffff,-0x70(%ebp)
		ptr = (char*)ptr_allocations[10];
f011b612:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b618:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011b61b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b622:	eb 0e                	jmp    f011b632 <test_kfree_bestfirstfit+0x13be>
		{
			ptr[i] = 10 ;
f011b624:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b627:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b62a:	01 d0                	add    %edx,%eax
f011b62c:	c6 00 0a             	movb   $0xa,(%eax)
		if ((uint32) ptr_allocations[10] != (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
		if ((freeFrames - sys_calculate_free_frames()) < 30*Mega/PAGE_SIZE) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
		lastIndices[10] = (30*Mega)/sizeof(char) - 1;
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011b62f:	ff 45 f4             	incl   -0xc(%ebp)
f011b632:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b635:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b638:	7f ea                	jg     f011b624 <test_kfree_bestfirstfit+0x13b0>
			ptr[i] = 10 ;
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
f011b63a:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011b640:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[10]; ++i)
f011b643:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b64a:	eb 1e                	jmp    f011b66a <test_kfree_bestfirstfit+0x13f6>
		{
			sums[10] += ptr[i] ;
f011b64c:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011b652:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b655:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b658:	01 c8                	add    %ecx,%eax
f011b65a:	8a 00                	mov    (%eax),%al
f011b65c:	0f be c0             	movsbl %al,%eax
f011b65f:	01 d0                	add    %edx,%eax
f011b661:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		}


		//30 MB
		ptr = (char*)ptr_allocations[10];
		for (i = 0; i < lastIndices[10]; ++i)
f011b667:	ff 45 f4             	incl   -0xc(%ebp)
f011b66a:	8b 45 90             	mov    -0x70(%ebp),%eax
f011b66d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b670:	7f da                	jg     f011b64c <test_kfree_bestfirstfit+0x13d8>
		{
			sums[10] += ptr[i] ;
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b672:	8b 8d 40 ff ff ff    	mov    -0xc0(%ebp),%ecx
f011b678:	8b 55 90             	mov    -0x70(%ebp),%edx
f011b67b:	89 d0                	mov    %edx,%eax
f011b67d:	c1 e0 02             	shl    $0x2,%eax
f011b680:	01 d0                	add    %edx,%eax
f011b682:	01 c0                	add    %eax,%eax
f011b684:	39 c1                	cmp    %eax,%ecx
f011b686:	74 17                	je     f011b69f <test_kfree_bestfirstfit+0x142b>
f011b688:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b68f:	83 ec 0c             	sub    $0xc,%esp
f011b692:	68 60 c4 12 f0       	push   $0xf012c460
f011b697:	e8 d0 58 fe ff       	call   f0100f6c <cprintf>
f011b69c:	83 c4 10             	add    $0x10,%esp

		//1 KB
		ptr = (char*)ptr_allocations[11];
f011b69f:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011b6a5:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[11]; ++i)
f011b6a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b6af:	eb 1e                	jmp    f011b6cf <test_kfree_bestfirstfit+0x145b>
		{
			sums[11] += ptr[i] ;
f011b6b1:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011b6b7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b6ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b6bd:	01 c8                	add    %ecx,%eax
f011b6bf:	8a 00                	mov    (%eax),%al
f011b6c1:	0f be c0             	movsbl %al,%eax
f011b6c4:	01 d0                	add    %edx,%eax
f011b6c6:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		}
		if (sums[10] != 10*lastIndices[10])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1 KB
		ptr = (char*)ptr_allocations[11];
		for (i = 0; i < lastIndices[11]; ++i)
f011b6cc:	ff 45 f4             	incl   -0xc(%ebp)
f011b6cf:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011b6d2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b6d5:	7f da                	jg     f011b6b1 <test_kfree_bestfirstfit+0x143d>
		{
			sums[11] += ptr[i] ;
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b6d7:	8b 8d 44 ff ff ff    	mov    -0xbc(%ebp),%ecx
f011b6dd:	8b 55 94             	mov    -0x6c(%ebp),%edx
f011b6e0:	89 d0                	mov    %edx,%eax
f011b6e2:	c1 e0 02             	shl    $0x2,%eax
f011b6e5:	01 d0                	add    %edx,%eax
f011b6e7:	01 c0                	add    %eax,%eax
f011b6e9:	01 d0                	add    %edx,%eax
f011b6eb:	39 c1                	cmp    %eax,%ecx
f011b6ed:	74 17                	je     f011b706 <test_kfree_bestfirstfit+0x1492>
f011b6ef:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b6f6:	83 ec 0c             	sub    $0xc,%esp
f011b6f9:	68 60 c4 12 f0       	push   $0xf012c460
f011b6fe:	e8 69 58 fe ff       	call   f0100f6c <cprintf>
f011b703:	83 c4 10             	add    $0x10,%esp

		//2 KB
		ptr = (char*)ptr_allocations[12];
f011b706:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011b70c:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[12]; ++i)
f011b70f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b716:	eb 1e                	jmp    f011b736 <test_kfree_bestfirstfit+0x14c2>
		{
			sums[12] += ptr[i] ;
f011b718:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011b71e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b721:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b724:	01 c8                	add    %ecx,%eax
f011b726:	8a 00                	mov    (%eax),%al
f011b728:	0f be c0             	movsbl %al,%eax
f011b72b:	01 d0                	add    %edx,%eax
f011b72d:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		}
		if (sums[11] != 11*lastIndices[11])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//2 KB
		ptr = (char*)ptr_allocations[12];
		for (i = 0; i < lastIndices[12]; ++i)
f011b733:	ff 45 f4             	incl   -0xc(%ebp)
f011b736:	8b 45 98             	mov    -0x68(%ebp),%eax
f011b739:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b73c:	7f da                	jg     f011b718 <test_kfree_bestfirstfit+0x14a4>
		{
			sums[12] += ptr[i] ;
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b73e:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
f011b744:	8b 55 98             	mov    -0x68(%ebp),%edx
f011b747:	89 d0                	mov    %edx,%eax
f011b749:	01 c0                	add    %eax,%eax
f011b74b:	01 d0                	add    %edx,%eax
f011b74d:	c1 e0 02             	shl    $0x2,%eax
f011b750:	39 c1                	cmp    %eax,%ecx
f011b752:	74 17                	je     f011b76b <test_kfree_bestfirstfit+0x14f7>
f011b754:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b75b:	83 ec 0c             	sub    $0xc,%esp
f011b75e:	68 60 c4 12 f0       	push   $0xf012c460
f011b763:	e8 04 58 fe ff       	call   f0100f6c <cprintf>
f011b768:	83 c4 10             	add    $0x10,%esp

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
f011b76b:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011b771:	89 45 c0             	mov    %eax,-0x40(%ebp)
		for (i = 0; i < lastIndices[13]; ++i)
f011b774:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011b77b:	eb 1e                	jmp    f011b79b <test_kfree_bestfirstfit+0x1527>
		{
			sums[13] += ptr[i] ;
f011b77d:	8b 95 4c ff ff ff    	mov    -0xb4(%ebp),%edx
f011b783:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011b786:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011b789:	01 c8                	add    %ecx,%eax
f011b78b:	8a 00                	mov    (%eax),%al
f011b78d:	0f be c0             	movsbl %al,%eax
f011b790:	01 d0                	add    %edx,%eax
f011b792:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		}
		if (sums[12] != 12*lastIndices[12])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }

		//1.5 KB
		ptr = (char*)ptr_allocations[13];
		for (i = 0; i < lastIndices[13]; ++i)
f011b798:	ff 45 f4             	incl   -0xc(%ebp)
f011b79b:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011b79e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b7a1:	7f da                	jg     f011b77d <test_kfree_bestfirstfit+0x1509>
		{
			sums[13] += ptr[i] ;
		}
		if (sums[13] != 13*lastIndices[13])	{ correct = 0; cprintf("kfree: invalid read - data is corrupted\n"); }
f011b7a3:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
f011b7a9:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011b7ac:	89 d0                	mov    %edx,%eax
f011b7ae:	01 c0                	add    %eax,%eax
f011b7b0:	01 d0                	add    %edx,%eax
f011b7b2:	c1 e0 02             	shl    $0x2,%eax
f011b7b5:	01 d0                	add    %edx,%eax
f011b7b7:	39 c1                	cmp    %eax,%ecx
f011b7b9:	74 17                	je     f011b7d2 <test_kfree_bestfirstfit+0x155e>
f011b7bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b7c2:	83 ec 0c             	sub    $0xc,%esp
f011b7c5:	68 60 c4 12 f0       	push   $0xf012c460
f011b7ca:	e8 9d 57 fe ff       	call   f0100f6c <cprintf>
f011b7cf:	83 c4 10             	add    $0x10,%esp
	}
	if (correct)	eval+=30 ;
f011b7d2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b7d6:	74 04                	je     f011b7dc <test_kfree_bestfirstfit+0x1568>
f011b7d8:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011b7dc:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b7e3:	c7 45 e0 00 00 00 f6 	movl   $0xf6000000,-0x20(%ebp)
f011b7ea:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011b7f1:	eb 4e                	jmp    f011b841 <test_kfree_bestfirstfit+0x15cd>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va, &ptr_table);
f011b7f3:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b7f6:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011b7fb:	83 ec 04             	sub    $0x4,%esp
f011b7fe:	8d 8d c4 fe ff ff    	lea    -0x13c(%ebp),%ecx
f011b804:	51                   	push   %ecx
f011b805:	52                   	push   %edx
f011b806:	50                   	push   %eax
f011b807:	e8 02 c9 fe ff       	call   f010810e <get_page_table>
f011b80c:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011b80f:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
f011b815:	85 c0                	test   %eax,%eax
f011b817:	75 1d                	jne    f011b836 <test_kfree_bestfirstfit+0x15c2>
			{
				if (correct)
f011b819:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b81d:	74 17                	je     f011b836 <test_kfree_bestfirstfit+0x15c2>
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
f011b81f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b826:	83 ec 0c             	sub    $0xc,%esp
f011b829:	68 8c c4 12 f0       	push   $0xf012c48c
f011b82e:	e8 39 57 fe ff       	call   f0100f6c <cprintf>
f011b833:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//check tables	[5%]
	{
		long long va;
		for (va = KERNEL_HEAP_START; va < (long long)KERNEL_HEAP_MAX; va+=PTSIZE)
f011b836:	81 45 e0 00 00 40 00 	addl   $0x400000,-0x20(%ebp)
f011b83d:	83 55 e4 00          	adcl   $0x0,-0x1c(%ebp)
f011b841:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b845:	78 ac                	js     f011b7f3 <test_kfree_bestfirstfit+0x157f>
f011b847:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011b84b:	7f 09                	jg     f011b856 <test_kfree_bestfirstfit+0x15e2>
f011b84d:	81 7d e0 ff ef ff ff 	cmpl   $0xffffefff,-0x20(%ebp)
f011b854:	76 9d                	jbe    f011b7f3 <test_kfree_bestfirstfit+0x157f>
				if (correct)
				{ correct = 0; cprintf("Wrong kfree: one of the kernel tables is wrongly removed! Tables should not be removed here in kfree\n"); }
			}
		}
	}
	if (correct)	eval+=5 ;
f011b856:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011b85a:	74 04                	je     f011b860 <test_kfree_bestfirstfit+0x15ec>
f011b85c:	83 45 f0 05          	addl   $0x5,-0x10(%ebp)

	cprintf("\ntest kfree completed. Eval = %d%\n", eval);
f011b860:	83 ec 08             	sub    $0x8,%esp
f011b863:	ff 75 f0             	pushl  -0x10(%ebp)
f011b866:	68 f4 c4 12 f0       	push   $0xf012c4f4
f011b86b:	e8 fc 56 fe ff       	call   f0100f6c <cprintf>
f011b870:	83 c4 10             	add    $0x10,%esp

	return 1;
f011b873:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011b878:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b87b:	5b                   	pop    %ebx
f011b87c:	5f                   	pop    %edi
f011b87d:	5d                   	pop    %ebp
f011b87e:	c3                   	ret    

f011b87f <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011b87f:	55                   	push   %ebp
f011b880:	89 e5                	mov    %esp,%ebp
f011b882:	57                   	push   %edi
f011b883:	53                   	push   %ebx
f011b884:	81 ec b0 35 00 00    	sub    $0x35b0,%esp
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011b88a:	83 ec 0c             	sub    $0xc,%esp
f011b88d:	68 00 be 12 f0       	push   $0xf012be00
f011b892:	e8 d5 56 fe ff       	call   f0100f6c <cprintf>
f011b897:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011b89a:	83 ec 0c             	sub    $0xc,%esp
f011b89d:	68 30 be 12 f0       	push   $0xf012be30
f011b8a2:	e8 c5 56 fe ff       	call   f0100f6c <cprintf>
f011b8a7:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011b8aa:	83 ec 0c             	sub    $0xc,%esp
f011b8ad:	68 00 be 12 f0       	push   $0xf012be00
f011b8b2:	e8 b5 56 fe ff       	call   f0100f6c <cprintf>
f011b8b7:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011b8ba:	c6 45 bf 80          	movb   $0x80,-0x41(%ebp)
	char maxByte = 0x7F;
f011b8be:	c6 45 be 7f          	movb   $0x7f,-0x42(%ebp)
	short minShort = 1<<15 ;
f011b8c2:	66 c7 45 bc 00 80    	movw   $0x8000,-0x44(%ebp)
	short maxShort = 0x7FFF;
f011b8c8:	66 c7 45 ba ff 7f    	movw   $0x7fff,-0x46(%ebp)
	int minInt = 1<<31 ;
f011b8ce:	c7 45 b4 00 00 00 80 	movl   $0x80000000,-0x4c(%ebp)
	int maxInt = 0x7FFFFFFF;
f011b8d5:	c7 45 b0 ff ff ff 7f 	movl   $0x7fffffff,-0x50(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011b8dc:	e8 28 1e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b8e1:	89 45 ac             	mov    %eax,-0x54(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011b8e4:	8d 95 14 ff ff ff    	lea    -0xec(%ebp),%edx
f011b8ea:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b8ef:	b8 00 00 00 00       	mov    $0x0,%eax
f011b8f4:	89 d7                	mov    %edx,%edi
f011b8f6:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011b8f8:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
f011b8fe:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b903:	b8 00 00 00 00       	mov    $0x0,%eax
f011b908:	89 d7                	mov    %edx,%edi
f011b90a:	f3 ab                	rep stos %eax,%es:(%edi)
	int eval = 0;
f011b90c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	bool correct = 1;
f011b913:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	void* ptr_allocations[20] = {0};
f011b91a:	8d 95 74 fe ff ff    	lea    -0x18c(%ebp),%edx
f011b920:	b9 14 00 00 00       	mov    $0x14,%ecx
f011b925:	b8 00 00 00 00       	mov    $0x0,%eax
f011b92a:	89 d7                	mov    %edx,%edi
f011b92c:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b92e:	e8 d6 1d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b933:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b936:	e8 06 8c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b93b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011b93e:	83 ec 0c             	sub    $0xc,%esp
f011b941:	68 00 fc 1f 00       	push   $0x1ffc00
f011b946:	e8 6c ce fe ff       	call   f01087b7 <kmalloc>
f011b94b:	83 c4 10             	add    $0x10,%esp
f011b94e:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b954:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011b95a:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011b95f:	74 17                	je     f011b978 <test_kheap_phys_addr+0xf9>
f011b961:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b968:	83 ec 0c             	sub    $0xc,%esp
f011b96b:	68 70 bf 12 f0       	push   $0xf012bf70
f011b970:	e8 f7 55 fe ff       	call   f0100f6c <cprintf>
f011b975:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011b978:	e8 c4 8b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b97d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011b980:	74 17                	je     f011b999 <test_kheap_phys_addr+0x11a>
f011b982:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b989:	83 ec 0c             	sub    $0xc,%esp
f011b98c:	68 c0 be 12 f0       	push   $0xf012bec0
f011b991:	e8 d6 55 fe ff       	call   f0100f6c <cprintf>
f011b996:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011b999:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011b99c:	e8 68 1d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b9a1:	29 c3                	sub    %eax,%ebx
f011b9a3:	89 d8                	mov    %ebx,%eax
f011b9a5:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011b9aa:	77 17                	ja     f011b9c3 <test_kheap_phys_addr+0x144>
f011b9ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9b3:	83 ec 0c             	sub    $0xc,%esp
f011b9b6:	68 2c bf 12 f0       	push   $0xf012bf2c
f011b9bb:	e8 ac 55 fe ff       	call   f0100f6c <cprintf>
f011b9c0:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011b9c3:	e8 41 1d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011b9c8:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011b9cb:	e8 71 8b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011b9d0:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011b9d3:	83 ec 0c             	sub    $0xc,%esp
f011b9d6:	68 00 fc 1f 00       	push   $0x1ffc00
f011b9db:	e8 d7 cd fe ff       	call   f01087b7 <kmalloc>
f011b9e0:	83 c4 10             	add    $0x10,%esp
f011b9e3:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011b9e9:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011b9ef:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011b9f4:	74 17                	je     f011ba0d <test_kheap_phys_addr+0x18e>
f011b9f6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011b9fd:	83 ec 0c             	sub    $0xc,%esp
f011ba00:	68 70 bf 12 f0       	push   $0xf012bf70
f011ba05:	e8 62 55 fe ff       	call   f0100f6c <cprintf>
f011ba0a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ba0d:	e8 2f 8b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ba12:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011ba15:	74 17                	je     f011ba2e <test_kheap_phys_addr+0x1af>
f011ba17:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba1e:	83 ec 0c             	sub    $0xc,%esp
f011ba21:	68 c0 be 12 f0       	push   $0xf012bec0
f011ba26:	e8 41 55 fe ff       	call   f0100f6c <cprintf>
f011ba2b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ba2e:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011ba31:	e8 d3 1c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ba36:	29 c3                	sub    %eax,%ebx
f011ba38:	89 d8                	mov    %ebx,%eax
f011ba3a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ba3f:	77 17                	ja     f011ba58 <test_kheap_phys_addr+0x1d9>
f011ba41:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011ba48:	83 ec 0c             	sub    $0xc,%esp
f011ba4b:	68 2c bf 12 f0       	push   $0xf012bf2c
f011ba50:	e8 17 55 fe ff       	call   f0100f6c <cprintf>
f011ba55:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011ba58:	e8 ac 1c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ba5d:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011ba60:	e8 dc 8a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ba65:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011ba68:	83 ec 0c             	sub    $0xc,%esp
f011ba6b:	68 00 04 00 00       	push   $0x400
f011ba70:	e8 42 cd fe ff       	call   f01087b7 <kmalloc>
f011ba75:	83 c4 10             	add    $0x10,%esp
f011ba78:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011ba7e:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011ba84:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011ba89:	76 28                	jbe    f011bab3 <test_kheap_phys_addr+0x234>
f011ba8b:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011ba91:	83 ec 0c             	sub    $0xc,%esp
f011ba94:	6a 00                	push   $0x0
f011ba96:	e8 12 cd fe ff       	call   f01087ad <sbrk>
f011ba9b:	83 c4 10             	add    $0x10,%esp
f011ba9e:	39 c3                	cmp    %eax,%ebx
f011baa0:	73 11                	jae    f011bab3 <test_kheap_phys_addr+0x234>
f011baa2:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011baa8:	89 c2                	mov    %eax,%edx
f011baaa:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011baaf:	39 c2                	cmp    %eax,%edx
f011bab1:	72 17                	jb     f011baca <test_kheap_phys_addr+0x24b>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bab3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011baba:	83 ec 0c             	sub    $0xc,%esp
f011babd:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011bac2:	e8 a5 54 fe ff       	call   f0100f6c <cprintf>
f011bac7:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011baca:	e8 72 8a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bacf:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bad2:	74 17                	je     f011baeb <test_kheap_phys_addr+0x26c>
f011bad4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011badb:	83 ec 0c             	sub    $0xc,%esp
f011bade:	68 c0 be 12 f0       	push   $0xf012bec0
f011bae3:	e8 84 54 fe ff       	call   f0100f6c <cprintf>
f011bae8:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011baeb:	e8 19 1c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011baf0:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011baf3:	e8 49 8a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011baf8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011bafb:	83 ec 0c             	sub    $0xc,%esp
f011bafe:	68 00 08 00 00       	push   $0x800
f011bb03:	e8 af cc fe ff       	call   f01087b7 <kmalloc>
f011bb08:	83 c4 10             	add    $0x10,%esp
f011bb0b:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011bb11:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bb17:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bb1c:	76 28                	jbe    f011bb46 <test_kheap_phys_addr+0x2c7>
f011bb1e:	8b 9d 80 fe ff ff    	mov    -0x180(%ebp),%ebx
f011bb24:	83 ec 0c             	sub    $0xc,%esp
f011bb27:	6a 00                	push   $0x0
f011bb29:	e8 7f cc fe ff       	call   f01087ad <sbrk>
f011bb2e:	83 c4 10             	add    $0x10,%esp
f011bb31:	39 c3                	cmp    %eax,%ebx
f011bb33:	73 11                	jae    f011bb46 <test_kheap_phys_addr+0x2c7>
f011bb35:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011bb3b:	89 c2                	mov    %eax,%edx
f011bb3d:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011bb42:	39 c2                	cmp    %eax,%edx
f011bb44:	72 17                	jb     f011bb5d <test_kheap_phys_addr+0x2de>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bb46:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb4d:	83 ec 0c             	sub    $0xc,%esp
f011bb50:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011bb55:	e8 12 54 fe ff       	call   f0100f6c <cprintf>
f011bb5a:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bb5d:	e8 df 89 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bb62:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bb65:	74 17                	je     f011bb7e <test_kheap_phys_addr+0x2ff>
f011bb67:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bb6e:	83 ec 0c             	sub    $0xc,%esp
f011bb71:	68 c0 be 12 f0       	push   $0xf012bec0
f011bb76:	e8 f1 53 fe ff       	call   f0100f6c <cprintf>
f011bb7b:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011bb7e:	e8 86 1b ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bb83:	89 45 a8             	mov    %eax,-0x58(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011bb86:	e8 b6 89 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bb8b:	89 45 a4             	mov    %eax,-0x5c(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011bb8e:	83 ec 0c             	sub    $0xc,%esp
f011bb91:	68 00 06 00 00       	push   $0x600
f011bb96:	e8 1c cc fe ff       	call   f01087b7 <kmalloc>
f011bb9b:	83 c4 10             	add    $0x10,%esp
f011bb9e:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011bba4:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bbaa:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011bbaf:	76 28                	jbe    f011bbd9 <test_kheap_phys_addr+0x35a>
f011bbb1:	8b 9d 84 fe ff ff    	mov    -0x17c(%ebp),%ebx
f011bbb7:	83 ec 0c             	sub    $0xc,%esp
f011bbba:	6a 00                	push   $0x0
f011bbbc:	e8 ec cb fe ff       	call   f01087ad <sbrk>
f011bbc1:	83 c4 10             	add    $0x10,%esp
f011bbc4:	39 c3                	cmp    %eax,%ebx
f011bbc6:	73 11                	jae    f011bbd9 <test_kheap_phys_addr+0x35a>
f011bbc8:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011bbce:	89 c2                	mov    %eax,%edx
f011bbd0:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011bbd5:	39 c2                	cmp    %eax,%edx
f011bbd7:	72 17                	jb     f011bbf0 <test_kheap_phys_addr+0x371>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011bbd9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bbe0:	83 ec 0c             	sub    $0xc,%esp
f011bbe3:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011bbe8:	e8 7f 53 fe ff       	call   f0100f6c <cprintf>
f011bbed:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bbf0:	e8 4c 89 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bbf5:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bbf8:	74 17                	je     f011bc11 <test_kheap_phys_addr+0x392>
f011bbfa:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc01:	83 ec 0c             	sub    $0xc,%esp
f011bc04:	68 c0 be 12 f0       	push   $0xf012bec0
f011bc09:	e8 5e 53 fe ff       	call   f0100f6c <cprintf>
f011bc0e:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011bc11:	e8 f3 1a ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bc16:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bc19:	e8 23 89 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bc1e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011bc21:	83 ec 0c             	sub    $0xc,%esp
f011bc24:	68 00 1c 00 00       	push   $0x1c00
f011bc29:	e8 89 cb fe ff       	call   f01087b7 <kmalloc>
f011bc2e:	83 c4 10             	add    $0x10,%esp
f011bc31:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bc37:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011bc3d:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011bc42:	74 17                	je     f011bc5b <test_kheap_phys_addr+0x3dc>
f011bc44:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc4b:	83 ec 0c             	sub    $0xc,%esp
f011bc4e:	68 70 bf 12 f0       	push   $0xf012bf70
f011bc53:	e8 14 53 fe ff       	call   f0100f6c <cprintf>
f011bc58:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bc5b:	e8 e1 88 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bc60:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bc63:	74 17                	je     f011bc7c <test_kheap_phys_addr+0x3fd>
f011bc65:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc6c:	83 ec 0c             	sub    $0xc,%esp
f011bc6f:	68 c0 be 12 f0       	push   $0xf012bec0
f011bc74:	e8 f3 52 fe ff       	call   f0100f6c <cprintf>
f011bc79:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bc7c:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bc7f:	e8 85 1a ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bc84:	29 c3                	sub    %eax,%ebx
f011bc86:	89 d8                	mov    %ebx,%eax
f011bc88:	83 f8 01             	cmp    $0x1,%eax
f011bc8b:	77 17                	ja     f011bca4 <test_kheap_phys_addr+0x425>
f011bc8d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bc94:	83 ec 0c             	sub    $0xc,%esp
f011bc97:	68 2c bf 12 f0       	push   $0xf012bf2c
f011bc9c:	e8 cb 52 fe ff       	call   f0100f6c <cprintf>
f011bca1:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011bca4:	e8 60 1a ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bca9:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bcac:	e8 90 88 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bcb1:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011bcb4:	83 ec 0c             	sub    $0xc,%esp
f011bcb7:	68 00 fc 2f 00       	push   $0x2ffc00
f011bcbc:	e8 f6 ca fe ff       	call   f01087b7 <kmalloc>
f011bcc1:	83 c4 10             	add    $0x10,%esp
f011bcc4:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bcca:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011bcd0:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011bcd5:	74 17                	je     f011bcee <test_kheap_phys_addr+0x46f>
f011bcd7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcde:	83 ec 0c             	sub    $0xc,%esp
f011bce1:	68 70 bf 12 f0       	push   $0xf012bf70
f011bce6:	e8 81 52 fe ff       	call   f0100f6c <cprintf>
f011bceb:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bcee:	e8 4e 88 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bcf3:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bcf6:	74 17                	je     f011bd0f <test_kheap_phys_addr+0x490>
f011bcf8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bcff:	83 ec 0c             	sub    $0xc,%esp
f011bd02:	68 c0 be 12 f0       	push   $0xf012bec0
f011bd07:	e8 60 52 fe ff       	call   f0100f6c <cprintf>
f011bd0c:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bd0f:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bd12:	e8 f2 19 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bd17:	29 c3                	sub    %eax,%ebx
f011bd19:	89 d8                	mov    %ebx,%eax
f011bd1b:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011bd20:	77 17                	ja     f011bd39 <test_kheap_phys_addr+0x4ba>
f011bd22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd29:	83 ec 0c             	sub    $0xc,%esp
f011bd2c:	68 2c bf 12 f0       	push   $0xf012bf2c
f011bd31:	e8 36 52 fe ff       	call   f0100f6c <cprintf>
f011bd36:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011bd39:	e8 cb 19 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bd3e:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bd41:	e8 fb 87 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bd46:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011bd49:	83 ec 0c             	sub    $0xc,%esp
f011bd4c:	68 00 fc 5f 00       	push   $0x5ffc00
f011bd51:	e8 61 ca fe ff       	call   f01087b7 <kmalloc>
f011bd56:	83 c4 10             	add    $0x10,%esp
f011bd59:	89 85 90 fe ff ff    	mov    %eax,-0x170(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bd5f:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011bd65:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011bd6a:	74 17                	je     f011bd83 <test_kheap_phys_addr+0x504>
f011bd6c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd73:	83 ec 0c             	sub    $0xc,%esp
f011bd76:	68 70 bf 12 f0       	push   $0xf012bf70
f011bd7b:	e8 ec 51 fe ff       	call   f0100f6c <cprintf>
f011bd80:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011bd83:	e8 b9 87 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bd88:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011bd8b:	74 17                	je     f011bda4 <test_kheap_phys_addr+0x525>
f011bd8d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bd94:	83 ec 0c             	sub    $0xc,%esp
f011bd97:	68 c0 be 12 f0       	push   $0xf012bec0
f011bd9c:	e8 cb 51 fe ff       	call   f0100f6c <cprintf>
f011bda1:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011bda4:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011bda7:	e8 5d 19 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bdac:	29 c3                	sub    %eax,%ebx
f011bdae:	89 d8                	mov    %ebx,%eax
f011bdb0:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011bdb5:	77 17                	ja     f011bdce <test_kheap_phys_addr+0x54f>
f011bdb7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bdbe:	83 ec 0c             	sub    $0xc,%esp
f011bdc1:	68 2c bf 12 f0       	push   $0xf012bf2c
f011bdc6:	e8 a1 51 fe ff       	call   f0100f6c <cprintf>
f011bdcb:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011bdce:	e8 36 19 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011bdd3:	89 45 a8             	mov    %eax,-0x58(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011bdd6:	e8 66 87 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011bddb:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011bdde:	83 ec 0c             	sub    $0xc,%esp
f011bde1:	68 00 38 00 00       	push   $0x3800
f011bde6:	e8 cc c9 fe ff       	call   f01087b7 <kmalloc>
f011bdeb:	83 c4 10             	add    $0x10,%esp
f011bdee:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011bdf4:	8b 85 94 fe ff ff    	mov    -0x16c(%ebp),%eax
f011bdfa:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011bdff:	74 17                	je     f011be18 <test_kheap_phys_addr+0x599>
f011be01:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be08:	83 ec 0c             	sub    $0xc,%esp
f011be0b:	68 70 bf 12 f0       	push   $0xf012bf70
f011be10:	e8 57 51 fe ff       	call   f0100f6c <cprintf>
f011be15:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011be18:	e8 24 87 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011be1d:	3b 45 a4             	cmp    -0x5c(%ebp),%eax
f011be20:	74 17                	je     f011be39 <test_kheap_phys_addr+0x5ba>
f011be22:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be29:	83 ec 0c             	sub    $0xc,%esp
f011be2c:	68 c0 be 12 f0       	push   $0xf012bec0
f011be31:	e8 36 51 fe ff       	call   f0100f6c <cprintf>
f011be36:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011be39:	8b 5d a8             	mov    -0x58(%ebp),%ebx
f011be3c:	e8 c8 18 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011be41:	29 c3                	sub    %eax,%ebx
f011be43:	89 d8                	mov    %ebx,%eax
f011be45:	83 f8 03             	cmp    $0x3,%eax
f011be48:	77 17                	ja     f011be61 <test_kheap_phys_addr+0x5e2>
f011be4a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011be51:	83 ec 0c             	sub    $0xc,%esp
f011be54:	68 2c bf 12 f0       	push   $0xf012bf2c
f011be59:	e8 0e 51 fe ff       	call   f0100f6c <cprintf>
f011be5e:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc only [30%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011be61:	c7 45 a0 00 70 d0 f8 	movl   $0xf8d07000,-0x60(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011be68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 offset = 1;
f011be6f:	c7 45 9c 01 00 00 00 	movl   $0x1,-0x64(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011be76:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011be7b:	05 00 10 00 00       	add    $0x1000,%eax
f011be80:	89 45 98             	mov    %eax,-0x68(%ebp)
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011be83:	8b 45 98             	mov    -0x68(%ebp),%eax
f011be86:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011be89:	eb 2e                	jmp    f011beb9 <test_kheap_phys_addr+0x63a>
		{
			allPAs[i++] = kheap_physical_address(va);
f011be8b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011be8e:	8d 43 01             	lea    0x1(%ebx),%eax
f011be91:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011be94:	83 ec 0c             	sub    $0xc,%esp
f011be97:	ff 75 e8             	pushl  -0x18(%ebp)
f011be9a:	e8 66 c9 fe ff       	call   f0108805 <kheap_physical_address>
f011be9f:	83 c4 10             	add    $0x10,%esp
f011bea2:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 offset = 1;
		uint32 startVA = da_limit + PAGE_SIZE;
		for (va = startVA; va < endVA; va+=PAGE_SIZE+offset)
f011bea9:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011beac:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011beaf:	01 d0                	add    %edx,%eax
f011beb1:	05 00 10 00 00       	add    $0x1000,%eax
f011beb6:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011beb9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bebc:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bebf:	72 ca                	jb     f011be8b <test_kheap_phys_addr+0x60c>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011bec1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bec4:	89 45 94             	mov    %eax,-0x6c(%ebp)
		i = 0;
f011bec7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011bece:	8b 45 98             	mov    -0x68(%ebp),%eax
f011bed1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011bed4:	e9 ce 00 00 00       	jmp    f011bfa7 <test_kheap_phys_addr+0x728>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bed9:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011bede:	83 ec 04             	sub    $0x4,%esp
f011bee1:	8d 95 70 fe ff ff    	lea    -0x190(%ebp),%edx
f011bee7:	52                   	push   %edx
f011bee8:	ff 75 e8             	pushl  -0x18(%ebp)
f011beeb:	50                   	push   %eax
f011beec:	e8 1d c2 fe ff       	call   f010810e <get_page_table>
f011bef1:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011bef4:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011befa:	85 c0                	test   %eax,%eax
f011befc:	75 1e                	jne    f011bf1c <test_kheap_phys_addr+0x69d>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011befe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bf05:	83 ec 04             	sub    $0x4,%esp
f011bf08:	68 18 c5 12 f0       	push   $0xf012c518
f011bf0d:	68 30 05 00 00       	push   $0x530
f011bf12:	68 72 c5 12 f0       	push   $0xf012c572
f011bf17:	e8 fe 43 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bf1c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf1f:	c1 e8 0c             	shr    $0xc,%eax
f011bf22:	25 ff 03 00 00       	and    $0x3ff,%eax
f011bf27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011bf2a:	eb 62                	jmp    f011bf8e <test_kheap_phys_addr+0x70f>
			{
				if (((ptr_table[j] & 0xFFFFF000)+(va & 0x00000FFF))!= allPAs[i])
f011bf2c:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011bf32:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011bf35:	c1 e2 02             	shl    $0x2,%edx
f011bf38:	01 d0                	add    %edx,%eax
f011bf3a:	8b 00                	mov    (%eax),%eax
f011bf3c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011bf41:	89 c2                	mov    %eax,%edx
f011bf43:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf46:	25 ff 0f 00 00       	and    $0xfff,%eax
f011bf4b:	01 c2                	add    %eax,%edx
f011bf4d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bf50:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011bf57:	39 c2                	cmp    %eax,%edx
f011bf59:	74 1d                	je     f011bf78 <test_kheap_phys_addr+0x6f9>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011bf5b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bf5f:	74 17                	je     f011bf78 <test_kheap_phys_addr+0x6f9>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011bf61:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011bf68:	83 ec 0c             	sub    $0xc,%esp
f011bf6b:	68 8a c5 12 f0       	push   $0xf012c58a
f011bf70:	e8 f7 4f fe ff       	call   f0100f6c <cprintf>
f011bf75:	83 c4 10             	add    $0x10,%esp
				}
				va+=PAGE_SIZE+offset;
f011bf78:	8b 55 9c             	mov    -0x64(%ebp),%edx
f011bf7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bf7e:	01 d0                	add    %edx,%eax
f011bf80:	05 00 10 00 00       	add    $0x1000,%eax
f011bf85:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011bf88:	ff 45 e4             	incl   -0x1c(%ebp)
f011bf8b:	ff 45 f4             	incl   -0xc(%ebp)
f011bf8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011bf91:	3b 45 94             	cmp    -0x6c(%ebp),%eax
f011bf94:	7d 11                	jge    f011bfa7 <test_kheap_phys_addr+0x728>
f011bf96:	81 7d e4 ff 03 00 00 	cmpl   $0x3ff,-0x1c(%ebp)
f011bf9d:	7f 08                	jg     f011bfa7 <test_kheap_phys_addr+0x728>
f011bf9f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bfa2:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bfa5:	72 85                	jb     f011bf2c <test_kheap_phys_addr+0x6ad>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011bfa7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011bfaa:	3b 45 a0             	cmp    -0x60(%ebp),%eax
f011bfad:	0f 82 26 ff ff ff    	jb     f011bed9 <test_kheap_phys_addr+0x65a>
				}
				va+=PAGE_SIZE+offset;
			}
		}
	}
	if (correct)	eval+=30 ;
f011bfb3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011bfb7:	74 04                	je     f011bfbd <test_kheap_phys_addr+0x73e>
f011bfb9:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011bfbd:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011bfc4:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)
f011bfcb:	e9 b0 00 00 00       	jmp    f011c080 <test_kheap_phys_addr+0x801>
		{
			va = (uint32)ptr_allocations[i];
f011bfd0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011bfd3:	8b 84 85 74 fe ff ff 	mov    -0x18c(%ebp,%eax,4),%eax
f011bfda:	89 45 90             	mov    %eax,-0x70(%ebp)
			pa = kheap_physical_address(va);
f011bfdd:	83 ec 0c             	sub    $0xc,%esp
f011bfe0:	ff 75 90             	pushl  -0x70(%ebp)
f011bfe3:	e8 1d c8 fe ff       	call   f0108805 <kheap_physical_address>
f011bfe8:	83 c4 10             	add    $0x10,%esp
f011bfeb:	89 45 8c             	mov    %eax,-0x74(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011bfee:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011bff3:	83 ec 04             	sub    $0x4,%esp
f011bff6:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011bffc:	52                   	push   %edx
f011bffd:	ff 75 90             	pushl  -0x70(%ebp)
f011c000:	50                   	push   %eax
f011c001:	e8 08 c1 fe ff       	call   f010810e <get_page_table>
f011c006:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c009:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c00f:	85 c0                	test   %eax,%eax
f011c011:	75 1e                	jne    f011c031 <test_kheap_phys_addr+0x7b2>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c013:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c01a:	83 ec 04             	sub    $0x4,%esp
f011c01d:	68 18 c5 12 f0       	push   $0xf012c518
f011c022:	68 4c 05 00 00       	push   $0x54c
f011c027:	68 72 c5 12 f0       	push   $0xf012c572
f011c02c:	e8 e9 42 fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011c031:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c037:	8b 55 90             	mov    -0x70(%ebp),%edx
f011c03a:	c1 ea 0c             	shr    $0xc,%edx
f011c03d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c043:	c1 e2 02             	shl    $0x2,%edx
f011c046:	01 d0                	add    %edx,%eax
f011c048:	8b 00                	mov    (%eax),%eax
f011c04a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c04f:	89 c2                	mov    %eax,%edx
f011c051:	8b 45 90             	mov    -0x70(%ebp),%eax
f011c054:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c059:	01 d0                	add    %edx,%eax
f011c05b:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011c05e:	74 1d                	je     f011c07d <test_kheap_phys_addr+0x7fe>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011c060:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c064:	74 17                	je     f011c07d <test_kheap_phys_addr+0x7fe>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c066:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c06d:	83 ec 0c             	sub    $0xc,%esp
f011c070:	68 8a c5 12 f0       	push   $0xf012c58a
f011c075:	e8 f2 4e fe ff       	call   f0100f6c <cprintf>
f011c07a:	83 c4 10             	add    $0x10,%esp
	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address after kmalloc only [10%]
	{
		int i;
		uint32 va, pa;
		for (i = 2; i <= 4; i++)
f011c07d:	ff 45 e0             	incl   -0x20(%ebp)
f011c080:	83 7d e0 04          	cmpl   $0x4,-0x20(%ebp)
f011c084:	0f 8e 46 ff ff ff    	jle    f011bfd0 <test_kheap_phys_addr+0x751>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=10 ;
f011c08a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c08e:	74 04                	je     f011c094 <test_kheap_phys_addr+0x815>
f011c090:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	correct = 1 ;
f011c094:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011c09b:	e8 69 16 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c0a0:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011c0a3:	e8 99 84 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c0a8:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011c0ab:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c0b1:	83 ec 0c             	sub    $0xc,%esp
f011c0b4:	50                   	push   %eax
f011c0b5:	e8 17 c7 fe ff       	call   f01087d1 <kfree>
f011c0ba:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c0bd:	e8 7f 84 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c0c2:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c0c5:	74 17                	je     f011c0de <test_kheap_phys_addr+0x85f>
f011c0c7:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c0ce:	83 ec 0c             	sub    $0xc,%esp
f011c0d1:	68 c0 be 12 f0       	push   $0xf012bec0
f011c0d6:	e8 91 4e fe ff       	call   f0100f6c <cprintf>
f011c0db:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c0de:	e8 26 16 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c0e3:	89 c2                	mov    %eax,%edx
f011c0e5:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c0e8:	29 c2                	sub    %eax,%edx
f011c0ea:	89 d0                	mov    %edx,%eax
f011c0ec:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c0f1:	77 17                	ja     f011c10a <test_kheap_phys_addr+0x88b>
f011c0f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c0fa:	83 ec 0c             	sub    $0xc,%esp
f011c0fd:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011c102:	e8 65 4e fe ff       	call   f0100f6c <cprintf>
f011c107:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c10a:	e8 fa 15 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c10f:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c112:	e8 2a 84 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c117:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011c11a:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c120:	83 ec 0c             	sub    $0xc,%esp
f011c123:	50                   	push   %eax
f011c124:	e8 a8 c6 fe ff       	call   f01087d1 <kfree>
f011c129:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c12c:	e8 10 84 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c131:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c134:	74 17                	je     f011c14d <test_kheap_phys_addr+0x8ce>
f011c136:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c13d:	83 ec 0c             	sub    $0xc,%esp
f011c140:	68 c0 be 12 f0       	push   $0xf012bec0
f011c145:	e8 22 4e fe ff       	call   f0100f6c <cprintf>
f011c14a:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c14d:	e8 b7 15 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c152:	89 c2                	mov    %eax,%edx
f011c154:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c157:	29 c2                	sub    %eax,%edx
f011c159:	89 d0                	mov    %edx,%eax
f011c15b:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c160:	77 17                	ja     f011c179 <test_kheap_phys_addr+0x8fa>
f011c162:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c169:	83 ec 0c             	sub    $0xc,%esp
f011c16c:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011c171:	e8 f6 4d fe ff       	call   f0100f6c <cprintf>
f011c176:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011c179:	e8 8b 15 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c17e:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c181:	e8 bb 83 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c186:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011c189:	8b 85 90 fe ff ff    	mov    -0x170(%ebp),%eax
f011c18f:	83 ec 0c             	sub    $0xc,%esp
f011c192:	50                   	push   %eax
f011c193:	e8 39 c6 fe ff       	call   f01087d1 <kfree>
f011c198:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c19b:	e8 a1 83 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c1a0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011c1a3:	74 17                	je     f011c1bc <test_kheap_phys_addr+0x93d>
f011c1a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1ac:	83 ec 0c             	sub    $0xc,%esp
f011c1af:	68 c0 be 12 f0       	push   $0xf012bec0
f011c1b4:	e8 b3 4d fe ff       	call   f0100f6c <cprintf>
f011c1b9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011c1bc:	e8 48 15 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c1c1:	89 c2                	mov    %eax,%edx
f011c1c3:	8b 45 88             	mov    -0x78(%ebp),%eax
f011c1c6:	29 c2                	sub    %eax,%edx
f011c1c8:	89 d0                	mov    %edx,%eax
f011c1ca:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011c1cf:	77 17                	ja     f011c1e8 <test_kheap_phys_addr+0x969>
f011c1d1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c1d8:	83 ec 0c             	sub    $0xc,%esp
f011c1db:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011c1e0:	e8 87 4d fe ff       	call   f0100f6c <cprintf>
f011c1e5:	83 c4 10             	add    $0x10,%esp
	}

	//[PAGE ALLOCATOR] test kheap_physical_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011c1e8:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
f011c1ef:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011c1f6:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c1fb:	05 00 10 00 00       	add    $0x1000,%eax
f011c200:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011c206:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c20c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c20f:	eb 25                	jmp    f011c236 <test_kheap_phys_addr+0x9b7>
		{
			allPAs[i++] = kheap_physical_address(va);
f011c211:	8b 5d f4             	mov    -0xc(%ebp),%ebx
f011c214:	8d 43 01             	lea    0x1(%ebx),%eax
f011c217:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011c21a:	83 ec 0c             	sub    $0xc,%esp
f011c21d:	ff 75 dc             	pushl  -0x24(%ebp)
f011c220:	e8 e0 c5 fe ff       	call   f0108805 <kheap_physical_address>
f011c225:	83 c4 10             	add    $0x10,%esp
f011c228:	89 84 9d 48 ca ff ff 	mov    %eax,-0x35b8(%ebp,%ebx,4)
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 allPAs[(13*Mega + 24*kilo + INITIAL_KHEAP_ALLOCATIONS)/PAGE_SIZE] ;
		i = 0;
		uint32 startVA = da_limit + PAGE_SIZE;

		for (va = startVA; va < endVA; va+=PAGE_SIZE)
f011c22f:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
f011c236:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c239:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c23c:	72 d3                	jb     f011c211 <test_kheap_phys_addr+0x992>
		{
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
f011c23e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c241:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
		i = 0;
f011c247:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011c24e:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011c254:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011c257:	e9 f1 00 00 00       	jmp    f011c34d <test_kheap_phys_addr+0xace>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c25c:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c261:	83 ec 04             	sub    $0x4,%esp
f011c264:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011c26a:	52                   	push   %edx
f011c26b:	ff 75 dc             	pushl  -0x24(%ebp)
f011c26e:	50                   	push   %eax
f011c26f:	e8 9a be fe ff       	call   f010810e <get_page_table>
f011c274:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c277:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c27d:	85 c0                	test   %eax,%eax
f011c27f:	75 24                	jne    f011c2a5 <test_kheap_phys_addr+0xa26>
				if (correct)
f011c281:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c285:	74 1e                	je     f011c2a5 <test_kheap_phys_addr+0xa26>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c287:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c28e:	83 ec 04             	sub    $0x4,%esp
f011c291:	68 18 c5 12 f0       	push   $0xf012c518
f011c296:	68 86 05 00 00       	push   $0x586
f011c29b:	68 72 c5 12 f0       	push   $0xf012c572
f011c2a0:	e8 75 40 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011c2a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c2a8:	c1 e8 0c             	shr    $0xc,%eax
f011c2ab:	25 ff 03 00 00       	and    $0x3ff,%eax
f011c2b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011c2b3:	eb 78                	jmp    f011c32d <test_kheap_phys_addr+0xaae>
			{
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : va & 0x00000FFF)) != allPAs[i])
f011c2b5:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c2bb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2be:	c1 e2 02             	shl    $0x2,%edx
f011c2c1:	01 d0                	add    %edx,%eax
f011c2c3:	8b 00                	mov    (%eax),%eax
f011c2c5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c2ca:	89 c1                	mov    %eax,%ecx
f011c2cc:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011c2d2:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011c2d5:	c1 e2 02             	shl    $0x2,%edx
f011c2d8:	01 d0                	add    %edx,%eax
f011c2da:	8b 00                	mov    (%eax),%eax
f011c2dc:	83 e0 01             	and    $0x1,%eax
f011c2df:	85 c0                	test   %eax,%eax
f011c2e1:	74 0a                	je     f011c2ed <test_kheap_phys_addr+0xa6e>
f011c2e3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c2e6:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c2eb:	eb 05                	jmp    f011c2f2 <test_kheap_phys_addr+0xa73>
f011c2ed:	b8 00 00 00 00       	mov    $0x0,%eax
f011c2f2:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f011c2f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c2f8:	8b 84 85 48 ca ff ff 	mov    -0x35b8(%ebp,%eax,4),%eax
f011c2ff:	39 c2                	cmp    %eax,%edx
f011c301:	74 1d                	je     f011c320 <test_kheap_phys_addr+0xaa1>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011c303:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c307:	74 17                	je     f011c320 <test_kheap_phys_addr+0xaa1>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c309:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c310:	83 ec 0c             	sub    $0xc,%esp
f011c313:	68 8a c5 12 f0       	push   $0xf012c58a
f011c318:	e8 4f 4c fe ff       	call   f0100f6c <cprintf>
f011c31d:	83 c4 10             	add    $0x10,%esp
				}
				va += PAGE_SIZE;
f011c320:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < ii && j < 1024 && va < endVA; ++j, ++i)
f011c327:	ff 45 d8             	incl   -0x28(%ebp)
f011c32a:	ff 45 f4             	incl   -0xc(%ebp)
f011c32d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c330:	3b 85 78 ff ff ff    	cmp    -0x88(%ebp),%eax
f011c336:	7d 15                	jge    f011c34d <test_kheap_phys_addr+0xace>
f011c338:	81 7d d8 ff 03 00 00 	cmpl   $0x3ff,-0x28(%ebp)
f011c33f:	7f 0c                	jg     f011c34d <test_kheap_phys_addr+0xace>
f011c341:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c344:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c347:	0f 82 68 ff ff ff    	jb     f011c2b5 <test_kheap_phys_addr+0xa36>
			allPAs[i++] = kheap_physical_address(va);
		}
		int ii = i ;
		i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011c34d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011c350:	3b 45 80             	cmp    -0x80(%ebp),%eax
f011c353:	0f 82 03 ff ff ff    	jb     f011c25c <test_kheap_phys_addr+0x9dd>
				}
				va += PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011c359:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c35d:	74 04                	je     f011c363 <test_kheap_phys_addr+0xae4>
f011c35f:	83 45 f0 14          	addl   $0x14,-0x10(%ebp)

	correct = 1 ;
f011c363:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c36a:	c7 45 d4 00 00 00 f6 	movl   $0xf6000000,-0x2c(%ebp)
f011c371:	e9 af 00 00 00       	jmp    f011c425 <test_kheap_phys_addr+0xba6>
		{
			pa = kheap_physical_address(va);
f011c376:	83 ec 0c             	sub    $0xc,%esp
f011c379:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c37c:	e8 84 c4 fe ff       	call   f0108805 <kheap_physical_address>
f011c381:	83 c4 10             	add    $0x10,%esp
f011c384:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011c38a:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c38f:	83 ec 04             	sub    $0x4,%esp
f011c392:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011c398:	52                   	push   %edx
f011c399:	ff 75 d4             	pushl  -0x2c(%ebp)
f011c39c:	50                   	push   %eax
f011c39d:	e8 6c bd fe ff       	call   f010810e <get_page_table>
f011c3a2:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c3a5:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c3ab:	85 c0                	test   %eax,%eax
f011c3ad:	75 24                	jne    f011c3d3 <test_kheap_phys_addr+0xb54>
				if (correct)
f011c3af:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c3b3:	74 1e                	je     f011c3d3 <test_kheap_phys_addr+0xb54>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c3b5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c3bc:	83 ec 04             	sub    $0x4,%esp
f011c3bf:	68 18 c5 12 f0       	push   $0xf012c518
f011c3c4:	68 a1 05 00 00       	push   $0x5a1
f011c3c9:	68 72 c5 12 f0       	push   $0xf012c572
f011c3ce:	e8 47 3f fe ff       	call   f010031a <_panic>

			if (((ptr_table[PTX(va)] & 0xFFFFF000)+(va & 0x00000FFF))!= pa)
f011c3d3:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011c3d9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011c3dc:	c1 ea 0c             	shr    $0xc,%edx
f011c3df:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011c3e5:	c1 e2 02             	shl    $0x2,%edx
f011c3e8:	01 d0                	add    %edx,%eax
f011c3ea:	8b 00                	mov    (%eax),%eax
f011c3ec:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c3f1:	89 c2                	mov    %eax,%edx
f011c3f3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011c3f6:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c3fb:	01 d0                	add    %edx,%eax
f011c3fd:	3b 85 74 ff ff ff    	cmp    -0x8c(%ebp),%eax
f011c403:	74 1d                	je     f011c422 <test_kheap_phys_addr+0xba3>
			{
				//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
				if (correct)
f011c405:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c409:	74 17                	je     f011c422 <test_kheap_phys_addr+0xba3>
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c40b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c412:	83 ec 0c             	sub    $0xc,%esp
f011c415:	68 8a c5 12 f0       	push   $0xf012c58a
f011c41a:	e8 4d 4b fe ff       	call   f0100f6c <cprintf>
f011c41f:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_physical_address on the entire allocated area [30%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011c422:	ff 45 d4             	incl   -0x2c(%ebp)
f011c425:	83 ec 0c             	sub    $0xc,%esp
f011c428:	6a 00                	push   $0x0
f011c42a:	e8 7e c3 fe ff       	call   f01087ad <sbrk>
f011c42f:	83 c4 10             	add    $0x10,%esp
f011c432:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f011c435:	0f 87 3b ff ff ff    	ja     f011c376 <test_kheap_phys_addr+0xaf7>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
			}
		}
	}
	if (correct)	eval+=30 ;
f011c43b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c43f:	74 04                	je     f011c445 <test_kheap_phys_addr+0xbc6>
f011c441:	83 45 f0 1e          	addl   $0x1e,-0x10(%ebp)

	correct = 1 ;
f011c445:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
f011c44c:	c7 85 70 ff ff ff 00 	movl   $0xf9001000,-0x90(%ebp)
f011c453:	10 00 f9 
		i = 0;
f011c456:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011c45d:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c463:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011c466:	eb 0a                	jmp    f011c472 <test_kheap_phys_addr+0xbf3>
		{
			i++;
f011c468:	ff 45 f4             	incl   -0xc(%ebp)
	//test kheap_physical_address on non-mapped area [10%]
	{
		uint32 va;
		uint32 startVA = ACTUAL_START + 16*Mega;
		i = 0;
		for (va = startVA; va < KERNEL_HEAP_MAX; va+=PAGE_SIZE)
f011c46b:	81 45 d0 00 10 00 00 	addl   $0x1000,-0x30(%ebp)
f011c472:	81 7d d0 ff ef ff ff 	cmpl   $0xffffefff,-0x30(%ebp)
f011c479:	76 ed                	jbe    f011c468 <test_kheap_phys_addr+0xbe9>
		{
			i++;
		}
		int ii = i ;
f011c47b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c47e:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
		i = 0;
f011c484:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011c48b:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c491:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011c494:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f011c49b:	e9 13 01 00 00       	jmp    f011c5b3 <test_kheap_phys_addr+0xd34>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, (uint32)va2, &ptr_table);
f011c4a0:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011c4a3:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011c4a8:	83 ec 04             	sub    $0x4,%esp
f011c4ab:	8d 8d 60 fe ff ff    	lea    -0x1a0(%ebp),%ecx
f011c4b1:	51                   	push   %ecx
f011c4b2:	52                   	push   %edx
f011c4b3:	50                   	push   %eax
f011c4b4:	e8 55 bc fe ff       	call   f010810e <get_page_table>
f011c4b9:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011c4bc:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c4c2:	85 c0                	test   %eax,%eax
f011c4c4:	75 24                	jne    f011c4ea <test_kheap_phys_addr+0xc6b>
			{
				if (correct)
f011c4c6:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c4ca:	74 1e                	je     f011c4ea <test_kheap_phys_addr+0xc6b>
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011c4cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c4d3:	83 ec 04             	sub    $0x4,%esp
f011c4d6:	68 18 c5 12 f0       	push   $0xf012c518
f011c4db:	68 c2 05 00 00       	push   $0x5c2
f011c4e0:	68 72 c5 12 f0       	push   $0xf012c572
f011c4e5:	e8 30 3e fe ff       	call   f010031a <_panic>
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011c4ea:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f011c4f1:	e9 9a 00 00 00       	jmp    f011c590 <test_kheap_phys_addr+0xd11>
			{
				//if ((ptr_table[j] & 0xFFFFF000) != allPAs[i])
				unsigned int page_va = startVA+i*PAGE_SIZE;
f011c4f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c4f9:	c1 e0 0c             	shl    $0xc,%eax
f011c4fc:	89 c2                	mov    %eax,%edx
f011c4fe:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f011c504:	01 d0                	add    %edx,%eax
f011c506:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
				unsigned int supposed_kheap_phys_add = kheap_physical_address(page_va);
f011c50c:	83 ec 0c             	sub    $0xc,%esp
f011c50f:	ff b5 68 ff ff ff    	pushl  -0x98(%ebp)
f011c515:	e8 eb c2 fe ff       	call   f0108805 <kheap_physical_address>
f011c51a:	83 c4 10             	add    $0x10,%esp
f011c51d:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
				if (((ptr_table[j] & 0xFFFFF000)+((ptr_table[j] & PERM_PRESENT) == 0? 0 : page_va & 0x00000FFF)) != supposed_kheap_phys_add)
f011c523:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c529:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c52c:	c1 e2 02             	shl    $0x2,%edx
f011c52f:	01 d0                	add    %edx,%eax
f011c531:	8b 00                	mov    (%eax),%eax
f011c533:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011c538:	89 c1                	mov    %eax,%ecx
f011c53a:	8b 85 60 fe ff ff    	mov    -0x1a0(%ebp),%eax
f011c540:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011c543:	c1 e2 02             	shl    $0x2,%edx
f011c546:	01 d0                	add    %edx,%eax
f011c548:	8b 00                	mov    (%eax),%eax
f011c54a:	83 e0 01             	and    $0x1,%eax
f011c54d:	85 c0                	test   %eax,%eax
f011c54f:	74 0d                	je     f011c55e <test_kheap_phys_addr+0xcdf>
f011c551:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f011c557:	25 ff 0f 00 00       	and    $0xfff,%eax
f011c55c:	eb 05                	jmp    f011c563 <test_kheap_phys_addr+0xce4>
f011c55e:	b8 00 00 00 00       	mov    $0x0,%eax
f011c563:	01 c8                	add    %ecx,%eax
f011c565:	3b 85 64 ff ff ff    	cmp    -0x9c(%ebp),%eax
f011c56b:	74 1d                	je     f011c58a <test_kheap_phys_addr+0xd0b>
				{
					//cprintf("\nVA = %x, table entry = %x, khep_pa = %x\n",va2 + j*PAGE_SIZE, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
					if (correct)
f011c56d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c571:	74 17                	je     f011c58a <test_kheap_phys_addr+0xd0b>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
f011c573:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011c57a:	83 ec 0c             	sub    $0xc,%esp
f011c57d:	68 8a c5 12 f0       	push   $0xf012c58a
f011c582:	e8 e5 49 fe ff       	call   f0100f6c <cprintf>
f011c587:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
			{
				if (correct)
				{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
			}
			for (j = 0; i < ii && j < 1024; ++j, ++i)
f011c58a:	ff 45 cc             	incl   -0x34(%ebp)
f011c58d:	ff 45 f4             	incl   -0xc(%ebp)
f011c590:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011c593:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f011c599:	7d 0d                	jge    f011c5a8 <test_kheap_phys_addr+0xd29>
f011c59b:	81 7d cc ff 03 00 00 	cmpl   $0x3ff,-0x34(%ebp)
f011c5a2:	0f 8e 4e ff ff ff    	jle    f011c4f6 <test_kheap_phys_addr+0xc77>
		}
		int ii = i ;
		i = 0;
		int j;
		long long va2;
		for (va2 = startVA; va2 < (long long)KERNEL_HEAP_MAX; va2+=PTSIZE)
f011c5a8:	81 45 c0 00 00 40 00 	addl   $0x400000,-0x40(%ebp)
f011c5af:	83 55 c4 00          	adcl   $0x0,-0x3c(%ebp)
f011c5b3:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011c5b7:	0f 88 e3 fe ff ff    	js     f011c4a0 <test_kheap_phys_addr+0xc21>
f011c5bd:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f011c5c1:	7f 0d                	jg     f011c5d0 <test_kheap_phys_addr+0xd51>
f011c5c3:	81 7d c0 ff ef ff ff 	cmpl   $0xffffefff,-0x40(%ebp)
f011c5ca:	0f 86 d0 fe ff ff    	jbe    f011c4a0 <test_kheap_phys_addr+0xc21>
					{ correct = 0; cprintf("Wrong kheap_physical_address\n"); }
				}
			}
		}
	}
	if (correct)	eval+=10 ;
f011c5d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011c5d4:	74 04                	je     f011c5da <test_kheap_phys_addr+0xd5b>
f011c5d6:	83 45 f0 0a          	addl   $0xa,-0x10(%ebp)

	cprintf("\ntest kheap_physical_address completed. Eval = %d%\n", eval);
f011c5da:	83 ec 08             	sub    $0x8,%esp
f011c5dd:	ff 75 f0             	pushl  -0x10(%ebp)
f011c5e0:	68 a8 c5 12 f0       	push   $0xf012c5a8
f011c5e5:	e8 82 49 fe ff       	call   f0100f6c <cprintf>
f011c5ea:	83 c4 10             	add    $0x10,%esp

	return 1;
f011c5ed:	b8 01 00 00 00       	mov    $0x1,%eax

}
f011c5f2:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011c5f5:	5b                   	pop    %ebx
f011c5f6:	5f                   	pop    %edi
f011c5f7:	5d                   	pop    %ebp
f011c5f8:	c3                   	ret    

f011c5f9 <test_kheap_virt_addr>:

int test_kheap_virt_addr()
{
f011c5f9:	55                   	push   %ebp
f011c5fa:	89 e5                	mov    %esp,%ebp
f011c5fc:	57                   	push   %edi
f011c5fd:	56                   	push   %esi
f011c5fe:	53                   	push   %ebx
f011c5ff:	81 ec 9c 01 00 00    	sub    $0x19c,%esp
f011c605:	89 e0                	mov    %esp,%eax
f011c607:	89 c6                	mov    %eax,%esi
	 * INSTEAD OF "EQUAL" RULE SINCE IT'S POSSIBLE FOR SOME
	 * IMPLEMENTATIONS TO DYNAMICALLY ALLOCATE SPECIAL DATA
	 * STRUCTURE TO MANAGE THE PAGE ALLOCATOR.
	 *********************************************************/

	cprintf("==============================================\n");
f011c609:	83 ec 0c             	sub    $0xc,%esp
f011c60c:	68 00 be 12 f0       	push   $0xf012be00
f011c611:	e8 56 49 fe ff       	call   f0100f6c <cprintf>
f011c616:	83 c4 10             	add    $0x10,%esp
	cprintf("MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
f011c619:	83 ec 0c             	sub    $0xc,%esp
f011c61c:	68 30 be 12 f0       	push   $0xf012be30
f011c621:	e8 46 49 fe ff       	call   f0100f6c <cprintf>
f011c626:	83 c4 10             	add    $0x10,%esp
	cprintf("==============================================\n");
f011c629:	83 ec 0c             	sub    $0xc,%esp
f011c62c:	68 00 be 12 f0       	push   $0xf012be00
f011c631:	e8 36 49 fe ff       	call   f0100f6c <cprintf>
f011c636:	83 c4 10             	add    $0x10,%esp

	char minByte = 1<<7;
f011c639:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
	char maxByte = 0x7F;
f011c63d:	c6 45 c6 7f          	movb   $0x7f,-0x3a(%ebp)
	short minShort = 1<<15 ;
f011c641:	66 c7 45 c4 00 80    	movw   $0x8000,-0x3c(%ebp)
	short maxShort = 0x7FFF;
f011c647:	66 c7 45 c2 ff 7f    	movw   $0x7fff,-0x3e(%ebp)
	int minInt = 1<<31 ;
f011c64d:	c7 45 bc 00 00 00 80 	movl   $0x80000000,-0x44(%ebp)
	int maxInt = 0x7FFFFFFF;
f011c654:	c7 45 b8 ff ff ff 7f 	movl   $0x7fffffff,-0x48(%ebp)
	char *byteArr, *byteArr2 ;
	short *shortArr, *shortArr2 ;
	int *intArr;
	struct MyStruct *structArr ;
	int lastIndexOfByte, lastIndexOfByte2, lastIndexOfShort, lastIndexOfShort2, lastIndexOfInt, lastIndexOfStruct;
	int start_freeFrames = sys_calculate_free_frames() ;
f011c65b:	e8 a9 10 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c660:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	//malloc some spaces
	int i, freeFrames, freeDiskFrames ;
	char* ptr;
	int lastIndices[20] = {0};
f011c663:	8d 95 0c ff ff ff    	lea    -0xf4(%ebp),%edx
f011c669:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c66e:	b8 00 00 00 00       	mov    $0x0,%eax
f011c673:	89 d7                	mov    %edx,%edi
f011c675:	f3 ab                	rep stos %eax,%es:(%edi)
	int sums[20] = {0};
f011c677:	8d 95 bc fe ff ff    	lea    -0x144(%ebp),%edx
f011c67d:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c682:	b8 00 00 00 00       	mov    $0x0,%eax
f011c687:	89 d7                	mov    %edx,%edi
f011c689:	f3 ab                	rep stos %eax,%es:(%edi)

	int eval = 0;
f011c68b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011c692:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	void* ptr_allocations[20] = {0};
f011c699:	8d 95 6c fe ff ff    	lea    -0x194(%ebp),%edx
f011c69f:	b9 14 00 00 00       	mov    $0x14,%ecx
f011c6a4:	b8 00 00 00 00       	mov    $0x0,%eax
f011c6a9:	89 d7                	mov    %edx,%edi
f011c6ab:	f3 ab                	rep stos %eax,%es:(%edi)
	{
		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c6ad:	e8 57 10 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c6b2:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c6b5:	e8 87 7e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c6ba:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[0] = kmalloc(2*Mega-kilo);
f011c6bd:	83 ec 0c             	sub    $0xc,%esp
f011c6c0:	68 00 fc 1f 00       	push   $0x1ffc00
f011c6c5:	e8 ed c0 fe ff       	call   f01087b7 <kmalloc>
f011c6ca:	83 c4 10             	add    $0x10,%esp
f011c6cd:	89 85 6c fe ff ff    	mov    %eax,-0x194(%ebp)
		if ((uint32) ptr_allocations[0] !=  (ACTUAL_START)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c6d3:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011c6d9:	3d 00 10 00 f8       	cmp    $0xf8001000,%eax
f011c6de:	74 17                	je     f011c6f7 <test_kheap_virt_addr+0xfe>
f011c6e0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c6e7:	83 ec 0c             	sub    $0xc,%esp
f011c6ea:	68 70 bf 12 f0       	push   $0xf012bf70
f011c6ef:	e8 78 48 fe ff       	call   f0100f6c <cprintf>
f011c6f4:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c6f7:	e8 45 7e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c6fc:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c6ff:	74 17                	je     f011c718 <test_kheap_virt_addr+0x11f>
f011c701:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c708:	83 ec 0c             	sub    $0xc,%esp
f011c70b:	68 c0 be 12 f0       	push   $0xf012bec0
f011c710:	e8 57 48 fe ff       	call   f0100f6c <cprintf>
f011c715:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c718:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c71b:	e8 e9 0f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c720:	29 c3                	sub    %eax,%ebx
f011c722:	89 d8                	mov    %ebx,%eax
f011c724:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c729:	77 17                	ja     f011c742 <test_kheap_virt_addr+0x149>
f011c72b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c732:	83 ec 0c             	sub    $0xc,%esp
f011c735:	68 2c bf 12 f0       	push   $0xf012bf2c
f011c73a:	e8 2d 48 fe ff       	call   f0100f6c <cprintf>
f011c73f:	83 c4 10             	add    $0x10,%esp

		//2 MB
		freeFrames = sys_calculate_free_frames() ;
f011c742:	e8 c2 0f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c747:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c74a:	e8 f2 7d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c74f:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[1] = kmalloc(2*Mega-kilo);
f011c752:	83 ec 0c             	sub    $0xc,%esp
f011c755:	68 00 fc 1f 00       	push   $0x1ffc00
f011c75a:	e8 58 c0 fe ff       	call   f01087b7 <kmalloc>
f011c75f:	83 c4 10             	add    $0x10,%esp
f011c762:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
		if ((uint32) ptr_allocations[1] != (ACTUAL_START + 2*Mega)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c768:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011c76e:	3d 00 10 20 f8       	cmp    $0xf8201000,%eax
f011c773:	74 17                	je     f011c78c <test_kheap_virt_addr+0x193>
f011c775:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c77c:	83 ec 0c             	sub    $0xc,%esp
f011c77f:	68 70 bf 12 f0       	push   $0xf012bf70
f011c784:	e8 e3 47 fe ff       	call   f0100f6c <cprintf>
f011c789:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c78c:	e8 b0 7d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c791:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c794:	74 17                	je     f011c7ad <test_kheap_virt_addr+0x1b4>
f011c796:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c79d:	83 ec 0c             	sub    $0xc,%esp
f011c7a0:	68 c0 be 12 f0       	push   $0xf012bec0
f011c7a5:	e8 c2 47 fe ff       	call   f0100f6c <cprintf>
f011c7aa:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 512) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c7ad:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c7b0:	e8 54 0f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c7b5:	29 c3                	sub    %eax,%ebx
f011c7b7:	89 d8                	mov    %ebx,%eax
f011c7b9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011c7be:	77 17                	ja     f011c7d7 <test_kheap_virt_addr+0x1de>
f011c7c0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c7c7:	83 ec 0c             	sub    $0xc,%esp
f011c7ca:	68 2c bf 12 f0       	push   $0xf012bf2c
f011c7cf:	e8 98 47 fe ff       	call   f0100f6c <cprintf>
f011c7d4:	83 c4 10             	add    $0x10,%esp

		//[DYNAMIC ALLOCATOR]
		{
			//1 KB
			freeFrames = sys_calculate_free_frames() ;
f011c7d7:	e8 2d 0f ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c7dc:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c7df:	e8 5d 7d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c7e4:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[2] = kmalloc(1*kilo);
f011c7e7:	83 ec 0c             	sub    $0xc,%esp
f011c7ea:	68 00 04 00 00       	push   $0x400
f011c7ef:	e8 c3 bf fe ff       	call   f01087b7 <kmalloc>
f011c7f4:	83 c4 10             	add    $0x10,%esp
f011c7f7:	89 85 74 fe ff ff    	mov    %eax,-0x18c(%ebp)
			if ((uint32) ptr_allocations[2] < KERNEL_HEAP_START || ptr_allocations[2] >= sbrk(0) || (uint32) ptr_allocations[2] >= da_limit)
f011c7fd:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c803:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c808:	76 28                	jbe    f011c832 <test_kheap_virt_addr+0x239>
f011c80a:	8b 9d 74 fe ff ff    	mov    -0x18c(%ebp),%ebx
f011c810:	83 ec 0c             	sub    $0xc,%esp
f011c813:	6a 00                	push   $0x0
f011c815:	e8 93 bf fe ff       	call   f01087ad <sbrk>
f011c81a:	83 c4 10             	add    $0x10,%esp
f011c81d:	39 c3                	cmp    %eax,%ebx
f011c81f:	73 11                	jae    f011c832 <test_kheap_virt_addr+0x239>
f011c821:	8b 85 74 fe ff ff    	mov    -0x18c(%ebp),%eax
f011c827:	89 c2                	mov    %eax,%edx
f011c829:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c82e:	39 c2                	cmp    %eax,%edx
f011c830:	72 17                	jb     f011c849 <test_kheap_virt_addr+0x250>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c832:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c839:	83 ec 0c             	sub    $0xc,%esp
f011c83c:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011c841:	e8 26 47 fe ff       	call   f0100f6c <cprintf>
f011c846:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c849:	e8 f3 7c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c84e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c851:	74 17                	je     f011c86a <test_kheap_virt_addr+0x271>
f011c853:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c85a:	83 ec 0c             	sub    $0xc,%esp
f011c85d:	68 c0 be 12 f0       	push   $0xf012bec0
f011c862:	e8 05 47 fe ff       	call   f0100f6c <cprintf>
f011c867:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//2 KB
			freeFrames = sys_calculate_free_frames() ;
f011c86a:	e8 9a 0e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c86f:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c872:	e8 ca 7c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c877:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[3] = kmalloc(2*kilo);
f011c87a:	83 ec 0c             	sub    $0xc,%esp
f011c87d:	68 00 08 00 00       	push   $0x800
f011c882:	e8 30 bf fe ff       	call   f01087b7 <kmalloc>
f011c887:	83 c4 10             	add    $0x10,%esp
f011c88a:	89 85 78 fe ff ff    	mov    %eax,-0x188(%ebp)
			if ((uint32) ptr_allocations[3] < KERNEL_HEAP_START || ptr_allocations[3] >= sbrk(0) || (uint32) ptr_allocations[3] >= da_limit)
f011c890:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c896:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c89b:	76 28                	jbe    f011c8c5 <test_kheap_virt_addr+0x2cc>
f011c89d:	8b 9d 78 fe ff ff    	mov    -0x188(%ebp),%ebx
f011c8a3:	83 ec 0c             	sub    $0xc,%esp
f011c8a6:	6a 00                	push   $0x0
f011c8a8:	e8 00 bf fe ff       	call   f01087ad <sbrk>
f011c8ad:	83 c4 10             	add    $0x10,%esp
f011c8b0:	39 c3                	cmp    %eax,%ebx
f011c8b2:	73 11                	jae    f011c8c5 <test_kheap_virt_addr+0x2cc>
f011c8b4:	8b 85 78 fe ff ff    	mov    -0x188(%ebp),%eax
f011c8ba:	89 c2                	mov    %eax,%edx
f011c8bc:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c8c1:	39 c2                	cmp    %eax,%edx
f011c8c3:	72 17                	jb     f011c8dc <test_kheap_virt_addr+0x2e3>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c8c5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8cc:	83 ec 0c             	sub    $0xc,%esp
f011c8cf:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011c8d4:	e8 93 46 fe ff       	call   f0100f6c <cprintf>
f011c8d9:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c8dc:	e8 60 7c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c8e1:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c8e4:	74 17                	je     f011c8fd <test_kheap_virt_addr+0x304>
f011c8e6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c8ed:	83 ec 0c             	sub    $0xc,%esp
f011c8f0:	68 c0 be 12 f0       	push   $0xf012bec0
f011c8f5:	e8 72 46 fe ff       	call   f0100f6c <cprintf>
f011c8fa:	83 c4 10             	add    $0x10,%esp
			//if ((freeFrames - sys_calculate_free_frames()) != 1) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }

			//1.5 KB
			freeFrames = sys_calculate_free_frames() ;
f011c8fd:	e8 07 0e ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c902:	89 45 b0             	mov    %eax,-0x50(%ebp)
			freeDiskFrames = pf_calculate_free_frames() ;
f011c905:	e8 37 7c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c90a:	89 45 ac             	mov    %eax,-0x54(%ebp)
			ptr_allocations[4] = kmalloc(3*kilo/2);
f011c90d:	83 ec 0c             	sub    $0xc,%esp
f011c910:	68 00 06 00 00       	push   $0x600
f011c915:	e8 9d be fe ff       	call   f01087b7 <kmalloc>
f011c91a:	83 c4 10             	add    $0x10,%esp
f011c91d:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
			if ((uint32) ptr_allocations[4] < KERNEL_HEAP_START || ptr_allocations[4] >= sbrk(0) || (uint32) ptr_allocations[4] >= da_limit)
f011c923:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c929:	3d ff ff ff f5       	cmp    $0xf5ffffff,%eax
f011c92e:	76 28                	jbe    f011c958 <test_kheap_virt_addr+0x35f>
f011c930:	8b 9d 7c fe ff ff    	mov    -0x184(%ebp),%ebx
f011c936:	83 ec 0c             	sub    $0xc,%esp
f011c939:	6a 00                	push   $0x0
f011c93b:	e8 6d be fe ff       	call   f01087ad <sbrk>
f011c940:	83 c4 10             	add    $0x10,%esp
f011c943:	39 c3                	cmp    %eax,%ebx
f011c945:	73 11                	jae    f011c958 <test_kheap_virt_addr+0x35f>
f011c947:	8b 85 7c fe ff ff    	mov    -0x184(%ebp),%eax
f011c94d:	89 c2                	mov    %eax,%edx
f011c94f:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011c954:	39 c2                	cmp    %eax,%edx
f011c956:	72 17                	jb     f011c96f <test_kheap_virt_addr+0x376>
			{ correct = 0; cprintf("Wrong start address for the allocated space... should allocated by the dynamic allocator! check return address of kmalloc and/or sbrk\n"); }
f011c958:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c95f:	83 ec 0c             	sub    $0xc,%esp
f011c962:	68 c0 bf 12 f0       	push   $0xf012bfc0
f011c967:	e8 00 46 fe ff       	call   f0100f6c <cprintf>
f011c96c:	83 c4 10             	add    $0x10,%esp
			if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c96f:	e8 cd 7b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c974:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c977:	74 17                	je     f011c990 <test_kheap_virt_addr+0x397>
f011c979:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c980:	83 ec 0c             	sub    $0xc,%esp
f011c983:	68 c0 be 12 f0       	push   $0xf012bec0
f011c988:	e8 df 45 fe ff       	call   f0100f6c <cprintf>
f011c98d:	83 c4 10             	add    $0x10,%esp
		}

		//7 KB
		freeFrames = sys_calculate_free_frames() ;
f011c990:	e8 74 0d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011c995:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011c998:	e8 a4 7b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c99d:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[5] = kmalloc(7*kilo);
f011c9a0:	83 ec 0c             	sub    $0xc,%esp
f011c9a3:	68 00 1c 00 00       	push   $0x1c00
f011c9a8:	e8 0a be fe ff       	call   f01087b7 <kmalloc>
f011c9ad:	83 c4 10             	add    $0x10,%esp
f011c9b0:	89 85 80 fe ff ff    	mov    %eax,-0x180(%ebp)
		if ((uint32) ptr_allocations[5] != (ACTUAL_START + 4*Mega /*+ 8*kilo*/)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011c9b6:	8b 85 80 fe ff ff    	mov    -0x180(%ebp),%eax
f011c9bc:	3d 00 10 40 f8       	cmp    $0xf8401000,%eax
f011c9c1:	74 17                	je     f011c9da <test_kheap_virt_addr+0x3e1>
f011c9c3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9ca:	83 ec 0c             	sub    $0xc,%esp
f011c9cd:	68 70 bf 12 f0       	push   $0xf012bf70
f011c9d2:	e8 95 45 fe ff       	call   f0100f6c <cprintf>
f011c9d7:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011c9da:	e8 62 7b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011c9df:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011c9e2:	74 17                	je     f011c9fb <test_kheap_virt_addr+0x402>
f011c9e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011c9eb:	83 ec 0c             	sub    $0xc,%esp
f011c9ee:	68 c0 be 12 f0       	push   $0xf012bec0
f011c9f3:	e8 74 45 fe ff       	call   f0100f6c <cprintf>
f011c9f8:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 2) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011c9fb:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011c9fe:	e8 06 0d ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ca03:	29 c3                	sub    %eax,%ebx
f011ca05:	89 d8                	mov    %ebx,%eax
f011ca07:	83 f8 01             	cmp    $0x1,%eax
f011ca0a:	77 17                	ja     f011ca23 <test_kheap_virt_addr+0x42a>
f011ca0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca13:	83 ec 0c             	sub    $0xc,%esp
f011ca16:	68 2c bf 12 f0       	push   $0xf012bf2c
f011ca1b:	e8 4c 45 fe ff       	call   f0100f6c <cprintf>
f011ca20:	83 c4 10             	add    $0x10,%esp

		//3 MB
		freeFrames = sys_calculate_free_frames() ;
f011ca23:	e8 e1 0c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ca28:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ca2b:	e8 11 7b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ca30:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[6] = kmalloc(3*Mega-kilo);
f011ca33:	83 ec 0c             	sub    $0xc,%esp
f011ca36:	68 00 fc 2f 00       	push   $0x2ffc00
f011ca3b:	e8 77 bd fe ff       	call   f01087b7 <kmalloc>
f011ca40:	83 c4 10             	add    $0x10,%esp
f011ca43:	89 85 84 fe ff ff    	mov    %eax,-0x17c(%ebp)
		if ((uint32) ptr_allocations[6] != (ACTUAL_START + 4*Mega + 8*kilo) ) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011ca49:	8b 85 84 fe ff ff    	mov    -0x17c(%ebp),%eax
f011ca4f:	3d 00 30 40 f8       	cmp    $0xf8403000,%eax
f011ca54:	74 17                	je     f011ca6d <test_kheap_virt_addr+0x474>
f011ca56:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca5d:	83 ec 0c             	sub    $0xc,%esp
f011ca60:	68 70 bf 12 f0       	push   $0xf012bf70
f011ca65:	e8 02 45 fe ff       	call   f0100f6c <cprintf>
f011ca6a:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ca6d:	e8 cf 7a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ca72:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011ca75:	74 17                	je     f011ca8e <test_kheap_virt_addr+0x495>
f011ca77:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ca7e:	83 ec 0c             	sub    $0xc,%esp
f011ca81:	68 c0 be 12 f0       	push   $0xf012bec0
f011ca86:	e8 e1 44 fe ff       	call   f0100f6c <cprintf>
f011ca8b:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 768) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011ca8e:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011ca91:	e8 73 0c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ca96:	29 c3                	sub    %eax,%ebx
f011ca98:	89 d8                	mov    %ebx,%eax
f011ca9a:	3d ff 02 00 00       	cmp    $0x2ff,%eax
f011ca9f:	77 17                	ja     f011cab8 <test_kheap_virt_addr+0x4bf>
f011caa1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011caa8:	83 ec 0c             	sub    $0xc,%esp
f011caab:	68 2c bf 12 f0       	push   $0xf012bf2c
f011cab0:	e8 b7 44 fe ff       	call   f0100f6c <cprintf>
f011cab5:	83 c4 10             	add    $0x10,%esp

		//6 MB
		freeFrames = sys_calculate_free_frames() ;
f011cab8:	e8 4c 0c ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cabd:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cac0:	e8 7c 7a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011cac5:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[7] = kmalloc(6*Mega-kilo);
f011cac8:	83 ec 0c             	sub    $0xc,%esp
f011cacb:	68 00 fc 5f 00       	push   $0x5ffc00
f011cad0:	e8 e2 bc fe ff       	call   f01087b7 <kmalloc>
f011cad5:	83 c4 10             	add    $0x10,%esp
f011cad8:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
		if ((uint32) ptr_allocations[7] != (ACTUAL_START + 7*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cade:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011cae4:	3d 00 30 70 f8       	cmp    $0xf8703000,%eax
f011cae9:	74 17                	je     f011cb02 <test_kheap_virt_addr+0x509>
f011caeb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011caf2:	83 ec 0c             	sub    $0xc,%esp
f011caf5:	68 70 bf 12 f0       	push   $0xf012bf70
f011cafa:	e8 6d 44 fe ff       	call   f0100f6c <cprintf>
f011caff:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cb02:	e8 3a 7a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011cb07:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cb0a:	74 17                	je     f011cb23 <test_kheap_virt_addr+0x52a>
f011cb0c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb13:	83 ec 0c             	sub    $0xc,%esp
f011cb16:	68 c0 be 12 f0       	push   $0xf012bec0
f011cb1b:	e8 4c 44 fe ff       	call   f0100f6c <cprintf>
f011cb20:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 1536) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cb23:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cb26:	e8 de 0b ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cb2b:	29 c3                	sub    %eax,%ebx
f011cb2d:	89 d8                	mov    %ebx,%eax
f011cb2f:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011cb34:	77 17                	ja     f011cb4d <test_kheap_virt_addr+0x554>
f011cb36:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb3d:	83 ec 0c             	sub    $0xc,%esp
f011cb40:	68 2c bf 12 f0       	push   $0xf012bf2c
f011cb45:	e8 22 44 fe ff       	call   f0100f6c <cprintf>
f011cb4a:	83 c4 10             	add    $0x10,%esp

		//14 KB
		freeFrames = sys_calculate_free_frames() ;
f011cb4d:	e8 b7 0b ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cb52:	89 45 b0             	mov    %eax,-0x50(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011cb55:	e8 e7 79 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011cb5a:	89 45 ac             	mov    %eax,-0x54(%ebp)
		ptr_allocations[8] = kmalloc(14*kilo);
f011cb5d:	83 ec 0c             	sub    $0xc,%esp
f011cb60:	68 00 38 00 00       	push   $0x3800
f011cb65:	e8 4d bc fe ff       	call   f01087b7 <kmalloc>
f011cb6a:	83 c4 10             	add    $0x10,%esp
f011cb6d:	89 85 8c fe ff ff    	mov    %eax,-0x174(%ebp)
		if ((uint32) ptr_allocations[8] != (ACTUAL_START + 13*Mega + 8*kilo)) { correct = 0; cprintf("Wrong start address for the allocated space... check return address of kmalloc\n"); }
f011cb73:	8b 85 8c fe ff ff    	mov    -0x174(%ebp),%eax
f011cb79:	3d 00 30 d0 f8       	cmp    $0xf8d03000,%eax
f011cb7e:	74 17                	je     f011cb97 <test_kheap_virt_addr+0x59e>
f011cb80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cb87:	83 ec 0c             	sub    $0xc,%esp
f011cb8a:	68 70 bf 12 f0       	push   $0xf012bf70
f011cb8f:	e8 d8 43 fe ff       	call   f0100f6c <cprintf>
f011cb94:	83 c4 10             	add    $0x10,%esp
		if ((pf_calculate_free_frames() - freeDiskFrames) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cb97:	e8 a5 79 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011cb9c:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011cb9f:	74 17                	je     f011cbb8 <test_kheap_virt_addr+0x5bf>
f011cba1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cba8:	83 ec 0c             	sub    $0xc,%esp
f011cbab:	68 c0 be 12 f0       	push   $0xf012bec0
f011cbb0:	e8 b7 43 fe ff       	call   f0100f6c <cprintf>
f011cbb5:	83 c4 10             	add    $0x10,%esp
		if ((freeFrames - sys_calculate_free_frames()) < 4) { correct = 0; cprintf("Wrong allocation: pages are not loaded successfully into memory\n"); }
f011cbb8:	8b 5d b0             	mov    -0x50(%ebp),%ebx
f011cbbb:	e8 49 0b ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cbc0:	29 c3                	sub    %eax,%ebx
f011cbc2:	89 d8                	mov    %ebx,%eax
f011cbc4:	83 f8 03             	cmp    $0x3,%eax
f011cbc7:	77 17                	ja     f011cbe0 <test_kheap_virt_addr+0x5e7>
f011cbc9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cbd0:	83 ec 0c             	sub    $0xc,%esp
f011cbd3:	68 2c bf 12 f0       	push   $0xf012bf2c
f011cbd8:	e8 8f 43 fe ff       	call   f0100f6c <cprintf>
f011cbdd:	83 c4 10             	add    $0x10,%esp
	}

	uint32 allocatedSpace = (13*Mega + 24*kilo + (INITIAL_KHEAP_ALLOCATIONS));
f011cbe0:	c7 45 a8 00 60 d0 00 	movl   $0xd06000,-0x58(%ebp)
	uint32 allPAs[allocatedSpace/PAGE_SIZE] ;
f011cbe7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011cbea:	c1 e8 0c             	shr    $0xc,%eax
f011cbed:	89 c2                	mov    %eax,%edx
f011cbef:	4a                   	dec    %edx
f011cbf0:	89 55 a4             	mov    %edx,-0x5c(%ebp)
f011cbf3:	c1 e0 02             	shl    $0x2,%eax
f011cbf6:	8d 50 03             	lea    0x3(%eax),%edx
f011cbf9:	b8 10 00 00 00       	mov    $0x10,%eax
f011cbfe:	48                   	dec    %eax
f011cbff:	01 d0                	add    %edx,%eax
f011cc01:	bf 10 00 00 00       	mov    $0x10,%edi
f011cc06:	ba 00 00 00 00       	mov    $0x0,%edx
f011cc0b:	f7 f7                	div    %edi
f011cc0d:	6b c0 10             	imul   $0x10,%eax,%eax
f011cc10:	29 c4                	sub    %eax,%esp
f011cc12:	89 e0                	mov    %esp,%eax
f011cc14:	83 c0 03             	add    $0x3,%eax
f011cc17:	c1 e8 02             	shr    $0x2,%eax
f011cc1a:	c1 e0 02             	shl    $0x2,%eax
f011cc1d:	89 45 a0             	mov    %eax,-0x60(%ebp)
	int numOfFrames = allocatedSpace/PAGE_SIZE ;
f011cc20:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011cc23:	c1 e8 0c             	shr    $0xc,%eax
f011cc26:	89 45 9c             	mov    %eax,-0x64(%ebp)

	//test kheap_virtual_address after kmalloc only [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011cc29:	c7 45 98 00 70 d0 f8 	movl   $0xf8d07000,-0x68(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011cc30:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011cc35:	05 00 10 00 00       	add    $0x1000,%eax
f011cc3a:	89 45 94             	mov    %eax,-0x6c(%ebp)
		int i = 0;
f011cc3d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		int j;
		for (va = startVA; va < endVA; )
f011cc44:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011cc47:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011cc4a:	e9 2d 01 00 00       	jmp    f011cd7c <test_kheap_virt_addr+0x783>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011cc4f:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011cc54:	83 ec 04             	sub    $0x4,%esp
f011cc57:	8d 95 68 fe ff ff    	lea    -0x198(%ebp),%edx
f011cc5d:	52                   	push   %edx
f011cc5e:	ff 75 dc             	pushl  -0x24(%ebp)
f011cc61:	50                   	push   %eax
f011cc62:	e8 a7 b4 fe ff       	call   f010810e <get_page_table>
f011cc67:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011cc6a:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011cc70:	85 c0                	test   %eax,%eax
f011cc72:	75 1e                	jne    f011cc92 <test_kheap_virt_addr+0x699>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011cc74:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cc7b:	83 ec 04             	sub    $0x4,%esp
f011cc7e:	68 18 c5 12 f0       	push   $0xf012c518
f011cc83:	68 5e 06 00 00       	push   $0x65e
f011cc88:	68 72 c5 12 f0       	push   $0xf012c572
f011cc8d:	e8 88 36 fe ff       	call   f010031a <_panic>

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011cc92:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cc95:	c1 e8 0c             	shr    $0xc,%eax
f011cc98:	25 ff 03 00 00       	and    $0x3ff,%eax
f011cc9d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011cca0:	e9 ba 00 00 00       	jmp    f011cd5f <test_kheap_virt_addr+0x766>
			{
				uint32 offset = j;
f011cca5:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011cca8:	89 45 90             	mov    %eax,-0x70(%ebp)
				allPAs[i] = (ptr_table[j] & 0xFFFFF000) + offset;
f011ccab:	8b 85 68 fe ff ff    	mov    -0x198(%ebp),%eax
f011ccb1:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011ccb4:	c1 e2 02             	shl    $0x2,%edx
f011ccb7:	01 d0                	add    %edx,%eax
f011ccb9:	8b 00                	mov    (%eax),%eax
f011ccbb:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011ccc0:	89 c2                	mov    %eax,%edx
f011ccc2:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ccc5:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011ccc8:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cccb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ccce:	89 0c 90             	mov    %ecx,(%eax,%edx,4)
				uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011ccd1:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ccd4:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ccd7:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011ccda:	83 ec 0c             	sub    $0xc,%esp
f011ccdd:	50                   	push   %eax
f011ccde:	e8 08 bb fe ff       	call   f01087eb <kheap_virtual_address>
f011cce3:	83 c4 10             	add    $0x10,%esp
f011cce6:	89 45 8c             	mov    %eax,-0x74(%ebp)
				//cprintf("va to check = %x\n", va);
				if (retrievedVA != (va+offset))
f011cce9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011ccec:	8b 45 90             	mov    -0x70(%ebp),%eax
f011ccef:	01 d0                	add    %edx,%eax
f011ccf1:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f011ccf4:	74 5c                	je     f011cd52 <test_kheap_virt_addr+0x759>
				{
					if (correct)
f011ccf6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ccfa:	74 56                	je     f011cd52 <test_kheap_virt_addr+0x759>
					{
						cprintf("\nretrievedVA = %x, Actual VA = %x, table entry = %x, khep_pa = %x\n",retrievedVA, va + offset /*+ j*PAGE_SIZE*/, (ptr_table[j] & 0xFFFFF000) , allPAs[i]);
f011ccfc:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011ccff:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011cd02:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cd05:	8b 95 68 fe ff ff    	mov    -0x198(%ebp),%edx
f011cd0b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011cd0e:	c1 e1 02             	shl    $0x2,%ecx
f011cd11:	01 ca                	add    %ecx,%edx
f011cd13:	8b 12                	mov    (%edx),%edx
f011cd15:	89 d1                	mov    %edx,%ecx
f011cd17:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
f011cd1d:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f011cd20:	8b 55 90             	mov    -0x70(%ebp),%edx
f011cd23:	01 da                	add    %ebx,%edx
f011cd25:	83 ec 0c             	sub    $0xc,%esp
f011cd28:	50                   	push   %eax
f011cd29:	51                   	push   %ecx
f011cd2a:	52                   	push   %edx
f011cd2b:	ff 75 8c             	pushl  -0x74(%ebp)
f011cd2e:	68 dc c5 12 f0       	push   $0xf012c5dc
f011cd33:	e8 34 42 fe ff       	call   f0100f6c <cprintf>
f011cd38:	83 c4 20             	add    $0x20,%esp
						correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011cd3b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cd42:	83 ec 0c             	sub    $0xc,%esp
f011cd45:	68 1f c6 12 f0       	push   $0xf012c61f
f011cd4a:	e8 1d 42 fe ff       	call   f0100f6c <cprintf>
f011cd4f:	83 c4 10             	add    $0x10,%esp
					}
				}
				va+=PAGE_SIZE;
f011cd52:	81 45 dc 00 10 00 00 	addl   $0x1000,-0x24(%ebp)
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
			if (ptr_table == NULL)
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }

			for (j = PTX(va); i < numOfFrames && j < 1024 && va < endVA; ++j, ++i)
f011cd59:	ff 45 d4             	incl   -0x2c(%ebp)
f011cd5c:	ff 45 d8             	incl   -0x28(%ebp)
f011cd5f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011cd62:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f011cd65:	7d 15                	jge    f011cd7c <test_kheap_virt_addr+0x783>
f011cd67:	81 7d d4 ff 03 00 00 	cmpl   $0x3ff,-0x2c(%ebp)
f011cd6e:	7f 0c                	jg     f011cd7c <test_kheap_virt_addr+0x783>
f011cd70:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cd73:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011cd76:	0f 82 29 ff ff ff    	jb     f011cca5 <test_kheap_virt_addr+0x6ac>
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		for (va = startVA; va < endVA; )
f011cd7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011cd7f:	3b 45 98             	cmp    -0x68(%ebp),%eax
f011cd82:	0f 82 c7 fe ff ff    	jb     f011cc4f <test_kheap_virt_addr+0x656>
				}
				va+=PAGE_SIZE;
			}
		}
	}
	if (correct)	eval+=20 ;
f011cd88:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cd8c:	74 04                	je     f011cd92 <test_kheap_virt_addr+0x799>
f011cd8e:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011cd92:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//kfree some of the allocated spaces
	{
		//kfree 1st 2 MB
		int freeFrames = sys_calculate_free_frames() ;
f011cd99:	e8 6b 09 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cd9e:	89 45 88             	mov    %eax,-0x78(%ebp)
		int freeDiskFrames = pf_calculate_free_frames() ;
f011cda1:	e8 9b 77 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011cda6:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[0]);
f011cda9:	8b 85 6c fe ff ff    	mov    -0x194(%ebp),%eax
f011cdaf:	83 ec 0c             	sub    $0xc,%esp
f011cdb2:	50                   	push   %eax
f011cdb3:	e8 19 ba fe ff       	call   f01087d1 <kfree>
f011cdb8:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011cdbb:	e8 81 77 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011cdc0:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cdc3:	74 17                	je     f011cddc <test_kheap_virt_addr+0x7e3>
f011cdc5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdcc:	83 ec 0c             	sub    $0xc,%esp
f011cdcf:	68 c0 be 12 f0       	push   $0xf012bec0
f011cdd4:	e8 93 41 fe ff       	call   f0100f6c <cprintf>
f011cdd9:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512 ) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011cddc:	e8 28 09 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cde1:	89 c2                	mov    %eax,%edx
f011cde3:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cde6:	29 c2                	sub    %eax,%edx
f011cde8:	89 d0                	mov    %edx,%eax
f011cdea:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011cdef:	77 17                	ja     f011ce08 <test_kheap_virt_addr+0x80f>
f011cdf1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cdf8:	83 ec 0c             	sub    $0xc,%esp
f011cdfb:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011ce00:	e8 67 41 fe ff       	call   f0100f6c <cprintf>
f011ce05:	83 c4 10             	add    $0x10,%esp

		//kfree 2nd 2 MB
		freeFrames = sys_calculate_free_frames() ;
f011ce08:	e8 fc 08 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ce0d:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce10:	e8 2c 77 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ce15:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[1]);
f011ce18:	8b 85 70 fe ff ff    	mov    -0x190(%ebp),%eax
f011ce1e:	83 ec 0c             	sub    $0xc,%esp
f011ce21:	50                   	push   %eax
f011ce22:	e8 aa b9 fe ff       	call   f01087d1 <kfree>
f011ce27:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce2a:	e8 12 77 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ce2f:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011ce32:	74 17                	je     f011ce4b <test_kheap_virt_addr+0x852>
f011ce34:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce3b:	83 ec 0c             	sub    $0xc,%esp
f011ce3e:	68 c0 be 12 f0       	push   $0xf012bec0
f011ce43:	e8 24 41 fe ff       	call   f0100f6c <cprintf>
f011ce48:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 512) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ce4b:	e8 b9 08 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ce50:	89 c2                	mov    %eax,%edx
f011ce52:	8b 45 88             	mov    -0x78(%ebp),%eax
f011ce55:	29 c2                	sub    %eax,%edx
f011ce57:	89 d0                	mov    %edx,%eax
f011ce59:	3d ff 01 00 00       	cmp    $0x1ff,%eax
f011ce5e:	77 17                	ja     f011ce77 <test_kheap_virt_addr+0x87e>
f011ce60:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ce67:	83 ec 0c             	sub    $0xc,%esp
f011ce6a:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011ce6f:	e8 f8 40 fe ff       	call   f0100f6c <cprintf>
f011ce74:	83 c4 10             	add    $0x10,%esp

		//kfree 6 MB
		freeFrames = sys_calculate_free_frames() ;
f011ce77:	e8 8d 08 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011ce7c:	89 45 88             	mov    %eax,-0x78(%ebp)
		freeDiskFrames = pf_calculate_free_frames() ;
f011ce7f:	e8 bd 76 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ce84:	89 45 84             	mov    %eax,-0x7c(%ebp)
		kfree(ptr_allocations[7]);
f011ce87:	8b 85 88 fe ff ff    	mov    -0x178(%ebp),%eax
f011ce8d:	83 ec 0c             	sub    $0xc,%esp
f011ce90:	50                   	push   %eax
f011ce91:	e8 3b b9 fe ff       	call   f01087d1 <kfree>
f011ce96:	83 c4 10             	add    $0x10,%esp
		if ((freeDiskFrames - pf_calculate_free_frames()) != 0) { correct = 0; cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)\n"); }
f011ce99:	e8 a3 76 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011ce9e:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f011cea1:	74 17                	je     f011ceba <test_kheap_virt_addr+0x8c1>
f011cea3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ceaa:	83 ec 0c             	sub    $0xc,%esp
f011cead:	68 c0 be 12 f0       	push   $0xf012bec0
f011ceb2:	e8 b5 40 fe ff       	call   f0100f6c <cprintf>
f011ceb7:	83 c4 10             	add    $0x10,%esp
		if ((sys_calculate_free_frames() - freeFrames) < 6*Mega/4096) { correct = 0; cprintf("Wrong kfree: pages in memory are not freed correctly\n"); }
f011ceba:	e8 4a 08 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011cebf:	89 c2                	mov    %eax,%edx
f011cec1:	8b 45 88             	mov    -0x78(%ebp),%eax
f011cec4:	29 c2                	sub    %eax,%edx
f011cec6:	89 d0                	mov    %edx,%eax
f011cec8:	3d ff 05 00 00       	cmp    $0x5ff,%eax
f011cecd:	77 17                	ja     f011cee6 <test_kheap_virt_addr+0x8ed>
f011cecf:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011ced6:	83 ec 0c             	sub    $0xc,%esp
f011ced9:	68 c4 c2 12 f0       	push   $0xf012c2c4
f011cede:	e8 89 40 fe ff       	call   f0100f6c <cprintf>
f011cee3:	83 c4 10             	add    $0x10,%esp


	//test kheap_virtual_address after kmalloc and kfree [20%]
	{
		uint32 va;
		uint32 endVA = ACTUAL_START + 13*Mega + 24*kilo;
f011cee6:	c7 45 80 00 70 d0 f8 	movl   $0xf8d07000,-0x80(%ebp)
		uint32 startVA = da_limit + PAGE_SIZE;
f011ceed:	a1 98 9d 17 f0       	mov    0xf0179d98,%eax
f011cef2:	05 00 10 00 00       	add    $0x1000,%eax
f011cef7:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
		int i = 0;
f011cefd:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
f011cf04:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f011cf0b:	00 00 00 
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011cf0e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf14:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011cf17:	eb 44                	jmp    f011cf5d <test_kheap_virt_addr+0x964>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011cf19:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cf1c:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cf1f:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cf22:	83 ec 0c             	sub    $0xc,%esp
f011cf25:	50                   	push   %eax
f011cf26:	e8 c0 b8 fe ff       	call   f01087eb <kheap_virtual_address>
f011cf2b:	83 c4 10             	add    $0x10,%esp
f011cf2e:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
			if (retrievedVA != 0)
f011cf34:	83 bd 74 ff ff ff 00 	cmpl   $0x0,-0x8c(%ebp)
f011cf3b:	74 1d                	je     f011cf5a <test_kheap_virt_addr+0x961>
			{
				if (correct)
f011cf3d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cf41:	74 17                	je     f011cf5a <test_kheap_virt_addr+0x961>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011cf43:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cf4a:	83 ec 0c             	sub    $0xc,%esp
f011cf4d:	68 1f c6 12 f0       	push   $0xf012c61f
f011cf52:	e8 15 40 fe ff       	call   f0100f6c <cprintf>
f011cf57:	83 c4 10             	add    $0x10,%esp
		uint32 startVA = da_limit + PAGE_SIZE;
		int i = 0;
		int j;
		//frames of first 4 MB
		uint32 startIndex = (INITIAL_KHEAP_ALLOCATIONS) / PAGE_SIZE;
		for (i = startIndex ; i < startIndex + 4*Mega/PAGE_SIZE; ++i)
f011cf5a:	ff 45 d0             	incl   -0x30(%ebp)
f011cf5d:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf63:	8d 90 00 04 00 00    	lea    0x400(%eax),%edx
f011cf69:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf6c:	39 c2                	cmp    %eax,%edx
f011cf6e:	77 a9                	ja     f011cf19 <test_kheap_virt_addr+0x920>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011cf70:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cf76:	05 00 04 00 00       	add    $0x400,%eax
f011cf7b:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011cf7e:	eb 64                	jmp    f011cfe4 <test_kheap_virt_addr+0x9eb>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011cf80:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cf83:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cf86:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cf89:	83 ec 0c             	sub    $0xc,%esp
f011cf8c:	50                   	push   %eax
f011cf8d:	e8 59 b8 fe ff       	call   f01087eb <kheap_virtual_address>
f011cf92:	83 c4 10             	add    $0x10,%esp
f011cf95:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011cf9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cf9e:	c1 e0 0c             	shl    $0xc,%eax
f011cfa1:	89 c2                	mov    %eax,%edx
f011cfa3:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011cfa9:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011cfac:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011cfaf:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011cfb2:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011cfb5:	25 ff 0f 00 00       	and    $0xfff,%eax
f011cfba:	01 c8                	add    %ecx,%eax
f011cfbc:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f011cfc2:	74 1d                	je     f011cfe1 <test_kheap_virt_addr+0x9e8>
			{
				if (correct)
f011cfc4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011cfc8:	74 17                	je     f011cfe1 <test_kheap_virt_addr+0x9e8>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011cfca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011cfd1:	83 ec 0c             	sub    $0xc,%esp
f011cfd4:	68 1f c6 12 f0       	push   $0xf012c61f
f011cfd9:	e8 8e 3f fe ff       	call   f0100f6c <cprintf>
f011cfde:	83 c4 10             	add    $0x10,%esp
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}

		}
		//next frames until 6 MB
		for (i = startIndex + 4*Mega/PAGE_SIZE; i < startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011cfe1:	ff 45 d0             	incl   -0x30(%ebp)
f011cfe4:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cfea:	8d 90 02 07 00 00    	lea    0x702(%eax),%edx
f011cff0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011cff3:	39 c2                	cmp    %eax,%edx
f011cff5:	77 89                	ja     f011cf80 <test_kheap_virt_addr+0x987>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011cff7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011cffd:	05 02 07 00 00       	add    $0x702,%eax
f011d002:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d005:	eb 44                	jmp    f011d04b <test_kheap_virt_addr+0xa52>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d007:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d00a:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d00d:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d010:	83 ec 0c             	sub    $0xc,%esp
f011d013:	50                   	push   %eax
f011d014:	e8 d2 b7 fe ff       	call   f01087eb <kheap_virtual_address>
f011d019:	83 c4 10             	add    $0x10,%esp
f011d01c:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
			if (retrievedVA != 0)
f011d022:	83 bd 6c ff ff ff 00 	cmpl   $0x0,-0x94(%ebp)
f011d029:	74 1d                	je     f011d048 <test_kheap_virt_addr+0xa4f>
			{
				if (correct)
f011d02b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d02f:	74 17                	je     f011d048 <test_kheap_virt_addr+0xa4f>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011d031:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d038:	83 ec 0c             	sub    $0xc,%esp
f011d03b:	68 1f c6 12 f0       	push   $0xf012c61f
f011d040:	e8 27 3f fe ff       	call   f0100f6c <cprintf>
f011d045:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of 6 MB
		for (i = startIndex + (7*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; ++i)
f011d048:	ff 45 d0             	incl   -0x30(%ebp)
f011d04b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d051:	8d 90 02 0d 00 00    	lea    0xd02(%eax),%edx
f011d057:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d05a:	39 c2                	cmp    %eax,%edx
f011d05c:	77 a9                	ja     f011d007 <test_kheap_virt_addr+0xa0e>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011d05e:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d064:	05 02 0d 00 00       	add    $0xd02,%eax
f011d069:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011d06c:	eb 64                	jmp    f011d0d2 <test_kheap_virt_addr+0xad9>
		{
			uint32 retrievedVA = kheap_virtual_address(allPAs[i]);
f011d06e:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d071:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d074:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d077:	83 ec 0c             	sub    $0xc,%esp
f011d07a:	50                   	push   %eax
f011d07b:	e8 6b b7 fe ff       	call   f01087eb <kheap_virtual_address>
f011d080:	83 c4 10             	add    $0x10,%esp
f011d083:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
			if (retrievedVA != ((startVA + i*PAGE_SIZE) + (allPAs[i] & 0xFFF)))
f011d089:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d08c:	c1 e0 0c             	shl    $0xc,%eax
f011d08f:	89 c2                	mov    %eax,%edx
f011d091:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f011d097:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
f011d09a:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011d09d:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011d0a0:	8b 04 90             	mov    (%eax,%edx,4),%eax
f011d0a3:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d0a8:	01 c8                	add    %ecx,%eax
f011d0aa:	3b 85 68 ff ff ff    	cmp    -0x98(%ebp),%eax
f011d0b0:	74 1d                	je     f011d0cf <test_kheap_virt_addr+0xad6>
			{
				if (correct)
f011d0b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d0b6:	74 17                	je     f011d0cf <test_kheap_virt_addr+0xad6>
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
f011d0b8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d0bf:	83 ec 0c             	sub    $0xc,%esp
f011d0c2:	68 1f c6 12 f0       	push   $0xf012c61f
f011d0c7:	e8 a0 3e fe ff       	call   f0100f6c <cprintf>
f011d0cc:	83 c4 10             	add    $0x10,%esp
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
		//frames of last allocation (14 KB)
		for (i = startIndex + (13*Mega + 8*kilo)/PAGE_SIZE; i < startIndex + (13*Mega + 24*kilo)/PAGE_SIZE; ++i)
f011d0cf:	ff 45 d0             	incl   -0x30(%ebp)
f011d0d2:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f011d0d8:	8d 90 06 0d 00 00    	lea    0xd06(%eax),%edx
f011d0de:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011d0e1:	39 c2                	cmp    %eax,%edx
f011d0e3:	77 89                	ja     f011d06e <test_kheap_virt_addr+0xa75>
				if (correct)
				{ correct = 0; cprintf("Wrong kheap_virtual_address\n"); }
			}
		}
	}
	if (correct)	eval+=20 ;
f011d0e5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d0e9:	74 04                	je     f011d0ef <test_kheap_virt_addr+0xaf6>
f011d0eb:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	correct = 1 ;
f011d0ef:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011d0f6:	c7 45 cc 00 00 00 f6 	movl   $0xf6000000,-0x34(%ebp)
f011d0fd:	e9 d1 00 00 00       	jmp    f011d1d3 <test_kheap_virt_addr+0xbda>
		{
			uint32 *ptr_table ;
			get_page_table(ptr_page_directory, va, &ptr_table);
f011d102:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011d107:	83 ec 04             	sub    $0x4,%esp
f011d10a:	8d 95 64 fe ff ff    	lea    -0x19c(%ebp),%edx
f011d110:	52                   	push   %edx
f011d111:	ff 75 cc             	pushl  -0x34(%ebp)
f011d114:	50                   	push   %eax
f011d115:	e8 f4 af fe ff       	call   f010810e <get_page_table>
f011d11a:	83 c4 10             	add    $0x10,%esp
			if (ptr_table == NULL)
f011d11d:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011d123:	85 c0                	test   %eax,%eax
f011d125:	75 1e                	jne    f011d145 <test_kheap_virt_addr+0xb4c>
			{ correct = 0; panic("one of the kernel tables is wrongly removed! Tables of Kernel Heap should not be removed\n"); }
f011d127:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d12e:	83 ec 04             	sub    $0x4,%esp
f011d131:	68 18 c5 12 f0       	push   $0xf012c518
f011d136:	68 cb 06 00 00       	push   $0x6cb
f011d13b:	68 72 c5 12 f0       	push   $0xf012c572
f011d140:	e8 d5 31 fe ff       	call   f010031a <_panic>
			pa = (ptr_table[PTX(va)] & 0xFFFFF000) + (va & 0xFFF);
f011d145:	8b 85 64 fe ff ff    	mov    -0x19c(%ebp),%eax
f011d14b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f011d14e:	c1 ea 0c             	shr    $0xc,%edx
f011d151:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011d157:	c1 e2 02             	shl    $0x2,%edx
f011d15a:	01 d0                	add    %edx,%eax
f011d15c:	8b 00                	mov    (%eax),%eax
f011d15e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011d163:	89 c2                	mov    %eax,%edx
f011d165:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011d168:	25 ff 0f 00 00       	and    $0xfff,%eax
f011d16d:	01 d0                	add    %edx,%eax
f011d16f:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
			uint32 retrievedVA = kheap_virtual_address(pa);
f011d175:	83 ec 0c             	sub    $0xc,%esp
f011d178:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011d17e:	e8 68 b6 fe ff       	call   f01087eb <kheap_virtual_address>
f011d183:	83 c4 10             	add    $0x10,%esp
f011d186:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
			if (retrievedVA != va)
f011d18c:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
f011d192:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d195:	74 39                	je     f011d1d0 <test_kheap_virt_addr+0xbd7>
			{
				if (correct)
f011d197:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d19b:	74 33                	je     f011d1d0 <test_kheap_virt_addr+0xbd7>
				{
					cprintf("\nPA = %x, retrievedVA = %x expectedVA = %x\n", pa, retrievedVA, va);
f011d19d:	ff 75 cc             	pushl  -0x34(%ebp)
f011d1a0:	ff b5 60 ff ff ff    	pushl  -0xa0(%ebp)
f011d1a6:	ff b5 64 ff ff ff    	pushl  -0x9c(%ebp)
f011d1ac:	68 3c c6 12 f0       	push   $0xf012c63c
f011d1b1:	e8 b6 3d fe ff       	call   f0100f6c <cprintf>
f011d1b6:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011d1b9:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d1c0:	83 ec 0c             	sub    $0xc,%esp
f011d1c3:	68 1f c6 12 f0       	push   $0xf012c61f
f011d1c8:	e8 9f 3d fe ff       	call   f0100f6c <cprintf>
f011d1cd:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//[DYNAMIC ALLOCATOR] test kheap_virtual_address each address [40%]
	{
		uint32 va, pa;
		for (va = KERNEL_HEAP_START; va < (uint32)sbrk(0); va++)
f011d1d0:	ff 45 cc             	incl   -0x34(%ebp)
f011d1d3:	83 ec 0c             	sub    $0xc,%esp
f011d1d6:	6a 00                	push   $0x0
f011d1d8:	e8 d0 b5 fe ff       	call   f01087ad <sbrk>
f011d1dd:	83 c4 10             	add    $0x10,%esp
f011d1e0:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f011d1e3:	0f 87 19 ff ff ff    	ja     f011d102 <test_kheap_virt_addr+0xb09>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=40 ;
f011d1e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d1ed:	74 04                	je     f011d1f3 <test_kheap_virt_addr+0xbfa>
f011d1ef:	83 45 e4 28          	addl   $0x28,-0x1c(%ebp)

	correct = 1 ;
f011d1f3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011d1fa:	c7 45 c8 00 00 10 00 	movl   $0x100000,-0x38(%ebp)
f011d201:	eb 5a                	jmp    f011d25d <test_kheap_virt_addr+0xc64>
		{
			uint32 retrievedVA = kheap_virtual_address(i);
f011d203:	83 ec 0c             	sub    $0xc,%esp
f011d206:	ff 75 c8             	pushl  -0x38(%ebp)
f011d209:	e8 dd b5 fe ff       	call   f01087eb <kheap_virtual_address>
f011d20e:	83 c4 10             	add    $0x10,%esp
f011d211:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
			if (retrievedVA != 0)
f011d217:	83 bd 5c ff ff ff 00 	cmpl   $0x0,-0xa4(%ebp)
f011d21e:	74 36                	je     f011d256 <test_kheap_virt_addr+0xc5d>
			{
				if (correct)
f011d220:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d224:	74 30                	je     f011d256 <test_kheap_virt_addr+0xc5d>
				{
					cprintf("\nPA = %x, retrievedVA = %x\n", i, retrievedVA);
f011d226:	83 ec 04             	sub    $0x4,%esp
f011d229:	ff b5 5c ff ff ff    	pushl  -0xa4(%ebp)
f011d22f:	ff 75 c8             	pushl  -0x38(%ebp)
f011d232:	68 68 c6 12 f0       	push   $0xf012c668
f011d237:	e8 30 3d fe ff       	call   f0100f6c <cprintf>
f011d23c:	83 c4 10             	add    $0x10,%esp
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
f011d23f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011d246:	83 ec 0c             	sub    $0xc,%esp
f011d249:	68 1f c6 12 f0       	push   $0xf012c61f
f011d24e:	e8 19 3d fe ff       	call   f0100f6c <cprintf>
f011d253:	83 c4 10             	add    $0x10,%esp

	correct = 1 ;
	//test kheap_virtual_address on frames of KERNEL CODE [20%]
	{
		uint32 i;
		for (i = 1*Mega; i < (uint32)(end_of_kernel - KERNEL_BASE); i+=PAGE_SIZE)
f011d256:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f011d25d:	b8 a8 79 57 00       	mov    $0x5779a8,%eax
f011d262:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f011d265:	72 9c                	jb     f011d203 <test_kheap_virt_addr+0xc0a>
					correct = 0; cprintf("Wrong kheap_virtual_address\n");
				}
			}
		}
	}
	if (correct)	eval+=20 ;
f011d267:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d26b:	74 04                	je     f011d271 <test_kheap_virt_addr+0xc78>
f011d26d:	83 45 e4 14          	addl   $0x14,-0x1c(%ebp)

	cprintf("\ntest kheap_virtual_address completed. Eval = %d%\n", eval);
f011d271:	83 ec 08             	sub    $0x8,%esp
f011d274:	ff 75 e4             	pushl  -0x1c(%ebp)
f011d277:	68 84 c6 12 f0       	push   $0xf012c684
f011d27c:	e8 eb 3c fe ff       	call   f0100f6c <cprintf>
f011d281:	83 c4 10             	add    $0x10,%esp

	return 1;
f011d284:	b8 01 00 00 00       	mov    $0x1,%eax
f011d289:	89 f4                	mov    %esi,%esp

}
f011d28b:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011d28e:	5b                   	pop    %ebx
f011d28f:	5e                   	pop    %esi
f011d290:	5f                   	pop    %edi
f011d291:	5d                   	pop    %ebp
f011d292:	c3                   	ret    

f011d293 <test_ksbrk>:


// 2023
int test_ksbrk()
{
f011d293:	55                   	push   %ebp
f011d294:	89 e5                	mov    %esp,%ebp
f011d296:	57                   	push   %edi
f011d297:	56                   	push   %esi
f011d298:	53                   	push   %ebx
f011d299:	81 ec 1c 01 00 00    	sub    $0x11c,%esp

	// malloc some spaces
	int i, freeFrames, freeDiskFrames;
	char *ptr;
	// int lastIndices[20] = {0};
	int sums[20] = {0};
f011d29f:	8d 95 7c ff ff ff    	lea    -0x84(%ebp),%edx
f011d2a5:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d2aa:	b8 00 00 00 00       	mov    $0x0,%eax
f011d2af:	89 d7                	mov    %edx,%edi
f011d2b1:	f3 ab                	rep stos %eax,%es:(%edi)
	void *ptr_allocations[20] = {0};
f011d2b3:	8d 95 2c ff ff ff    	lea    -0xd4(%ebp),%edx
f011d2b9:	b9 14 00 00 00       	mov    $0x14,%ecx
f011d2be:	b8 00 00 00 00       	mov    $0x0,%eax
f011d2c3:	89 d7                	mov    %edx,%edi
f011d2c5:	f3 ab                	rep stos %eax,%es:(%edi)

	// uint32 inputIncrementValues[] = {0, kilo, 2*kilo, -512, -2 * kilo, -2* kilo, 128, kilo};
	uint32 expectedVAs[] = {
f011d2c7:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f011d2cd:	bb 20 cc 12 f0       	mov    $0xf012cc20,%ebx
f011d2d2:	ba 0a 00 00 00       	mov    $0xa,%edx
f011d2d7:	89 c7                	mov    %eax,%edi
f011d2d9:	89 de                	mov    %ebx,%esi
f011d2db:	89 d1                	mov    %edx,%ecx
f011d2dd:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x1E00, // 128
			KERNEL_HEAP_START + 0x2000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x0C00, // +6*kilo
	};
	uint32 expectedSbrks[] = {
f011d2df:	8d 85 dc fe ff ff    	lea    -0x124(%ebp),%eax
f011d2e5:	bb 60 cc 12 f0       	mov    $0xf012cc60,%ebx
f011d2ea:	ba 0a 00 00 00       	mov    $0xa,%edx
f011d2ef:	89 c7                	mov    %eax,%edi
f011d2f1:	89 de                	mov    %ebx,%esi
f011d2f3:	89 d1                	mov    %edx,%ecx
f011d2f5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			KERNEL_HEAP_START + 0x3000, // kilo
			KERNEL_HEAP_START + 0x0C00, // -9*kilo
			KERNEL_HEAP_START + 0x4000, // +10*kilo
	};
	uint32 oldBrk, newBrk;
	int eval = 0;
f011d2f7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool correct = 1;
f011d2fe:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	cprintf("STEP A: checking increment with ZERO\n");
f011d305:	83 ec 0c             	sub    $0xc,%esp
f011d308:	68 b8 c6 12 f0       	push   $0xf012c6b8
f011d30d:	e8 5a 3c fe ff       	call   f0100f6c <cprintf>
f011d312:	83 c4 10             	add    $0x10,%esp
	{
		freeFrames = (int)sys_calculate_free_frames();
f011d315:	e8 ef 03 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d31a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d31d:	e8 1f 72 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d322:	89 45 d8             	mov    %eax,-0x28(%ebp)
		ptr_allocations[0] = sbrk(0);
f011d325:	83 ec 0c             	sub    $0xc,%esp
f011d328:	6a 00                	push   $0x0
f011d32a:	e8 7e b4 fe ff       	call   f01087ad <sbrk>
f011d32f:	83 c4 10             	add    $0x10,%esp
f011d332:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d338:	e8 04 72 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d33d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d340:	74 17                	je     f011d359 <test_ksbrk+0xc6>
		{
			correct = 0;
f011d342:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d349:	83 ec 0c             	sub    $0xc,%esp
f011d34c:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d351:	e8 16 3c fe ff       	call   f0100f6c <cprintf>
f011d356:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d359:	e8 ab 03 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d35e:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d361:	74 17                	je     f011d37a <test_ksbrk+0xe7>
		{
			correct = 0;
f011d363:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d36a:	83 ec 0c             	sub    $0xc,%esp
f011d36d:	68 48 c7 12 f0       	push   $0xf012c748
f011d372:	e8 f5 3b fe ff       	call   f0100f6c <cprintf>
f011d377:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[0] != expectedVAs[0])
f011d37a:	8b 85 2c ff ff ff    	mov    -0xd4(%ebp),%eax
f011d380:	89 c2                	mov    %eax,%edx
f011d382:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011d388:	39 c2                	cmp    %eax,%edx
f011d38a:	74 25                	je     f011d3b1 <test_ksbrk+0x11e>
		{
			correct = 0;
f011d38c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[0], ptr_allocations[0]);
f011d393:	8b 95 2c ff ff ff    	mov    -0xd4(%ebp),%edx
f011d399:	8b 85 04 ff ff ff    	mov    -0xfc(%ebp),%eax
f011d39f:	83 ec 04             	sub    $0x4,%esp
f011d3a2:	52                   	push   %edx
f011d3a3:	50                   	push   %eax
f011d3a4:	68 88 c7 12 f0       	push   $0xf012c788
f011d3a9:	e8 be 3b fe ff       	call   f0100f6c <cprintf>
f011d3ae:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d3b1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d3b5:	74 04                	je     f011d3bb <test_ksbrk+0x128>
			eval += 5;
f011d3b7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP B: checking increment with +ve value\n");
f011d3bb:	83 ec 0c             	sub    $0xc,%esp
f011d3be:	68 b8 c7 12 f0       	push   $0xf012c7b8
f011d3c3:	e8 a4 3b fe ff       	call   f0100f6c <cprintf>
f011d3c8:	83 c4 10             	add    $0x10,%esp
	{ // +1 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d3cb:	e8 39 03 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d3d0:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d3d3:	e8 69 71 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d3d8:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d3db:	83 ec 0c             	sub    $0xc,%esp
f011d3de:	6a 00                	push   $0x0
f011d3e0:	e8 c8 b3 fe ff       	call   f01087ad <sbrk>
f011d3e5:	83 c4 10             	add    $0x10,%esp
f011d3e8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[1] = sbrk(kilo);
f011d3eb:	83 ec 0c             	sub    $0xc,%esp
f011d3ee:	68 00 04 00 00       	push   $0x400
f011d3f3:	e8 b5 b3 fe ff       	call   f01087ad <sbrk>
f011d3f8:	83 c4 10             	add    $0x10,%esp
f011d3fb:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
		newBrk = (uint32)sbrk(0);
f011d401:	83 ec 0c             	sub    $0xc,%esp
f011d404:	6a 00                	push   $0x0
f011d406:	e8 a2 b3 fe ff       	call   f01087ad <sbrk>
f011d40b:	83 c4 10             	add    $0x10,%esp
f011d40e:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d411:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d418:	e8 24 71 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d41d:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d420:	74 17                	je     f011d439 <test_ksbrk+0x1a6>
		{
			correct = 0;
f011d422:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d429:	83 ec 0c             	sub    $0xc,%esp
f011d42c:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d431:	e8 36 3b fe ff       	call   f0100f6c <cprintf>
f011d436:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d439:	e8 cb 02 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d43e:	89 c2                	mov    %eax,%edx
f011d440:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d443:	29 d0                	sub    %edx,%eax
f011d445:	83 f8 01             	cmp    $0x1,%eax
f011d448:	74 17                	je     f011d461 <test_ksbrk+0x1ce>
		{
			correct = 0;
f011d44a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d451:	83 ec 0c             	sub    $0xc,%esp
f011d454:	68 48 c7 12 f0       	push   $0xf012c748
f011d459:	e8 0e 3b fe ff       	call   f0100f6c <cprintf>
f011d45e:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[1] != expectedVAs[1])
f011d461:	8b 85 30 ff ff ff    	mov    -0xd0(%ebp),%eax
f011d467:	89 c2                	mov    %eax,%edx
f011d469:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011d46f:	39 c2                	cmp    %eax,%edx
f011d471:	74 25                	je     f011d498 <test_ksbrk+0x205>
		{
			correct = 0;
f011d473:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[1], ptr_allocations[1]);
f011d47a:	8b 95 30 ff ff ff    	mov    -0xd0(%ebp),%edx
f011d480:	8b 85 08 ff ff ff    	mov    -0xf8(%ebp),%eax
f011d486:	83 ec 04             	sub    $0x4,%esp
f011d489:	52                   	push   %edx
f011d48a:	50                   	push   %eax
f011d48b:	68 88 c7 12 f0       	push   $0xf012c788
f011d490:	e8 d7 3a fe ff       	call   f0100f6c <cprintf>
f011d495:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[1])
f011d498:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011d49e:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d4a1:	74 21                	je     f011d4c4 <test_ksbrk+0x231>
		{
			correct = 0;
f011d4a3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[1]);
f011d4aa:	8b 85 e0 fe ff ff    	mov    -0x120(%ebp),%eax
f011d4b0:	83 ec 04             	sub    $0x4,%esp
f011d4b3:	50                   	push   %eax
f011d4b4:	ff 75 d0             	pushl  -0x30(%ebp)
f011d4b7:	68 e4 c7 12 f0       	push   $0xf012c7e4
f011d4bc:	e8 ab 3a fe ff       	call   f0100f6c <cprintf>
f011d4c1:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d4c4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d4c8:	74 04                	je     f011d4ce <test_ksbrk+0x23b>
			eval += 5;
f011d4ca:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	{ // +2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d4ce:	e8 36 02 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d4d3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d4d6:	e8 66 70 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d4db:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d4de:	83 ec 0c             	sub    $0xc,%esp
f011d4e1:	6a 00                	push   $0x0
f011d4e3:	e8 c5 b2 fe ff       	call   f01087ad <sbrk>
f011d4e8:	83 c4 10             	add    $0x10,%esp
f011d4eb:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[2] = sbrk(2 * kilo);
f011d4ee:	83 ec 0c             	sub    $0xc,%esp
f011d4f1:	68 00 08 00 00       	push   $0x800
f011d4f6:	e8 b2 b2 fe ff       	call   f01087ad <sbrk>
f011d4fb:	83 c4 10             	add    $0x10,%esp
f011d4fe:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%ebp)
		newBrk = (uint32)sbrk(0);
f011d504:	83 ec 0c             	sub    $0xc,%esp
f011d507:	6a 00                	push   $0x0
f011d509:	e8 9f b2 fe ff       	call   f01087ad <sbrk>
f011d50e:	83 c4 10             	add    $0x10,%esp
f011d511:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d514:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d51b:	e8 21 70 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d520:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d523:	74 17                	je     f011d53c <test_ksbrk+0x2a9>
		{
			correct = 0;
f011d525:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d52c:	83 ec 0c             	sub    $0xc,%esp
f011d52f:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d534:	e8 33 3a fe ff       	call   f0100f6c <cprintf>
f011d539:	83 c4 10             	add    $0x10,%esp
		}
		int x = (freeFrames - (int)sys_calculate_free_frames());
f011d53c:	e8 c8 01 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d541:	89 c2                	mov    %eax,%edx
f011d543:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d546:	29 d0                	sub    %edx,%eax
f011d548:	89 45 cc             	mov    %eax,-0x34(%ebp)
		if ((freeFrames - (int)sys_calculate_free_frames()) != 1)
f011d54b:	e8 b9 01 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d550:	89 c2                	mov    %eax,%edx
f011d552:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011d555:	29 d0                	sub    %edx,%eax
f011d557:	83 f8 01             	cmp    $0x1,%eax
f011d55a:	74 17                	je     f011d573 <test_ksbrk+0x2e0>
		{
			correct = 0;
f011d55c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d563:	83 ec 0c             	sub    $0xc,%esp
f011d566:	68 48 c7 12 f0       	push   $0xf012c748
f011d56b:	e8 fc 39 fe ff       	call   f0100f6c <cprintf>
f011d570:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[2] != expectedVAs[2])
f011d573:	8b 85 34 ff ff ff    	mov    -0xcc(%ebp),%eax
f011d579:	89 c2                	mov    %eax,%edx
f011d57b:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011d581:	39 c2                	cmp    %eax,%edx
f011d583:	74 25                	je     f011d5aa <test_ksbrk+0x317>
		{
			correct = 0;
f011d585:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[2], ptr_allocations[2]);
f011d58c:	8b 95 34 ff ff ff    	mov    -0xcc(%ebp),%edx
f011d592:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
f011d598:	83 ec 04             	sub    $0x4,%esp
f011d59b:	52                   	push   %edx
f011d59c:	50                   	push   %eax
f011d59d:	68 88 c7 12 f0       	push   $0xf012c788
f011d5a2:	e8 c5 39 fe ff       	call   f0100f6c <cprintf>
f011d5a7:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[2])
f011d5aa:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011d5b0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d5b3:	74 21                	je     f011d5d6 <test_ksbrk+0x343>
		{
			correct = 0;
f011d5b5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[2]);
f011d5bc:	8b 85 e4 fe ff ff    	mov    -0x11c(%ebp),%eax
f011d5c2:	83 ec 04             	sub    $0x4,%esp
f011d5c5:	50                   	push   %eax
f011d5c6:	ff 75 d0             	pushl  -0x30(%ebp)
f011d5c9:	68 e4 c7 12 f0       	push   $0xf012c7e4
f011d5ce:	e8 99 39 fe ff       	call   f0100f6c <cprintf>
f011d5d3:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d5d6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d5da:	74 04                	je     f011d5e0 <test_ksbrk+0x34d>
			eval += 5;
f011d5dc:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	}
	cprintf("STEP C: checking increment with -ve value [No Frames to be Deallocated]\n");
f011d5e0:	83 ec 0c             	sub    $0xc,%esp
f011d5e3:	68 10 c8 12 f0       	push   $0xf012c810
f011d5e8:	e8 7f 39 fe ff       	call   f0100f6c <cprintf>
f011d5ed:	83 c4 10             	add    $0x10,%esp
	{ // -512 Bytes
		freeFrames = (int)sys_calculate_free_frames();
f011d5f0:	e8 14 01 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d5f5:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d5f8:	e8 44 6f fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d5fd:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d600:	83 ec 0c             	sub    $0xc,%esp
f011d603:	6a 00                	push   $0x0
f011d605:	e8 a3 b1 fe ff       	call   f01087ad <sbrk>
f011d60a:	83 c4 10             	add    $0x10,%esp
f011d60d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[3] = sbrk(-512);
f011d610:	83 ec 0c             	sub    $0xc,%esp
f011d613:	68 00 fe ff ff       	push   $0xfffffe00
f011d618:	e8 90 b1 fe ff       	call   f01087ad <sbrk>
f011d61d:	83 c4 10             	add    $0x10,%esp
f011d620:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
		newBrk = (uint32)sbrk(0);
f011d626:	83 ec 0c             	sub    $0xc,%esp
f011d629:	6a 00                	push   $0x0
f011d62b:	e8 7d b1 fe ff       	call   f01087ad <sbrk>
f011d630:	83 c4 10             	add    $0x10,%esp
f011d633:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d636:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d63d:	e8 ff 6e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d642:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d645:	74 17                	je     f011d65e <test_ksbrk+0x3cb>
		{
			correct = 0;
f011d647:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d64e:	83 ec 0c             	sub    $0xc,%esp
f011d651:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d656:	e8 11 39 fe ff       	call   f0100f6c <cprintf>
f011d65b:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d65e:	e8 a6 00 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d663:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d666:	74 17                	je     f011d67f <test_ksbrk+0x3ec>
		{
			correct = 0;
f011d668:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d66f:	83 ec 0c             	sub    $0xc,%esp
f011d672:	68 48 c7 12 f0       	push   $0xf012c748
f011d677:	e8 f0 38 fe ff       	call   f0100f6c <cprintf>
f011d67c:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[3] != expectedVAs[3])
f011d67f:	8b 85 38 ff ff ff    	mov    -0xc8(%ebp),%eax
f011d685:	89 c2                	mov    %eax,%edx
f011d687:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011d68d:	39 c2                	cmp    %eax,%edx
f011d68f:	74 25                	je     f011d6b6 <test_ksbrk+0x423>
		{
			correct = 0;
f011d691:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[3], ptr_allocations[3]);
f011d698:	8b 95 38 ff ff ff    	mov    -0xc8(%ebp),%edx
f011d69e:	8b 85 10 ff ff ff    	mov    -0xf0(%ebp),%eax
f011d6a4:	83 ec 04             	sub    $0x4,%esp
f011d6a7:	52                   	push   %edx
f011d6a8:	50                   	push   %eax
f011d6a9:	68 88 c7 12 f0       	push   $0xf012c788
f011d6ae:	e8 b9 38 fe ff       	call   f0100f6c <cprintf>
f011d6b3:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[3])
f011d6b6:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011d6bc:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d6bf:	74 21                	je     f011d6e2 <test_ksbrk+0x44f>
		{
			correct = 0;
f011d6c1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[3]);
f011d6c8:	8b 85 e8 fe ff ff    	mov    -0x118(%ebp),%eax
f011d6ce:	83 ec 04             	sub    $0x4,%esp
f011d6d1:	50                   	push   %eax
f011d6d2:	ff 75 d0             	pushl  -0x30(%ebp)
f011d6d5:	68 e4 c7 12 f0       	push   $0xf012c7e4
f011d6da:	e8 8d 38 fe ff       	call   f0100f6c <cprintf>
f011d6df:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d6e2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d6e6:	74 04                	je     f011d6ec <test_ksbrk+0x459>
			eval += 10;
f011d6e8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d6ec:	e8 18 00 ff ff       	call   f010d709 <sys_calculate_free_frames>
f011d6f1:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d6f4:	e8 48 6e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d6f9:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d6fc:	83 ec 0c             	sub    $0xc,%esp
f011d6ff:	6a 00                	push   $0x0
f011d701:	e8 a7 b0 fe ff       	call   f01087ad <sbrk>
f011d706:	83 c4 10             	add    $0x10,%esp
f011d709:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[4] = sbrk(-2 * kilo);
f011d70c:	83 ec 0c             	sub    $0xc,%esp
f011d70f:	68 00 f8 ff ff       	push   $0xfffff800
f011d714:	e8 94 b0 fe ff       	call   f01087ad <sbrk>
f011d719:	83 c4 10             	add    $0x10,%esp
f011d71c:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%ebp)
		newBrk = (uint32)sbrk(0);
f011d722:	83 ec 0c             	sub    $0xc,%esp
f011d725:	6a 00                	push   $0x0
f011d727:	e8 81 b0 fe ff       	call   f01087ad <sbrk>
f011d72c:	83 c4 10             	add    $0x10,%esp
f011d72f:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d732:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d739:	e8 03 6e fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d73e:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d741:	74 17                	je     f011d75a <test_ksbrk+0x4c7>
		{
			correct = 0;
f011d743:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d74a:	83 ec 0c             	sub    $0xc,%esp
f011d74d:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d752:	e8 15 38 fe ff       	call   f0100f6c <cprintf>
f011d757:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if ((freeFrames - (int)sys_calculate_free_frames()) != 0)
f011d75a:	e8 aa ff fe ff       	call   f010d709 <sys_calculate_free_frames>
f011d75f:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d762:	74 17                	je     f011d77b <test_ksbrk+0x4e8>
		{
			correct = 0;
f011d764:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d76b:	83 ec 0c             	sub    $0xc,%esp
f011d76e:	68 48 c7 12 f0       	push   $0xf012c748
f011d773:	e8 f4 37 fe ff       	call   f0100f6c <cprintf>
f011d778:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[4] != expectedVAs[4])
f011d77b:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f011d781:	89 c2                	mov    %eax,%edx
f011d783:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011d789:	39 c2                	cmp    %eax,%edx
f011d78b:	74 25                	je     f011d7b2 <test_ksbrk+0x51f>
		{
			correct = 0;
f011d78d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[4], ptr_allocations[4]);
f011d794:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
f011d79a:	8b 85 14 ff ff ff    	mov    -0xec(%ebp),%eax
f011d7a0:	83 ec 04             	sub    $0x4,%esp
f011d7a3:	52                   	push   %edx
f011d7a4:	50                   	push   %eax
f011d7a5:	68 88 c7 12 f0       	push   $0xf012c788
f011d7aa:	e8 bd 37 fe ff       	call   f0100f6c <cprintf>
f011d7af:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[4])
f011d7b2:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011d7b8:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d7bb:	74 21                	je     f011d7de <test_ksbrk+0x54b>
		{
			correct = 0;
f011d7bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[4]);
f011d7c4:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
f011d7ca:	83 ec 04             	sub    $0x4,%esp
f011d7cd:	50                   	push   %eax
f011d7ce:	ff 75 d0             	pushl  -0x30(%ebp)
f011d7d1:	68 e4 c7 12 f0       	push   $0xf012c7e4
f011d7d6:	e8 91 37 fe ff       	call   f0100f6c <cprintf>
f011d7db:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d7de:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d7e2:	74 04                	je     f011d7e8 <test_ksbrk+0x555>
			eval += 10;
f011d7e4:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP D: checking increment with -ve value [ONE Frame should be Deallocated]\n");
f011d7e8:	83 ec 0c             	sub    $0xc,%esp
f011d7eb:	68 5c c8 12 f0       	push   $0xf012c85c
f011d7f0:	e8 77 37 fe ff       	call   f0100f6c <cprintf>
f011d7f5:	83 c4 10             	add    $0x10,%esp
	{ // -2 KB
		freeFrames = (int)sys_calculate_free_frames();
f011d7f8:	e8 0c ff fe ff       	call   f010d709 <sys_calculate_free_frames>
f011d7fd:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011d800:	e8 3c 6d fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d805:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d808:	83 ec 0c             	sub    $0xc,%esp
f011d80b:	6a 00                	push   $0x0
f011d80d:	e8 9b af fe ff       	call   f01087ad <sbrk>
f011d812:	83 c4 10             	add    $0x10,%esp
f011d815:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[5] = sbrk(-2 * kilo);
f011d818:	83 ec 0c             	sub    $0xc,%esp
f011d81b:	68 00 f8 ff ff       	push   $0xfffff800
f011d820:	e8 88 af fe ff       	call   f01087ad <sbrk>
f011d825:	83 c4 10             	add    $0x10,%esp
f011d828:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		newBrk = (uint32)sbrk(0);
f011d82e:	83 ec 0c             	sub    $0xc,%esp
f011d831:	6a 00                	push   $0x0
f011d833:	e8 75 af fe ff       	call   f01087ad <sbrk>
f011d838:	83 c4 10             	add    $0x10,%esp
f011d83b:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d83e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d845:	e8 f7 6c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d84a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d84d:	74 17                	je     f011d866 <test_ksbrk+0x5d3>
		{
			correct = 0;
f011d84f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d856:	83 ec 0c             	sub    $0xc,%esp
f011d859:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d85e:	e8 09 37 fe ff       	call   f0100f6c <cprintf>
f011d863:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 1)
f011d866:	e8 9e fe fe ff       	call   f010d709 <sys_calculate_free_frames>
f011d86b:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011d86e:	83 f8 01             	cmp    $0x1,%eax
f011d871:	74 17                	je     f011d88a <test_ksbrk+0x5f7>
		{
			correct = 0;
f011d873:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d87a:	83 ec 0c             	sub    $0xc,%esp
f011d87d:	68 48 c7 12 f0       	push   $0xf012c748
f011d882:	e8 e5 36 fe ff       	call   f0100f6c <cprintf>
f011d887:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[5] != expectedVAs[5])
f011d88a:	8b 85 40 ff ff ff    	mov    -0xc0(%ebp),%eax
f011d890:	89 c2                	mov    %eax,%edx
f011d892:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011d898:	39 c2                	cmp    %eax,%edx
f011d89a:	74 25                	je     f011d8c1 <test_ksbrk+0x62e>
		{
			correct = 0;
f011d89c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011d8a3:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011d8a9:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011d8af:	83 ec 04             	sub    $0x4,%esp
f011d8b2:	52                   	push   %edx
f011d8b3:	50                   	push   %eax
f011d8b4:	68 88 c7 12 f0       	push   $0xf012c788
f011d8b9:	e8 ae 36 fe ff       	call   f0100f6c <cprintf>
f011d8be:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[5])
f011d8c1:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d8c7:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d8ca:	74 21                	je     f011d8ed <test_ksbrk+0x65a>
		{
			correct = 0;
f011d8cc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011d8d3:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011d8d9:	83 ec 04             	sub    $0x4,%esp
f011d8dc:	50                   	push   %eax
f011d8dd:	ff 75 d0             	pushl  -0x30(%ebp)
f011d8e0:	68 e4 c7 12 f0       	push   $0xf012c7e4
f011d8e5:	e8 82 36 fe ff       	call   f0100f6c <cprintf>
f011d8ea:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d8ed:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d8f1:	74 04                	je     f011d8f7 <test_ksbrk+0x664>
			eval += 15;
f011d8f3:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP E: checking increment with +ve value [No Frames to be Allocated]\n");
f011d8f7:	83 ec 0c             	sub    $0xc,%esp
f011d8fa:	68 ac c8 12 f0       	push   $0xf012c8ac
f011d8ff:	e8 68 36 fe ff       	call   f0100f6c <cprintf>
f011d904:	83 c4 10             	add    $0x10,%esp
	{ // 128 Bytes
		freeFrames = (int)(int)sys_calculate_free_frames();
f011d907:	e8 fd fd fe ff       	call   f010d709 <sys_calculate_free_frames>
f011d90c:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)(int)pf_calculate_free_frames();
f011d90f:	e8 2d 6c fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d914:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011d917:	83 ec 0c             	sub    $0xc,%esp
f011d91a:	6a 00                	push   $0x0
f011d91c:	e8 8c ae fe ff       	call   f01087ad <sbrk>
f011d921:	83 c4 10             	add    $0x10,%esp
f011d924:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[6] = sbrk(128);
f011d927:	83 ec 0c             	sub    $0xc,%esp
f011d92a:	68 80 00 00 00       	push   $0x80
f011d92f:	e8 79 ae fe ff       	call   f01087ad <sbrk>
f011d934:	83 c4 10             	add    $0x10,%esp
f011d937:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
		newBrk = (uint32)sbrk(0);
f011d93d:	83 ec 0c             	sub    $0xc,%esp
f011d940:	6a 00                	push   $0x0
f011d942:	e8 66 ae fe ff       	call   f01087ad <sbrk>
f011d947:	83 c4 10             	add    $0x10,%esp
f011d94a:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011d94d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011d954:	e8 e8 6b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011d959:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011d95c:	74 17                	je     f011d975 <test_ksbrk+0x6e2>
		{
			correct = 0;
f011d95e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011d965:	83 ec 0c             	sub    $0xc,%esp
f011d968:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011d96d:	e8 fa 35 fe ff       	call   f0100f6c <cprintf>
f011d972:	83 c4 10             	add    $0x10,%esp
		}
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 0)
f011d975:	e8 8f fd fe ff       	call   f010d709 <sys_calculate_free_frames>
f011d97a:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011d97d:	74 17                	je     f011d996 <test_ksbrk+0x703>
		{
			correct = 0;
f011d97f:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong allocation: pages are not loaded successfully into memory");
f011d986:	83 ec 0c             	sub    $0xc,%esp
f011d989:	68 48 c7 12 f0       	push   $0xf012c748
f011d98e:	e8 d9 35 fe ff       	call   f0100f6c <cprintf>
f011d993:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[6] != expectedVAs[6])
f011d996:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f011d99c:	89 c2                	mov    %eax,%edx
f011d99e:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011d9a4:	39 c2                	cmp    %eax,%edx
f011d9a6:	74 25                	je     f011d9cd <test_ksbrk+0x73a>
		{
			correct = 0;
f011d9a8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[6], ptr_allocations[6]);
f011d9af:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f011d9b5:	8b 85 1c ff ff ff    	mov    -0xe4(%ebp),%eax
f011d9bb:	83 ec 04             	sub    $0x4,%esp
f011d9be:	52                   	push   %edx
f011d9bf:	50                   	push   %eax
f011d9c0:	68 88 c7 12 f0       	push   $0xf012c788
f011d9c5:	e8 a2 35 fe ff       	call   f0100f6c <cprintf>
f011d9ca:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[6])
f011d9cd:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d9d3:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011d9d6:	74 21                	je     f011d9f9 <test_ksbrk+0x766>
		{
			correct = 0;
f011d9d8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[6]);
f011d9df:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
f011d9e5:	83 ec 04             	sub    $0x4,%esp
f011d9e8:	50                   	push   %eax
f011d9e9:	ff 75 d0             	pushl  -0x30(%ebp)
f011d9ec:	68 e4 c7 12 f0       	push   $0xf012c7e4
f011d9f1:	e8 76 35 fe ff       	call   f0100f6c <cprintf>
f011d9f6:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011d9f9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011d9fd:	74 04                	je     f011da03 <test_ksbrk+0x770>
			eval += 15;
f011d9ff:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP F: checking increment with +ve value [ONE Frame should be Allocated]\n");
f011da03:	83 ec 0c             	sub    $0xc,%esp
f011da06:	68 f4 c8 12 f0       	push   $0xf012c8f4
f011da0b:	e8 5c 35 fe ff       	call   f0100f6c <cprintf>
f011da10:	83 c4 10             	add    $0x10,%esp
	{ // 1 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011da13:	e8 f1 fc fe ff       	call   f010d709 <sys_calculate_free_frames>
f011da18:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011da1b:	e8 21 6b fe ff       	call   f0104541 <pf_calculate_free_frames>
f011da20:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011da23:	83 ec 0c             	sub    $0xc,%esp
f011da26:	6a 00                	push   $0x0
f011da28:	e8 80 ad fe ff       	call   f01087ad <sbrk>
f011da2d:	83 c4 10             	add    $0x10,%esp
f011da30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[7] = sbrk(kilo);
f011da33:	83 ec 0c             	sub    $0xc,%esp
f011da36:	68 00 04 00 00       	push   $0x400
f011da3b:	e8 6d ad fe ff       	call   f01087ad <sbrk>
f011da40:	83 c4 10             	add    $0x10,%esp
f011da43:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
		newBrk = (uint32)sbrk(0);
f011da49:	83 ec 0c             	sub    $0xc,%esp
f011da4c:	6a 00                	push   $0x0
f011da4e:	e8 5a ad fe ff       	call   f01087ad <sbrk>
f011da53:	83 c4 10             	add    $0x10,%esp
f011da56:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011da59:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011da60:	e8 dc 6a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011da65:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011da68:	74 17                	je     f011da81 <test_ksbrk+0x7ee>
		{
			correct = 0;
f011da6a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011da71:	83 ec 0c             	sub    $0xc,%esp
f011da74:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011da79:	e8 ee 34 fe ff       	call   f0100f6c <cprintf>
f011da7e:	83 c4 10             	add    $0x10,%esp
		}
		//cprintf("((int)(int)sys_calculate_free_frames() - freeFrames) = %d\n", ((int)(int)sys_calculate_free_frames() - freeFrames));
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 1)
f011da81:	e8 83 fc fe ff       	call   f010d709 <sys_calculate_free_frames>
f011da86:	89 c2                	mov    %eax,%edx
f011da88:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011da8b:	29 d0                	sub    %edx,%eax
f011da8d:	83 f8 01             	cmp    $0x1,%eax
f011da90:	74 17                	je     f011daa9 <test_ksbrk+0x816>
		{
			correct = 0;
f011da92:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong allocation: pages are not loaded successfully into memory");
f011da99:	83 ec 0c             	sub    $0xc,%esp
f011da9c:	68 40 c9 12 f0       	push   $0xf012c940
f011daa1:	e8 c6 34 fe ff       	call   f0100f6c <cprintf>
f011daa6:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[7] != expectedVAs[7])
f011daa9:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f011daaf:	89 c2                	mov    %eax,%edx
f011dab1:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011dab7:	39 c2                	cmp    %eax,%edx
f011dab9:	74 25                	je     f011dae0 <test_ksbrk+0x84d>
		{
			correct = 0;
f011dabb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011dac2:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011dac8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011dace:	83 ec 04             	sub    $0x4,%esp
f011dad1:	52                   	push   %edx
f011dad2:	50                   	push   %eax
f011dad3:	68 84 c9 12 f0       	push   $0xf012c984
f011dad8:	e8 8f 34 fe ff       	call   f0100f6c <cprintf>
f011dadd:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[7])
f011dae0:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011dae6:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011dae9:	74 21                	je     f011db0c <test_ksbrk+0x879>
		{
			correct = 0;
f011daeb:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("7 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011daf2:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011daf8:	83 ec 04             	sub    $0x4,%esp
f011dafb:	50                   	push   %eax
f011dafc:	ff 75 d0             	pushl  -0x30(%ebp)
f011daff:	68 b8 c9 12 f0       	push   $0xf012c9b8
f011db04:	e8 63 34 fe ff       	call   f0100f6c <cprintf>
f011db09:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011db0c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011db10:	74 04                	je     f011db16 <test_ksbrk+0x883>
			eval += 15;
f011db12:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	}
	cprintf("STEP G: checking increment with -ve value [TWO Frames should be Deallocated]\n");
f011db16:	83 ec 0c             	sub    $0xc,%esp
f011db19:	68 e8 c9 12 f0       	push   $0xf012c9e8
f011db1e:	e8 49 34 fe ff       	call   f0100f6c <cprintf>
f011db23:	83 c4 10             	add    $0x10,%esp
	{ // -9 KB
		freeFrames = (int)sys_calculate_free_frames();
f011db26:	e8 de fb fe ff       	call   f010d709 <sys_calculate_free_frames>
f011db2b:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011db2e:	e8 0e 6a fe ff       	call   f0104541 <pf_calculate_free_frames>
f011db33:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011db36:	83 ec 0c             	sub    $0xc,%esp
f011db39:	6a 00                	push   $0x0
f011db3b:	e8 6d ac fe ff       	call   f01087ad <sbrk>
f011db40:	83 c4 10             	add    $0x10,%esp
f011db43:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[8] = sbrk(-9 * kilo);
f011db46:	83 ec 0c             	sub    $0xc,%esp
f011db49:	68 00 dc ff ff       	push   $0xffffdc00
f011db4e:	e8 5a ac fe ff       	call   f01087ad <sbrk>
f011db53:	83 c4 10             	add    $0x10,%esp
f011db56:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
		newBrk = (uint32)sbrk(0);
f011db5c:	83 ec 0c             	sub    $0xc,%esp
f011db5f:	6a 00                	push   $0x0
f011db61:	e8 47 ac fe ff       	call   f01087ad <sbrk>
f011db66:	83 c4 10             	add    $0x10,%esp
f011db69:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011db6c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)(int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011db73:	e8 c9 69 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011db78:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011db7b:	74 17                	je     f011db94 <test_ksbrk+0x901>
		{
			correct = 0;
f011db7d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011db84:	83 ec 0c             	sub    $0xc,%esp
f011db87:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011db8c:	e8 db 33 fe ff       	call   f0100f6c <cprintf>
f011db91:	83 c4 10             	add    $0x10,%esp
		}
		// cprintf("####### %x - %x\n", freeFrames - (int)sys_calculate_free_frames(), -1 * ((ROUNDUP(oldBrk, PAGE_SIZE) - newBrk) / PAGE_SIZE));
		if (((int)(int)sys_calculate_free_frames() - freeFrames) != 2)
f011db94:	e8 70 fb fe ff       	call   f010d709 <sys_calculate_free_frames>
f011db99:	2b 45 dc             	sub    -0x24(%ebp),%eax
f011db9c:	83 f8 02             	cmp    $0x2,%eax
f011db9f:	74 17                	je     f011dbb8 <test_ksbrk+0x925>
		{
			correct = 0;
f011dba1:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong allocation: pages are not loaded successfully into memory");
f011dba8:	83 ec 0c             	sub    $0xc,%esp
f011dbab:	68 38 ca 12 f0       	push   $0xf012ca38
f011dbb0:	e8 b7 33 fe ff       	call   f0100f6c <cprintf>
f011dbb5:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[8] != expectedVAs[8])
f011dbb8:	8b 85 4c ff ff ff    	mov    -0xb4(%ebp),%eax
f011dbbe:	89 c2                	mov    %eax,%edx
f011dbc0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011dbc6:	39 c2                	cmp    %eax,%edx
f011dbc8:	74 25                	je     f011dbef <test_ksbrk+0x95c>
		{
			correct = 0;
f011dbca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[5], ptr_allocations[5]);
f011dbd1:	8b 95 40 ff ff ff    	mov    -0xc0(%ebp),%edx
f011dbd7:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
f011dbdd:	83 ec 04             	sub    $0x4,%esp
f011dbe0:	52                   	push   %edx
f011dbe1:	50                   	push   %eax
f011dbe2:	68 7c ca 12 f0       	push   $0xf012ca7c
f011dbe7:	e8 80 33 fe ff       	call   f0100f6c <cprintf>
f011dbec:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[8])
f011dbef:	8b 85 fc fe ff ff    	mov    -0x104(%ebp),%eax
f011dbf5:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011dbf8:	74 21                	je     f011dc1b <test_ksbrk+0x988>
		{
			correct = 0;
f011dbfa:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("8 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[5]);
f011dc01:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
f011dc07:	83 ec 04             	sub    $0x4,%esp
f011dc0a:	50                   	push   %eax
f011dc0b:	ff 75 d0             	pushl  -0x30(%ebp)
f011dc0e:	68 b0 ca 12 f0       	push   $0xf012cab0
f011dc13:	e8 54 33 fe ff       	call   f0100f6c <cprintf>
f011dc18:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011dc1b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dc1f:	74 04                	je     f011dc25 <test_ksbrk+0x992>
			eval += 10;
f011dc21:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}
	cprintf("STEP H: checking increment with +ve value [THREE Frames should be Allocated]\n");
f011dc25:	83 ec 0c             	sub    $0xc,%esp
f011dc28:	68 e0 ca 12 f0       	push   $0xf012cae0
f011dc2d:	e8 3a 33 fe ff       	call   f0100f6c <cprintf>
f011dc32:	83 c4 10             	add    $0x10,%esp
	{ // 10 KB
		freeFrames = (int)(int)sys_calculate_free_frames();
f011dc35:	e8 cf fa fe ff       	call   f010d709 <sys_calculate_free_frames>
f011dc3a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		freeDiskFrames = (int)pf_calculate_free_frames();
f011dc3d:	e8 ff 68 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011dc42:	89 45 d8             	mov    %eax,-0x28(%ebp)
		oldBrk = (uint32)sbrk(0);
f011dc45:	83 ec 0c             	sub    $0xc,%esp
f011dc48:	6a 00                	push   $0x0
f011dc4a:	e8 5e ab fe ff       	call   f01087ad <sbrk>
f011dc4f:	83 c4 10             	add    $0x10,%esp
f011dc52:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		ptr_allocations[9] = sbrk(10*kilo);
f011dc55:	83 ec 0c             	sub    $0xc,%esp
f011dc58:	68 00 28 00 00       	push   $0x2800
f011dc5d:	e8 4b ab fe ff       	call   f01087ad <sbrk>
f011dc62:	83 c4 10             	add    $0x10,%esp
f011dc65:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
		newBrk = (uint32)sbrk(0);
f011dc6b:	83 ec 0c             	sub    $0xc,%esp
f011dc6e:	6a 00                	push   $0x0
f011dc70:	e8 38 ab fe ff       	call   f01087ad <sbrk>
f011dc75:	83 c4 10             	add    $0x10,%esp
f011dc78:	89 45 d0             	mov    %eax,-0x30(%ebp)
		correct = 1;
f011dc7b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (((int)pf_calculate_free_frames() - freeDiskFrames) != 0)
f011dc82:	e8 ba 68 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011dc87:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011dc8a:	74 17                	je     f011dca3 <test_ksbrk+0xa10>
		{
			correct = 0;
f011dc8c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011dc93:	83 ec 0c             	sub    $0xc,%esp
f011dc96:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011dc9b:	e8 cc 32 fe ff       	call   f0100f6c <cprintf>
f011dca0:	83 c4 10             	add    $0x10,%esp
		}
		if ((freeFrames - (int)(int)sys_calculate_free_frames()) != 3)
f011dca3:	e8 61 fa fe ff       	call   f010d709 <sys_calculate_free_frames>
f011dca8:	89 c2                	mov    %eax,%edx
f011dcaa:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011dcad:	29 d0                	sub    %edx,%eax
f011dcaf:	83 f8 03             	cmp    $0x3,%eax
f011dcb2:	74 17                	je     f011dccb <test_ksbrk+0xa38>
		{
			correct = 0;
f011dcb4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong allocation: pages are not loaded successfully into memory");
f011dcbb:	83 ec 0c             	sub    $0xc,%esp
f011dcbe:	68 30 cb 12 f0       	push   $0xf012cb30
f011dcc3:	e8 a4 32 fe ff       	call   f0100f6c <cprintf>
f011dcc8:	83 c4 10             	add    $0x10,%esp
		}
		if ((uint32)ptr_allocations[9] != expectedVAs[9])
f011dccb:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
f011dcd1:	89 c2                	mov    %eax,%edx
f011dcd3:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f011dcd9:	39 c2                	cmp    %eax,%edx
f011dcdb:	74 25                	je     f011dd02 <test_ksbrk+0xa6f>
		{
			correct = 0;
f011dcdd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong returned break: Expected: %x, Actual: %x\n", expectedVAs[7], ptr_allocations[7]);
f011dce4:	8b 95 48 ff ff ff    	mov    -0xb8(%ebp),%edx
f011dcea:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011dcf0:	83 ec 04             	sub    $0x4,%esp
f011dcf3:	52                   	push   %edx
f011dcf4:	50                   	push   %eax
f011dcf5:	68 74 cb 12 f0       	push   $0xf012cb74
f011dcfa:	e8 6d 32 fe ff       	call   f0100f6c <cprintf>
f011dcff:	83 c4 10             	add    $0x10,%esp
		}
		if (newBrk != expectedSbrks[9])
f011dd02:	8b 85 00 ff ff ff    	mov    -0x100(%ebp),%eax
f011dd08:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011dd0b:	74 21                	je     f011dd2e <test_ksbrk+0xa9b>
		{
			correct = 0;
f011dd0d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			cprintf("9 Wrong new break: Expected: %x, Actual: %x\n", newBrk, expectedSbrks[7]);
f011dd14:	8b 85 f8 fe ff ff    	mov    -0x108(%ebp),%eax
f011dd1a:	83 ec 04             	sub    $0x4,%esp
f011dd1d:	50                   	push   %eax
f011dd1e:	ff 75 d0             	pushl  -0x30(%ebp)
f011dd21:	68 a8 cb 12 f0       	push   $0xf012cba8
f011dd26:	e8 41 32 fe ff       	call   f0100f6c <cprintf>
f011dd2b:	83 c4 10             	add    $0x10,%esp
		}
		if (correct)
f011dd2e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011dd32:	74 04                	je     f011dd38 <test_ksbrk+0xaa5>
			eval += 10;
f011dd34:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	}

	//cprintf("Test kheap sbrk completed. Evaluation = %d%%\n", eval);
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f011dd38:	83 ec 08             	sub    $0x8,%esp
f011dd3b:	ff 75 e4             	pushl  -0x1c(%ebp)
f011dd3e:	68 d5 cb 12 f0       	push   $0xf012cbd5
f011dd43:	e8 24 32 fe ff       	call   f0100f6c <cprintf>
f011dd48:	83 c4 10             	add    $0x10,%esp

	cprintf("=================\n\n");
f011dd4b:	83 ec 0c             	sub    $0xc,%esp
f011dd4e:	68 ef cb 12 f0       	push   $0xf012cbef
f011dd53:	e8 14 32 fe ff       	call   f0100f6c <cprintf>
f011dd58:	83 c4 10             	add    $0x10,%esp
	return 0;
f011dd5b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011dd60:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dd63:	5b                   	pop    %ebx
f011dd64:	5e                   	pop    %esi
f011dd65:	5f                   	pop    %edi
f011dd66:	5d                   	pop    %ebp
f011dd67:	c3                   	ret    

f011dd68 <test_kmalloc_nextfit>:




int test_kmalloc_nextfit()
{
f011dd68:	55                   	push   %ebp
f011dd69:	89 e5                	mov    %esp,%ebp
f011dd6b:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011dd71:	83 ec 04             	sub    $0x4,%esp
f011dd74:	68 88 cc 12 f0       	push   $0xf012cc88
f011dd79:	68 76 08 00 00       	push   $0x876
f011dd7e:	68 72 c5 12 f0       	push   $0xf012c572
f011dd83:	e8 92 25 fe ff       	call   f010031a <_panic>

f011dd88 <test_kmalloc_bestfit1>:
	return 1;

}

int test_kmalloc_bestfit1()
{
f011dd88:	55                   	push   %ebp
f011dd89:	89 e5                	mov    %esp,%ebp
f011dd8b:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011dd8e:	83 ec 04             	sub    $0x4,%esp
f011dd91:	68 88 cc 12 f0       	push   $0xf012cc88
f011dd96:	68 1c 09 00 00       	push   $0x91c
f011dd9b:	68 72 c5 12 f0       	push   $0xf012c572
f011dda0:	e8 75 25 fe ff       	call   f010031a <_panic>

f011dda5 <test_kmalloc_bestfit2>:
	return 1;

}

int test_kmalloc_bestfit2()
{
f011dda5:	55                   	push   %ebp
f011dda6:	89 e5                	mov    %esp,%ebp
f011dda8:	83 ec 58             	sub    $0x58,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011ddab:	83 ec 04             	sub    $0x4,%esp
f011ddae:	68 88 cc 12 f0       	push   $0xf012cc88
f011ddb3:	68 c8 09 00 00       	push   $0x9c8
f011ddb8:	68 72 c5 12 f0       	push   $0xf012c572
f011ddbd:	e8 58 25 fe ff       	call   f010031a <_panic>

f011ddc2 <test_kmalloc_worstfit>:
	return 1;

}

int test_kmalloc_worstfit()
{
f011ddc2:	55                   	push   %ebp
f011ddc3:	89 e5                	mov    %esp,%ebp
f011ddc5:	81 ec 88 02 00 00    	sub    $0x288,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011ddcb:	83 ec 04             	sub    $0x4,%esp
f011ddce:	68 88 cc 12 f0       	push   $0xf012cc88
f011ddd3:	68 6e 0a 00 00       	push   $0xa6e
f011ddd8:	68 72 c5 12 f0       	push   $0xf012c572
f011dddd:	e8 38 25 fe ff       	call   f010031a <_panic>

f011dde2 <test_kfree>:

	return 1;
}

int test_kfree()
{
f011dde2:	55                   	push   %ebp
f011dde3:	89 e5                	mov    %esp,%ebp
f011dde5:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("not handled yet after applying dynamic allocator with page allocator");
f011ddeb:	83 ec 04             	sub    $0x4,%esp
f011ddee:	68 88 cc 12 f0       	push   $0xf012cc88
f011ddf3:	68 14 0b 00 00       	push   $0xb14
f011ddf8:	68 72 c5 12 f0       	push   $0xf012c572
f011ddfd:	e8 18 25 fe ff       	call   f010031a <_panic>

f011de02 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f011de02:	55                   	push   %ebp
f011de03:	89 e5                	mov    %esp,%ebp
f011de05:	57                   	push   %edi
f011de06:	56                   	push   %esi
f011de07:	53                   	push   %ebx
f011de08:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f011de0e:	a0 9c 9d 17 f0       	mov    0xf0179d9c,%al
f011de13:	84 c0                	test   %al,%al
f011de15:	74 56                	je     f011de6d <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f011de17:	c6 05 9c 9d 17 f0 00 	movb   $0x0,0xf0179d9c
		initFreeFrames = sys_calculate_free_frames() ;
f011de1e:	e8 e6 f8 fe ff       	call   f010d709 <sys_calculate_free_frames>
f011de23:	a3 c8 78 57 f0       	mov    %eax,0xf05778c8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f011de28:	e8 14 67 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011de2d:	a3 c4 78 57 f0       	mov    %eax,0xf05778c4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f011de32:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011de38:	bb e5 cd 12 f0       	mov    $0xf012cde5,%ebx
f011de3d:	ba 11 00 00 00       	mov    $0x11,%edx
f011de42:	89 c7                	mov    %eax,%edi
f011de44:	89 de                	mov    %ebx,%esi
f011de46:	89 d1                	mov    %edx,%ecx
f011de48:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011de4a:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f011de50:	b9 53 00 00 00       	mov    $0x53,%ecx
f011de55:	b0 00                	mov    $0x0,%al
f011de57:	89 d7                	mov    %edx,%edi
f011de59:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f011de5b:	83 ec 0c             	sub    $0xc,%esp
f011de5e:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011de64:	50                   	push   %eax
f011de65:	e8 72 40 fe ff       	call   f0101edc <execute_command>
f011de6a:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f011de6d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f011de74:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011de7b:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f011de80:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011de83:	eb 2b                	jmp    f011deb0 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f011de85:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011de88:	83 c0 20             	add    $0x20,%eax
f011de8b:	83 ec 08             	sub    $0x8,%esp
f011de8e:	68 cd cc 12 f0       	push   $0xf012cccd
f011de93:	50                   	push   %eax
f011de94:	e8 a6 27 00 00       	call   f012063f <strcmp>
f011de99:	83 c4 10             	add    $0x10,%esp
f011de9c:	85 c0                	test   %eax,%eax
f011de9e:	75 08                	jne    f011dea8 <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f011dea0:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011dea3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f011dea6:	eb 2f                	jmp    f011ded7 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f011dea8:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011dead:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011deb0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011deb4:	74 08                	je     f011debe <test_three_creation_functions+0xbc>
f011deb6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011deb9:	8b 40 08             	mov    0x8(%eax),%eax
f011debc:	eb 05                	jmp    f011dec3 <test_three_creation_functions+0xc1>
f011debe:	b8 00 00 00 00       	mov    $0x0,%eax
f011dec3:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f011dec8:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011decd:	85 c0                	test   %eax,%eax
f011decf:	75 b4                	jne    f011de85 <test_three_creation_functions+0x83>
f011ded1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011ded5:	75 ae                	jne    f011de85 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f011ded7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011deda:	8b 80 40 da 01 00    	mov    0x1da40(%eax),%eax
f011dee0:	85 c0                	test   %eax,%eax
f011dee2:	74 17                	je     f011defb <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f011dee4:	83 ec 04             	sub    $0x4,%esp
f011dee7:	68 d8 cc 12 f0       	push   $0xf012ccd8
f011deec:	68 f0 0c 00 00       	push   $0xcf0
f011def1:	68 72 c5 12 f0       	push   $0xf012c572
f011def6:	e8 1f 24 fe ff       	call   f010031a <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
#else
		int pagesInWS = env_page_ws_get_size(e);
f011defb:	83 ec 0c             	sub    $0xc,%esp
f011defe:	ff 75 e4             	pushl  -0x1c(%ebp)
f011df01:	e8 59 ab fe ff       	call   f0108a5f <env_page_ws_get_size>
f011df06:	83 c4 10             	add    $0x10,%esp
f011df09:	89 45 dc             	mov    %eax,-0x24(%ebp)
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f011df0c:	e8 f8 f7 fe ff       	call   f010d709 <sys_calculate_free_frames>
f011df11:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f011df14:	e8 28 66 fe ff       	call   f0104541 <pf_calculate_free_frames>
f011df19:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f011df1c:	a1 c4 78 57 f0       	mov    0xf05778c4,%eax
f011df21:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f011df24:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011df27:	74 17                	je     f011df40 <test_three_creation_functions+0x13e>
f011df29:	83 ec 04             	sub    $0x4,%esp
f011df2c:	68 e0 c6 12 f0       	push   $0xf012c6e0
f011df31:	68 fa 0c 00 00       	push   $0xcfa
f011df36:	68 72 c5 12 f0       	push   $0xf012c572
f011df3b:	e8 da 23 fe ff       	call   f010031a <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f011df40:	a1 c8 78 57 f0       	mov    0xf05778c8,%eax
f011df45:	2b 45 d8             	sub    -0x28(%ebp),%eax
f011df48:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011df4b:	83 c2 15             	add    $0x15,%edx
f011df4e:	39 d0                	cmp    %edx,%eax
f011df50:	74 17                	je     f011df69 <test_three_creation_functions+0x167>
f011df52:	83 ec 04             	sub    $0x4,%esp
f011df55:	68 48 c7 12 f0       	push   $0xf012c748
f011df5a:	68 fc 0c 00 00       	push   $0xcfc
f011df5f:	68 72 c5 12 f0       	push   $0xf012c572
f011df64:	e8 b1 23 fe ff       	call   f010031a <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f011df69:	83 ec 0c             	sub    $0xc,%esp
f011df6c:	68 00 10 00 00       	push   $0x1000
f011df71:	e8 41 a8 fe ff       	call   f01087b7 <kmalloc>
f011df76:	83 c4 10             	add    $0x10,%esp
f011df79:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f011df7c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011df7f:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f011df84:	74 17                	je     f011df9d <test_three_creation_functions+0x19b>
f011df86:	83 ec 04             	sub    $0x4,%esp
f011df89:	68 28 cd 12 f0       	push   $0xf012cd28
f011df8e:	68 00 0d 00 00       	push   $0xd00
f011df93:	68 72 c5 12 f0       	push   $0xf012c572
f011df98:	e8 7d 23 fe ff       	call   f010031a <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f011df9d:	83 ec 0c             	sub    $0xc,%esp
f011dfa0:	68 98 cd 12 f0       	push   $0xf012cd98
f011dfa5:	e8 c2 2f fe ff       	call   f0100f6c <cprintf>
f011dfaa:	83 c4 10             	add    $0x10,%esp

	return 1;
f011dfad:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011dfb2:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011dfb5:	5b                   	pop    %ebx
f011dfb6:	5e                   	pop    %esi
f011dfb7:	5f                   	pop    %edi
f011dfb8:	5d                   	pop    %ebp
f011dfb9:	c3                   	ret    

f011dfba <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f011dfba:	55                   	push   %ebp
f011dfbb:	89 e5                	mov    %esp,%ebp
f011dfbd:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011dfc0:	83 ec 04             	sub    $0x4,%esp
f011dfc3:	68 49 ce 12 f0       	push   $0xf012ce49
f011dfc8:	68 0e 0d 00 00       	push   $0xd0e
f011dfcd:	68 72 c5 12 f0       	push   $0xf012c572
f011dfd2:	e8 43 23 fe ff       	call   f010031a <_panic>

f011dfd7 <test_kexpand>:

	return 1;

}
int test_kexpand(){
f011dfd7:	55                   	push   %ebp
f011dfd8:	89 e5                	mov    %esp,%ebp
f011dfda:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011dfdd:	83 ec 04             	sub    $0x4,%esp
f011dfe0:	68 49 ce 12 f0       	push   $0xf012ce49
f011dfe5:	68 14 0d 00 00       	push   $0xd14
f011dfea:	68 72 c5 12 f0       	push   $0xf012c572
f011dfef:	e8 26 23 fe ff       	call   f010031a <_panic>

f011dff4 <test_kshrink>:
	return 1;
}

int test_kshrink(){
f011dff4:	55                   	push   %ebp
f011dff5:	89 e5                	mov    %esp,%ebp
f011dff7:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011dffa:	83 ec 04             	sub    $0x4,%esp
f011dffd:	68 49 ce 12 f0       	push   $0xf012ce49
f011e002:	68 19 0d 00 00       	push   $0xd19
f011e007:	68 72 c5 12 f0       	push   $0xf012c572
f011e00c:	e8 09 23 fe ff       	call   f010031a <_panic>

f011e011 <test_kfreelast>:
	return 1;
}
int test_kfreelast(){
f011e011:	55                   	push   %ebp
f011e012:	89 e5                	mov    %esp,%ebp
f011e014:	83 ec 08             	sub    $0x8,%esp
	panic("test not available yet");
f011e017:	83 ec 04             	sub    $0x4,%esp
f011e01a:	68 49 ce 12 f0       	push   $0xf012ce49
f011e01f:	68 1d 0d 00 00       	push   $0xd1d
f011e024:	68 72 c5 12 f0       	push   $0xf012c572
f011e029:	e8 ec 22 fe ff       	call   f010031a <_panic>

f011e02e <test_krealloc>:
	return 1;
}

int test_krealloc() {
f011e02e:	55                   	push   %ebp
f011e02f:	89 e5                	mov    %esp,%ebp
f011e031:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011e034:	83 ec 0c             	sub    $0xc,%esp
f011e037:	68 00 be 12 f0       	push   $0xf012be00
f011e03c:	e8 2b 2f fe ff       	call   f0100f6c <cprintf>
f011e041:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011e044:	83 ec 0c             	sub    $0xc,%esp
f011e047:	68 30 be 12 f0       	push   $0xf012be30
f011e04c:	e8 1b 2f fe ff       	call   f0100f6c <cprintf>
f011e051:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011e054:	83 ec 0c             	sub    $0xc,%esp
f011e057:	68 00 be 12 f0       	push   $0xf012be00
f011e05c:	e8 0b 2f fe ff       	call   f0100f6c <cprintf>
f011e061:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011e064:	83 ec 04             	sub    $0x4,%esp
f011e067:	68 49 ce 12 f0       	push   $0xf012ce49
f011e06c:	68 26 0d 00 00       	push   $0xd26
f011e071:	68 72 c5 12 f0       	push   $0xf012c572
f011e076:	e8 9f 22 fe ff       	call   f010031a <_panic>

f011e07b <test_krealloc_BF>:
	return 0;
}


int test_krealloc_BF() {
f011e07b:	55                   	push   %ebp
f011e07c:	89 e5                	mov    %esp,%ebp
f011e07e:	83 ec 08             	sub    $0x8,%esp
	cprintf("==============================================\n");
f011e081:	83 ec 0c             	sub    $0xc,%esp
f011e084:	68 00 be 12 f0       	push   $0xf012be00
f011e089:	e8 de 2e fe ff       	call   f0100f6c <cprintf>
f011e08e:	83 c4 10             	add    $0x10,%esp
	cprintf(
f011e091:	83 ec 0c             	sub    $0xc,%esp
f011e094:	68 30 be 12 f0       	push   $0xf012be30
f011e099:	e8 ce 2e fe ff       	call   f0100f6c <cprintf>
f011e09e:	83 c4 10             	add    $0x10,%esp
			"MAKE SURE to have a FRESH RUN for this test\n(i.e. don't run any program/test before it)\n");
	cprintf("==============================================\n");
f011e0a1:	83 ec 0c             	sub    $0xc,%esp
f011e0a4:	68 00 be 12 f0       	push   $0xf012be00
f011e0a9:	e8 be 2e fe ff       	call   f0100f6c <cprintf>
f011e0ae:	83 c4 10             	add    $0x10,%esp
	panic("test not available yet");
f011e0b1:	83 ec 04             	sub    $0x4,%esp
f011e0b4:	68 49 ce 12 f0       	push   $0xf012ce49
f011e0b9:	68 30 0d 00 00       	push   $0xd30
f011e0be:	68 72 c5 12 f0       	push   $0xf012c572
f011e0c3:	e8 52 22 fe ff       	call   f010031a <_panic>

f011e0c8 <test_krealloc_FF1>:
	return 0;
}

int test_krealloc_FF1()
{
f011e0c8:	55                   	push   %ebp
f011e0c9:	89 e5                	mov    %esp,%ebp
f011e0cb:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011e0ce:	83 ec 0c             	sub    $0xc,%esp
f011e0d1:	68 60 ce 12 f0       	push   $0xf012ce60
f011e0d6:	e8 91 2e fe ff       	call   f0100f6c <cprintf>
f011e0db:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [BLOCK ALLOCATOR]******\n") ;
f011e0de:	83 ec 0c             	sub    $0xc,%esp
f011e0e1:	68 98 ce 12 f0       	push   $0xf012ce98
f011e0e6:	e8 81 2e fe ff       	call   f0100f6c <cprintf>
f011e0eb:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011e0ee:	83 ec 0c             	sub    $0xc,%esp
f011e0f1:	68 60 ce 12 f0       	push   $0xf012ce60
f011e0f6:	e8 71 2e fe ff       	call   f0100f6c <cprintf>
f011e0fb:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011e0fe:	83 ec 04             	sub    $0x4,%esp
f011e101:	68 49 ce 12 f0       	push   $0xf012ce49
f011e106:	68 3a 0d 00 00       	push   $0xd3a
f011e10b:	68 72 c5 12 f0       	push   $0xf012c572
f011e110:	e8 05 22 fe ff       	call   f010031a <_panic>

f011e115 <test_krealloc_FF2>:
	return 0;

}
int test_krealloc_FF2()
{
f011e115:	55                   	push   %ebp
f011e116:	89 e5                	mov    %esp,%ebp
f011e118:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011e11b:	83 ec 0c             	sub    $0xc,%esp
f011e11e:	68 60 ce 12 f0       	push   $0xf012ce60
f011e123:	e8 44 2e fe ff       	call   f0100f6c <cprintf>
f011e128:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [PAGE ALLOCATOR]******\n") ;
f011e12b:	83 ec 0c             	sub    $0xc,%esp
f011e12e:	68 e4 ce 12 f0       	push   $0xf012cee4
f011e133:	e8 34 2e fe ff       	call   f0100f6c <cprintf>
f011e138:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011e13b:	83 ec 0c             	sub    $0xc,%esp
f011e13e:	68 60 ce 12 f0       	push   $0xf012ce60
f011e143:	e8 24 2e fe ff       	call   f0100f6c <cprintf>
f011e148:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011e14b:	83 ec 04             	sub    $0x4,%esp
f011e14e:	68 49 ce 12 f0       	push   $0xf012ce49
f011e153:	68 44 0d 00 00       	push   $0xd44
f011e158:	68 72 c5 12 f0       	push   $0xf012c572
f011e15d:	e8 b8 21 fe ff       	call   f010031a <_panic>

f011e162 <test_krealloc_FF3>:
	return 0;
}

int test_krealloc_FF3()
{
f011e162:	55                   	push   %ebp
f011e163:	89 e5                	mov    %esp,%ebp
f011e165:	83 ec 08             	sub    $0x8,%esp
	cprintf("===================================================\n");
f011e168:	83 ec 0c             	sub    $0xc,%esp
f011e16b:	68 60 ce 12 f0       	push   $0xf012ce60
f011e170:	e8 f7 2d fe ff       	call   f0100f6c <cprintf>
f011e175:	83 c4 10             	add    $0x10,%esp
	cprintf("*****NOTE: THIS IS A COMPLETE TEST FOR KREALLOC [SWITCH FROM PAGE ALLOCATOR TO DYNAMIC ALLOCATOR AND VICE VERSA]******\n") ;
f011e178:	83 ec 0c             	sub    $0xc,%esp
f011e17b:	68 2c cf 12 f0       	push   $0xf012cf2c
f011e180:	e8 e7 2d fe ff       	call   f0100f6c <cprintf>
f011e185:	83 c4 10             	add    $0x10,%esp
	cprintf("===================================================\n");
f011e188:	83 ec 0c             	sub    $0xc,%esp
f011e18b:	68 60 ce 12 f0       	push   $0xf012ce60
f011e190:	e8 d7 2d fe ff       	call   f0100f6c <cprintf>
f011e195:	83 c4 10             	add    $0x10,%esp

	panic("test not available yet");
f011e198:	83 ec 04             	sub    $0x4,%esp
f011e19b:	68 49 ce 12 f0       	push   $0xf012ce49
f011e1a0:	68 4e 0d 00 00       	push   $0xd4e
f011e1a5:	68 72 c5 12 f0       	push   $0xf012c572
f011e1aa:	e8 6b 21 fe ff       	call   f010031a <_panic>

f011e1af <print_order>:
uint8 firstTimeTestBSD = 1;
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f011e1af:	55                   	push   %ebp
f011e1b0:	89 e5                	mov    %esp,%ebp
f011e1b2:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e1b5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011e1bc:	e9 84 00 00 00       	jmp    f011e245 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f011e1c1:	83 ec 08             	sub    $0x8,%esp
f011e1c4:	ff 75 f4             	pushl  -0xc(%ebp)
f011e1c7:	68 a4 cf 12 f0       	push   $0xf012cfa4
f011e1cc:	e8 9b 2d fe ff       	call   f0100f6c <cprintf>
f011e1d1:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011e1d4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011e1db:	eb 4c                	jmp    f011e229 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f011e1dd:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1e0:	89 d0                	mov    %edx,%eax
f011e1e2:	c1 e0 02             	shl    $0x2,%eax
f011e1e5:	01 d0                	add    %edx,%eax
f011e1e7:	c1 e0 03             	shl    $0x3,%eax
f011e1ea:	89 c2                	mov    %eax,%edx
f011e1ec:	8b 45 08             	mov    0x8(%ebp),%eax
f011e1ef:	01 c2                	add    %eax,%edx
f011e1f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e1f4:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011e1f7:	85 c0                	test   %eax,%eax
f011e1f9:	74 36                	je     f011e231 <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f011e1fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e1fe:	89 d0                	mov    %edx,%eax
f011e200:	c1 e0 02             	shl    $0x2,%eax
f011e203:	01 d0                	add    %edx,%eax
f011e205:	c1 e0 03             	shl    $0x3,%eax
f011e208:	89 c2                	mov    %eax,%edx
f011e20a:	8b 45 08             	mov    0x8(%ebp),%eax
f011e20d:	01 c2                	add    %eax,%edx
f011e20f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e212:	8b 04 82             	mov    (%edx,%eax,4),%eax
f011e215:	83 ec 08             	sub    $0x8,%esp
f011e218:	50                   	push   %eax
f011e219:	68 ac cf 12 f0       	push   $0xf012cfac
f011e21e:	e8 49 2d fe ff       	call   f0100f6c <cprintf>
f011e223:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f011e226:	ff 45 f0             	incl   -0x10(%ebp)
f011e229:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011e22d:	7e ae                	jle    f011e1dd <print_order+0x2e>
f011e22f:	eb 01                	jmp    f011e232 <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f011e231:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f011e232:	83 ec 0c             	sub    $0xc,%esp
f011e235:	68 b1 cf 12 f0       	push   $0xf012cfb1
f011e23a:	e8 2d 2d fe ff       	call   f0100f6c <cprintf>
f011e23f:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_NICE_VALUES][INSTANCES_NUMBER];
int nice_count[TOTAL_NICE_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e242:	ff 45 f4             	incl   -0xc(%ebp)
f011e245:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f011e249:	0f 8e 72 ff ff ff    	jle    f011e1c1 <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f011e24f:	90                   	nop
f011e250:	c9                   	leave  
f011e251:	c3                   	ret    

f011e252 <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f011e252:	55                   	push   %ebp
f011e253:	89 e5                	mov    %esp,%ebp
f011e255:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f011e258:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_spinlock(&ProcessQueues.qlock);
f011e25f:	83 ec 0c             	sub    $0xc,%esp
f011e262:	68 60 24 55 f0       	push   $0xf0552460
f011e267:	e8 14 05 ff ff       	call   f010e780 <acquire_spinlock>
f011e26c:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f011e26f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f011e276:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f011e27d:	8b 55 0c             	mov    0xc(%ebp),%edx
f011e280:	8b 45 10             	mov    0x10(%ebp),%eax
f011e283:	01 d0                	add    %edx,%eax
f011e285:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e288:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011e28d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e290:	a1 e4 24 55 f0       	mov    0xf05524e4,%eax
f011e295:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f011e298:	ff 75 e8             	pushl  -0x18(%ebp)
f011e29b:	ff 75 0c             	pushl  0xc(%ebp)
f011e29e:	ff 75 08             	pushl  0x8(%ebp)
f011e2a1:	68 b4 cf 12 f0       	push   $0xf012cfb4
f011e2a6:	e8 c1 2c fe ff       	call   f0100f6c <cprintf>
f011e2ab:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e2ae:	eb 34                	jmp    f011e2e4 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f011e2b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2b3:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011e2b6:	7d 05                	jge    f011e2bd <find_in_range+0x6b>
			{
				i++;
f011e2b8:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f011e2bb:	eb 1e                	jmp    f011e2db <find_in_range+0x89>
			}
			if (i >= end)
f011e2bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2c0:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011e2c3:	7d 29                	jge    f011e2ee <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f011e2c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e2c8:	8b 40 10             	mov    0x10(%eax),%eax
f011e2cb:	3b 45 08             	cmp    0x8(%ebp),%eax
f011e2ce:	75 08                	jne    f011e2d8 <find_in_range+0x86>
			{
				ret = i;
f011e2d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2d3:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f011e2d6:	eb 17                	jmp    f011e2ef <find_in_range+0x9d>
			}
			i++;
f011e2d8:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e2db:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e2de:	8b 40 0c             	mov    0xc(%eax),%eax
f011e2e1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e2e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e2e7:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011e2ea:	7c c4                	jl     f011e2b0 <find_in_range+0x5e>
f011e2ec:	eb 01                	jmp    f011e2ef <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f011e2ee:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011e2ef:	83 ec 0c             	sub    $0xc,%esp
f011e2f2:	68 60 24 55 f0       	push   $0xf0552460
f011e2f7:	e8 0b 05 ff ff       	call   f010e807 <release_spinlock>
f011e2fc:	83 c4 10             	add    $0x10,%esp
	return ret;
f011e2ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011e302:	c9                   	leave  
f011e303:	c3                   	ret    

f011e304 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f011e304:	55                   	push   %ebp
f011e305:	89 e5                	mov    %esp,%ebp
f011e307:	57                   	push   %edi
f011e308:	56                   	push   %esi
f011e309:	53                   	push   %ebx
f011e30a:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011e30d:	a0 9d 9d 17 f0       	mov    0xf0179d9d,%al
f011e312:	84 c0                	test   %al,%al
f011e314:	0f 84 9b 01 00 00    	je     f011e4b5 <test_bsd_nice_0+0x1b1>
	{
		firstTimeTestBSD = 0;
f011e31a:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
		int nice_values[] = {-10, -5, 0, 5, 10};
f011e321:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e324:	bb 2c d1 12 f0       	mov    $0xf012d12c,%ebx
f011e329:	ba 05 00 00 00       	mov    $0x5,%edx
f011e32e:	89 c7                	mov    %eax,%edi
f011e330:	89 de                	mov    %ebx,%esi
f011e332:	89 d1                	mov    %edx,%ecx
f011e334:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011e336:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011e33d:	e9 44 01 00 00       	jmp    f011e486 <test_bsd_nice_0+0x182>
		{
			struct Env *env = env_create("bsd_fib", 500, 0, 0);
f011e342:	6a 00                	push   $0x0
f011e344:	6a 00                	push   $0x0
f011e346:	68 f4 01 00 00       	push   $0x1f4
f011e34b:	68 e5 cf 12 f0       	push   $0xf012cfe5
f011e350:	e8 1c b4 fe ff       	call   f0109771 <env_create>
f011e355:	83 c4 10             	add    $0x10,%esp
f011e358:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011e35b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e35e:	b9 05 00 00 00       	mov    $0x5,%ecx
f011e363:	99                   	cltd   
f011e364:	f7 f9                	idiv   %ecx
f011e366:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011e369:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e36c:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e370:	83 ec 08             	sub    $0x8,%esp
f011e373:	50                   	push   %eax
f011e374:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e377:	e8 2c 80 fe ff       	call   f01063a8 <env_set_nice>
f011e37c:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011e37f:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011e383:	75 14                	jne    f011e399 <test_bsd_nice_0+0x95>
				panic("Loading programs failed\n");
f011e385:	83 ec 04             	sub    $0x4,%esp
f011e388:	68 ed cf 12 f0       	push   $0xf012cfed
f011e38d:	6a 53                	push   $0x53
f011e38f:	68 06 d0 12 f0       	push   $0xf012d006
f011e394:	e8 81 1f fe ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 500)
f011e399:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e39c:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e3a2:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e3a7:	74 14                	je     f011e3bd <test_bsd_nice_0+0xb9>
				panic("The program working set size is not correct\n");
f011e3a9:	83 ec 04             	sub    $0x4,%esp
f011e3ac:	68 24 d0 12 f0       	push   $0xf012d024
f011e3b1:	6a 55                	push   $0x55
f011e3b3:	68 06 d0 12 f0       	push   $0xf012d006
f011e3b8:	e8 5d 1f fe ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f011e3bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e3c0:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e3c4:	83 c0 0a             	add    $0xa,%eax
f011e3c7:	83 f8 14             	cmp    $0x14,%eax
f011e3ca:	0f 87 a5 00 00 00    	ja     f011e475 <test_bsd_nice_0+0x171>
f011e3d0:	8b 04 85 40 d1 12 f0 	mov    -0xfed2ec0(,%eax,4),%eax
f011e3d7:	ff e0                	jmp    *%eax
			{
			case -10:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011e3d9:	a1 9c 22 55 f0       	mov    0xf055229c,%eax
f011e3de:	8d 50 01             	lea    0x1(%eax),%edx
f011e3e1:	89 15 9c 22 55 f0    	mov    %edx,0xf055229c
f011e3e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e3ea:	8b 52 10             	mov    0x10(%edx),%edx
f011e3ed:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e3f4:	eb 7f                	jmp    f011e475 <test_bsd_nice_0+0x171>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011e3f6:	a1 a0 22 55 f0       	mov    0xf05522a0,%eax
f011e3fb:	8d 50 01             	lea    0x1(%eax),%edx
f011e3fe:	89 15 a0 22 55 f0    	mov    %edx,0xf05522a0
f011e404:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e407:	8b 52 10             	mov    0x10(%edx),%edx
f011e40a:	83 c0 0a             	add    $0xa,%eax
f011e40d:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e414:	eb 5f                	jmp    f011e475 <test_bsd_nice_0+0x171>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e416:	a1 a4 22 55 f0       	mov    0xf05522a4,%eax
f011e41b:	8d 50 01             	lea    0x1(%eax),%edx
f011e41e:	89 15 a4 22 55 f0    	mov    %edx,0xf05522a4
f011e424:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e427:	8b 52 10             	mov    0x10(%edx),%edx
f011e42a:	83 c0 14             	add    $0x14,%eax
f011e42d:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e434:	eb 3f                	jmp    f011e475 <test_bsd_nice_0+0x171>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e436:	a1 a8 22 55 f0       	mov    0xf05522a8,%eax
f011e43b:	8d 50 01             	lea    0x1(%eax),%edx
f011e43e:	89 15 a8 22 55 f0    	mov    %edx,0xf05522a8
f011e444:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e447:	8b 52 10             	mov    0x10(%edx),%edx
f011e44a:	83 c0 1e             	add    $0x1e,%eax
f011e44d:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e454:	eb 1f                	jmp    f011e475 <test_bsd_nice_0+0x171>
			case 10:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e456:	a1 ac 22 55 f0       	mov    0xf05522ac,%eax
f011e45b:	8d 50 01             	lea    0x1(%eax),%edx
f011e45e:	89 15 ac 22 55 f0    	mov    %edx,0xf05522ac
f011e464:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e467:	8b 52 10             	mov    0x10(%edx),%edx
f011e46a:	83 c0 28             	add    $0x28,%eax
f011e46d:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e474:	90                   	nop
			}
			sched_new_env(env);
f011e475:	83 ec 0c             	sub    $0xc,%esp
f011e478:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e47b:	e8 26 6f fe ff       	call   f01053a6 <sched_new_env>
f011e480:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTestBSD)
	{
		firstTimeTestBSD = 0;
		int nice_values[] = {-10, -5, 0, 5, 10};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f011e483:	ff 45 e4             	incl   -0x1c(%ebp)
f011e486:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f011e48a:	0f 8e b2 fe ff ff    	jle    f011e342 <test_bsd_nice_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e490:	83 ec 0c             	sub    $0xc,%esp
f011e493:	68 54 d0 12 f0       	push   $0xf012d054
f011e498:	e8 cf 2a fe ff       	call   f0100f6c <cprintf>
f011e49d:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e4a0:	83 ec 0c             	sub    $0xc,%esp
f011e4a3:	68 a3 d0 12 f0       	push   $0xf012d0a3
f011e4a8:	e8 2f 3a fe ff       	call   f0101edc <execute_command>
f011e4ad:	83 c4 10             	add    $0x10,%esp
f011e4b0:	e9 c0 00 00 00       	jmp    f011e575 <test_bsd_nice_0+0x271>
	}
	else
	{
		cprintf("> Checking...\n");
f011e4b5:	83 ec 0c             	sub    $0xc,%esp
f011e4b8:	68 aa d0 12 f0       	push   $0xf012d0aa
f011e4bd:	e8 aa 2a fe ff       	call   f0100f6c <cprintf>
f011e4c2:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e4c5:	e8 58 76 fe ff       	call   f0105b22 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e4ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e4d1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e4d8:	e9 87 00 00 00       	jmp    f011e564 <test_bsd_nice_0+0x260>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e4dd:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e4e4:	eb 52                	jmp    f011e538 <test_bsd_nice_0+0x234>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e4e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e4e9:	8b 14 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%edx
f011e4f0:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e4f3:	89 c8                	mov    %ecx,%eax
f011e4f5:	c1 e0 02             	shl    $0x2,%eax
f011e4f8:	01 c8                	add    %ecx,%eax
f011e4fa:	01 c0                	add    %eax,%eax
f011e4fc:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e4ff:	01 c8                	add    %ecx,%eax
f011e501:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011e508:	83 ec 04             	sub    $0x4,%esp
f011e50b:	52                   	push   %edx
f011e50c:	ff 75 e0             	pushl  -0x20(%ebp)
f011e50f:	50                   	push   %eax
f011e510:	e8 3d fd ff ff       	call   f011e252 <find_in_range>
f011e515:	83 c4 10             	add    $0x10,%esp
f011e518:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e51b:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e51f:	75 14                	jne    f011e535 <test_bsd_nice_0+0x231>
					panic("The programs' order of finishing is not correct\n");
f011e521:	83 ec 04             	sub    $0x4,%esp
f011e524:	68 bc d0 12 f0       	push   $0xf012d0bc
f011e529:	6a 7b                	push   $0x7b
f011e52b:	68 06 d0 12 f0       	push   $0xf012d006
f011e530:	e8 e5 1d fe ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e535:	ff 45 d8             	incl   -0x28(%ebp)
f011e538:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e53b:	89 d0                	mov    %edx,%eax
f011e53d:	c1 e0 02             	shl    $0x2,%eax
f011e540:	01 d0                	add    %edx,%eax
f011e542:	01 c0                	add    %eax,%eax
f011e544:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011e547:	01 d0                	add    %edx,%eax
f011e549:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011e550:	85 c0                	test   %eax,%eax
f011e552:	75 92                	jne    f011e4e6 <test_bsd_nice_0+0x1e2>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011e554:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e557:	8b 04 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%eax
f011e55e:	01 45 e0             	add    %eax,-0x20(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e561:	ff 45 dc             	incl   -0x24(%ebp)
f011e564:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011e568:	0f 8e 6f ff ff ff    	jle    f011e4dd <test_bsd_nice_0+0x1d9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011e56e:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
	}
	cprintf("\nCongratulations!! test_bsd_nice_0 completed successfully.\n");
f011e575:	83 ec 0c             	sub    $0xc,%esp
f011e578:	68 f0 d0 12 f0       	push   $0xf012d0f0
f011e57d:	e8 ea 29 fe ff       	call   f0100f6c <cprintf>
f011e582:	83 c4 10             	add    $0x10,%esp
}
f011e585:	90                   	nop
f011e586:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011e589:	5b                   	pop    %ebx
f011e58a:	5e                   	pop    %esi
f011e58b:	5f                   	pop    %edi
f011e58c:	5d                   	pop    %ebp
f011e58d:	c3                   	ret    

f011e58e <test_bsd_nice_1>:


void test_bsd_nice_1()
{
f011e58e:	55                   	push   %ebp
f011e58f:	89 e5                	mov    %esp,%ebp
f011e591:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTestBSD)
f011e594:	a0 9d 9d 17 f0       	mov    0xf0179d9d,%al
f011e599:	84 c0                	test   %al,%al
f011e59b:	0f 84 50 01 00 00    	je     f011e6f1 <test_bsd_nice_1+0x163>
	{
		firstTimeTestBSD = 0;
f011e5a1:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
		struct Env *fibEnv = env_create("bsd_fib", 500, 0, 0);
f011e5a8:	6a 00                	push   $0x0
f011e5aa:	6a 00                	push   $0x0
f011e5ac:	68 f4 01 00 00       	push   $0x1f4
f011e5b1:	68 e5 cf 12 f0       	push   $0xf012cfe5
f011e5b6:	e8 b6 b1 fe ff       	call   f0109771 <env_create>
f011e5bb:	83 c4 10             	add    $0x10,%esp
f011e5be:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibposnEnv = env_create("bsd_fib_posn", 500, 0, 0);
f011e5c1:	6a 00                	push   $0x0
f011e5c3:	6a 00                	push   $0x0
f011e5c5:	68 f4 01 00 00       	push   $0x1f4
f011e5ca:	68 94 d1 12 f0       	push   $0xf012d194
f011e5cf:	e8 9d b1 fe ff       	call   f0109771 <env_create>
f011e5d4:	83 c4 10             	add    $0x10,%esp
f011e5d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibnegnEnv = env_create("bsd_fib_negn", 500, 0, 0);
f011e5da:	6a 00                	push   $0x0
f011e5dc:	6a 00                	push   $0x0
f011e5de:	68 f4 01 00 00       	push   $0x1f4
f011e5e3:	68 a1 d1 12 f0       	push   $0xf012d1a1
f011e5e8:	e8 84 b1 fe ff       	call   f0109771 <env_create>
f011e5ed:	83 c4 10             	add    $0x10,%esp
f011e5f0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		if (fibEnv == NULL || fibposnEnv == NULL || fibnegnEnv == NULL)
f011e5f3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011e5f7:	74 0c                	je     f011e605 <test_bsd_nice_1+0x77>
f011e5f9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011e5fd:	74 06                	je     f011e605 <test_bsd_nice_1+0x77>
f011e5ff:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011e603:	75 17                	jne    f011e61c <test_bsd_nice_1+0x8e>
			panic("Loading programs failed\n");
f011e605:	83 ec 04             	sub    $0x4,%esp
f011e608:	68 ed cf 12 f0       	push   $0xf012cfed
f011e60d:	68 8e 00 00 00       	push   $0x8e
f011e612:	68 06 d0 12 f0       	push   $0xf012d006
f011e617:	e8 fe 1c fe ff       	call   f010031a <_panic>
		if (fibEnv->page_WS_max_size != 500 || fibposnEnv->page_WS_max_size != 500 || fibnegnEnv->page_WS_max_size != 500)
f011e61c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e61f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e625:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e62a:	75 20                	jne    f011e64c <test_bsd_nice_1+0xbe>
f011e62c:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e62f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e635:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e63a:	75 10                	jne    f011e64c <test_bsd_nice_1+0xbe>
f011e63c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e63f:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e645:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011e64a:	74 35                	je     f011e681 <test_bsd_nice_1+0xf3>
			panic("The programs should be initially loaded with the given working set size. fib: %d, fibposn: %d, fibnegn: %d\n", fibEnv->page_WS_max_size, fibposnEnv->page_WS_max_size, fibnegnEnv->page_WS_max_size);
f011e64c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e64f:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f011e655:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e658:	8b 90 84 00 00 00    	mov    0x84(%eax),%edx
f011e65e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e661:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e667:	83 ec 08             	sub    $0x8,%esp
f011e66a:	51                   	push   %ecx
f011e66b:	52                   	push   %edx
f011e66c:	50                   	push   %eax
f011e66d:	68 b0 d1 12 f0       	push   $0xf012d1b0
f011e672:	68 90 00 00 00       	push   $0x90
f011e677:	68 06 d0 12 f0       	push   $0xf012d006
f011e67c:	e8 99 1c fe ff       	call   f010031a <_panic>
		sched_new_env(fibEnv);
f011e681:	83 ec 0c             	sub    $0xc,%esp
f011e684:	ff 75 ec             	pushl  -0x14(%ebp)
f011e687:	e8 1a 6d fe ff       	call   f01053a6 <sched_new_env>
f011e68c:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibposnEnv);
f011e68f:	83 ec 0c             	sub    $0xc,%esp
f011e692:	ff 75 e8             	pushl  -0x18(%ebp)
f011e695:	e8 0c 6d fe ff       	call   f01053a6 <sched_new_env>
f011e69a:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibnegnEnv);
f011e69d:	83 ec 0c             	sub    $0xc,%esp
f011e6a0:	ff 75 e4             	pushl  -0x1c(%ebp)
f011e6a3:	e8 fe 6c fe ff       	call   f01053a6 <sched_new_env>
f011e6a8:	83 c4 10             	add    $0x10,%esp
		prog_orders[0][0] = fibnegnEnv->env_id;
f011e6ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e6ae:	8b 40 10             	mov    0x10(%eax),%eax
f011e6b1:	a3 e0 78 57 f0       	mov    %eax,0xf05778e0
		prog_orders[1][0] = fibEnv->env_id;
f011e6b6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011e6b9:	8b 40 10             	mov    0x10(%eax),%eax
f011e6bc:	a3 08 79 57 f0       	mov    %eax,0xf0577908
		prog_orders[2][0] = fibposnEnv->env_id;
f011e6c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011e6c4:	8b 40 10             	mov    0x10(%eax),%eax
f011e6c7:	a3 30 79 57 f0       	mov    %eax,0xf0577930
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e6cc:	83 ec 0c             	sub    $0xc,%esp
f011e6cf:	68 54 d0 12 f0       	push   $0xf012d054
f011e6d4:	e8 93 28 fe ff       	call   f0100f6c <cprintf>
f011e6d9:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e6dc:	83 ec 0c             	sub    $0xc,%esp
f011e6df:	68 a3 d0 12 f0       	push   $0xf012d0a3
f011e6e4:	e8 f3 37 fe ff       	call   f0101edc <execute_command>
f011e6e9:	83 c4 10             	add    $0x10,%esp
f011e6ec:	e9 9e 00 00 00       	jmp    f011e78f <test_bsd_nice_1+0x201>
	}
	else
	{
		cprintf("> Checking...\n");
f011e6f1:	83 ec 0c             	sub    $0xc,%esp
f011e6f4:	68 aa d0 12 f0       	push   $0xf012d0aa
f011e6f9:	e8 6e 28 fe ff       	call   f0100f6c <cprintf>
f011e6fe:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e701:	e8 1c 74 fe ff       	call   f0105b22 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f011e706:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f011e70d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
f011e714:	83 ec 0c             	sub    $0xc,%esp
f011e717:	68 60 24 55 f0       	push   $0xf0552460
f011e71c:	e8 5f 00 ff ff       	call   f010e780 <acquire_spinlock>
f011e721:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011e724:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011e729:	89 45 e0             	mov    %eax,-0x20(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011e72c:	a1 e4 24 55 f0       	mov    0xf05524e4,%eax
f011e731:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e734:	eb 41                	jmp    f011e777 <test_bsd_nice_1+0x1e9>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				//cprintf("%s - id=%d, priority=%d, nice=%d\n", env->prog_name, env->env_id, env->priority, env->nice);
				if (prog_orders[i][0] != env->env_id)
f011e736:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011e739:	89 d0                	mov    %edx,%eax
f011e73b:	c1 e0 02             	shl    $0x2,%eax
f011e73e:	01 d0                	add    %edx,%eax
f011e740:	c1 e0 03             	shl    $0x3,%eax
f011e743:	05 e0 78 57 f0       	add    $0xf05778e0,%eax
f011e748:	8b 10                	mov    (%eax),%edx
f011e74a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e74d:	8b 40 10             	mov    0x10(%eax),%eax
f011e750:	39 c2                	cmp    %eax,%edx
f011e752:	74 17                	je     f011e76b <test_bsd_nice_1+0x1dd>
					panic("The programs' order of finishing is not correct\n");
f011e754:	83 ec 04             	sub    $0x4,%esp
f011e757:	68 bc d0 12 f0       	push   $0xf012d0bc
f011e75c:	68 ab 00 00 00       	push   $0xab
f011e761:	68 06 d0 12 f0       	push   $0xf012d006
f011e766:	e8 af 1b fe ff       	call   f010031a <_panic>
				i++;
f011e76b:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011e76e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011e771:	8b 40 0c             	mov    0xc(%eax),%eax
f011e774:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011e777:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011e77a:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011e77d:	7c b7                	jl     f011e736 <test_bsd_nice_1+0x1a8>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011e77f:	83 ec 0c             	sub    $0xc,%esp
f011e782:	68 60 24 55 f0       	push   $0xf0552460
f011e787:	e8 7b 00 ff ff       	call   f010e807 <release_spinlock>
f011e78c:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_bsd_nice_1 completed successfully.\n");
f011e78f:	83 ec 0c             	sub    $0xc,%esp
f011e792:	68 1c d2 12 f0       	push   $0xf012d21c
f011e797:	e8 d0 27 fe ff       	call   f0100f6c <cprintf>
f011e79c:	83 c4 10             	add    $0x10,%esp
}
f011e79f:	90                   	nop
f011e7a0:	c9                   	leave  
f011e7a1:	c3                   	ret    

f011e7a2 <test_bsd_nice_2>:

void test_bsd_nice_2()
{
f011e7a2:	55                   	push   %ebp
f011e7a3:	89 e5                	mov    %esp,%ebp
f011e7a5:	57                   	push   %edi
f011e7a6:	56                   	push   %esi
f011e7a7:	53                   	push   %ebx
f011e7a8:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTestBSD)
f011e7ab:	a0 9d 9d 17 f0       	mov    0xf0179d9d,%al
f011e7b0:	84 c0                	test   %al,%al
f011e7b2:	0f 84 ae 01 00 00    	je     f011e966 <test_bsd_nice_2+0x1c4>
	{
		chksch(1);
f011e7b8:	83 ec 0c             	sub    $0xc,%esp
f011e7bb:	6a 01                	push   $0x1
f011e7bd:	e8 ce 0e 00 00       	call   f011f690 <chksch>
f011e7c2:	83 c4 10             	add    $0x10,%esp
		firstTimeTestBSD = 0;
f011e7c5:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
		int nice_values[] = {15, 5, 0, -5, -15};
f011e7cc:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011e7cf:	bb a0 d2 12 f0       	mov    $0xf012d2a0,%ebx
f011e7d4:	ba 05 00 00 00       	mov    $0x5,%edx
f011e7d9:	89 c7                	mov    %eax,%edi
f011e7db:	89 de                	mov    %ebx,%esi
f011e7dd:	89 d1                	mov    %edx,%ecx
f011e7df:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e7e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011e7e8:	e9 4a 01 00 00       	jmp    f011e937 <test_bsd_nice_2+0x195>
		{
			struct Env *env = env_create("bsd_matops", 10000, 0, 0);
f011e7ed:	6a 00                	push   $0x0
f011e7ef:	6a 00                	push   $0x0
f011e7f1:	68 10 27 00 00       	push   $0x2710
f011e7f6:	68 58 d2 12 f0       	push   $0xf012d258
f011e7fb:	e8 71 af fe ff       	call   f0109771 <env_create>
f011e800:	83 c4 10             	add    $0x10,%esp
f011e803:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			int nice_index = i % TOTAL_NICE_VALUES;
f011e806:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011e809:	b9 05 00 00 00       	mov    $0x5,%ecx
f011e80e:	99                   	cltd   
f011e80f:	f7 f9                	idiv   %ecx
f011e811:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_nice(env, nice_values[nice_index]);
f011e814:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e817:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e81b:	83 ec 08             	sub    $0x8,%esp
f011e81e:	50                   	push   %eax
f011e81f:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e822:	e8 81 7b fe ff       	call   f01063a8 <env_set_nice>
f011e827:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f011e82a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f011e82e:	75 17                	jne    f011e847 <test_bsd_nice_2+0xa5>
				panic("Loading programs failed\n");
f011e830:	83 ec 04             	sub    $0x4,%esp
f011e833:	68 ed cf 12 f0       	push   $0xf012cfed
f011e838:	68 c1 00 00 00       	push   $0xc1
f011e83d:	68 06 d0 12 f0       	push   $0xf012d006
f011e842:	e8 d3 1a fe ff       	call   f010031a <_panic>
			if (env->page_WS_max_size != 10000)
f011e847:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011e84a:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011e850:	3d 10 27 00 00       	cmp    $0x2710,%eax
f011e855:	74 17                	je     f011e86e <test_bsd_nice_2+0xcc>
				panic("The program working set size is not correct\n");
f011e857:	83 ec 04             	sub    $0x4,%esp
f011e85a:	68 24 d0 12 f0       	push   $0xf012d024
f011e85f:	68 c3 00 00 00       	push   $0xc3
f011e864:	68 06 d0 12 f0       	push   $0xf012d006
f011e869:	e8 ac 1a fe ff       	call   f010031a <_panic>

			switch (nice_values[nice_index])
f011e86e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011e871:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f011e875:	83 c0 0f             	add    $0xf,%eax
f011e878:	83 f8 1e             	cmp    $0x1e,%eax
f011e87b:	0f 87 a5 00 00 00    	ja     f011e926 <test_bsd_nice_2+0x184>
f011e881:	8b 04 85 b4 d2 12 f0 	mov    -0xfed2d4c(,%eax,4),%eax
f011e888:	ff e0                	jmp    *%eax
			{
			case -15:
				prog_orders[0][nice_count[0]++] = env->env_id;
f011e88a:	a1 9c 22 55 f0       	mov    0xf055229c,%eax
f011e88f:	8d 50 01             	lea    0x1(%eax),%edx
f011e892:	89 15 9c 22 55 f0    	mov    %edx,0xf055229c
f011e898:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e89b:	8b 52 10             	mov    0x10(%edx),%edx
f011e89e:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e8a5:	eb 7f                	jmp    f011e926 <test_bsd_nice_2+0x184>
			case -5:
				prog_orders[1][nice_count[1]++] = env->env_id;
f011e8a7:	a1 a0 22 55 f0       	mov    0xf05522a0,%eax
f011e8ac:	8d 50 01             	lea    0x1(%eax),%edx
f011e8af:	89 15 a0 22 55 f0    	mov    %edx,0xf05522a0
f011e8b5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e8b8:	8b 52 10             	mov    0x10(%edx),%edx
f011e8bb:	83 c0 0a             	add    $0xa,%eax
f011e8be:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e8c5:	eb 5f                	jmp    f011e926 <test_bsd_nice_2+0x184>
			case 0:
				prog_orders[2][nice_count[2]++] = env->env_id;
f011e8c7:	a1 a4 22 55 f0       	mov    0xf05522a4,%eax
f011e8cc:	8d 50 01             	lea    0x1(%eax),%edx
f011e8cf:	89 15 a4 22 55 f0    	mov    %edx,0xf05522a4
f011e8d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e8d8:	8b 52 10             	mov    0x10(%edx),%edx
f011e8db:	83 c0 14             	add    $0x14,%eax
f011e8de:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e8e5:	eb 3f                	jmp    f011e926 <test_bsd_nice_2+0x184>
			case 5:
				prog_orders[3][nice_count[3]++] = env->env_id;
f011e8e7:	a1 a8 22 55 f0       	mov    0xf05522a8,%eax
f011e8ec:	8d 50 01             	lea    0x1(%eax),%edx
f011e8ef:	89 15 a8 22 55 f0    	mov    %edx,0xf05522a8
f011e8f5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e8f8:	8b 52 10             	mov    0x10(%edx),%edx
f011e8fb:	83 c0 1e             	add    $0x1e,%eax
f011e8fe:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e905:	eb 1f                	jmp    f011e926 <test_bsd_nice_2+0x184>
			case 15:
				prog_orders[4][nice_count[4]++] = env->env_id;
f011e907:	a1 ac 22 55 f0       	mov    0xf05522ac,%eax
f011e90c:	8d 50 01             	lea    0x1(%eax),%edx
f011e90f:	89 15 ac 22 55 f0    	mov    %edx,0xf05522ac
f011e915:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011e918:	8b 52 10             	mov    0x10(%edx),%edx
f011e91b:	83 c0 28             	add    $0x28,%eax
f011e91e:	89 14 85 e0 78 57 f0 	mov    %edx,-0xfa88720(,%eax,4)
				break;
f011e925:	90                   	nop
			}
			sched_new_env(env);
f011e926:	83 ec 0c             	sub    $0xc,%esp
f011e929:	ff 75 d4             	pushl  -0x2c(%ebp)
f011e92c:	e8 75 6a fe ff       	call   f01053a6 <sched_new_env>
f011e931:	83 c4 10             	add    $0x10,%esp
	if (firstTimeTestBSD)
	{
		chksch(1);
		firstTimeTestBSD = 0;
		int nice_values[] = {15, 5, 0, -5, -15};
		for (int i = 0; i < INSTANCES_NUMBER; i++)
f011e934:	ff 45 e4             	incl   -0x1c(%ebp)
f011e937:	83 7d e4 09          	cmpl   $0x9,-0x1c(%ebp)
f011e93b:	0f 8e ac fe ff ff    	jle    f011e7ed <test_bsd_nice_2+0x4b>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f011e941:	83 ec 0c             	sub    $0xc,%esp
f011e944:	68 54 d0 12 f0       	push   $0xf012d054
f011e949:	e8 1e 26 fe ff       	call   f0100f6c <cprintf>
f011e94e:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f011e951:	83 ec 0c             	sub    $0xc,%esp
f011e954:	68 a3 d0 12 f0       	push   $0xf012d0a3
f011e959:	e8 7e 35 fe ff       	call   f0101edc <execute_command>
f011e95e:	83 c4 10             	add    $0x10,%esp
f011e961:	e9 d0 00 00 00       	jmp    f011ea36 <test_bsd_nice_2+0x294>
	}
	else
	{
		chksch(0);
f011e966:	83 ec 0c             	sub    $0xc,%esp
f011e969:	6a 00                	push   $0x0
f011e96b:	e8 20 0d 00 00       	call   f011f690 <chksch>
f011e970:	83 c4 10             	add    $0x10,%esp
		cprintf("> Checking...\n");
f011e973:	83 ec 0c             	sub    $0xc,%esp
f011e976:	68 aa d0 12 f0       	push   $0xf012d0aa
f011e97b:	e8 ec 25 fe ff       	call   f0100f6c <cprintf>
f011e980:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f011e983:	e8 9a 71 fe ff       	call   f0105b22 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f011e988:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011e98f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f011e996:	e9 8a 00 00 00       	jmp    f011ea25 <test_bsd_nice_2+0x283>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e99b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f011e9a2:	eb 55                	jmp    f011e9f9 <test_bsd_nice_2+0x257>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
f011e9a4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011e9a7:	8b 14 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%edx
f011e9ae:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f011e9b1:	89 c8                	mov    %ecx,%eax
f011e9b3:	c1 e0 02             	shl    $0x2,%eax
f011e9b6:	01 c8                	add    %ecx,%eax
f011e9b8:	01 c0                	add    %eax,%eax
f011e9ba:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011e9bd:	01 c8                	add    %ecx,%eax
f011e9bf:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011e9c6:	83 ec 04             	sub    $0x4,%esp
f011e9c9:	52                   	push   %edx
f011e9ca:	ff 75 e0             	pushl  -0x20(%ebp)
f011e9cd:	50                   	push   %eax
f011e9ce:	e8 7f f8 ff ff       	call   f011e252 <find_in_range>
f011e9d3:	83 c4 10             	add    $0x10,%esp
f011e9d6:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f011e9d9:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011e9dd:	75 17                	jne    f011e9f6 <test_bsd_nice_2+0x254>
					panic("The programs' order of finishing is not correct\n");
f011e9df:	83 ec 04             	sub    $0x4,%esp
f011e9e2:	68 bc d0 12 f0       	push   $0xf012d0bc
f011e9e7:	68 ea 00 00 00       	push   $0xea
f011e9ec:	68 06 d0 12 f0       	push   $0xf012d006
f011e9f1:	e8 24 19 fe ff       	call   f010031a <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f011e9f6:	ff 45 d8             	incl   -0x28(%ebp)
f011e9f9:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011e9fc:	89 d0                	mov    %edx,%eax
f011e9fe:	c1 e0 02             	shl    $0x2,%eax
f011ea01:	01 d0                	add    %edx,%eax
f011ea03:	01 c0                	add    %eax,%eax
f011ea05:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011ea08:	01 d0                	add    %edx,%eax
f011ea0a:	8b 04 85 e0 78 57 f0 	mov    -0xfa88720(,%eax,4),%eax
f011ea11:	85 c0                	test   %eax,%eax
f011ea13:	75 8f                	jne    f011e9a4 <test_bsd_nice_2+0x202>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, nice_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
f011ea15:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ea18:	8b 04 85 9c 22 55 f0 	mov    -0xfaadd64(,%eax,4),%eax
f011ea1f:	01 45 e0             	add    %eax,-0x20(%ebp)
		chksch(0);
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_NICE_VALUES; i++)
f011ea22:	ff 45 dc             	incl   -0x24(%ebp)
f011ea25:	83 7d dc 04          	cmpl   $0x4,-0x24(%ebp)
f011ea29:	0f 8e 6c ff ff ff    	jle    f011e99b <test_bsd_nice_2+0x1f9>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += nice_count[i];
		}
		firstTimeTestBSD = 0;
f011ea2f:	c6 05 9d 9d 17 f0 00 	movb   $0x0,0xf0179d9d
	}
	cprintf("\nCongratulations!! test_bsd_nice_2 completed successfully.\n");
f011ea36:	83 ec 0c             	sub    $0xc,%esp
f011ea39:	68 64 d2 12 f0       	push   $0xf012d264
f011ea3e:	e8 29 25 fe ff       	call   f0100f6c <cprintf>
f011ea43:	83 c4 10             	add    $0x10,%esp
}
f011ea46:	90                   	nop
f011ea47:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011ea4a:	5b                   	pop    %ebx
f011ea4b:	5e                   	pop    %esi
f011ea4c:	5f                   	pop    %edi
f011ea4d:	5d                   	pop    %ebp
f011ea4e:	c3                   	ret    

f011ea4f <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f011ea4f:	55                   	push   %ebp
f011ea50:	89 e5                	mov    %esp,%ebp
f011ea52:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f011ea55:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ea58:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011ea5b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea5e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011ea61:	89 10                	mov    %edx,(%eax)
}
f011ea63:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea66:	c9                   	leave  
f011ea67:	c2 04 00             	ret    $0x4

f011ea6a <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011ea6a:	55                   	push   %ebp
f011ea6b:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011ea6d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea70:	85 c0                	test   %eax,%eax
f011ea72:	78 16                	js     f011ea8a <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f011ea74:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea77:	05 00 20 00 00       	add    $0x2000,%eax
f011ea7c:	85 c0                	test   %eax,%eax
f011ea7e:	79 05                	jns    f011ea85 <fix_round+0x1b>
f011ea80:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011ea85:	c1 f8 0e             	sar    $0xe,%eax
f011ea88:	eb 14                	jmp    f011ea9e <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011ea8a:	8b 45 08             	mov    0x8(%ebp),%eax
f011ea8d:	2d 00 20 00 00       	sub    $0x2000,%eax
f011ea92:	85 c0                	test   %eax,%eax
f011ea94:	79 05                	jns    f011ea9b <fix_round+0x31>
f011ea96:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011ea9b:	c1 f8 0e             	sar    $0xe,%eax
}
f011ea9e:	5d                   	pop    %ebp
f011ea9f:	c3                   	ret    

f011eaa0 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f011eaa0:	55                   	push   %ebp
f011eaa1:	89 e5                	mov    %esp,%ebp
f011eaa3:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f011eaa6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011eaaa:	79 16                	jns    f011eac2 <fix_scale+0x22>
f011eaac:	68 30 d3 12 f0       	push   $0xf012d330
f011eab1:	68 37 d3 12 f0       	push   $0xf012d337
f011eab6:	6a 5a                	push   $0x5a
f011eab8:	68 4c d3 12 f0       	push   $0xf012d34c
f011eabd:	e8 58 18 fe ff       	call   f010031a <_panic>
  return __mk_fix (x.f * n);
f011eac2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011eac5:	0f af 45 10          	imul   0x10(%ebp),%eax
f011eac9:	89 c2                	mov    %eax,%edx
f011eacb:	8b 45 08             	mov    0x8(%ebp),%eax
f011eace:	83 ec 08             	sub    $0x8,%esp
f011ead1:	52                   	push   %edx
f011ead2:	50                   	push   %eax
f011ead3:	e8 77 ff ff ff       	call   f011ea4f <__mk_fix>
f011ead8:	83 c4 0c             	add    $0xc,%esp
}
f011eadb:	8b 45 08             	mov    0x8(%ebp),%eax
f011eade:	c9                   	leave  
f011eadf:	c2 04 00             	ret    $0x4

f011eae2 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f011eae2:	55                   	push   %ebp
f011eae3:	89 e5                	mov    %esp,%ebp
f011eae5:	83 ec 08             	sub    $0x8,%esp
	init_spinlock(&tstcntlock, "tstcnt lock");
f011eae8:	83 ec 08             	sub    $0x8,%esp
f011eaeb:	68 60 d3 12 f0       	push   $0xf012d360
f011eaf0:	68 00 52 55 f0       	push   $0xf0555200
f011eaf5:	e8 55 fc fe ff       	call   f010e74f <init_spinlock>
f011eafa:	83 c4 10             	add    $0x10,%esp
	acquire_spinlock(&tstcntlock);
f011eafd:	83 ec 0c             	sub    $0xc,%esp
f011eb00:	68 00 52 55 f0       	push   $0xf0555200
f011eb05:	e8 76 fc fe ff       	call   f010e780 <acquire_spinlock>
f011eb0a:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f011eb0d:	c7 05 e8 23 55 f0 00 	movl   $0x0,0xf05523e8
f011eb14:	00 00 00 
	}
	release_spinlock(&tstcntlock);
f011eb17:	83 ec 0c             	sub    $0xc,%esp
f011eb1a:	68 00 52 55 f0       	push   $0xf0555200
f011eb1f:	e8 e3 fc fe ff       	call   f010e807 <release_spinlock>
f011eb24:	83 c4 10             	add    $0x10,%esp
}
f011eb27:	90                   	nop
f011eb28:	c9                   	leave  
f011eb29:	c3                   	ret    

f011eb2a <inctst>:
void inctst()
{
f011eb2a:	55                   	push   %ebp
f011eb2b:	89 e5                	mov    %esp,%ebp
f011eb2d:	83 ec 08             	sub    $0x8,%esp
	acquire_spinlock(&tstcntlock);
f011eb30:	83 ec 0c             	sub    $0xc,%esp
f011eb33:	68 00 52 55 f0       	push   $0xf0555200
f011eb38:	e8 43 fc fe ff       	call   f010e780 <acquire_spinlock>
f011eb3d:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f011eb40:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
f011eb45:	40                   	inc    %eax
f011eb46:	a3 e8 23 55 f0       	mov    %eax,0xf05523e8
	}
	release_spinlock(&tstcntlock);
f011eb4b:	83 ec 0c             	sub    $0xc,%esp
f011eb4e:	68 00 52 55 f0       	push   $0xf0555200
f011eb53:	e8 af fc fe ff       	call   f010e807 <release_spinlock>
f011eb58:	83 c4 10             	add    $0x10,%esp
}
f011eb5b:	90                   	nop
f011eb5c:	c9                   	leave  
f011eb5d:	c3                   	ret    

f011eb5e <gettst>:
uint32 gettst()
{
f011eb5e:	55                   	push   %ebp
f011eb5f:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f011eb61:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
}
f011eb66:	5d                   	pop    %ebp
f011eb67:	c3                   	ret    

f011eb68 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f011eb68:	55                   	push   %ebp
f011eb69:	89 e5                	mov    %esp,%ebp
f011eb6b:	83 ec 28             	sub    $0x28,%esp
f011eb6e:	8b 45 14             	mov    0x14(%ebp),%eax
f011eb71:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f011eb74:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f011eb7b:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f011eb7f:	83 f8 65             	cmp    $0x65,%eax
f011eb82:	74 5d                	je     f011ebe1 <tst+0x79>
f011eb84:	83 f8 65             	cmp    $0x65,%eax
f011eb87:	7f 0a                	jg     f011eb93 <tst+0x2b>
f011eb89:	83 f8 62             	cmp    $0x62,%eax
f011eb8c:	74 73                	je     f011ec01 <tst+0x99>
f011eb8e:	e9 91 00 00 00       	jmp    f011ec24 <tst+0xbc>
f011eb93:	83 f8 67             	cmp    $0x67,%eax
f011eb96:	74 29                	je     f011ebc1 <tst+0x59>
f011eb98:	83 f8 6c             	cmp    $0x6c,%eax
f011eb9b:	0f 85 83 00 00 00    	jne    f011ec24 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f011eba1:	8b 45 08             	mov    0x8(%ebp),%eax
f011eba4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011eba7:	73 09                	jae    f011ebb2 <tst+0x4a>
			chk = 1;
f011eba9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011ebb0:	eb 68                	jmp    f011ec1a <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f011ebb2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011ebb6:	74 62                	je     f011ec1a <tst+0xb2>
			chk = 1;
f011ebb8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ebbf:	eb 59                	jmp    f011ec1a <tst+0xb2>
	case 'g':
		if (n > v1)
f011ebc1:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebc4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ebc7:	76 09                	jbe    f011ebd2 <tst+0x6a>
			chk = 1;
f011ebc9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011ebd0:	eb 4b                	jmp    f011ec1d <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f011ebd2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011ebd6:	74 45                	je     f011ec1d <tst+0xb5>
			chk = 1;
f011ebd8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ebdf:	eb 3c                	jmp    f011ec1d <tst+0xb5>
	case 'e':
		if (n == v1)
f011ebe1:	8b 45 08             	mov    0x8(%ebp),%eax
f011ebe4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ebe7:	75 09                	jne    f011ebf2 <tst+0x8a>
			chk = 1;
f011ebe9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f011ebf0:	eb 2e                	jmp    f011ec20 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f011ebf2:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f011ebf6:	74 28                	je     f011ec20 <tst+0xb8>
			chk = 1;
f011ebf8:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ebff:	eb 1f                	jmp    f011ec20 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f011ec01:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec04:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ec07:	72 1a                	jb     f011ec23 <tst+0xbb>
f011ec09:	8b 45 08             	mov    0x8(%ebp),%eax
f011ec0c:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ec0f:	77 12                	ja     f011ec23 <tst+0xbb>
			chk = 1;
f011ec11:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f011ec18:	eb 09                	jmp    f011ec23 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011ec1a:	90                   	nop
f011ec1b:	eb 07                	jmp    f011ec24 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011ec1d:	90                   	nop
f011ec1e:	eb 04                	jmp    f011ec24 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f011ec20:	90                   	nop
f011ec21:	eb 01                	jmp    f011ec24 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f011ec23:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f011ec24:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ec28:	75 14                	jne    f011ec3e <tst+0xd6>
f011ec2a:	83 ec 04             	sub    $0x4,%esp
f011ec2d:	68 6c d3 12 f0       	push   $0xf012d36c
f011ec32:	6a 47                	push   $0x47
f011ec34:	68 7f d3 12 f0       	push   $0xf012d37f
f011ec39:	e8 dc 16 fe ff       	call   f010031a <_panic>

	acquire_spinlock(&tstcntlock);
f011ec3e:	83 ec 0c             	sub    $0xc,%esp
f011ec41:	68 00 52 55 f0       	push   $0xf0555200
f011ec46:	e8 35 fb fe ff       	call   f010e780 <acquire_spinlock>
f011ec4b:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f011ec4e:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
f011ec53:	40                   	inc    %eax
f011ec54:	a3 e8 23 55 f0       	mov    %eax,0xf05523e8
	}
	release_spinlock(&tstcntlock);
f011ec59:	83 ec 0c             	sub    $0xc,%esp
f011ec5c:	68 00 52 55 f0       	push   $0xf0555200
f011ec61:	e8 a1 fb fe ff       	call   f010e807 <release_spinlock>
f011ec66:	83 c4 10             	add    $0x10,%esp

	return;
f011ec69:	90                   	nop
}
f011ec6a:	c9                   	leave  
f011ec6b:	c3                   	ret    

f011ec6c <chktst>:

void chktst(uint32 n)
{
f011ec6c:	55                   	push   %ebp
f011ec6d:	89 e5                	mov    %esp,%ebp
f011ec6f:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_spinlock(&tstcntlock);
f011ec72:	83 ec 0c             	sub    $0xc,%esp
f011ec75:	68 00 52 55 f0       	push   $0xf0555200
f011ec7a:	e8 01 fb fe ff       	call   f010e780 <acquire_spinlock>
f011ec7f:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f011ec82:	a1 e8 23 55 f0       	mov    0xf05523e8,%eax
f011ec87:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_spinlock(&tstcntlock);
f011ec8a:	83 ec 0c             	sub    $0xc,%esp
f011ec8d:	68 00 52 55 f0       	push   $0xf0555200
f011ec92:	e8 70 fb fe ff       	call   f010e807 <release_spinlock>
f011ec97:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f011ec9a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ec9d:	3b 45 08             	cmp    0x8(%ebp),%eax
f011eca0:	75 12                	jne    f011ecb4 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f011eca2:	83 ec 0c             	sub    $0xc,%esp
f011eca5:	68 98 d3 12 f0       	push   $0xf012d398
f011ecaa:	e8 bd 22 fe ff       	call   f0100f6c <cprintf>
f011ecaf:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f011ecb2:	eb 14                	jmp    f011ecc8 <chktst+0x5c>
	}
	release_spinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f011ecb4:	83 ec 04             	sub    $0x4,%esp
f011ecb7:	68 c4 d3 12 f0       	push   $0xf012d3c4
f011ecbc:	6a 5d                	push   $0x5d
f011ecbe:	68 7f d3 12 f0       	push   $0xf012d37f
f011ecc3:	e8 52 16 fe ff       	call   f010031a <_panic>
}
f011ecc8:	c9                   	leave  
f011ecc9:	c3                   	ret    

f011ecca <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f011ecca:	55                   	push   %ebp
f011eccb:	89 e5                	mov    %esp,%ebp
f011eccd:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011ecd0:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ecd4:	77 07                	ja     f011ecdd <nearest_pow2_ceil+0x13>
f011ecd6:	b8 01 00 00 00       	mov    $0x1,%eax
f011ecdb:	eb 20                	jmp    f011ecfd <nearest_pow2_ceil+0x33>
	int power = 2;
f011ecdd:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011ece4:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011ece7:	eb 08                	jmp    f011ecf1 <nearest_pow2_ceil+0x27>
		power <<= 1;
f011ece9:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ecec:	01 c0                	add    %eax,%eax
f011ecee:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f011ecf1:	d1 6d 08             	shrl   0x8(%ebp)
f011ecf4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ecf8:	75 ef                	jne    f011ece9 <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f011ecfa:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ecfd:	c9                   	leave  
f011ecfe:	c3                   	ret    

f011ecff <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f011ecff:	55                   	push   %ebp
f011ed00:	89 e5                	mov    %esp,%ebp
f011ed02:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f011ed05:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011ed09:	77 07                	ja     f011ed12 <log2_ceil+0x13>
f011ed0b:	b8 01 00 00 00       	mov    $0x1,%eax
f011ed10:	eb 1b                	jmp    f011ed2d <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f011ed12:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f011ed19:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f011ed1c:	eb 03                	jmp    f011ed21 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f011ed1e:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f011ed21:	d1 6d 08             	shrl   0x8(%ebp)
f011ed24:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011ed28:	75 f4                	jne    f011ed1e <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f011ed2a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ed2d:	c9                   	leave  
f011ed2e:	c3                   	ret    

f011ed2f <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f011ed2f:	55                   	push   %ebp
f011ed30:	89 e5                	mov    %esp,%ebp
f011ed32:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f011ed35:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f011ed3c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011ed43:	eb 12                	jmp    f011ed57 <fixedPt2Str+0x28>
		mulFactor *= 10;
f011ed45:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ed48:	89 d0                	mov    %edx,%eax
f011ed4a:	c1 e0 02             	shl    $0x2,%eax
f011ed4d:	01 d0                	add    %edx,%eax
f011ed4f:	01 c0                	add    %eax,%eax
f011ed51:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f011ed54:	ff 45 f0             	incl   -0x10(%ebp)
f011ed57:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ed5a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011ed5d:	7c e6                	jl     f011ed45 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f011ed5f:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011ed62:	83 ec 04             	sub    $0x4,%esp
f011ed65:	ff 75 f4             	pushl  -0xc(%ebp)
f011ed68:	ff 75 08             	pushl  0x8(%ebp)
f011ed6b:	50                   	push   %eax
f011ed6c:	e8 2f fd ff ff       	call   f011eaa0 <fix_scale>
f011ed71:	83 c4 0c             	add    $0xc,%esp
f011ed74:	83 ec 0c             	sub    $0xc,%esp
f011ed77:	ff 75 dc             	pushl  -0x24(%ebp)
f011ed7a:	e8 eb fc ff ff       	call   f011ea6a <fix_round>
f011ed7f:	83 c4 10             	add    $0x10,%esp
f011ed82:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f011ed85:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ed88:	99                   	cltd   
f011ed89:	f7 7d f4             	idivl  -0xc(%ebp)
f011ed8c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f011ed8f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011ed92:	99                   	cltd   
f011ed93:	f7 7d f4             	idivl  -0xc(%ebp)
f011ed96:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f011ed99:	83 ec 08             	sub    $0x8,%esp
f011ed9c:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ed9f:	50                   	push   %eax
f011eda0:	ff 75 e4             	pushl  -0x1c(%ebp)
f011eda3:	e8 31 1c 00 00       	call   f01209d9 <ltostr>
f011eda8:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f011edab:	83 ec 08             	sub    $0x8,%esp
f011edae:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011edb1:	50                   	push   %eax
f011edb2:	ff 75 e0             	pushl  -0x20(%ebp)
f011edb5:	e8 1f 1c 00 00       	call   f01209d9 <ltostr>
f011edba:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f011edbd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011edc0:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011edc5:	f7 e9                	imul   %ecx
f011edc7:	c1 fa 02             	sar    $0x2,%edx
f011edca:	89 c8                	mov    %ecx,%eax
f011edcc:	c1 f8 1f             	sar    $0x1f,%eax
f011edcf:	29 c2                	sub    %eax,%edx
f011edd1:	89 d0                	mov    %edx,%eax
f011edd3:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f011edd6:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f011eddd:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f011ede4:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f011edea:	eb 31                	jmp    f011ee1d <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f011edec:	83 ec 04             	sub    $0x4,%esp
f011edef:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011edf2:	50                   	push   %eax
f011edf3:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011edf6:	50                   	push   %eax
f011edf7:	68 e0 d3 12 f0       	push   $0xf012d3e0
f011edfc:	e8 b1 1c 00 00       	call   f0120ab2 <strcconcat>
f011ee01:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f011ee04:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f011ee07:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011ee0c:	f7 e9                	imul   %ecx
f011ee0e:	c1 fa 02             	sar    $0x2,%edx
f011ee11:	89 c8                	mov    %ecx,%eax
f011ee13:	c1 f8 1f             	sar    $0x1f,%eax
f011ee16:	29 c2                	sub    %eax,%edx
f011ee18:	89 d0                	mov    %edx,%eax
f011ee1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f011ee1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ee20:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011ee23:	7c c7                	jl     f011edec <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f011ee25:	83 ec 04             	sub    $0x4,%esp
f011ee28:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011ee2b:	50                   	push   %eax
f011ee2c:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f011ee2f:	50                   	push   %eax
f011ee30:	8d 45 aa             	lea    -0x56(%ebp),%eax
f011ee33:	50                   	push   %eax
f011ee34:	e8 79 1c 00 00       	call   f0120ab2 <strcconcat>
f011ee39:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f011ee3c:	83 ec 04             	sub    $0x4,%esp
f011ee3f:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ee42:	50                   	push   %eax
f011ee43:	68 e2 d3 12 f0       	push   $0xf012d3e2
f011ee48:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ee4b:	50                   	push   %eax
f011ee4c:	e8 61 1c 00 00       	call   f0120ab2 <strcconcat>
f011ee51:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f011ee54:	83 ec 04             	sub    $0x4,%esp
f011ee57:	ff 75 10             	pushl  0x10(%ebp)
f011ee5a:	8d 45 96             	lea    -0x6a(%ebp),%eax
f011ee5d:	50                   	push   %eax
f011ee5e:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ee61:	50                   	push   %eax
f011ee62:	e8 4b 1c 00 00       	call   f0120ab2 <strcconcat>
f011ee67:	83 c4 10             	add    $0x10,%esp

}
f011ee6a:	90                   	nop
f011ee6b:	c9                   	leave  
f011ee6c:	c3                   	ret    

f011ee6d <sys_utilities>:

void sys_utilities(char* utilityName, int value)
{
f011ee6d:	55                   	push   %ebp
f011ee6e:	89 e5                	mov    %esp,%ebp
f011ee70:	83 ec 78             	sub    $0x78,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f011ee73:	83 ec 0c             	sub    $0xc,%esp
f011ee76:	68 e4 d3 12 f0       	push   $0xf012d3e4
f011ee7b:	e8 b3 16 00 00       	call   f0120533 <strlen>
f011ee80:	83 c4 10             	add    $0x10,%esp
f011ee83:	83 ec 04             	sub    $0x4,%esp
f011ee86:	50                   	push   %eax
f011ee87:	68 e4 d3 12 f0       	push   $0xf012d3e4
f011ee8c:	ff 75 08             	pushl  0x8(%ebp)
f011ee8f:	e8 e3 17 00 00       	call   f0120677 <strncmp>
f011ee94:	83 c4 10             	add    $0x10,%esp
f011ee97:	85 c0                	test   %eax,%eax
f011ee99:	0f 85 84 00 00 00    	jne    f011ef23 <sys_utilities+0xb6>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011ee9f:	8d 45 d0             	lea    -0x30(%ebp),%eax
f011eea2:	50                   	push   %eax
f011eea3:	8d 45 88             	lea    -0x78(%ebp),%eax
f011eea6:	50                   	push   %eax
f011eea7:	68 f2 d3 12 f0       	push   $0xf012d3f2
f011eeac:	ff 75 08             	pushl  0x8(%ebp)
f011eeaf:	e8 94 1c 00 00       	call   f0120b48 <strsplit>
f011eeb4:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f011eeb7:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011eeba:	83 ec 04             	sub    $0x4,%esp
f011eebd:	6a 0a                	push   $0xa
f011eebf:	6a 00                	push   $0x0
f011eec1:	50                   	push   %eax
f011eec2:	e8 cc 19 00 00       	call   f0120893 <strtol>
f011eec7:	83 c4 10             	add    $0x10,%esp
f011eeca:	89 45 e0             	mov    %eax,-0x20(%ebp)
		struct Env* env = NULL ;
f011eecd:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
		envid2env(envID, &env, 0);
f011eed4:	83 ec 04             	sub    $0x4,%esp
f011eed7:	6a 00                	push   $0x0
f011eed9:	8d 45 cc             	lea    -0x34(%ebp),%eax
f011eedc:	50                   	push   %eax
f011eedd:	ff 75 e0             	pushl  -0x20(%ebp)
f011eee0:	e8 dc b5 fe ff       	call   f010a4c1 <envid2env>
f011eee5:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f011eee8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011eeeb:	8b 40 10             	mov    0x10(%eax),%eax
f011eeee:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f011eef1:	74 19                	je     f011ef0c <sys_utilities+0x9f>
f011eef3:	68 f4 d3 12 f0       	push   $0xf012d3f4
f011eef8:	68 37 d3 12 f0       	push   $0xf012d337
f011eefd:	68 9d 00 00 00       	push   $0x9d
f011ef02:	68 7f d3 12 f0       	push   $0xf012d37f
f011ef07:	e8 0e 14 fe ff       	call   f010031a <_panic>
		env_set_nice(env, value);
f011ef0c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011ef0f:	83 ec 08             	sub    $0x8,%esp
f011ef12:	ff 75 0c             	pushl  0xc(%ebp)
f011ef15:	50                   	push   %eax
f011ef16:	e8 8d 74 fe ff       	call   f01063a8 <env_set_nice>
f011ef1b:	83 c4 10             	add    $0x10,%esp
f011ef1e:	e9 c4 01 00 00       	jmp    f011f0e7 <sys_utilities+0x27a>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f011ef23:	83 ec 0c             	sub    $0xc,%esp
f011ef26:	68 09 d4 12 f0       	push   $0xf012d409
f011ef2b:	e8 03 16 00 00       	call   f0120533 <strlen>
f011ef30:	83 c4 10             	add    $0x10,%esp
f011ef33:	83 ec 04             	sub    $0x4,%esp
f011ef36:	50                   	push   %eax
f011ef37:	68 09 d4 12 f0       	push   $0xf012d409
f011ef3c:	ff 75 08             	pushl  0x8(%ebp)
f011ef3f:	e8 33 17 00 00       	call   f0120677 <strncmp>
f011ef44:	83 c4 10             	add    $0x10,%esp
f011ef47:	85 c0                	test   %eax,%eax
f011ef49:	0f 85 98 01 00 00    	jne    f011f0e7 <sys_utilities+0x27a>
	{
		int* numOfInstances = (int*) value ;
f011ef4f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ef52:	89 45 dc             	mov    %eax,-0x24(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f011ef55:	8d 45 c8             	lea    -0x38(%ebp),%eax
f011ef58:	50                   	push   %eax
f011ef59:	8d 45 88             	lea    -0x78(%ebp),%eax
f011ef5c:	50                   	push   %eax
f011ef5d:	68 f2 d3 12 f0       	push   $0xf012d3f2
f011ef62:	ff 75 08             	pushl  0x8(%ebp)
f011ef65:	e8 de 1b 00 00       	call   f0120b48 <strsplit>
f011ef6a:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f011ef6d:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011ef70:	89 45 d8             	mov    %eax,-0x28(%ebp)
		struct Env* env = NULL ;
f011ef73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f011ef7a:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f011ef81:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f011ef88:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ef8b:	8b 00                	mov    (%eax),%eax
f011ef8d:	85 c0                	test   %eax,%eax
f011ef8f:	79 1c                	jns    f011efad <sys_utilities+0x140>
		{
			chkAscending = 0;
f011ef91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f011ef98:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011ef9b:	8b 00                	mov    (%eax),%eax
f011ef9d:	f7 d8                	neg    %eax
f011ef9f:	89 c2                	mov    %eax,%edx
f011efa1:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011efa4:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f011efa6:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f011efad:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_spinlock(&ProcessQueues.qlock);
f011efb4:	83 ec 0c             	sub    $0xc,%esp
f011efb7:	68 60 24 55 f0       	push   $0xf0552460
f011efbc:	e8 bf f7 fe ff       	call   f010e780 <acquire_spinlock>
f011efc1:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011efc4:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011efc9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f011efcc:	a1 e4 24 55 f0       	mov    0xf05524e4,%eax
f011efd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011efd4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011efd7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011efda:	eb 6c                	jmp    f011f048 <sys_utilities+0x1db>
			{
				if (strcmp(env->prog_name, progName) != 0)
f011efdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011efdf:	83 c0 20             	add    $0x20,%eax
f011efe2:	83 ec 08             	sub    $0x8,%esp
f011efe5:	ff 75 d8             	pushl  -0x28(%ebp)
f011efe8:	50                   	push   %eax
f011efe9:	e8 51 16 00 00       	call   f012063f <strcmp>
f011efee:	83 c4 10             	add    $0x10,%esp
f011eff1:	85 c0                	test   %eax,%eax
f011eff3:	75 46                	jne    f011f03b <sys_utilities+0x1ce>
					continue;
				(*numOfInstances)-- ;
f011eff5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011eff8:	8b 00                	mov    (%eax),%eax
f011effa:	8d 50 ff             	lea    -0x1(%eax),%edx
f011effd:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f000:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f011f002:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f006:	74 14                	je     f011f01c <sys_utilities+0x1af>
				{
					if (prevEnvID > env->env_id)
f011f008:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f00b:	8b 40 10             	mov    0x10(%eax),%eax
f011f00e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f011:	7d 1d                	jge    f011f030 <sys_utilities+0x1c3>
					{
						success = 0;
f011f013:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011f01a:	eb 32                	jmp    f011f04e <sys_utilities+0x1e1>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f011f01c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f01f:	8b 40 10             	mov    0x10(%eax),%eax
f011f022:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f025:	7e 09                	jle    f011f030 <sys_utilities+0x1c3>
					{
						success = 0;
f011f027:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011f02e:	eb 1e                	jmp    f011f04e <sys_utilities+0x1e1>
					}
				}
				prevEnvID = env->env_id;
f011f030:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f033:	8b 40 10             	mov    0x10(%eax),%eax
f011f036:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f039:	eb 01                	jmp    f011f03c <sys_utilities+0x1cf>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f011f03b:	90                   	nop
		acquire_spinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f011f03c:	ff 4d e4             	decl   -0x1c(%ebp)
f011f03f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f042:	8b 40 0c             	mov    0xc(%eax),%eax
f011f045:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f048:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f04c:	7f 8e                	jg     f011efdc <sys_utilities+0x16f>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011f04e:	83 ec 0c             	sub    $0xc,%esp
f011f051:	68 60 24 55 f0       	push   $0xf0552460
f011f056:	e8 ac f7 fe ff       	call   f010e807 <release_spinlock>
f011f05b:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f011f05e:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f061:	8b 00                	mov    (%eax),%eax
f011f063:	85 c0                	test   %eax,%eax
f011f065:	75 06                	jne    f011f06d <sys_utilities+0x200>
f011f067:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011f06b:	75 3e                	jne    f011f0ab <sys_utilities+0x23e>
		{
			cprintf("###########################################\n");
f011f06d:	83 ec 0c             	sub    $0xc,%esp
f011f070:	68 1c d4 12 f0       	push   $0xf012d41c
f011f075:	e8 f2 1e fe ff       	call   f0100f6c <cprintf>
f011f07a:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is FAILED\n", progName);
f011f07d:	83 ec 08             	sub    $0x8,%esp
f011f080:	ff 75 d8             	pushl  -0x28(%ebp)
f011f083:	68 4c d4 12 f0       	push   $0xf012d44c
f011f088:	e8 df 1e fe ff       	call   f0100f6c <cprintf>
f011f08d:	83 c4 10             	add    $0x10,%esp
			cprintf("###########################################\n");
f011f090:	83 ec 0c             	sub    $0xc,%esp
f011f093:	68 1c d4 12 f0       	push   $0xf012d41c
f011f098:	e8 cf 1e fe ff       	call   f0100f6c <cprintf>
f011f09d:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 0; //to indicate the failure of test
f011f0a0:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f0a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f011f0a9:	eb 3c                	jmp    f011f0e7 <sys_utilities+0x27a>
		}
		else
		{
			cprintf("####################################################\n");
f011f0ab:	83 ec 0c             	sub    $0xc,%esp
f011f0ae:	68 6c d4 12 f0       	push   $0xf012d46c
f011f0b3:	e8 b4 1e fe ff       	call   f0100f6c <cprintf>
f011f0b8:	83 c4 10             	add    $0x10,%esp
			cprintf("%s: check exit order is SUCCEEDED\n", progName);
f011f0bb:	83 ec 08             	sub    $0x8,%esp
f011f0be:	ff 75 d8             	pushl  -0x28(%ebp)
f011f0c1:	68 a4 d4 12 f0       	push   $0xf012d4a4
f011f0c6:	e8 a1 1e fe ff       	call   f0100f6c <cprintf>
f011f0cb:	83 c4 10             	add    $0x10,%esp
			cprintf("####################################################\n");
f011f0ce:	83 ec 0c             	sub    $0xc,%esp
f011f0d1:	68 6c d4 12 f0       	push   $0xf012d46c
f011f0d6:	e8 91 1e fe ff       	call   f0100f6c <cprintf>
f011f0db:	83 c4 10             	add    $0x10,%esp
			*numOfInstances = 1; //to indicate the success of test
f011f0de:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f0e1:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
		}
	}
	if ((int)value < 0)
f011f0e7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011f0eb:	79 5b                	jns    f011f148 <sys_utilities+0x2db>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f011f0ed:	83 ec 08             	sub    $0x8,%esp
f011f0f0:	68 c7 d4 12 f0       	push   $0xf012d4c7
f011f0f5:	ff 75 08             	pushl  0x8(%ebp)
f011f0f8:	e8 42 15 00 00       	call   f012063f <strcmp>
f011f0fd:	83 c4 10             	add    $0x10,%esp
f011f100:	85 c0                	test   %eax,%eax
f011f102:	75 44                	jne    f011f148 <sys_utilities+0x2db>
		{
			switch (value)
f011f104:	8b 45 0c             	mov    0xc(%ebp),%eax
f011f107:	83 f8 fc             	cmp    $0xfffffffc,%eax
f011f10a:	74 07                	je     f011f113 <sys_utilities+0x2a6>
f011f10c:	83 f8 fe             	cmp    $0xfffffffe,%eax
f011f10f:	74 19                	je     f011f12a <sys_utilities+0x2bd>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
				break;
			default:
				break;
f011f111:	eb 35                	jmp    f011f148 <sys_utilities+0x2db>
		if (strcmp(utilityName, "__ReplStrat__") == 0)
		{
			switch (value)
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f011f113:	83 ec 0c             	sub    $0xc,%esp
f011f116:	68 d8 d4 12 f0       	push   $0xf012d4d8
f011f11b:	e8 4c 1e fe ff       	call   f0100f6c <cprintf>
f011f120:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f011f123:	e8 ff f1 fe ff       	call   f010e327 <setPageReplacmentAlgorithmFIFO>
				break;
f011f128:	eb 1e                	jmp    f011f148 <sys_utilities+0x2db>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f011f12a:	83 ec 0c             	sub    $0xc,%esp
f011f12d:	68 48 d5 12 f0       	push   $0xf012d548
f011f132:	e8 35 1e fe ff       	call   f0100f6c <cprintf>
f011f137:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f011f13a:	83 ec 0c             	sub    $0xc,%esp
f011f13d:	6a 02                	push   $0x2
f011f13f:	e8 a0 f1 fe ff       	call   f010e2e4 <setPageReplacmentAlgorithmLRU>
f011f144:	83 c4 10             	add    $0x10,%esp
				break;
f011f147:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f011f148:	90                   	nop
f011f149:	c9                   	leave  
f011f14a:	c3                   	ret    

f011f14b <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f011f14b:	55                   	push   %ebp
f011f14c:	89 e5                	mov    %esp,%ebp
f011f14e:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011f151:	8b 45 08             	mov    0x8(%ebp),%eax
f011f154:	8b 00                	mov    (%eax),%eax
f011f156:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f011f159:	8b 45 08             	mov    0x8(%ebp),%eax
f011f15c:	8b 00                	mov    (%eax),%eax
f011f15e:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011f161:	eb 52                	jmp    f011f1b5 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f011f163:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f166:	8b 00                	mov    (%eax),%eax
f011f168:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f011f16b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f16e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f171:	75 12                	jne    f011f185 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f011f173:	83 ec 0c             	sub    $0xc,%esp
f011f176:	68 bc d5 12 f0       	push   $0xf012d5bc
f011f17b:	e8 ec 1d fe ff       	call   f0100f6c <cprintf>
f011f180:	83 c4 10             	add    $0x10,%esp
			break;
f011f183:	eb 3f                	jmp    f011f1c4 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f011f185:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f189:	74 38                	je     f011f1c3 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f011f18b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f18e:	8b 00                	mov    (%eax),%eax
f011f190:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f011f193:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f196:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f199:	75 12                	jne    f011f1ad <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f011f19b:	83 ec 0c             	sub    $0xc,%esp
f011f19e:	68 d8 d5 12 f0       	push   $0xf012d5d8
f011f1a3:	e8 c4 1d fe ff       	call   f0100f6c <cprintf>
f011f1a8:	83 c4 10             	add    $0x10,%esp
			break;
f011f1ab:	eb 17                	jmp    f011f1c4 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011f1ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f1b0:	8b 00                	mov    (%eax),%eax
f011f1b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f011f1b5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f1b9:	74 09                	je     f011f1c4 <detect_loop_in_FrameInfo_list+0x79>
f011f1bb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f1bf:	75 a2                	jne    f011f163 <detect_loop_in_FrameInfo_list+0x18>
f011f1c1:	eb 01                	jmp    f011f1c4 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f011f1c3:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f011f1c4:	83 ec 0c             	sub    $0xc,%esp
f011f1c7:	68 ef d5 12 f0       	push   $0xf012d5ef
f011f1cc:	e8 9b 1d fe ff       	call   f0100f6c <cprintf>
f011f1d1:	83 c4 10             	add    $0x10,%esp
}
f011f1d4:	90                   	nop
f011f1d5:	c9                   	leave  
f011f1d6:	c3                   	ret    

f011f1d7 <scarce_memory>:

void scarce_memory()
{
f011f1d7:	55                   	push   %ebp
f011f1d8:	89 e5                	mov    %esp,%ebp
f011f1da:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011f1dd:	a1 e0 4b 55 f0       	mov    0xf0554be0,%eax
f011f1e2:	ba 64 00 00 00       	mov    $0x64,%edx
f011f1e7:	29 c2                	sub    %eax,%edx
f011f1e9:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011f1ee:	0f af c2             	imul   %edx,%eax
f011f1f1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f1f6:	f7 e2                	mul    %edx
f011f1f8:	89 d0                	mov    %edx,%eax
f011f1fa:	c1 e8 05             	shr    $0x5,%eax
f011f1fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f011f200:	a1 e0 4b 55 f0       	mov    0xf0554be0,%eax
f011f205:	ba 64 00 00 00       	mov    $0x64,%edx
f011f20a:	29 c2                	sub    %eax,%edx
f011f20c:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011f211:	89 d1                	mov    %edx,%ecx
f011f213:	0f af c8             	imul   %eax,%ecx
f011f216:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f21b:	f7 e1                	mul    %ecx
f011f21d:	c1 ea 05             	shr    $0x5,%edx
f011f220:	89 d0                	mov    %edx,%eax
f011f222:	c1 e0 02             	shl    $0x2,%eax
f011f225:	01 d0                	add    %edx,%eax
f011f227:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f22e:	01 d0                	add    %edx,%eax
f011f230:	c1 e0 02             	shl    $0x2,%eax
f011f233:	29 c1                	sub    %eax,%ecx
f011f235:	89 ca                	mov    %ecx,%edx
f011f237:	85 d2                	test   %edx,%edx
f011f239:	74 03                	je     f011f23e <scarce_memory+0x67>
		total_size_tobe_allocated++;
f011f23b:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f011f23e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_spinlock(&MemFrameLists.mfllock);
f011f245:	83 ec 0c             	sub    $0xc,%esp
f011f248:	68 40 25 55 f0       	push   $0xf0552540
f011f24d:	e8 2e f5 fe ff       	call   f010e780 <acquire_spinlock>
f011f252:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f011f255:	a1 2c 25 55 f0       	mov    0xf055252c,%eax
f011f25a:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011f25d:	8b 15 b8 4c 55 f0    	mov    0xf0554cb8,%edx
f011f263:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011f266:	29 c2                	sub    %eax,%edx
f011f268:	89 d0                	mov    %edx,%eax
f011f26a:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011f26d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f270:	2b 45 e8             	sub    -0x18(%ebp),%eax
f011f273:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f011f276:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011f27d:	eb 12                	jmp    f011f291 <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011f27f:	83 ec 0c             	sub    $0xc,%esp
f011f282:	8d 45 e0             	lea    -0x20(%ebp),%eax
f011f285:	50                   	push   %eax
f011f286:	e8 46 8c fe ff       	call   f0107ed1 <allocate_frame>
f011f28b:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011f28e:	ff 45 f0             	incl   -0x10(%ebp)
f011f291:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f294:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011f297:	76 e6                	jbe    f011f27f <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_spinlock(&MemFrameLists.mfllock);
f011f299:	83 ec 0c             	sub    $0xc,%esp
f011f29c:	68 40 25 55 f0       	push   $0xf0552540
f011f2a1:	e8 61 f5 fe ff       	call   f010e807 <release_spinlock>
f011f2a6:	83 c4 10             	add    $0x10,%esp

}
f011f2a9:	90                   	nop
f011f2aa:	c9                   	leave  
f011f2ab:	c3                   	ret    

f011f2ac <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011f2ac:	55                   	push   %ebp
f011f2ad:	89 e5                	mov    %esp,%ebp
f011f2af:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f011f2b2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f011f2b9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011f2c0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f011f2c7:	e8 a5 b1 fe ff       	call   f010a471 <get_cpu_proc>
f011f2cc:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011f2cf:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011f2d3:	75 19                	jne    f011f2ee <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f011f2d5:	68 09 d6 12 f0       	push   $0xf012d609
f011f2da:	68 37 d3 12 f0       	push   $0xf012d337
f011f2df:	68 38 01 00 00       	push   $0x138
f011f2e4:	68 7f d3 12 f0       	push   $0xf012d37f
f011f2e9:	e8 2c 10 fe ff       	call   f010031a <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f011f2ee:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011f2f2:	0f 85 f7 01 00 00    	jne    f011f4ef <calc_no_pages_tobe_removed_from_ready_exit_queues+0x243>
	{
		acquire_spinlock(&ProcessQueues.qlock);
f011f2f8:	83 ec 0c             	sub    $0xc,%esp
f011f2fb:	68 60 24 55 f0       	push   $0xf0552460
f011f300:	e8 7b f4 fe ff       	call   f010e780 <acquire_spinlock>
f011f305:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011f308:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011f30f:	e9 e9 00 00 00       	jmp    f011f3fd <calc_no_pages_tobe_removed_from_ready_exit_queues+0x151>
			{
				struct Env * ptr_ready_env = NULL;
f011f314:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011f31b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f31e:	83 c0 09             	add    $0x9,%eax
f011f321:	c1 e0 04             	shl    $0x4,%eax
f011f324:	05 60 24 55 f0       	add    $0xf0552460,%eax
f011f329:	8b 00                	mov    (%eax),%eax
f011f32b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f32e:	e9 81 00 00 00       	jmp    f011f3b4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x108>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
f011f333:	83 ec 0c             	sub    $0xc,%esp
f011f336:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f339:	e8 21 97 fe ff       	call   f0108a5f <env_page_ws_get_size>
f011f33e:	83 c4 10             	add    $0x10,%esp
f011f341:	89 45 cc             	mov    %eax,-0x34(%ebp)
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011f344:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f347:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f34d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f350:	0f af c2             	imul   %edx,%eax
f011f353:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f358:	f7 e2                	mul    %edx
f011f35a:	89 d0                	mov    %edx,%eax
f011f35c:	c1 e8 05             	shr    $0x5,%eax
f011f35f:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011f362:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f365:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f36b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011f36e:	89 d1                	mov    %edx,%ecx
f011f370:	0f af c8             	imul   %eax,%ecx
f011f373:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f378:	f7 e1                	mul    %ecx
f011f37a:	c1 ea 05             	shr    $0x5,%edx
f011f37d:	89 d0                	mov    %edx,%eax
f011f37f:	c1 e0 02             	shl    $0x2,%eax
f011f382:	01 d0                	add    %edx,%eax
f011f384:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f38b:	01 d0                	add    %edx,%eax
f011f38d:	c1 e0 02             	shl    $0x2,%eax
f011f390:	29 c1                	sub    %eax,%ecx
f011f392:	89 ca                	mov    %ecx,%edx
f011f394:	85 d2                	test   %edx,%edx
f011f396:	74 03                	je     f011f39b <calc_no_pages_tobe_removed_from_ready_exit_queues+0xef>
						num_of_pages_to_be_removed++;
f011f398:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f011f39b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f39e:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f011f3a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f3a4:	83 c0 09             	add    $0x9,%eax
f011f3a7:	c1 e0 04             	shl    $0x4,%eax
f011f3aa:	05 68 24 55 f0       	add    $0xf0552468,%eax
f011f3af:	8b 00                	mov    (%eax),%eax
f011f3b1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011f3b4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f3b8:	74 08                	je     f011f3c2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x116>
f011f3ba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f3bd:	8b 40 08             	mov    0x8(%eax),%eax
f011f3c0:	eb 05                	jmp    f011f3c7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11b>
f011f3c2:	b8 00 00 00 00       	mov    $0x0,%eax
f011f3c7:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f3ca:	83 c2 09             	add    $0x9,%edx
f011f3cd:	c1 e2 04             	shl    $0x4,%edx
f011f3d0:	81 c2 68 24 55 f0    	add    $0xf0552468,%edx
f011f3d6:	89 02                	mov    %eax,(%edx)
f011f3d8:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011f3db:	83 c0 09             	add    $0x9,%eax
f011f3de:	c1 e0 04             	shl    $0x4,%eax
f011f3e1:	05 68 24 55 f0       	add    $0xf0552468,%eax
f011f3e6:	8b 00                	mov    (%eax),%eax
f011f3e8:	85 c0                	test   %eax,%eax
f011f3ea:	0f 85 43 ff ff ff    	jne    f011f333 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
f011f3f0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011f3f4:	0f 85 39 ff ff ff    	jne    f011f333 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x87>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_spinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f011f3fa:	ff 45 e8             	incl   -0x18(%ebp)
f011f3fd:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f402:	0f b6 c0             	movzbl %al,%eax
f011f405:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f408:	0f 8f 06 ff ff ff    	jg     f011f314 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f011f40e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011f415:	a1 e0 24 55 f0       	mov    0xf05524e0,%eax
f011f41a:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f41d:	eb 1f                	jmp    f011f43e <calc_no_pages_tobe_removed_from_ready_exit_queues+0x192>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
f011f41f:	83 ec 0c             	sub    $0xc,%esp
f011f422:	ff 75 dc             	pushl  -0x24(%ebp)
f011f425:	e8 35 96 fe ff       	call   f0108a5f <env_page_ws_get_size>
f011f42a:	83 c4 10             	add    $0x10,%esp
f011f42d:	89 45 c8             	mov    %eax,-0x38(%ebp)
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f011f430:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011f433:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f011f436:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011f43b:	89 45 dc             	mov    %eax,-0x24(%ebp)
f011f43e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f442:	74 08                	je     f011f44c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a0>
f011f444:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011f447:	8b 40 08             	mov    0x8(%eax),%eax
f011f44a:	eb 05                	jmp    f011f451 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x1a5>
f011f44c:	b8 00 00 00 00       	mov    $0x0,%eax
f011f451:	a3 e8 24 55 f0       	mov    %eax,0xf05524e8
f011f456:	a1 e8 24 55 f0       	mov    0xf05524e8,%eax
f011f45b:	85 c0                	test   %eax,%eax
f011f45d:	75 c0                	jne    f011f41f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
f011f45f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011f463:	75 ba                	jne    f011f41f <calc_no_pages_tobe_removed_from_ready_exit_queues+0x173>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_spinlock(&ProcessQueues.qlock);
f011f465:	83 ec 0c             	sub    $0xc,%esp
f011f468:	68 60 24 55 f0       	push   $0xf0552460
f011f46d:	e8 95 f3 fe ff       	call   f010e807 <release_spinlock>
f011f472:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f011f475:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f011f479:	0f 84 de 00 00 00    	je     f011f55d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f011f47f:	83 ec 0c             	sub    $0xc,%esp
f011f482:	ff 75 d0             	pushl  -0x30(%ebp)
f011f485:	e8 d5 95 fe ff       	call   f0108a5f <env_page_ws_get_size>
f011f48a:	83 c4 10             	add    $0x10,%esp
f011f48d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011f490:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f493:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f499:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011f49c:	0f af c2             	imul   %edx,%eax
f011f49f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f4a4:	f7 e2                	mul    %edx
f011f4a6:	89 d0                	mov    %edx,%eax
f011f4a8:	c1 e8 05             	shr    $0x5,%eax
f011f4ab:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011f4ae:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f4b1:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f4b7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011f4ba:	89 d1                	mov    %edx,%ecx
f011f4bc:	0f af c8             	imul   %eax,%ecx
f011f4bf:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f4c4:	f7 e1                	mul    %ecx
f011f4c6:	c1 ea 05             	shr    $0x5,%edx
f011f4c9:	89 d0                	mov    %edx,%eax
f011f4cb:	c1 e0 02             	shl    $0x2,%eax
f011f4ce:	01 d0                	add    %edx,%eax
f011f4d0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f4d7:	01 d0                	add    %edx,%eax
f011f4d9:	c1 e0 02             	shl    $0x2,%eax
f011f4dc:	29 c1                	sub    %eax,%ecx
f011f4de:	89 ca                	mov    %ecx,%edx
f011f4e0:	85 d2                	test   %edx,%edx
f011f4e2:	74 03                	je     f011f4e7 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x23b>
				num_of_pages_to_be_removed++;
f011f4e4:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011f4e7:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011f4ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011f4ed:	eb 6e                	jmp    f011f55d <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2b1>
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
f011f4ef:	83 ec 0c             	sub    $0xc,%esp
f011f4f2:	ff 75 d0             	pushl  -0x30(%ebp)
f011f4f5:	e8 65 95 fe ff       	call   f0108a5f <env_page_ws_get_size>
f011f4fa:	83 c4 10             	add    $0x10,%esp
f011f4fd:	89 45 c0             	mov    %eax,-0x40(%ebp)
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f011f500:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f503:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f509:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f50c:	0f af c2             	imul   %edx,%eax
f011f50f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011f514:	f7 e2                	mul    %edx
f011f516:	89 d0                	mov    %edx,%eax
f011f518:	c1 e8 05             	shr    $0x5,%eax
f011f51b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f011f51e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011f521:	8b 90 3c da 01 00    	mov    0x1da3c(%eax),%edx
f011f527:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011f52a:	89 d1                	mov    %edx,%ecx
f011f52c:	0f af c8             	imul   %eax,%ecx
f011f52f:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f534:	f7 e1                	mul    %ecx
f011f536:	c1 ea 05             	shr    $0x5,%edx
f011f539:	89 d0                	mov    %edx,%eax
f011f53b:	c1 e0 02             	shl    $0x2,%eax
f011f53e:	01 d0                	add    %edx,%eax
f011f540:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f547:	01 d0                	add    %edx,%eax
f011f549:	c1 e0 02             	shl    $0x2,%eax
f011f54c:	29 c1                	sub    %eax,%ecx
f011f54e:	89 ca                	mov    %ecx,%edx
f011f550:	85 d2                	test   %edx,%edx
f011f552:	74 03                	je     f011f557 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x2ab>
			num_of_pages_to_be_removed++;
f011f554:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f011f557:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011f55a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f011f55d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011f560:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f563:	01 c2                	add    %eax,%edx
f011f565:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f568:	01 d0                	add    %edx,%eax
}
f011f56a:	c9                   	leave  
f011f56b:	c3                   	ret    

f011f56c <schenv>:


void schenv()
{
f011f56c:	55                   	push   %ebp
f011f56d:	89 e5                	mov    %esp,%ebp
f011f56f:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f011f572:	c6 05 e0 51 55 f0 00 	movb   $0x0,0xf05551e0
	__ne = NULL;
f011f579:	c7 05 0c 4f 55 f0 00 	movl   $0x0,0xf0554f0c
f011f580:	00 00 00 
	acquire_spinlock(&ProcessQueues.qlock);
f011f583:	83 ec 0c             	sub    $0xc,%esp
f011f586:	68 60 24 55 f0       	push   $0xf0552460
f011f58b:	e8 f0 f1 fe ff       	call   f010e780 <acquire_spinlock>
f011f590:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011f593:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011f59a:	eb 40                	jmp    f011f5dc <schenv+0x70>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f011f59c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f59f:	83 c0 09             	add    $0x9,%eax
f011f5a2:	c1 e0 04             	shl    $0x4,%eax
f011f5a5:	05 60 24 55 f0       	add    $0xf0552460,%eax
f011f5aa:	83 ec 0c             	sub    $0xc,%esp
f011f5ad:	50                   	push   %eax
f011f5ae:	e8 ae 56 fe ff       	call   f0104c61 <queue_size>
f011f5b3:	83 c4 10             	add    $0x10,%esp
f011f5b6:	85 c0                	test   %eax,%eax
f011f5b8:	74 1f                	je     f011f5d9 <schenv+0x6d>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f011f5ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5bd:	83 c0 09             	add    $0x9,%eax
f011f5c0:	c1 e0 04             	shl    $0x4,%eax
f011f5c3:	05 64 24 55 f0       	add    $0xf0552464,%eax
f011f5c8:	8b 00                	mov    (%eax),%eax
f011f5ca:	a3 0c 4f 55 f0       	mov    %eax,0xf0554f0c
				__nl = i;
f011f5cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f5d2:	a2 e0 51 55 f0       	mov    %al,0xf05551e0
				break;
f011f5d7:	eb 10                	jmp    f011f5e9 <schenv+0x7d>

	__nl = 0;
	__ne = NULL;
	acquire_spinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f011f5d9:	ff 45 f4             	incl   -0xc(%ebp)
f011f5dc:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f5e1:	0f b6 c0             	movzbl %al,%eax
f011f5e4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011f5e7:	7f b3                	jg     f011f59c <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_spinlock(&ProcessQueues.qlock);
f011f5e9:	83 ec 0c             	sub    $0xc,%esp
f011f5ec:	68 60 24 55 f0       	push   $0xf0552460
f011f5f1:	e8 11 f2 fe ff       	call   f010e807 <release_spinlock>
f011f5f6:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f011f5f9:	e8 73 ae fe ff       	call   f010a471 <get_cpu_proc>
f011f5fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f011f601:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f605:	0f 84 82 00 00 00    	je     f011f68d <schenv+0x121>
	{
		if (__ne != NULL)
f011f60b:	a1 0c 4f 55 f0       	mov    0xf0554f0c,%eax
f011f610:	85 c0                	test   %eax,%eax
f011f612:	74 49                	je     f011f65d <schenv+0xf1>
		{
			if ((__pl + 1) < __nl)
f011f614:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f619:	0f b6 c0             	movzbl %al,%eax
f011f61c:	8d 50 01             	lea    0x1(%eax),%edx
f011f61f:	a0 e0 51 55 f0       	mov    0xf05551e0,%al
f011f624:	0f b6 c0             	movzbl %al,%eax
f011f627:	39 c2                	cmp    %eax,%edx
f011f629:	7d 62                	jge    f011f68d <schenv+0x121>
			{
				__ne = cur_env;
f011f62b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f62e:	a3 0c 4f 55 f0       	mov    %eax,0xf0554f0c
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f633:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f638:	0f b6 c0             	movzbl %al,%eax
f011f63b:	8a 15 60 51 55 f0    	mov    0xf0555160,%dl
f011f641:	0f b6 d2             	movzbl %dl,%edx
f011f644:	4a                   	dec    %edx
f011f645:	39 d0                	cmp    %edx,%eax
f011f647:	7d 08                	jge    f011f651 <schenv+0xe5>
f011f649:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f64e:	40                   	inc    %eax
f011f64f:	eb 05                	jmp    f011f656 <schenv+0xea>
f011f651:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f656:	a2 e0 51 55 f0       	mov    %al,0xf05551e0
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f011f65b:	eb 30                	jmp    f011f68d <schenv+0x121>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f011f65d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f660:	a3 0c 4f 55 f0       	mov    %eax,0xf0554f0c
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f011f665:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f66a:	0f b6 c0             	movzbl %al,%eax
f011f66d:	8a 15 60 51 55 f0    	mov    0xf0555160,%dl
f011f673:	0f b6 d2             	movzbl %dl,%edx
f011f676:	4a                   	dec    %edx
f011f677:	39 d0                	cmp    %edx,%eax
f011f679:	7d 08                	jge    f011f683 <schenv+0x117>
f011f67b:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f680:	40                   	inc    %eax
f011f681:	eb 05                	jmp    f011f688 <schenv+0x11c>
f011f683:	a0 51 24 55 f0       	mov    0xf0552451,%al
f011f688:	a2 e0 51 55 f0       	mov    %al,0xf05551e0
		}
	}
}
f011f68d:	90                   	nop
f011f68e:	c9                   	leave  
f011f68f:	c3                   	ret    

f011f690 <chksch>:

void chksch(uint8 onoff)
{
f011f690:	55                   	push   %ebp
f011f691:	89 e5                	mov    %esp,%ebp
f011f693:	83 ec 18             	sub    $0x18,%esp
f011f696:	8b 45 08             	mov    0x8(%ebp),%eax
f011f699:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f69c:	e8 93 6d fe ff       	call   f0106434 <isSchedMethodBSD>
f011f6a1:	85 c0                	test   %eax,%eax
f011f6a3:	74 48                	je     f011f6ed <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f011f6a5:	e8 38 6d fe ff       	call   f01063e2 <get_load_average>
f011f6aa:	a3 7c 51 55 f0       	mov    %eax,0xf055517c
f011f6af:	a1 7c 51 55 f0       	mov    0xf055517c,%eax
f011f6b4:	a3 bc 4c 55 f0       	mov    %eax,0xf0554cbc
		acquire_spinlock(&ProcessQueues.qlock);
f011f6b9:	83 ec 0c             	sub    $0xc,%esp
f011f6bc:	68 60 24 55 f0       	push   $0xf0552460
f011f6c1:	e8 ba f0 fe ff       	call   f010e780 <acquire_spinlock>
f011f6c6:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f011f6c9:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011f6ce:	a3 c0 25 55 f0       	mov    %eax,0xf05525c0
		}
		release_spinlock(&ProcessQueues.qlock);
f011f6d3:	83 ec 0c             	sub    $0xc,%esp
f011f6d6:	68 60 24 55 f0       	push   $0xf0552460
f011f6db:	e8 27 f1 fe ff       	call   f010e807 <release_spinlock>
f011f6e0:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f011f6e3:	c7 05 1c 4f 55 f0 01 	movl   $0x1,0xf0554f1c
f011f6ea:	00 00 00 
	}
	__chkstatus = onoff;
f011f6ed:	8a 45 f4             	mov    -0xc(%ebp),%al
f011f6f0:	a2 08 4f 55 f0       	mov    %al,0xf0554f08
}
f011f6f5:	90                   	nop
f011f6f6:	c9                   	leave  
f011f6f7:	c3                   	ret    

f011f6f8 <chk1>:
void chk1()
{
f011f6f8:	55                   	push   %ebp
f011f6f9:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f011f6fb:	90                   	nop
f011f6fc:	5d                   	pop    %ebp
f011f6fd:	c3                   	ret    

f011f6fe <chk2>:
void chk2(struct Env* __se)
{
f011f6fe:	55                   	push   %ebp
f011f6ff:	89 e5                	mov    %esp,%ebp
f011f701:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f011f704:	a0 08 4f 55 f0       	mov    0xf0554f08,%al
f011f709:	84 c0                	test   %al,%al
f011f70b:	0f 84 59 03 00 00    	je     f011fa6a <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f011f711:	e8 1e 6d fe ff       	call   f0106434 <isSchedMethodBSD>
f011f716:	85 c0                	test   %eax,%eax
f011f718:	0f 84 4d 03 00 00    	je     f011fa6b <chk2+0x36d>
	{
		__nla = get_load_average();
f011f71e:	e8 bf 6c fe ff       	call   f01063e2 <get_load_average>
f011f723:	a3 e4 4b 55 f0       	mov    %eax,0xf0554be4
		acquire_spinlock(&ProcessQueues.qlock);
f011f728:	83 ec 0c             	sub    $0xc,%esp
f011f72b:	68 60 24 55 f0       	push   $0xf0552460
f011f730:	e8 4b f0 fe ff       	call   f010e780 <acquire_spinlock>
f011f735:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f011f738:	a1 ec 24 55 f0       	mov    0xf05524ec,%eax
f011f73d:	a3 10 4f 55 f0       	mov    %eax,0xf0554f10
		}
		release_spinlock(&ProcessQueues.qlock);
f011f742:	83 ec 0c             	sub    $0xc,%esp
f011f745:	68 60 24 55 f0       	push   $0xf0552460
f011f74a:	e8 b8 f0 fe ff       	call   f010e807 <release_spinlock>
f011f74f:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f011f752:	a1 1c 4f 55 f0       	mov    0xf0554f1c,%eax
f011f757:	85 c0                	test   %eax,%eax
f011f759:	74 72                	je     f011f7cd <chk2+0xcf>
		{
			acquire_spinlock(&ProcessQueues.qlock);
f011f75b:	83 ec 0c             	sub    $0xc,%esp
f011f75e:	68 60 24 55 f0       	push   $0xf0552460
f011f763:	e8 18 f0 fe ff       	call   f010e780 <acquire_spinlock>
f011f768:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f011f76b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f76f:	0f 95 c0             	setne  %al
f011f772:	0f b6 c0             	movzbl %al,%eax
f011f775:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f77a:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f77f:	0f b6 c0             	movzbl %al,%eax
f011f782:	48                   	dec    %eax
f011f783:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011f786:	eb 20                	jmp    f011f7a8 <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f788:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011f78b:	83 c0 09             	add    $0x9,%eax
f011f78e:	c1 e0 04             	shl    $0x4,%eax
f011f791:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f011f796:	8b 00                	mov    (%eax),%eax
f011f798:	8b 15 d4 50 55 f0    	mov    0xf05550d4,%edx
f011f79e:	01 d0                	add    %edx,%eax
f011f7a0:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
		{
			acquire_spinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f7a5:	ff 4d f4             	decl   -0xc(%ebp)
f011f7a8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011f7ac:	79 da                	jns    f011f788 <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f011f7ae:	c7 05 1c 4f 55 f0 00 	movl   $0x0,0xf0554f1c
f011f7b5:	00 00 00 
			}
			release_spinlock(&ProcessQueues.qlock);
f011f7b8:	83 ec 0c             	sub    $0xc,%esp
f011f7bb:	68 60 24 55 f0       	push   $0xf0552460
f011f7c0:	e8 42 f0 fe ff       	call   f010e807 <release_spinlock>
f011f7c5:	83 c4 10             	add    $0x10,%esp
f011f7c8:	e9 91 02 00 00       	jmp    f011fa5e <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f011f7cd:	8b 15 c0 25 55 f0    	mov    0xf05525c0,%edx
f011f7d3:	a1 10 4f 55 f0       	mov    0xf0554f10,%eax
f011f7d8:	39 c2                	cmp    %eax,%edx
f011f7da:	74 63                	je     f011f83f <chk2+0x141>
			{
				acquire_spinlock(&ProcessQueues.qlock);
f011f7dc:	83 ec 0c             	sub    $0xc,%esp
f011f7df:	68 60 24 55 f0       	push   $0xf0552460
f011f7e4:	e8 97 ef fe ff       	call   f010e780 <acquire_spinlock>
f011f7e9:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f011f7ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011f7f0:	0f 95 c0             	setne  %al
f011f7f3:	0f b6 c0             	movzbl %al,%eax
f011f7f6:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f7fb:	a0 60 51 55 f0       	mov    0xf0555160,%al
f011f800:	0f b6 c0             	movzbl %al,%eax
f011f803:	48                   	dec    %eax
f011f804:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011f807:	eb 20                	jmp    f011f829 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f011f809:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011f80c:	83 c0 09             	add    $0x9,%eax
f011f80f:	c1 e0 04             	shl    $0x4,%eax
f011f812:	05 6c 24 55 f0       	add    $0xf055246c,%eax
f011f817:	8b 00                	mov    (%eax),%eax
f011f819:	8b 15 d4 50 55 f0    	mov    0xf05550d4,%edx
f011f81f:	01 d0                	add    %edx,%eax
f011f821:	a3 d4 50 55 f0       	mov    %eax,0xf05550d4
			{
				acquire_spinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f011f826:	ff 4d f0             	decl   -0x10(%ebp)
f011f829:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011f82d:	79 da                	jns    f011f809 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_spinlock(&ProcessQueues.qlock);
f011f82f:	83 ec 0c             	sub    $0xc,%esp
f011f832:	68 60 24 55 f0       	push   $0xf0552460
f011f837:	e8 cb ef fe ff       	call   f010e807 <release_spinlock>
f011f83c:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f011f83f:	e8 37 6b fe ff       	call   f010637b <timer_ticks>
f011f844:	6a 00                	push   $0x0
f011f846:	68 e8 03 00 00       	push   $0x3e8
f011f84b:	52                   	push   %edx
f011f84c:	50                   	push   %eax
f011f84d:	e8 3a 1a 00 00       	call   f012128c <__moddi3>
f011f852:	83 c4 10             	add    $0x10,%esp
f011f855:	09 d0                	or     %edx,%eax
f011f857:	85 c0                	test   %eax,%eax
f011f859:	75 32                	jne    f011f88d <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f011f85b:	8b 15 bc 4c 55 f0    	mov    0xf0554cbc,%edx
f011f861:	a1 e4 4b 55 f0       	mov    0xf0554be4,%eax
f011f866:	39 c2                	cmp    %eax,%edx
f011f868:	75 19                	jne    f011f883 <chk2+0x185>
f011f86a:	68 19 d6 12 f0       	push   $0xf012d619
f011f86f:	68 37 d3 12 f0       	push   $0xf012d337
f011f874:	68 f4 01 00 00       	push   $0x1f4
f011f879:	68 7f d3 12 f0       	push   $0xf012d37f
f011f87e:	e8 27 0b fe ff       	call   f01003aa <_panic_all>
				__histla = __nla;
f011f883:	a1 e4 4b 55 f0       	mov    0xf0554be4,%eax
f011f888:	a3 bc 4c 55 f0       	mov    %eax,0xf0554cbc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f011f88d:	e8 e9 6a fe ff       	call   f010637b <timer_ticks>
f011f892:	6a 00                	push   $0x0
f011f894:	6a 64                	push   $0x64
f011f896:	52                   	push   %edx
f011f897:	50                   	push   %eax
f011f898:	e8 ef 19 00 00       	call   f012128c <__moddi3>
f011f89d:	83 c4 10             	add    $0x10,%esp
f011f8a0:	09 d0                	or     %edx,%eax
f011f8a2:	85 c0                	test   %eax,%eax
f011f8a4:	0f 85 b4 01 00 00    	jne    f011fa5e <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f011f8aa:	8b 0d 7c 51 55 f0    	mov    0xf055517c,%ecx
f011f8b0:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f8b5:	f7 e9                	imul   %ecx
f011f8b7:	c1 fa 05             	sar    $0x5,%edx
f011f8ba:	89 c8                	mov    %ecx,%eax
f011f8bc:	c1 f8 1f             	sar    $0x1f,%eax
f011f8bf:	29 c2                	sub    %eax,%edx
f011f8c1:	89 d0                	mov    %edx,%eax
f011f8c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f011f8c6:	8b 0d 7c 51 55 f0    	mov    0xf055517c,%ecx
f011f8cc:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f8d1:	f7 e9                	imul   %ecx
f011f8d3:	c1 fa 05             	sar    $0x5,%edx
f011f8d6:	89 c8                	mov    %ecx,%eax
f011f8d8:	c1 f8 1f             	sar    $0x1f,%eax
f011f8db:	29 c2                	sub    %eax,%edx
f011f8dd:	89 d0                	mov    %edx,%eax
f011f8df:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011f8e2:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011f8e5:	89 d0                	mov    %edx,%eax
f011f8e7:	c1 e0 02             	shl    $0x2,%eax
f011f8ea:	01 d0                	add    %edx,%eax
f011f8ec:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f8f3:	01 d0                	add    %edx,%eax
f011f8f5:	c1 e0 02             	shl    $0x2,%eax
f011f8f8:	29 c1                	sub    %eax,%ecx
f011f8fa:	89 c8                	mov    %ecx,%eax
f011f8fc:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f011f8ff:	8b 0d e4 4b 55 f0    	mov    0xf0554be4,%ecx
f011f905:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f90a:	f7 e9                	imul   %ecx
f011f90c:	c1 fa 05             	sar    $0x5,%edx
f011f90f:	89 c8                	mov    %ecx,%eax
f011f911:	c1 f8 1f             	sar    $0x1f,%eax
f011f914:	29 c2                	sub    %eax,%edx
f011f916:	89 d0                	mov    %edx,%eax
f011f918:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f011f91b:	8b 0d e4 4b 55 f0    	mov    0xf0554be4,%ecx
f011f921:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011f926:	f7 e9                	imul   %ecx
f011f928:	c1 fa 05             	sar    $0x5,%edx
f011f92b:	89 c8                	mov    %ecx,%eax
f011f92d:	c1 f8 1f             	sar    $0x1f,%eax
f011f930:	29 c2                	sub    %eax,%edx
f011f932:	89 d0                	mov    %edx,%eax
f011f934:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011f937:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011f93a:	89 d0                	mov    %edx,%eax
f011f93c:	c1 e0 02             	shl    $0x2,%eax
f011f93f:	01 d0                	add    %edx,%eax
f011f941:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011f948:	01 d0                	add    %edx,%eax
f011f94a:	c1 e0 02             	shl    $0x2,%eax
f011f94d:	29 c1                	sub    %eax,%ecx
f011f94f:	89 c8                	mov    %ecx,%eax
f011f951:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f011f954:	8b 15 10 4f 55 f0    	mov    0xf0554f10,%edx
f011f95a:	a1 c0 25 55 f0       	mov    0xf05525c0,%eax
f011f95f:	39 c2                	cmp    %eax,%edx
f011f961:	0f 85 ed 00 00 00    	jne    f011fa54 <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f011f967:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f96c:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f96f:	7e 5b                	jle    f011f9cc <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f971:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f976:	83 ec 08             	sub    $0x8,%esp
f011f979:	ff 75 e0             	pushl  -0x20(%ebp)
f011f97c:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f97f:	ff 75 e8             	pushl  -0x18(%ebp)
f011f982:	ff 75 ec             	pushl  -0x14(%ebp)
f011f985:	50                   	push   %eax
f011f986:	68 2c d6 12 f0       	push   $0xf012d62c
f011f98b:	e8 dc 15 fe ff       	call   f0100f6c <cprintf>
f011f990:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f011f993:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f996:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f999:	0f 8f b5 00 00 00    	jg     f011fa54 <chk2+0x356>
f011f99f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f9a2:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f9a5:	75 0c                	jne    f011f9b3 <chk2+0x2b5>
f011f9a7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011f9aa:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011f9ad:	0f 8d a1 00 00 00    	jge    f011fa54 <chk2+0x356>
f011f9b3:	68 74 d6 12 f0       	push   $0xf012d674
f011f9b8:	68 37 d3 12 f0       	push   $0xf012d337
f011f9bd:	68 09 02 00 00       	push   $0x209
f011f9c2:	68 7f d3 12 f0       	push   $0xf012d37f
f011f9c7:	e8 de 09 fe ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc < plaint)
f011f9cc:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f9d1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f9d4:	7d 53                	jge    f011fa29 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f011f9d6:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011f9db:	83 ec 08             	sub    $0x8,%esp
f011f9de:	ff 75 e0             	pushl  -0x20(%ebp)
f011f9e1:	ff 75 e4             	pushl  -0x1c(%ebp)
f011f9e4:	ff 75 e8             	pushl  -0x18(%ebp)
f011f9e7:	ff 75 ec             	pushl  -0x14(%ebp)
f011f9ea:	50                   	push   %eax
f011f9eb:	68 b4 d6 12 f0       	push   $0xf012d6b4
f011f9f0:	e8 77 15 fe ff       	call   f0100f6c <cprintf>
f011f9f5:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f011f9f8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011f9fb:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011f9fe:	7c 54                	jl     f011fa54 <chk2+0x356>
f011fa00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fa03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa06:	75 08                	jne    f011fa10 <chk2+0x312>
f011fa08:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011fa0b:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f011fa0e:	7e 44                	jle    f011fa54 <chk2+0x356>
f011fa10:	68 fc d6 12 f0       	push   $0xf012d6fc
f011fa15:	68 37 d3 12 f0       	push   $0xf012d337
f011fa1a:	68 0f 02 00 00       	push   $0x20f
f011fa1f:	68 7f d3 12 f0       	push   $0xf012d37f
f011fa24:	e8 81 09 fe ff       	call   f01003aa <_panic_all>
					}
					else if (__nproc == plaint)
f011fa29:	a1 d4 50 55 f0       	mov    0xf05550d4,%eax
f011fa2e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa31:	75 21                	jne    f011fa54 <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f011fa33:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011fa36:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011fa39:	74 19                	je     f011fa54 <chk2+0x356>
f011fa3b:	68 3c d7 12 f0       	push   $0xf012d73c
f011fa40:	68 37 d3 12 f0       	push   $0xf012d337
f011fa45:	68 13 02 00 00       	push   $0x213
f011fa4a:	68 7f d3 12 f0       	push   $0xf012d37f
f011fa4f:	e8 56 09 fe ff       	call   f01003aa <_panic_all>
					}
				}
				__pla = __nla;
f011fa54:	a1 e4 4b 55 f0       	mov    0xf0554be4,%eax
f011fa59:	a3 7c 51 55 f0       	mov    %eax,0xf055517c
			}
		}
		__pnexit = __nnexit;
f011fa5e:	a1 10 4f 55 f0       	mov    0xf0554f10,%eax
f011fa63:	a3 c0 25 55 f0       	mov    %eax,0xf05525c0
f011fa68:	eb 01                	jmp    f011fa6b <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011fa6a:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011fa6b:	c9                   	leave  
f011fa6c:	c3                   	ret    

f011fa6d <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011fa6d:	55                   	push   %ebp
f011fa6e:	89 e5                	mov    %esp,%ebp
f011fa70:	83 ec 18             	sub    $0x18,%esp
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f011fa73:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011fa7a:	eb 40                	jmp    f011fabc <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011fa7c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fa7f:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011fa85:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fa8a:	83 ec 08             	sub    $0x8,%esp
f011fa8d:	52                   	push   %edx
f011fa8e:	50                   	push   %eax
f011fa8f:	e8 a6 01 00 00       	call   f011fc3a <check_va2pa>
f011fa94:	83 c4 10             	add    $0x10,%esp
f011fa97:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011fa9a:	74 19                	je     f011fab5 <check_boot_pgdir+0x48>
f011fa9c:	68 50 d7 12 f0       	push   $0xf012d750
f011faa1:	68 37 d3 12 f0       	push   $0xf012d337
f011faa6:	68 5f 02 00 00       	push   $0x25f
f011faab:	68 7f d3 12 f0       	push   $0xf012d37f
f011fab0:	e8 65 08 fe ff       	call   f010031a <_panic>
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#else
	{
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
f011fab5:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011fabc:	81 7d f4 00 00 00 10 	cmpl   $0x10000000,-0xc(%ebp)
f011fac3:	75 b7                	jne    f011fa7c <check_boot_pgdir+0xf>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011fac5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011facc:	e9 81 00 00 00       	jmp    f011fb52 <check_boot_pgdir+0xe5>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011fad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fad4:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011fad9:	85 c0                	test   %eax,%eax
f011fadb:	74 6d                	je     f011fb4a <check_boot_pgdir+0xdd>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011fadd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fae0:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011fae6:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011faeb:	83 ec 08             	sub    $0x8,%esp
f011faee:	52                   	push   %edx
f011faef:	50                   	push   %eax
f011faf0:	e8 45 01 00 00       	call   f011fc3a <check_va2pa>
f011faf5:	83 c4 10             	add    $0x10,%esp
f011faf8:	c7 45 f0 00 10 17 f0 	movl   $0xf0171000,-0x10(%ebp)
f011faff:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011fb06:	77 17                	ja     f011fb1f <check_boot_pgdir+0xb2>
f011fb08:	ff 75 f0             	pushl  -0x10(%ebp)
f011fb0b:	68 88 d7 12 f0       	push   $0xf012d788
f011fb10:	68 68 02 00 00       	push   $0x268
f011fb15:	68 7f d3 12 f0       	push   $0xf012d37f
f011fb1a:	e8 fb 07 fe ff       	call   f010031a <_panic>
f011fb1f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011fb22:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011fb28:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb2b:	01 ca                	add    %ecx,%edx
f011fb2d:	39 d0                	cmp    %edx,%eax
f011fb2f:	74 1a                	je     f011fb4b <check_boot_pgdir+0xde>
f011fb31:	68 bc d7 12 f0       	push   $0xf012d7bc
f011fb36:	68 37 d3 12 f0       	push   $0xf012d337
f011fb3b:	68 68 02 00 00       	push   $0x268
f011fb40:	68 7f d3 12 f0       	push   $0xf012d37f
f011fb45:	e8 d0 07 fe ff       	call   f010031a <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011fb4a:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011fb4b:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011fb52:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011fb59:	0f 86 72 ff ff ff    	jbe    f011fad1 <check_boot_pgdir+0x64>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011fb5f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011fb66:	e9 af 00 00 00       	jmp    f011fc1a <check_boot_pgdir+0x1ad>
		switch (i) {
f011fb6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fb6e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011fb73:	74 11                	je     f011fb86 <check_boot_pgdir+0x119>
f011fb75:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011fb7a:	72 36                	jb     f011fbb2 <check_boot_pgdir+0x145>
f011fb7c:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011fb81:	83 f8 02             	cmp    $0x2,%eax
f011fb84:	77 2c                	ja     f011fbb2 <check_boot_pgdir+0x145>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011fb86:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fb8b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fb8e:	c1 e2 02             	shl    $0x2,%edx
f011fb91:	01 d0                	add    %edx,%eax
f011fb93:	8b 00                	mov    (%eax),%eax
f011fb95:	85 c0                	test   %eax,%eax
f011fb97:	75 7a                	jne    f011fc13 <check_boot_pgdir+0x1a6>
f011fb99:	68 42 d8 12 f0       	push   $0xf012d842
f011fb9e:	68 37 d3 12 f0       	push   $0xf012d337
f011fba3:	68 73 02 00 00       	push   $0x273
f011fba8:	68 7f d3 12 f0       	push   $0xf012d37f
f011fbad:	e8 68 07 fe ff       	call   f010031a <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011fbb2:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011fbb9:	76 2c                	jbe    f011fbe7 <check_boot_pgdir+0x17a>
				assert(ptr_page_directory[i]);
f011fbbb:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fbc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbc3:	c1 e2 02             	shl    $0x2,%edx
f011fbc6:	01 d0                	add    %edx,%eax
f011fbc8:	8b 00                	mov    (%eax),%eax
f011fbca:	85 c0                	test   %eax,%eax
f011fbcc:	75 48                	jne    f011fc16 <check_boot_pgdir+0x1a9>
f011fbce:	68 42 d8 12 f0       	push   $0xf012d842
f011fbd3:	68 37 d3 12 f0       	push   $0xf012d337
f011fbd8:	68 77 02 00 00       	push   $0x277
f011fbdd:	68 7f d3 12 f0       	push   $0xf012d37f
f011fbe2:	e8 33 07 fe ff       	call   f010031a <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011fbe7:	a1 dc 50 55 f0       	mov    0xf05550dc,%eax
f011fbec:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fbef:	c1 e2 02             	shl    $0x2,%edx
f011fbf2:	01 d0                	add    %edx,%eax
f011fbf4:	8b 00                	mov    (%eax),%eax
f011fbf6:	85 c0                	test   %eax,%eax
f011fbf8:	74 1c                	je     f011fc16 <check_boot_pgdir+0x1a9>
f011fbfa:	68 58 d8 12 f0       	push   $0xf012d858
f011fbff:	68 37 d3 12 f0       	push   $0xf012d337
f011fc04:	68 79 02 00 00       	push   $0x279
f011fc09:	68 7f d3 12 f0       	push   $0xf012d37f
f011fc0e:	e8 07 07 fe ff       	call   f010031a <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011fc13:	90                   	nop
f011fc14:	eb 01                	jmp    f011fc17 <check_boot_pgdir+0x1aa>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011fc16:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011fc17:	ff 45 f4             	incl   -0xc(%ebp)
f011fc1a:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011fc21:	0f 86 44 ff ff ff    	jbe    f011fb6b <check_boot_pgdir+0xfe>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011fc27:	83 ec 0c             	sub    $0xc,%esp
f011fc2a:	68 74 d8 12 f0       	push   $0xf012d874
f011fc2f:	e8 38 13 fe ff       	call   f0100f6c <cprintf>
f011fc34:	83 c4 10             	add    $0x10,%esp
}
f011fc37:	90                   	nop
f011fc38:	c9                   	leave  
f011fc39:	c3                   	ret    

f011fc3a <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011fc3a:	55                   	push   %ebp
f011fc3b:	89 e5                	mov    %esp,%ebp
f011fc3d:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011fc40:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fc43:	c1 e8 16             	shr    $0x16,%eax
f011fc46:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fc4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fc50:	01 d0                	add    %edx,%eax
f011fc52:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011fc55:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc58:	8b 00                	mov    (%eax),%eax
f011fc5a:	83 e0 01             	and    $0x1,%eax
f011fc5d:	85 c0                	test   %eax,%eax
f011fc5f:	75 0a                	jne    f011fc6b <check_va2pa+0x31>
		return ~0;
f011fc61:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011fc66:	e9 87 00 00 00       	jmp    f011fcf2 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011fc6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011fc6e:	8b 00                	mov    (%eax),%eax
f011fc70:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011fc75:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fc78:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fc7b:	c1 e8 0c             	shr    $0xc,%eax
f011fc7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011fc81:	a1 b8 4c 55 f0       	mov    0xf0554cb8,%eax
f011fc86:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011fc89:	72 17                	jb     f011fca2 <check_va2pa+0x68>
f011fc8b:	ff 75 f0             	pushl  -0x10(%ebp)
f011fc8e:	68 98 d8 12 f0       	push   $0xf012d898
f011fc93:	68 8f 02 00 00       	push   $0x28f
f011fc98:	68 7f d3 12 f0       	push   $0xf012d37f
f011fc9d:	e8 78 06 fe ff       	call   f010031a <_panic>
f011fca2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fca5:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011fcaa:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011fcad:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcb0:	c1 e8 0c             	shr    $0xc,%eax
f011fcb3:	25 ff 03 00 00       	and    $0x3ff,%eax
f011fcb8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fcbf:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fcc2:	01 d0                	add    %edx,%eax
f011fcc4:	8b 00                	mov    (%eax),%eax
f011fcc6:	83 e0 01             	and    $0x1,%eax
f011fcc9:	85 c0                	test   %eax,%eax
f011fccb:	75 07                	jne    f011fcd4 <check_va2pa+0x9a>
		return ~0;
f011fccd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011fcd2:	eb 1e                	jmp    f011fcf2 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011fcd4:	8b 45 0c             	mov    0xc(%ebp),%eax
f011fcd7:	c1 e8 0c             	shr    $0xc,%eax
f011fcda:	25 ff 03 00 00       	and    $0x3ff,%eax
f011fcdf:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011fce6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011fce9:	01 d0                	add    %edx,%eax
f011fceb:	8b 00                	mov    (%eax),%eax
f011fced:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011fcf2:	c9                   	leave  
f011fcf3:	c3                   	ret    

f011fcf4 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011fcf4:	55                   	push   %ebp
f011fcf5:	89 e5                	mov    %esp,%ebp
f011fcf7:	53                   	push   %ebx
f011fcf8:	83 ec 14             	sub    $0x14,%esp
f011fcfb:	8b 45 10             	mov    0x10(%ebp),%eax
f011fcfe:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011fd01:	8b 45 14             	mov    0x14(%ebp),%eax
f011fd04:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011fd07:	8b 45 18             	mov    0x18(%ebp),%eax
f011fd0a:	ba 00 00 00 00       	mov    $0x0,%edx
f011fd0f:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011fd12:	77 55                	ja     f011fd69 <printnum+0x75>
f011fd14:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011fd17:	72 05                	jb     f011fd1e <printnum+0x2a>
f011fd19:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011fd1c:	77 4b                	ja     f011fd69 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011fd1e:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011fd21:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011fd24:	8b 45 18             	mov    0x18(%ebp),%eax
f011fd27:	ba 00 00 00 00       	mov    $0x0,%edx
f011fd2c:	52                   	push   %edx
f011fd2d:	50                   	push   %eax
f011fd2e:	ff 75 f4             	pushl  -0xc(%ebp)
f011fd31:	ff 75 f0             	pushl  -0x10(%ebp)
f011fd34:	e8 eb 16 00 00       	call   f0121424 <__udivdi3>
f011fd39:	83 c4 10             	add    $0x10,%esp
f011fd3c:	83 ec 04             	sub    $0x4,%esp
f011fd3f:	ff 75 20             	pushl  0x20(%ebp)
f011fd42:	53                   	push   %ebx
f011fd43:	ff 75 18             	pushl  0x18(%ebp)
f011fd46:	52                   	push   %edx
f011fd47:	50                   	push   %eax
f011fd48:	ff 75 0c             	pushl  0xc(%ebp)
f011fd4b:	ff 75 08             	pushl  0x8(%ebp)
f011fd4e:	e8 a1 ff ff ff       	call   f011fcf4 <printnum>
f011fd53:	83 c4 20             	add    $0x20,%esp
f011fd56:	eb 1a                	jmp    f011fd72 <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011fd58:	83 ec 08             	sub    $0x8,%esp
f011fd5b:	ff 75 0c             	pushl  0xc(%ebp)
f011fd5e:	ff 75 20             	pushl  0x20(%ebp)
f011fd61:	8b 45 08             	mov    0x8(%ebp),%eax
f011fd64:	ff d0                	call   *%eax
f011fd66:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011fd69:	ff 4d 1c             	decl   0x1c(%ebp)
f011fd6c:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011fd70:	7f e6                	jg     f011fd58 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011fd72:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011fd75:	bb 00 00 00 00       	mov    $0x0,%ebx
f011fd7a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011fd7d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011fd80:	53                   	push   %ebx
f011fd81:	51                   	push   %ecx
f011fd82:	52                   	push   %edx
f011fd83:	50                   	push   %eax
f011fd84:	e8 ab 17 00 00       	call   f0121534 <__umoddi3>
f011fd89:	83 c4 10             	add    $0x10,%esp
f011fd8c:	05 f4 da 12 f0       	add    $0xf012daf4,%eax
f011fd91:	8a 00                	mov    (%eax),%al
f011fd93:	0f be c0             	movsbl %al,%eax
f011fd96:	83 ec 08             	sub    $0x8,%esp
f011fd99:	ff 75 0c             	pushl  0xc(%ebp)
f011fd9c:	50                   	push   %eax
f011fd9d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fda0:	ff d0                	call   *%eax
f011fda2:	83 c4 10             	add    $0x10,%esp
}
f011fda5:	90                   	nop
f011fda6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011fda9:	c9                   	leave  
f011fdaa:	c3                   	ret    

f011fdab <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011fdab:	55                   	push   %ebp
f011fdac:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011fdae:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011fdb2:	7e 1c                	jle    f011fdd0 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011fdb4:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdb7:	8b 00                	mov    (%eax),%eax
f011fdb9:	8d 50 08             	lea    0x8(%eax),%edx
f011fdbc:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdbf:	89 10                	mov    %edx,(%eax)
f011fdc1:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdc4:	8b 00                	mov    (%eax),%eax
f011fdc6:	83 e8 08             	sub    $0x8,%eax
f011fdc9:	8b 50 04             	mov    0x4(%eax),%edx
f011fdcc:	8b 00                	mov    (%eax),%eax
f011fdce:	eb 40                	jmp    f011fe10 <getuint+0x65>
	else if (lflag)
f011fdd0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fdd4:	74 1e                	je     f011fdf4 <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011fdd6:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdd9:	8b 00                	mov    (%eax),%eax
f011fddb:	8d 50 04             	lea    0x4(%eax),%edx
f011fdde:	8b 45 08             	mov    0x8(%ebp),%eax
f011fde1:	89 10                	mov    %edx,(%eax)
f011fde3:	8b 45 08             	mov    0x8(%ebp),%eax
f011fde6:	8b 00                	mov    (%eax),%eax
f011fde8:	83 e8 04             	sub    $0x4,%eax
f011fdeb:	8b 00                	mov    (%eax),%eax
f011fded:	ba 00 00 00 00       	mov    $0x0,%edx
f011fdf2:	eb 1c                	jmp    f011fe10 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011fdf4:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdf7:	8b 00                	mov    (%eax),%eax
f011fdf9:	8d 50 04             	lea    0x4(%eax),%edx
f011fdfc:	8b 45 08             	mov    0x8(%ebp),%eax
f011fdff:	89 10                	mov    %edx,(%eax)
f011fe01:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe04:	8b 00                	mov    (%eax),%eax
f011fe06:	83 e8 04             	sub    $0x4,%eax
f011fe09:	8b 00                	mov    (%eax),%eax
f011fe0b:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011fe10:	5d                   	pop    %ebp
f011fe11:	c3                   	ret    

f011fe12 <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011fe12:	55                   	push   %ebp
f011fe13:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011fe15:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011fe19:	7e 1c                	jle    f011fe37 <getint+0x25>
		return va_arg(*ap, long long);
f011fe1b:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe1e:	8b 00                	mov    (%eax),%eax
f011fe20:	8d 50 08             	lea    0x8(%eax),%edx
f011fe23:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe26:	89 10                	mov    %edx,(%eax)
f011fe28:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe2b:	8b 00                	mov    (%eax),%eax
f011fe2d:	83 e8 08             	sub    $0x8,%eax
f011fe30:	8b 50 04             	mov    0x4(%eax),%edx
f011fe33:	8b 00                	mov    (%eax),%eax
f011fe35:	eb 38                	jmp    f011fe6f <getint+0x5d>
	else if (lflag)
f011fe37:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011fe3b:	74 1a                	je     f011fe57 <getint+0x45>
		return va_arg(*ap, long);
f011fe3d:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe40:	8b 00                	mov    (%eax),%eax
f011fe42:	8d 50 04             	lea    0x4(%eax),%edx
f011fe45:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe48:	89 10                	mov    %edx,(%eax)
f011fe4a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe4d:	8b 00                	mov    (%eax),%eax
f011fe4f:	83 e8 04             	sub    $0x4,%eax
f011fe52:	8b 00                	mov    (%eax),%eax
f011fe54:	99                   	cltd   
f011fe55:	eb 18                	jmp    f011fe6f <getint+0x5d>
	else
		return va_arg(*ap, int);
f011fe57:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe5a:	8b 00                	mov    (%eax),%eax
f011fe5c:	8d 50 04             	lea    0x4(%eax),%edx
f011fe5f:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe62:	89 10                	mov    %edx,(%eax)
f011fe64:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe67:	8b 00                	mov    (%eax),%eax
f011fe69:	83 e8 04             	sub    $0x4,%eax
f011fe6c:	8b 00                	mov    (%eax),%eax
f011fe6e:	99                   	cltd   
}
f011fe6f:	5d                   	pop    %ebp
f011fe70:	c3                   	ret    

f011fe71 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011fe71:	55                   	push   %ebp
f011fe72:	89 e5                	mov    %esp,%ebp
f011fe74:	56                   	push   %esi
f011fe75:	53                   	push   %ebx
f011fe76:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011fe79:	eb 17                	jmp    f011fe92 <vprintfmt+0x21>
			if (ch == '\0')
f011fe7b:	85 db                	test   %ebx,%ebx
f011fe7d:	0f 84 c1 03 00 00    	je     f0120244 <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011fe83:	83 ec 08             	sub    $0x8,%esp
f011fe86:	ff 75 0c             	pushl  0xc(%ebp)
f011fe89:	53                   	push   %ebx
f011fe8a:	8b 45 08             	mov    0x8(%ebp),%eax
f011fe8d:	ff d0                	call   *%eax
f011fe8f:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011fe92:	8b 45 10             	mov    0x10(%ebp),%eax
f011fe95:	8d 50 01             	lea    0x1(%eax),%edx
f011fe98:	89 55 10             	mov    %edx,0x10(%ebp)
f011fe9b:	8a 00                	mov    (%eax),%al
f011fe9d:	0f b6 d8             	movzbl %al,%ebx
f011fea0:	83 fb 25             	cmp    $0x25,%ebx
f011fea3:	75 d6                	jne    f011fe7b <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011fea5:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011fea9:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011feb0:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011feb7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011febe:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011fec5:	8b 45 10             	mov    0x10(%ebp),%eax
f011fec8:	8d 50 01             	lea    0x1(%eax),%edx
f011fecb:	89 55 10             	mov    %edx,0x10(%ebp)
f011fece:	8a 00                	mov    (%eax),%al
f011fed0:	0f b6 d8             	movzbl %al,%ebx
f011fed3:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011fed6:	83 f8 5b             	cmp    $0x5b,%eax
f011fed9:	0f 87 3d 03 00 00    	ja     f012021c <vprintfmt+0x3ab>
f011fedf:	8b 04 85 18 db 12 f0 	mov    -0xfed24e8(,%eax,4),%eax
f011fee6:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011fee8:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011feec:	eb d7                	jmp    f011fec5 <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011feee:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011fef2:	eb d1                	jmp    f011fec5 <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011fef4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011fefb:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011fefe:	89 d0                	mov    %edx,%eax
f011ff00:	c1 e0 02             	shl    $0x2,%eax
f011ff03:	01 d0                	add    %edx,%eax
f011ff05:	01 c0                	add    %eax,%eax
f011ff07:	01 d8                	add    %ebx,%eax
f011ff09:	83 e8 30             	sub    $0x30,%eax
f011ff0c:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011ff0f:	8b 45 10             	mov    0x10(%ebp),%eax
f011ff12:	8a 00                	mov    (%eax),%al
f011ff14:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011ff17:	83 fb 2f             	cmp    $0x2f,%ebx
f011ff1a:	7e 3e                	jle    f011ff5a <vprintfmt+0xe9>
f011ff1c:	83 fb 39             	cmp    $0x39,%ebx
f011ff1f:	7f 39                	jg     f011ff5a <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011ff21:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011ff24:	eb d5                	jmp    f011fefb <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011ff26:	8b 45 14             	mov    0x14(%ebp),%eax
f011ff29:	83 c0 04             	add    $0x4,%eax
f011ff2c:	89 45 14             	mov    %eax,0x14(%ebp)
f011ff2f:	8b 45 14             	mov    0x14(%ebp),%eax
f011ff32:	83 e8 04             	sub    $0x4,%eax
f011ff35:	8b 00                	mov    (%eax),%eax
f011ff37:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011ff3a:	eb 1f                	jmp    f011ff5b <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011ff3c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ff40:	79 83                	jns    f011fec5 <vprintfmt+0x54>
				width = 0;
f011ff42:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011ff49:	e9 77 ff ff ff       	jmp    f011fec5 <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011ff4e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011ff55:	e9 6b ff ff ff       	jmp    f011fec5 <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011ff5a:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011ff5b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011ff5f:	0f 89 60 ff ff ff    	jns    f011fec5 <vprintfmt+0x54>
				width = precision, precision = -1;
f011ff65:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011ff68:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011ff6b:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011ff72:	e9 4e ff ff ff       	jmp    f011fec5 <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011ff77:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011ff7a:	e9 46 ff ff ff       	jmp    f011fec5 <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011ff7f:	8b 45 14             	mov    0x14(%ebp),%eax
f011ff82:	83 c0 04             	add    $0x4,%eax
f011ff85:	89 45 14             	mov    %eax,0x14(%ebp)
f011ff88:	8b 45 14             	mov    0x14(%ebp),%eax
f011ff8b:	83 e8 04             	sub    $0x4,%eax
f011ff8e:	8b 00                	mov    (%eax),%eax
f011ff90:	83 ec 08             	sub    $0x8,%esp
f011ff93:	ff 75 0c             	pushl  0xc(%ebp)
f011ff96:	50                   	push   %eax
f011ff97:	8b 45 08             	mov    0x8(%ebp),%eax
f011ff9a:	ff d0                	call   *%eax
f011ff9c:	83 c4 10             	add    $0x10,%esp
			break;
f011ff9f:	e9 9b 02 00 00       	jmp    f012023f <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011ffa4:	8b 45 14             	mov    0x14(%ebp),%eax
f011ffa7:	83 c0 04             	add    $0x4,%eax
f011ffaa:	89 45 14             	mov    %eax,0x14(%ebp)
f011ffad:	8b 45 14             	mov    0x14(%ebp),%eax
f011ffb0:	83 e8 04             	sub    $0x4,%eax
f011ffb3:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011ffb5:	85 db                	test   %ebx,%ebx
f011ffb7:	79 02                	jns    f011ffbb <vprintfmt+0x14a>
				err = -err;
f011ffb9:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011ffbb:	83 fb 64             	cmp    $0x64,%ebx
f011ffbe:	7f 0b                	jg     f011ffcb <vprintfmt+0x15a>
f011ffc0:	8b 34 9d 60 d9 12 f0 	mov    -0xfed26a0(,%ebx,4),%esi
f011ffc7:	85 f6                	test   %esi,%esi
f011ffc9:	75 19                	jne    f011ffe4 <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011ffcb:	53                   	push   %ebx
f011ffcc:	68 05 db 12 f0       	push   $0xf012db05
f011ffd1:	ff 75 0c             	pushl  0xc(%ebp)
f011ffd4:	ff 75 08             	pushl  0x8(%ebp)
f011ffd7:	e8 70 02 00 00       	call   f012024c <printfmt>
f011ffdc:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011ffdf:	e9 5b 02 00 00       	jmp    f012023f <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011ffe4:	56                   	push   %esi
f011ffe5:	68 0e db 12 f0       	push   $0xf012db0e
f011ffea:	ff 75 0c             	pushl  0xc(%ebp)
f011ffed:	ff 75 08             	pushl  0x8(%ebp)
f011fff0:	e8 57 02 00 00       	call   f012024c <printfmt>
f011fff5:	83 c4 10             	add    $0x10,%esp
			break;
f011fff8:	e9 42 02 00 00       	jmp    f012023f <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011fffd:	8b 45 14             	mov    0x14(%ebp),%eax
f0120000:	83 c0 04             	add    $0x4,%eax
f0120003:	89 45 14             	mov    %eax,0x14(%ebp)
f0120006:	8b 45 14             	mov    0x14(%ebp),%eax
f0120009:	83 e8 04             	sub    $0x4,%eax
f012000c:	8b 30                	mov    (%eax),%esi
f012000e:	85 f6                	test   %esi,%esi
f0120010:	75 05                	jne    f0120017 <vprintfmt+0x1a6>
				p = "(null)";
f0120012:	be 11 db 12 f0       	mov    $0xf012db11,%esi
			if (width > 0 && padc != '-')
f0120017:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f012001b:	7e 6d                	jle    f012008a <vprintfmt+0x219>
f012001d:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f0120021:	74 67                	je     f012008a <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f0120023:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0120026:	83 ec 08             	sub    $0x8,%esp
f0120029:	50                   	push   %eax
f012002a:	56                   	push   %esi
f012002b:	e8 26 05 00 00       	call   f0120556 <strnlen>
f0120030:	83 c4 10             	add    $0x10,%esp
f0120033:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f0120036:	eb 16                	jmp    f012004e <vprintfmt+0x1dd>
					putch(padc, putdat);
f0120038:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f012003c:	83 ec 08             	sub    $0x8,%esp
f012003f:	ff 75 0c             	pushl  0xc(%ebp)
f0120042:	50                   	push   %eax
f0120043:	8b 45 08             	mov    0x8(%ebp),%eax
f0120046:	ff d0                	call   *%eax
f0120048:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f012004b:	ff 4d e4             	decl   -0x1c(%ebp)
f012004e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0120052:	7f e4                	jg     f0120038 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0120054:	eb 34                	jmp    f012008a <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f0120056:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f012005a:	74 1c                	je     f0120078 <vprintfmt+0x207>
f012005c:	83 fb 1f             	cmp    $0x1f,%ebx
f012005f:	7e 05                	jle    f0120066 <vprintfmt+0x1f5>
f0120061:	83 fb 7e             	cmp    $0x7e,%ebx
f0120064:	7e 12                	jle    f0120078 <vprintfmt+0x207>
					putch('?', putdat);
f0120066:	83 ec 08             	sub    $0x8,%esp
f0120069:	ff 75 0c             	pushl  0xc(%ebp)
f012006c:	6a 3f                	push   $0x3f
f012006e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120071:	ff d0                	call   *%eax
f0120073:	83 c4 10             	add    $0x10,%esp
f0120076:	eb 0f                	jmp    f0120087 <vprintfmt+0x216>
				else
					putch(ch, putdat);
f0120078:	83 ec 08             	sub    $0x8,%esp
f012007b:	ff 75 0c             	pushl  0xc(%ebp)
f012007e:	53                   	push   %ebx
f012007f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120082:	ff d0                	call   *%eax
f0120084:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f0120087:	ff 4d e4             	decl   -0x1c(%ebp)
f012008a:	89 f0                	mov    %esi,%eax
f012008c:	8d 70 01             	lea    0x1(%eax),%esi
f012008f:	8a 00                	mov    (%eax),%al
f0120091:	0f be d8             	movsbl %al,%ebx
f0120094:	85 db                	test   %ebx,%ebx
f0120096:	74 24                	je     f01200bc <vprintfmt+0x24b>
f0120098:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f012009c:	78 b8                	js     f0120056 <vprintfmt+0x1e5>
f012009e:	ff 4d e0             	decl   -0x20(%ebp)
f01200a1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01200a5:	79 af                	jns    f0120056 <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f01200a7:	eb 13                	jmp    f01200bc <vprintfmt+0x24b>
				putch(' ', putdat);
f01200a9:	83 ec 08             	sub    $0x8,%esp
f01200ac:	ff 75 0c             	pushl  0xc(%ebp)
f01200af:	6a 20                	push   $0x20
f01200b1:	8b 45 08             	mov    0x8(%ebp),%eax
f01200b4:	ff d0                	call   *%eax
f01200b6:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f01200b9:	ff 4d e4             	decl   -0x1c(%ebp)
f01200bc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f01200c0:	7f e7                	jg     f01200a9 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f01200c2:	e9 78 01 00 00       	jmp    f012023f <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f01200c7:	83 ec 08             	sub    $0x8,%esp
f01200ca:	ff 75 e8             	pushl  -0x18(%ebp)
f01200cd:	8d 45 14             	lea    0x14(%ebp),%eax
f01200d0:	50                   	push   %eax
f01200d1:	e8 3c fd ff ff       	call   f011fe12 <getint>
f01200d6:	83 c4 10             	add    $0x10,%esp
f01200d9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01200dc:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f01200df:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01200e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01200e5:	85 d2                	test   %edx,%edx
f01200e7:	79 23                	jns    f012010c <vprintfmt+0x29b>
				putch('-', putdat);
f01200e9:	83 ec 08             	sub    $0x8,%esp
f01200ec:	ff 75 0c             	pushl  0xc(%ebp)
f01200ef:	6a 2d                	push   $0x2d
f01200f1:	8b 45 08             	mov    0x8(%ebp),%eax
f01200f4:	ff d0                	call   *%eax
f01200f6:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f01200f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01200fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01200ff:	f7 d8                	neg    %eax
f0120101:	83 d2 00             	adc    $0x0,%edx
f0120104:	f7 da                	neg    %edx
f0120106:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0120109:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f012010c:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0120113:	e9 bc 00 00 00       	jmp    f01201d4 <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f0120118:	83 ec 08             	sub    $0x8,%esp
f012011b:	ff 75 e8             	pushl  -0x18(%ebp)
f012011e:	8d 45 14             	lea    0x14(%ebp),%eax
f0120121:	50                   	push   %eax
f0120122:	e8 84 fc ff ff       	call   f011fdab <getuint>
f0120127:	83 c4 10             	add    $0x10,%esp
f012012a:	89 45 f0             	mov    %eax,-0x10(%ebp)
f012012d:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f0120130:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f0120137:	e9 98 00 00 00       	jmp    f01201d4 <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f012013c:	83 ec 08             	sub    $0x8,%esp
f012013f:	ff 75 0c             	pushl  0xc(%ebp)
f0120142:	6a 58                	push   $0x58
f0120144:	8b 45 08             	mov    0x8(%ebp),%eax
f0120147:	ff d0                	call   *%eax
f0120149:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f012014c:	83 ec 08             	sub    $0x8,%esp
f012014f:	ff 75 0c             	pushl  0xc(%ebp)
f0120152:	6a 58                	push   $0x58
f0120154:	8b 45 08             	mov    0x8(%ebp),%eax
f0120157:	ff d0                	call   *%eax
f0120159:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f012015c:	83 ec 08             	sub    $0x8,%esp
f012015f:	ff 75 0c             	pushl  0xc(%ebp)
f0120162:	6a 58                	push   $0x58
f0120164:	8b 45 08             	mov    0x8(%ebp),%eax
f0120167:	ff d0                	call   *%eax
f0120169:	83 c4 10             	add    $0x10,%esp
			break;
f012016c:	e9 ce 00 00 00       	jmp    f012023f <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f0120171:	83 ec 08             	sub    $0x8,%esp
f0120174:	ff 75 0c             	pushl  0xc(%ebp)
f0120177:	6a 30                	push   $0x30
f0120179:	8b 45 08             	mov    0x8(%ebp),%eax
f012017c:	ff d0                	call   *%eax
f012017e:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f0120181:	83 ec 08             	sub    $0x8,%esp
f0120184:	ff 75 0c             	pushl  0xc(%ebp)
f0120187:	6a 78                	push   $0x78
f0120189:	8b 45 08             	mov    0x8(%ebp),%eax
f012018c:	ff d0                	call   *%eax
f012018e:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f0120191:	8b 45 14             	mov    0x14(%ebp),%eax
f0120194:	83 c0 04             	add    $0x4,%eax
f0120197:	89 45 14             	mov    %eax,0x14(%ebp)
f012019a:	8b 45 14             	mov    0x14(%ebp),%eax
f012019d:	83 e8 04             	sub    $0x4,%eax
f01201a0:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f01201a2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01201a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f01201ac:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f01201b3:	eb 1f                	jmp    f01201d4 <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f01201b5:	83 ec 08             	sub    $0x8,%esp
f01201b8:	ff 75 e8             	pushl  -0x18(%ebp)
f01201bb:	8d 45 14             	lea    0x14(%ebp),%eax
f01201be:	50                   	push   %eax
f01201bf:	e8 e7 fb ff ff       	call   f011fdab <getuint>
f01201c4:	83 c4 10             	add    $0x10,%esp
f01201c7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01201ca:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f01201cd:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f01201d4:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f01201d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01201db:	83 ec 04             	sub    $0x4,%esp
f01201de:	52                   	push   %edx
f01201df:	ff 75 e4             	pushl  -0x1c(%ebp)
f01201e2:	50                   	push   %eax
f01201e3:	ff 75 f4             	pushl  -0xc(%ebp)
f01201e6:	ff 75 f0             	pushl  -0x10(%ebp)
f01201e9:	ff 75 0c             	pushl  0xc(%ebp)
f01201ec:	ff 75 08             	pushl  0x8(%ebp)
f01201ef:	e8 00 fb ff ff       	call   f011fcf4 <printnum>
f01201f4:	83 c4 20             	add    $0x20,%esp
			break;
f01201f7:	eb 46                	jmp    f012023f <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f01201f9:	83 ec 08             	sub    $0x8,%esp
f01201fc:	ff 75 0c             	pushl  0xc(%ebp)
f01201ff:	53                   	push   %ebx
f0120200:	8b 45 08             	mov    0x8(%ebp),%eax
f0120203:	ff d0                	call   *%eax
f0120205:	83 c4 10             	add    $0x10,%esp
			break;
f0120208:	eb 35                	jmp    f012023f <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f012020a:	c6 05 50 24 55 f0 00 	movb   $0x0,0xf0552450
			break;
f0120211:	eb 2c                	jmp    f012023f <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f0120213:	c6 05 50 24 55 f0 01 	movb   $0x1,0xf0552450
			break;
f012021a:	eb 23                	jmp    f012023f <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f012021c:	83 ec 08             	sub    $0x8,%esp
f012021f:	ff 75 0c             	pushl  0xc(%ebp)
f0120222:	6a 25                	push   $0x25
f0120224:	8b 45 08             	mov    0x8(%ebp),%eax
f0120227:	ff d0                	call   *%eax
f0120229:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f012022c:	ff 4d 10             	decl   0x10(%ebp)
f012022f:	eb 03                	jmp    f0120234 <vprintfmt+0x3c3>
f0120231:	ff 4d 10             	decl   0x10(%ebp)
f0120234:	8b 45 10             	mov    0x10(%ebp),%eax
f0120237:	48                   	dec    %eax
f0120238:	8a 00                	mov    (%eax),%al
f012023a:	3c 25                	cmp    $0x25,%al
f012023c:	75 f3                	jne    f0120231 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f012023e:	90                   	nop
		}
	}
f012023f:	e9 35 fc ff ff       	jmp    f011fe79 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f0120244:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f0120245:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120248:	5b                   	pop    %ebx
f0120249:	5e                   	pop    %esi
f012024a:	5d                   	pop    %ebp
f012024b:	c3                   	ret    

f012024c <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f012024c:	55                   	push   %ebp
f012024d:	89 e5                	mov    %esp,%ebp
f012024f:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f0120252:	8d 45 10             	lea    0x10(%ebp),%eax
f0120255:	83 c0 04             	add    $0x4,%eax
f0120258:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f012025b:	8b 45 10             	mov    0x10(%ebp),%eax
f012025e:	ff 75 f4             	pushl  -0xc(%ebp)
f0120261:	50                   	push   %eax
f0120262:	ff 75 0c             	pushl  0xc(%ebp)
f0120265:	ff 75 08             	pushl  0x8(%ebp)
f0120268:	e8 04 fc ff ff       	call   f011fe71 <vprintfmt>
f012026d:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f0120270:	90                   	nop
f0120271:	c9                   	leave  
f0120272:	c3                   	ret    

f0120273 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f0120273:	55                   	push   %ebp
f0120274:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f0120276:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120279:	8b 40 08             	mov    0x8(%eax),%eax
f012027c:	8d 50 01             	lea    0x1(%eax),%edx
f012027f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120282:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f0120285:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120288:	8b 10                	mov    (%eax),%edx
f012028a:	8b 45 0c             	mov    0xc(%ebp),%eax
f012028d:	8b 40 04             	mov    0x4(%eax),%eax
f0120290:	39 c2                	cmp    %eax,%edx
f0120292:	73 12                	jae    f01202a6 <sprintputch+0x33>
		*b->buf++ = ch;
f0120294:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120297:	8b 00                	mov    (%eax),%eax
f0120299:	8d 48 01             	lea    0x1(%eax),%ecx
f012029c:	8b 55 0c             	mov    0xc(%ebp),%edx
f012029f:	89 0a                	mov    %ecx,(%edx)
f01202a1:	8b 55 08             	mov    0x8(%ebp),%edx
f01202a4:	88 10                	mov    %dl,(%eax)
}
f01202a6:	90                   	nop
f01202a7:	5d                   	pop    %ebp
f01202a8:	c3                   	ret    

f01202a9 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f01202a9:	55                   	push   %ebp
f01202aa:	89 e5                	mov    %esp,%ebp
f01202ac:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f01202af:	8b 45 08             	mov    0x8(%ebp),%eax
f01202b2:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01202b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01202b8:	8d 50 ff             	lea    -0x1(%eax),%edx
f01202bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01202be:	01 d0                	add    %edx,%eax
f01202c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01202c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f01202ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01202ce:	74 06                	je     f01202d6 <vsnprintf+0x2d>
f01202d0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01202d4:	7f 07                	jg     f01202dd <vsnprintf+0x34>
		return -E_INVAL;
f01202d6:	b8 03 00 00 00       	mov    $0x3,%eax
f01202db:	eb 20                	jmp    f01202fd <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f01202dd:	ff 75 14             	pushl  0x14(%ebp)
f01202e0:	ff 75 10             	pushl  0x10(%ebp)
f01202e3:	8d 45 ec             	lea    -0x14(%ebp),%eax
f01202e6:	50                   	push   %eax
f01202e7:	68 73 02 12 f0       	push   $0xf0120273
f01202ec:	e8 80 fb ff ff       	call   f011fe71 <vprintfmt>
f01202f1:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f01202f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01202f7:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f01202fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01202fd:	c9                   	leave  
f01202fe:	c3                   	ret    

f01202ff <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f01202ff:	55                   	push   %ebp
f0120300:	89 e5                	mov    %esp,%ebp
f0120302:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f0120305:	8d 45 10             	lea    0x10(%ebp),%eax
f0120308:	83 c0 04             	add    $0x4,%eax
f012030b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f012030e:	8b 45 10             	mov    0x10(%ebp),%eax
f0120311:	ff 75 f4             	pushl  -0xc(%ebp)
f0120314:	50                   	push   %eax
f0120315:	ff 75 0c             	pushl  0xc(%ebp)
f0120318:	ff 75 08             	pushl  0x8(%ebp)
f012031b:	e8 89 ff ff ff       	call   f01202a9 <vsnprintf>
f0120320:	83 c4 10             	add    $0x10,%esp
f0120323:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f0120326:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0120329:	c9                   	leave  
f012032a:	c3                   	ret    

f012032b <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f012032b:	55                   	push   %ebp
f012032c:	89 e5                	mov    %esp,%ebp
f012032e:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f0120331:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120335:	74 13                	je     f012034a <readline+0x1f>
		cprintf("%s", prompt);
f0120337:	83 ec 08             	sub    $0x8,%esp
f012033a:	ff 75 08             	pushl  0x8(%ebp)
f012033d:	68 88 dc 12 f0       	push   $0xf012dc88
f0120342:	e8 25 0c fe ff       	call   f0100f6c <cprintf>
f0120347:	83 c4 10             	add    $0x10,%esp

	i = 0;
f012034a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f0120351:	83 ec 0c             	sub    $0xc,%esp
f0120354:	6a 00                	push   $0x0
f0120356:	e8 1e 0b fe ff       	call   f0100e79 <iscons>
f012035b:	83 c4 10             	add    $0x10,%esp
f012035e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f0120361:	e8 fa 0a fe ff       	call   f0100e60 <getchar>
f0120366:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f0120369:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f012036d:	79 22                	jns    f0120391 <readline+0x66>
			if (c != -E_EOF)
f012036f:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0120373:	0f 84 ad 00 00 00    	je     f0120426 <readline+0xfb>
				cprintf("read error: %e\n", c);
f0120379:	83 ec 08             	sub    $0x8,%esp
f012037c:	ff 75 ec             	pushl  -0x14(%ebp)
f012037f:	68 8b dc 12 f0       	push   $0xf012dc8b
f0120384:	e8 e3 0b fe ff       	call   f0100f6c <cprintf>
f0120389:	83 c4 10             	add    $0x10,%esp
			break;
f012038c:	e9 95 00 00 00       	jmp    f0120426 <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f0120391:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0120395:	7e 34                	jle    f01203cb <readline+0xa0>
f0120397:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f012039e:	7f 2b                	jg     f01203cb <readline+0xa0>
			if (echoing)
f01203a0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01203a4:	74 0e                	je     f01203b4 <readline+0x89>
				cputchar(c);
f01203a6:	83 ec 0c             	sub    $0xc,%esp
f01203a9:	ff 75 ec             	pushl  -0x14(%ebp)
f01203ac:	e8 98 0a fe ff       	call   f0100e49 <cputchar>
f01203b1:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f01203b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01203b7:	8d 50 01             	lea    0x1(%eax),%edx
f01203ba:	89 55 f4             	mov    %edx,-0xc(%ebp)
f01203bd:	89 c2                	mov    %eax,%edx
f01203bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01203c2:	01 d0                	add    %edx,%eax
f01203c4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01203c7:	88 10                	mov    %dl,(%eax)
f01203c9:	eb 56                	jmp    f0120421 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f01203cb:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f01203cf:	75 1f                	jne    f01203f0 <readline+0xc5>
f01203d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01203d5:	7e 19                	jle    f01203f0 <readline+0xc5>
			if (echoing)
f01203d7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01203db:	74 0e                	je     f01203eb <readline+0xc0>
				cputchar(c);
f01203dd:	83 ec 0c             	sub    $0xc,%esp
f01203e0:	ff 75 ec             	pushl  -0x14(%ebp)
f01203e3:	e8 61 0a fe ff       	call   f0100e49 <cputchar>
f01203e8:	83 c4 10             	add    $0x10,%esp

			i--;
f01203eb:	ff 4d f4             	decl   -0xc(%ebp)
f01203ee:	eb 31                	jmp    f0120421 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f01203f0:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f01203f4:	74 0a                	je     f0120400 <readline+0xd5>
f01203f6:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f01203fa:	0f 85 61 ff ff ff    	jne    f0120361 <readline+0x36>
			if (echoing)
f0120400:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120404:	74 0e                	je     f0120414 <readline+0xe9>
				cputchar(c);
f0120406:	83 ec 0c             	sub    $0xc,%esp
f0120409:	ff 75 ec             	pushl  -0x14(%ebp)
f012040c:	e8 38 0a fe ff       	call   f0100e49 <cputchar>
f0120411:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f0120414:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120417:	8b 45 0c             	mov    0xc(%ebp),%eax
f012041a:	01 d0                	add    %edx,%eax
f012041c:	c6 00 00             	movb   $0x0,(%eax)
			break;
f012041f:	eb 06                	jmp    f0120427 <readline+0xfc>
		}
	}
f0120421:	e9 3b ff ff ff       	jmp    f0120361 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f0120426:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f0120427:	90                   	nop
f0120428:	c9                   	leave  
f0120429:	c3                   	ret    

f012042a <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f012042a:	55                   	push   %ebp
f012042b:	89 e5                	mov    %esp,%ebp
f012042d:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f0120430:	e8 5c d1 fe ff       	call   f010d591 <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f0120435:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120439:	74 13                	je     f012044e <atomic_readline+0x24>
			cprintf("%s", prompt);
f012043b:	83 ec 08             	sub    $0x8,%esp
f012043e:	ff 75 08             	pushl  0x8(%ebp)
f0120441:	68 88 dc 12 f0       	push   $0xf012dc88
f0120446:	e8 21 0b fe ff       	call   f0100f6c <cprintf>
f012044b:	83 c4 10             	add    $0x10,%esp

		i = 0;
f012044e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f0120455:	83 ec 0c             	sub    $0xc,%esp
f0120458:	6a 00                	push   $0x0
f012045a:	e8 1a 0a fe ff       	call   f0100e79 <iscons>
f012045f:	83 c4 10             	add    $0x10,%esp
f0120462:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f0120465:	e8 f6 09 fe ff       	call   f0100e60 <getchar>
f012046a:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f012046d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0120471:	79 22                	jns    f0120495 <atomic_readline+0x6b>
				if (c != -E_EOF)
f0120473:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f0120477:	0f 84 ad 00 00 00    	je     f012052a <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f012047d:	83 ec 08             	sub    $0x8,%esp
f0120480:	ff 75 ec             	pushl  -0x14(%ebp)
f0120483:	68 8b dc 12 f0       	push   $0xf012dc8b
f0120488:	e8 df 0a fe ff       	call   f0100f6c <cprintf>
f012048d:	83 c4 10             	add    $0x10,%esp
				break;
f0120490:	e9 95 00 00 00       	jmp    f012052a <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f0120495:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f0120499:	7e 34                	jle    f01204cf <atomic_readline+0xa5>
f012049b:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f01204a2:	7f 2b                	jg     f01204cf <atomic_readline+0xa5>
				if (echoing)
f01204a4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01204a8:	74 0e                	je     f01204b8 <atomic_readline+0x8e>
					cputchar(c);
f01204aa:	83 ec 0c             	sub    $0xc,%esp
f01204ad:	ff 75 ec             	pushl  -0x14(%ebp)
f01204b0:	e8 94 09 fe ff       	call   f0100e49 <cputchar>
f01204b5:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f01204b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01204bb:	8d 50 01             	lea    0x1(%eax),%edx
f01204be:	89 55 f4             	mov    %edx,-0xc(%ebp)
f01204c1:	89 c2                	mov    %eax,%edx
f01204c3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01204c6:	01 d0                	add    %edx,%eax
f01204c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01204cb:	88 10                	mov    %dl,(%eax)
f01204cd:	eb 56                	jmp    f0120525 <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f01204cf:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f01204d3:	75 1f                	jne    f01204f4 <atomic_readline+0xca>
f01204d5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01204d9:	7e 19                	jle    f01204f4 <atomic_readline+0xca>
				if (echoing)
f01204db:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01204df:	74 0e                	je     f01204ef <atomic_readline+0xc5>
					cputchar(c);
f01204e1:	83 ec 0c             	sub    $0xc,%esp
f01204e4:	ff 75 ec             	pushl  -0x14(%ebp)
f01204e7:	e8 5d 09 fe ff       	call   f0100e49 <cputchar>
f01204ec:	83 c4 10             	add    $0x10,%esp
				i--;
f01204ef:	ff 4d f4             	decl   -0xc(%ebp)
f01204f2:	eb 31                	jmp    f0120525 <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f01204f4:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f01204f8:	74 0a                	je     f0120504 <atomic_readline+0xda>
f01204fa:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f01204fe:	0f 85 61 ff ff ff    	jne    f0120465 <atomic_readline+0x3b>
				if (echoing)
f0120504:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0120508:	74 0e                	je     f0120518 <atomic_readline+0xee>
					cputchar(c);
f012050a:	83 ec 0c             	sub    $0xc,%esp
f012050d:	ff 75 ec             	pushl  -0x14(%ebp)
f0120510:	e8 34 09 fe ff       	call   f0100e49 <cputchar>
f0120515:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f0120518:	8b 55 f4             	mov    -0xc(%ebp),%edx
f012051b:	8b 45 0c             	mov    0xc(%ebp),%eax
f012051e:	01 d0                	add    %edx,%eax
f0120520:	c6 00 00             	movb   $0x0,(%eax)
				break;
f0120523:	eb 06                	jmp    f012052b <atomic_readline+0x101>
			}
		}
f0120525:	e9 3b ff ff ff       	jmp    f0120465 <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f012052a:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f012052b:	e8 6f d0 fe ff       	call   f010d59f <sys_unlock_cons>
}
f0120530:	90                   	nop
f0120531:	c9                   	leave  
f0120532:	c3                   	ret    

f0120533 <strlen>:
#include <inc/string.h>
#include <inc/assert.h>

int
strlen(const char *s)
{
f0120533:	55                   	push   %ebp
f0120534:	89 e5                	mov    %esp,%ebp
f0120536:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f0120539:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120540:	eb 06                	jmp    f0120548 <strlen+0x15>
		n++;
f0120542:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f0120545:	ff 45 08             	incl   0x8(%ebp)
f0120548:	8b 45 08             	mov    0x8(%ebp),%eax
f012054b:	8a 00                	mov    (%eax),%al
f012054d:	84 c0                	test   %al,%al
f012054f:	75 f1                	jne    f0120542 <strlen+0xf>
		n++;
	return n;
f0120551:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120554:	c9                   	leave  
f0120555:	c3                   	ret    

f0120556 <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f0120556:	55                   	push   %ebp
f0120557:	89 e5                	mov    %esp,%ebp
f0120559:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f012055c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120563:	eb 09                	jmp    f012056e <strnlen+0x18>
		n++;
f0120565:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f0120568:	ff 45 08             	incl   0x8(%ebp)
f012056b:	ff 4d 0c             	decl   0xc(%ebp)
f012056e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0120572:	74 09                	je     f012057d <strnlen+0x27>
f0120574:	8b 45 08             	mov    0x8(%ebp),%eax
f0120577:	8a 00                	mov    (%eax),%al
f0120579:	84 c0                	test   %al,%al
f012057b:	75 e8                	jne    f0120565 <strnlen+0xf>
		n++;
	return n;
f012057d:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0120580:	c9                   	leave  
f0120581:	c3                   	ret    

f0120582 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f0120582:	55                   	push   %ebp
f0120583:	89 e5                	mov    %esp,%ebp
f0120585:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f0120588:	8b 45 08             	mov    0x8(%ebp),%eax
f012058b:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f012058e:	90                   	nop
f012058f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120592:	8d 50 01             	lea    0x1(%eax),%edx
f0120595:	89 55 08             	mov    %edx,0x8(%ebp)
f0120598:	8b 55 0c             	mov    0xc(%ebp),%edx
f012059b:	8d 4a 01             	lea    0x1(%edx),%ecx
f012059e:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f01205a1:	8a 12                	mov    (%edx),%dl
f01205a3:	88 10                	mov    %dl,(%eax)
f01205a5:	8a 00                	mov    (%eax),%al
f01205a7:	84 c0                	test   %al,%al
f01205a9:	75 e4                	jne    f012058f <strcpy+0xd>
		/* do nothing */;
	return ret;
f01205ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f01205ae:	c9                   	leave  
f01205af:	c3                   	ret    

f01205b0 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f01205b0:	55                   	push   %ebp
f01205b1:	89 e5                	mov    %esp,%ebp
f01205b3:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f01205b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01205b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f01205bc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f01205c3:	eb 1f                	jmp    f01205e4 <strncpy+0x34>
		*dst++ = *src;
f01205c5:	8b 45 08             	mov    0x8(%ebp),%eax
f01205c8:	8d 50 01             	lea    0x1(%eax),%edx
f01205cb:	89 55 08             	mov    %edx,0x8(%ebp)
f01205ce:	8b 55 0c             	mov    0xc(%ebp),%edx
f01205d1:	8a 12                	mov    (%edx),%dl
f01205d3:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f01205d5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01205d8:	8a 00                	mov    (%eax),%al
f01205da:	84 c0                	test   %al,%al
f01205dc:	74 03                	je     f01205e1 <strncpy+0x31>
			src++;
f01205de:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f01205e1:	ff 45 fc             	incl   -0x4(%ebp)
f01205e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01205e7:	3b 45 10             	cmp    0x10(%ebp),%eax
f01205ea:	72 d9                	jb     f01205c5 <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f01205ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01205ef:	c9                   	leave  
f01205f0:	c3                   	ret    

f01205f1 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f01205f1:	55                   	push   %ebp
f01205f2:	89 e5                	mov    %esp,%ebp
f01205f4:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f01205f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01205fa:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f01205fd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120601:	74 30                	je     f0120633 <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f0120603:	eb 16                	jmp    f012061b <strlcpy+0x2a>
			*dst++ = *src++;
f0120605:	8b 45 08             	mov    0x8(%ebp),%eax
f0120608:	8d 50 01             	lea    0x1(%eax),%edx
f012060b:	89 55 08             	mov    %edx,0x8(%ebp)
f012060e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120611:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120614:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f0120617:	8a 12                	mov    (%edx),%dl
f0120619:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f012061b:	ff 4d 10             	decl   0x10(%ebp)
f012061e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120622:	74 09                	je     f012062d <strlcpy+0x3c>
f0120624:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120627:	8a 00                	mov    (%eax),%al
f0120629:	84 c0                	test   %al,%al
f012062b:	75 d8                	jne    f0120605 <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f012062d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120630:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f0120633:	8b 55 08             	mov    0x8(%ebp),%edx
f0120636:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120639:	29 c2                	sub    %eax,%edx
f012063b:	89 d0                	mov    %edx,%eax
}
f012063d:	c9                   	leave  
f012063e:	c3                   	ret    

f012063f <strcmp>:

int
strcmp(const char *p, const char *q)
{
f012063f:	55                   	push   %ebp
f0120640:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f0120642:	eb 06                	jmp    f012064a <strcmp+0xb>
		p++, q++;
f0120644:	ff 45 08             	incl   0x8(%ebp)
f0120647:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f012064a:	8b 45 08             	mov    0x8(%ebp),%eax
f012064d:	8a 00                	mov    (%eax),%al
f012064f:	84 c0                	test   %al,%al
f0120651:	74 0e                	je     f0120661 <strcmp+0x22>
f0120653:	8b 45 08             	mov    0x8(%ebp),%eax
f0120656:	8a 10                	mov    (%eax),%dl
f0120658:	8b 45 0c             	mov    0xc(%ebp),%eax
f012065b:	8a 00                	mov    (%eax),%al
f012065d:	38 c2                	cmp    %al,%dl
f012065f:	74 e3                	je     f0120644 <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f0120661:	8b 45 08             	mov    0x8(%ebp),%eax
f0120664:	8a 00                	mov    (%eax),%al
f0120666:	0f b6 d0             	movzbl %al,%edx
f0120669:	8b 45 0c             	mov    0xc(%ebp),%eax
f012066c:	8a 00                	mov    (%eax),%al
f012066e:	0f b6 c0             	movzbl %al,%eax
f0120671:	29 c2                	sub    %eax,%edx
f0120673:	89 d0                	mov    %edx,%eax
}
f0120675:	5d                   	pop    %ebp
f0120676:	c3                   	ret    

f0120677 <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f0120677:	55                   	push   %ebp
f0120678:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f012067a:	eb 09                	jmp    f0120685 <strncmp+0xe>
		n--, p++, q++;
f012067c:	ff 4d 10             	decl   0x10(%ebp)
f012067f:	ff 45 08             	incl   0x8(%ebp)
f0120682:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f0120685:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120689:	74 17                	je     f01206a2 <strncmp+0x2b>
f012068b:	8b 45 08             	mov    0x8(%ebp),%eax
f012068e:	8a 00                	mov    (%eax),%al
f0120690:	84 c0                	test   %al,%al
f0120692:	74 0e                	je     f01206a2 <strncmp+0x2b>
f0120694:	8b 45 08             	mov    0x8(%ebp),%eax
f0120697:	8a 10                	mov    (%eax),%dl
f0120699:	8b 45 0c             	mov    0xc(%ebp),%eax
f012069c:	8a 00                	mov    (%eax),%al
f012069e:	38 c2                	cmp    %al,%dl
f01206a0:	74 da                	je     f012067c <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f01206a2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01206a6:	75 07                	jne    f01206af <strncmp+0x38>
		return 0;
f01206a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01206ad:	eb 14                	jmp    f01206c3 <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f01206af:	8b 45 08             	mov    0x8(%ebp),%eax
f01206b2:	8a 00                	mov    (%eax),%al
f01206b4:	0f b6 d0             	movzbl %al,%edx
f01206b7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ba:	8a 00                	mov    (%eax),%al
f01206bc:	0f b6 c0             	movzbl %al,%eax
f01206bf:	29 c2                	sub    %eax,%edx
f01206c1:	89 d0                	mov    %edx,%eax
}
f01206c3:	5d                   	pop    %ebp
f01206c4:	c3                   	ret    

f01206c5 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f01206c5:	55                   	push   %ebp
f01206c6:	89 e5                	mov    %esp,%ebp
f01206c8:	83 ec 04             	sub    $0x4,%esp
f01206cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206ce:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f01206d1:	eb 12                	jmp    f01206e5 <strchr+0x20>
		if (*s == c)
f01206d3:	8b 45 08             	mov    0x8(%ebp),%eax
f01206d6:	8a 00                	mov    (%eax),%al
f01206d8:	3a 45 fc             	cmp    -0x4(%ebp),%al
f01206db:	75 05                	jne    f01206e2 <strchr+0x1d>
			return (char *) s;
f01206dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01206e0:	eb 11                	jmp    f01206f3 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f01206e2:	ff 45 08             	incl   0x8(%ebp)
f01206e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01206e8:	8a 00                	mov    (%eax),%al
f01206ea:	84 c0                	test   %al,%al
f01206ec:	75 e5                	jne    f01206d3 <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f01206ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01206f3:	c9                   	leave  
f01206f4:	c3                   	ret    

f01206f5 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f01206f5:	55                   	push   %ebp
f01206f6:	89 e5                	mov    %esp,%ebp
f01206f8:	83 ec 04             	sub    $0x4,%esp
f01206fb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01206fe:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f0120701:	eb 0d                	jmp    f0120710 <strfind+0x1b>
		if (*s == c)
f0120703:	8b 45 08             	mov    0x8(%ebp),%eax
f0120706:	8a 00                	mov    (%eax),%al
f0120708:	3a 45 fc             	cmp    -0x4(%ebp),%al
f012070b:	74 0e                	je     f012071b <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f012070d:	ff 45 08             	incl   0x8(%ebp)
f0120710:	8b 45 08             	mov    0x8(%ebp),%eax
f0120713:	8a 00                	mov    (%eax),%al
f0120715:	84 c0                	test   %al,%al
f0120717:	75 ea                	jne    f0120703 <strfind+0xe>
f0120719:	eb 01                	jmp    f012071c <strfind+0x27>
		if (*s == c)
			break;
f012071b:	90                   	nop
	return (char *) s;
f012071c:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012071f:	c9                   	leave  
f0120720:	c3                   	ret    

f0120721 <memset>:


void *
memset(void *v, int c, uint32 n)
{
f0120721:	55                   	push   %ebp
f0120722:	89 e5                	mov    %esp,%ebp
f0120724:	83 ec 10             	sub    $0x10,%esp
	char *p;
	int m;

	p = v;
f0120727:	8b 45 08             	mov    0x8(%ebp),%eax
f012072a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	m = n;
f012072d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120730:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (--m >= 0)
f0120733:	eb 0e                	jmp    f0120743 <memset+0x22>
		*p++ = c;
f0120735:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120738:	8d 50 01             	lea    0x1(%eax),%edx
f012073b:	89 55 fc             	mov    %edx,-0x4(%ebp)
f012073e:	8b 55 0c             	mov    0xc(%ebp),%edx
f0120741:	88 10                	mov    %dl,(%eax)
	char *p;
	int m;

	p = v;
	m = n;
	while (--m >= 0)
f0120743:	ff 4d f8             	decl   -0x8(%ebp)
f0120746:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
f012074a:	79 e9                	jns    f0120735 <memset+0x14>
		*p++ = c;

	return v;
f012074c:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012074f:	c9                   	leave  
f0120750:	c3                   	ret    

f0120751 <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f0120751:	55                   	push   %ebp
f0120752:	89 e5                	mov    %esp,%ebp
f0120754:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0120757:	8b 45 0c             	mov    0xc(%ebp),%eax
f012075a:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f012075d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120760:	89 45 f8             	mov    %eax,-0x8(%ebp)
	while (n-- > 0)
f0120763:	eb 16                	jmp    f012077b <memcpy+0x2a>
		*d++ = *s++;
f0120765:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120768:	8d 50 01             	lea    0x1(%eax),%edx
f012076b:	89 55 f8             	mov    %edx,-0x8(%ebp)
f012076e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120771:	8d 4a 01             	lea    0x1(%edx),%ecx
f0120774:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f0120777:	8a 12                	mov    (%edx),%dl
f0120779:	88 10                	mov    %dl,(%eax)
	const char *s;
	char *d;

	s = src;
	d = dst;
	while (n-- > 0)
f012077b:	8b 45 10             	mov    0x10(%ebp),%eax
f012077e:	8d 50 ff             	lea    -0x1(%eax),%edx
f0120781:	89 55 10             	mov    %edx,0x10(%ebp)
f0120784:	85 c0                	test   %eax,%eax
f0120786:	75 dd                	jne    f0120765 <memcpy+0x14>
		*d++ = *s++;

	return dst;
f0120788:	8b 45 08             	mov    0x8(%ebp),%eax
}
f012078b:	c9                   	leave  
f012078c:	c3                   	ret    

f012078d <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f012078d:	55                   	push   %ebp
f012078e:	89 e5                	mov    %esp,%ebp
f0120790:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f0120793:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120796:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f0120799:	8b 45 08             	mov    0x8(%ebp),%eax
f012079c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f012079f:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01207a2:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01207a5:	73 50                	jae    f01207f7 <memmove+0x6a>
f01207a7:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01207aa:	8b 45 10             	mov    0x10(%ebp),%eax
f01207ad:	01 d0                	add    %edx,%eax
f01207af:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f01207b2:	76 43                	jbe    f01207f7 <memmove+0x6a>
		s += n;
f01207b4:	8b 45 10             	mov    0x10(%ebp),%eax
f01207b7:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f01207ba:	8b 45 10             	mov    0x10(%ebp),%eax
f01207bd:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f01207c0:	eb 10                	jmp    f01207d2 <memmove+0x45>
			*--d = *--s;
f01207c2:	ff 4d f8             	decl   -0x8(%ebp)
f01207c5:	ff 4d fc             	decl   -0x4(%ebp)
f01207c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01207cb:	8a 10                	mov    (%eax),%dl
f01207cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01207d0:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f01207d2:	8b 45 10             	mov    0x10(%ebp),%eax
f01207d5:	8d 50 ff             	lea    -0x1(%eax),%edx
f01207d8:	89 55 10             	mov    %edx,0x10(%ebp)
f01207db:	85 c0                	test   %eax,%eax
f01207dd:	75 e3                	jne    f01207c2 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f01207df:	eb 23                	jmp    f0120804 <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f01207e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01207e4:	8d 50 01             	lea    0x1(%eax),%edx
f01207e7:	89 55 f8             	mov    %edx,-0x8(%ebp)
f01207ea:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01207ed:	8d 4a 01             	lea    0x1(%edx),%ecx
f01207f0:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f01207f3:	8a 12                	mov    (%edx),%dl
f01207f5:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f01207f7:	8b 45 10             	mov    0x10(%ebp),%eax
f01207fa:	8d 50 ff             	lea    -0x1(%eax),%edx
f01207fd:	89 55 10             	mov    %edx,0x10(%ebp)
f0120800:	85 c0                	test   %eax,%eax
f0120802:	75 dd                	jne    f01207e1 <memmove+0x54>
			*d++ = *s++;

	return dst;
f0120804:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120807:	c9                   	leave  
f0120808:	c3                   	ret    

f0120809 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f0120809:	55                   	push   %ebp
f012080a:	89 e5                	mov    %esp,%ebp
f012080c:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f012080f:	8b 45 08             	mov    0x8(%ebp),%eax
f0120812:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f0120815:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120818:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f012081b:	eb 2a                	jmp    f0120847 <memcmp+0x3e>
		if (*s1 != *s2)
f012081d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120820:	8a 10                	mov    (%eax),%dl
f0120822:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120825:	8a 00                	mov    (%eax),%al
f0120827:	38 c2                	cmp    %al,%dl
f0120829:	74 16                	je     f0120841 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f012082b:	8b 45 fc             	mov    -0x4(%ebp),%eax
f012082e:	8a 00                	mov    (%eax),%al
f0120830:	0f b6 d0             	movzbl %al,%edx
f0120833:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120836:	8a 00                	mov    (%eax),%al
f0120838:	0f b6 c0             	movzbl %al,%eax
f012083b:	29 c2                	sub    %eax,%edx
f012083d:	89 d0                	mov    %edx,%eax
f012083f:	eb 18                	jmp    f0120859 <memcmp+0x50>
		s1++, s2++;
f0120841:	ff 45 fc             	incl   -0x4(%ebp)
f0120844:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f0120847:	8b 45 10             	mov    0x10(%ebp),%eax
f012084a:	8d 50 ff             	lea    -0x1(%eax),%edx
f012084d:	89 55 10             	mov    %edx,0x10(%ebp)
f0120850:	85 c0                	test   %eax,%eax
f0120852:	75 c9                	jne    f012081d <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f0120854:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120859:	c9                   	leave  
f012085a:	c3                   	ret    

f012085b <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f012085b:	55                   	push   %ebp
f012085c:	89 e5                	mov    %esp,%ebp
f012085e:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f0120861:	8b 55 08             	mov    0x8(%ebp),%edx
f0120864:	8b 45 10             	mov    0x10(%ebp),%eax
f0120867:	01 d0                	add    %edx,%eax
f0120869:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f012086c:	eb 15                	jmp    f0120883 <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f012086e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120871:	8a 00                	mov    (%eax),%al
f0120873:	0f b6 d0             	movzbl %al,%edx
f0120876:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120879:	0f b6 c0             	movzbl %al,%eax
f012087c:	39 c2                	cmp    %eax,%edx
f012087e:	74 0d                	je     f012088d <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f0120880:	ff 45 08             	incl   0x8(%ebp)
f0120883:	8b 45 08             	mov    0x8(%ebp),%eax
f0120886:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f0120889:	72 e3                	jb     f012086e <memfind+0x13>
f012088b:	eb 01                	jmp    f012088e <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f012088d:	90                   	nop
	return (void *) s;
f012088e:	8b 45 08             	mov    0x8(%ebp),%eax
}
f0120891:	c9                   	leave  
f0120892:	c3                   	ret    

f0120893 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f0120893:	55                   	push   %ebp
f0120894:	89 e5                	mov    %esp,%ebp
f0120896:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f0120899:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f01208a0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01208a7:	eb 03                	jmp    f01208ac <strtol+0x19>
		s++;
f01208a9:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f01208ac:	8b 45 08             	mov    0x8(%ebp),%eax
f01208af:	8a 00                	mov    (%eax),%al
f01208b1:	3c 20                	cmp    $0x20,%al
f01208b3:	74 f4                	je     f01208a9 <strtol+0x16>
f01208b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01208b8:	8a 00                	mov    (%eax),%al
f01208ba:	3c 09                	cmp    $0x9,%al
f01208bc:	74 eb                	je     f01208a9 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f01208be:	8b 45 08             	mov    0x8(%ebp),%eax
f01208c1:	8a 00                	mov    (%eax),%al
f01208c3:	3c 2b                	cmp    $0x2b,%al
f01208c5:	75 05                	jne    f01208cc <strtol+0x39>
		s++;
f01208c7:	ff 45 08             	incl   0x8(%ebp)
f01208ca:	eb 13                	jmp    f01208df <strtol+0x4c>
	else if (*s == '-')
f01208cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01208cf:	8a 00                	mov    (%eax),%al
f01208d1:	3c 2d                	cmp    $0x2d,%al
f01208d3:	75 0a                	jne    f01208df <strtol+0x4c>
		s++, neg = 1;
f01208d5:	ff 45 08             	incl   0x8(%ebp)
f01208d8:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f01208df:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01208e3:	74 06                	je     f01208eb <strtol+0x58>
f01208e5:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f01208e9:	75 20                	jne    f012090b <strtol+0x78>
f01208eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01208ee:	8a 00                	mov    (%eax),%al
f01208f0:	3c 30                	cmp    $0x30,%al
f01208f2:	75 17                	jne    f012090b <strtol+0x78>
f01208f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01208f7:	40                   	inc    %eax
f01208f8:	8a 00                	mov    (%eax),%al
f01208fa:	3c 78                	cmp    $0x78,%al
f01208fc:	75 0d                	jne    f012090b <strtol+0x78>
		s += 2, base = 16;
f01208fe:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f0120902:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f0120909:	eb 28                	jmp    f0120933 <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f012090b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012090f:	75 15                	jne    f0120926 <strtol+0x93>
f0120911:	8b 45 08             	mov    0x8(%ebp),%eax
f0120914:	8a 00                	mov    (%eax),%al
f0120916:	3c 30                	cmp    $0x30,%al
f0120918:	75 0c                	jne    f0120926 <strtol+0x93>
		s++, base = 8;
f012091a:	ff 45 08             	incl   0x8(%ebp)
f012091d:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f0120924:	eb 0d                	jmp    f0120933 <strtol+0xa0>
	else if (base == 0)
f0120926:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f012092a:	75 07                	jne    f0120933 <strtol+0xa0>
		base = 10;
f012092c:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f0120933:	8b 45 08             	mov    0x8(%ebp),%eax
f0120936:	8a 00                	mov    (%eax),%al
f0120938:	3c 2f                	cmp    $0x2f,%al
f012093a:	7e 19                	jle    f0120955 <strtol+0xc2>
f012093c:	8b 45 08             	mov    0x8(%ebp),%eax
f012093f:	8a 00                	mov    (%eax),%al
f0120941:	3c 39                	cmp    $0x39,%al
f0120943:	7f 10                	jg     f0120955 <strtol+0xc2>
			dig = *s - '0';
f0120945:	8b 45 08             	mov    0x8(%ebp),%eax
f0120948:	8a 00                	mov    (%eax),%al
f012094a:	0f be c0             	movsbl %al,%eax
f012094d:	83 e8 30             	sub    $0x30,%eax
f0120950:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120953:	eb 42                	jmp    f0120997 <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f0120955:	8b 45 08             	mov    0x8(%ebp),%eax
f0120958:	8a 00                	mov    (%eax),%al
f012095a:	3c 60                	cmp    $0x60,%al
f012095c:	7e 19                	jle    f0120977 <strtol+0xe4>
f012095e:	8b 45 08             	mov    0x8(%ebp),%eax
f0120961:	8a 00                	mov    (%eax),%al
f0120963:	3c 7a                	cmp    $0x7a,%al
f0120965:	7f 10                	jg     f0120977 <strtol+0xe4>
			dig = *s - 'a' + 10;
f0120967:	8b 45 08             	mov    0x8(%ebp),%eax
f012096a:	8a 00                	mov    (%eax),%al
f012096c:	0f be c0             	movsbl %al,%eax
f012096f:	83 e8 57             	sub    $0x57,%eax
f0120972:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120975:	eb 20                	jmp    f0120997 <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f0120977:	8b 45 08             	mov    0x8(%ebp),%eax
f012097a:	8a 00                	mov    (%eax),%al
f012097c:	3c 40                	cmp    $0x40,%al
f012097e:	7e 39                	jle    f01209b9 <strtol+0x126>
f0120980:	8b 45 08             	mov    0x8(%ebp),%eax
f0120983:	8a 00                	mov    (%eax),%al
f0120985:	3c 5a                	cmp    $0x5a,%al
f0120987:	7f 30                	jg     f01209b9 <strtol+0x126>
			dig = *s - 'A' + 10;
f0120989:	8b 45 08             	mov    0x8(%ebp),%eax
f012098c:	8a 00                	mov    (%eax),%al
f012098e:	0f be c0             	movsbl %al,%eax
f0120991:	83 e8 37             	sub    $0x37,%eax
f0120994:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f0120997:	8b 45 f4             	mov    -0xc(%ebp),%eax
f012099a:	3b 45 10             	cmp    0x10(%ebp),%eax
f012099d:	7d 19                	jge    f01209b8 <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f012099f:	ff 45 08             	incl   0x8(%ebp)
f01209a2:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01209a5:	0f af 45 10          	imul   0x10(%ebp),%eax
f01209a9:	89 c2                	mov    %eax,%edx
f01209ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01209ae:	01 d0                	add    %edx,%eax
f01209b0:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f01209b3:	e9 7b ff ff ff       	jmp    f0120933 <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f01209b8:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f01209b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f01209bd:	74 08                	je     f01209c7 <strtol+0x134>
		*endptr = (char *) s;
f01209bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209c2:	8b 55 08             	mov    0x8(%ebp),%edx
f01209c5:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f01209c7:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f01209cb:	74 07                	je     f01209d4 <strtol+0x141>
f01209cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01209d0:	f7 d8                	neg    %eax
f01209d2:	eb 03                	jmp    f01209d7 <strtol+0x144>
f01209d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f01209d7:	c9                   	leave  
f01209d8:	c3                   	ret    

f01209d9 <ltostr>:

void
ltostr(long value, char *str)
{
f01209d9:	55                   	push   %ebp
f01209da:	89 e5                	mov    %esp,%ebp
f01209dc:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f01209df:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f01209e6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f01209ed:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01209f1:	79 13                	jns    f0120a06 <ltostr+0x2d>
	{
		neg = 1;
f01209f3:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f01209fa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01209fd:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f0120a00:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f0120a03:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f0120a06:	8b 45 08             	mov    0x8(%ebp),%eax
f0120a09:	b9 0a 00 00 00       	mov    $0xa,%ecx
f0120a0e:	99                   	cltd   
f0120a0f:	f7 f9                	idiv   %ecx
f0120a11:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f0120a14:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120a17:	8d 50 01             	lea    0x1(%eax),%edx
f0120a1a:	89 55 f8             	mov    %edx,-0x8(%ebp)
f0120a1d:	89 c2                	mov    %eax,%edx
f0120a1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a22:	01 d0                	add    %edx,%eax
f0120a24:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120a27:	83 c2 30             	add    $0x30,%edx
f0120a2a:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f0120a2c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0120a2f:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0120a34:	f7 e9                	imul   %ecx
f0120a36:	c1 fa 02             	sar    $0x2,%edx
f0120a39:	89 c8                	mov    %ecx,%eax
f0120a3b:	c1 f8 1f             	sar    $0x1f,%eax
f0120a3e:	29 c2                	sub    %eax,%edx
f0120a40:	89 d0                	mov    %edx,%eax
f0120a42:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f0120a45:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120a49:	75 bb                	jne    f0120a06 <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f0120a4b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f0120a52:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120a55:	48                   	dec    %eax
f0120a56:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f0120a59:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0120a5d:	74 3d                	je     f0120a9c <ltostr+0xc3>
		start = 1 ;
f0120a5f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f0120a66:	eb 34                	jmp    f0120a9c <ltostr+0xc3>
	{
		char tmp = str[start] ;
f0120a68:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a6b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a6e:	01 d0                	add    %edx,%eax
f0120a70:	8a 00                	mov    (%eax),%al
f0120a72:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f0120a75:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120a78:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a7b:	01 c2                	add    %eax,%edx
f0120a7d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0120a80:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a83:	01 c8                	add    %ecx,%eax
f0120a85:	8a 00                	mov    (%eax),%al
f0120a87:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f0120a89:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120a8c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120a8f:	01 c2                	add    %eax,%edx
f0120a91:	8a 45 eb             	mov    -0x15(%ebp),%al
f0120a94:	88 02                	mov    %al,(%edx)
		start++ ;
f0120a96:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f0120a99:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f0120a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120a9f:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120aa2:	7c c4                	jl     f0120a68 <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f0120aa4:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0120aa7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120aaa:	01 d0                	add    %edx,%eax
f0120aac:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f0120aaf:	90                   	nop
f0120ab0:	c9                   	leave  
f0120ab1:	c3                   	ret    

f0120ab2 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f0120ab2:	55                   	push   %ebp
f0120ab3:	89 e5                	mov    %esp,%ebp
f0120ab5:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f0120ab8:	ff 75 08             	pushl  0x8(%ebp)
f0120abb:	e8 73 fa ff ff       	call   f0120533 <strlen>
f0120ac0:	83 c4 04             	add    $0x4,%esp
f0120ac3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f0120ac6:	ff 75 0c             	pushl  0xc(%ebp)
f0120ac9:	e8 65 fa ff ff       	call   f0120533 <strlen>
f0120ace:	83 c4 04             	add    $0x4,%esp
f0120ad1:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f0120ad4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f0120adb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0120ae2:	eb 17                	jmp    f0120afb <strcconcat+0x49>
		final[s] = str1[s] ;
f0120ae4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120ae7:	8b 45 10             	mov    0x10(%ebp),%eax
f0120aea:	01 c2                	add    %eax,%edx
f0120aec:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f0120aef:	8b 45 08             	mov    0x8(%ebp),%eax
f0120af2:	01 c8                	add    %ecx,%eax
f0120af4:	8a 00                	mov    (%eax),%al
f0120af6:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f0120af8:	ff 45 fc             	incl   -0x4(%ebp)
f0120afb:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120afe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0120b01:	7c e1                	jl     f0120ae4 <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f0120b03:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f0120b0a:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f0120b11:	eb 1f                	jmp    f0120b32 <strcconcat+0x80>
		final[s++] = str2[i] ;
f0120b13:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120b16:	8d 50 01             	lea    0x1(%eax),%edx
f0120b19:	89 55 fc             	mov    %edx,-0x4(%ebp)
f0120b1c:	89 c2                	mov    %eax,%edx
f0120b1e:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b21:	01 c2                	add    %eax,%edx
f0120b23:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f0120b26:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120b29:	01 c8                	add    %ecx,%eax
f0120b2b:	8a 00                	mov    (%eax),%al
f0120b2d:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f0120b2f:	ff 45 f8             	incl   -0x8(%ebp)
f0120b32:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0120b35:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0120b38:	7c d9                	jl     f0120b13 <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f0120b3a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0120b3d:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b40:	01 d0                	add    %edx,%eax
f0120b42:	c6 00 00             	movb   $0x0,(%eax)
}
f0120b45:	90                   	nop
f0120b46:	c9                   	leave  
f0120b47:	c3                   	ret    

f0120b48 <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f0120b48:	55                   	push   %ebp
f0120b49:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f0120b4b:	8b 45 14             	mov    0x14(%ebp),%eax
f0120b4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f0120b54:	8b 45 14             	mov    0x14(%ebp),%eax
f0120b57:	8b 00                	mov    (%eax),%eax
f0120b59:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120b60:	8b 45 10             	mov    0x10(%ebp),%eax
f0120b63:	01 d0                	add    %edx,%eax
f0120b65:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120b6b:	eb 0c                	jmp    f0120b79 <strsplit+0x31>
			*string++ = 0;
f0120b6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b70:	8d 50 01             	lea    0x1(%eax),%edx
f0120b73:	89 55 08             	mov    %edx,0x8(%ebp)
f0120b76:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f0120b79:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b7c:	8a 00                	mov    (%eax),%al
f0120b7e:	84 c0                	test   %al,%al
f0120b80:	74 18                	je     f0120b9a <strsplit+0x52>
f0120b82:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b85:	8a 00                	mov    (%eax),%al
f0120b87:	0f be c0             	movsbl %al,%eax
f0120b8a:	50                   	push   %eax
f0120b8b:	ff 75 0c             	pushl  0xc(%ebp)
f0120b8e:	e8 32 fb ff ff       	call   f01206c5 <strchr>
f0120b93:	83 c4 08             	add    $0x8,%esp
f0120b96:	85 c0                	test   %eax,%eax
f0120b98:	75 d3                	jne    f0120b6d <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f0120b9a:	8b 45 08             	mov    0x8(%ebp),%eax
f0120b9d:	8a 00                	mov    (%eax),%al
f0120b9f:	84 c0                	test   %al,%al
f0120ba1:	74 5a                	je     f0120bfd <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f0120ba3:	8b 45 14             	mov    0x14(%ebp),%eax
f0120ba6:	8b 00                	mov    (%eax),%eax
f0120ba8:	83 f8 0f             	cmp    $0xf,%eax
f0120bab:	75 07                	jne    f0120bb4 <strsplit+0x6c>
		{
			return 0;
f0120bad:	b8 00 00 00 00       	mov    $0x0,%eax
f0120bb2:	eb 66                	jmp    f0120c1a <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f0120bb4:	8b 45 14             	mov    0x14(%ebp),%eax
f0120bb7:	8b 00                	mov    (%eax),%eax
f0120bb9:	8d 48 01             	lea    0x1(%eax),%ecx
f0120bbc:	8b 55 14             	mov    0x14(%ebp),%edx
f0120bbf:	89 0a                	mov    %ecx,(%edx)
f0120bc1:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120bc8:	8b 45 10             	mov    0x10(%ebp),%eax
f0120bcb:	01 c2                	add    %eax,%edx
f0120bcd:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bd0:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120bd2:	eb 03                	jmp    f0120bd7 <strsplit+0x8f>
			string++;
f0120bd4:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f0120bd7:	8b 45 08             	mov    0x8(%ebp),%eax
f0120bda:	8a 00                	mov    (%eax),%al
f0120bdc:	84 c0                	test   %al,%al
f0120bde:	74 8b                	je     f0120b6b <strsplit+0x23>
f0120be0:	8b 45 08             	mov    0x8(%ebp),%eax
f0120be3:	8a 00                	mov    (%eax),%al
f0120be5:	0f be c0             	movsbl %al,%eax
f0120be8:	50                   	push   %eax
f0120be9:	ff 75 0c             	pushl  0xc(%ebp)
f0120bec:	e8 d4 fa ff ff       	call   f01206c5 <strchr>
f0120bf1:	83 c4 08             	add    $0x8,%esp
f0120bf4:	85 c0                	test   %eax,%eax
f0120bf6:	74 dc                	je     f0120bd4 <strsplit+0x8c>
			string++;
	}
f0120bf8:	e9 6e ff ff ff       	jmp    f0120b6b <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f0120bfd:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f0120bfe:	8b 45 14             	mov    0x14(%ebp),%eax
f0120c01:	8b 00                	mov    (%eax),%eax
f0120c03:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0120c0a:	8b 45 10             	mov    0x10(%ebp),%eax
f0120c0d:	01 d0                	add    %edx,%eax
f0120c0f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f0120c15:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0120c1a:	c9                   	leave  
f0120c1b:	c3                   	ret    

f0120c1c <str2lower>:


char* str2lower(char *dst, const char *src)
{
f0120c1c:	55                   	push   %ebp
f0120c1d:	89 e5                	mov    %esp,%ebp
f0120c1f:	83 ec 08             	sub    $0x8,%esp
	//[PROJECT]
	panic("str2lower is not implemented yet!");
f0120c22:	83 ec 04             	sub    $0x4,%esp
f0120c25:	68 9c dc 12 f0       	push   $0xf012dc9c
f0120c2a:	68 3f 01 00 00       	push   $0x13f
f0120c2f:	68 be dc 12 f0       	push   $0xf012dcbe
f0120c34:	e8 e1 f6 fd ff       	call   f010031a <_panic>

f0120c39 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f0120c39:	55                   	push   %ebp
f0120c3a:	89 e5                	mov    %esp,%ebp
f0120c3c:	83 ec 18             	sub    $0x18,%esp
f0120c3f:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120c46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120c49:	89 c2                	mov    %eax,%edx
f0120c4b:	ec                   	in     (%dx),%al
f0120c4c:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120c4f:	8a 45 ef             	mov    -0x11(%ebp),%al
	int r;
	//cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120c52:	0f b6 c0             	movzbl %al,%eax
f0120c55:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120c58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120c5b:	25 c0 00 00 00       	and    $0xc0,%eax
f0120c60:	83 f8 40             	cmp    $0x40,%eax
f0120c63:	75 10                	jne    f0120c75 <disk_interrupt_handler+0x3c>
	{
		//cprintf("NOT READY\n");
	}
	else
	{
		wakeup_one(&DISKchannel);
f0120c65:	83 ec 0c             	sub    $0xc,%esp
f0120c68:	68 00 24 55 f0       	push   $0xf0552400
f0120c6d:	e8 a7 de fe ff       	call   f010eb19 <wakeup_one>
f0120c72:	83 c4 10             	add    $0x10,%esp
	}

}
f0120c75:	90                   	nop
f0120c76:	c9                   	leave  
f0120c77:	c3                   	ret    

f0120c78 <ide_init>:

void ide_init()
{
f0120c78:	55                   	push   %ebp
f0120c79:	89 e5                	mov    %esp,%ebp
f0120c7b:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(14, &disk_interrupt_handler);
f0120c7e:	83 ec 08             	sub    $0x8,%esp
f0120c81:	68 39 0c 12 f0       	push   $0xf0120c39
f0120c86:	6a 0e                	push   $0xe
f0120c88:	e8 0c c4 fe ff       	call   f010d099 <irq_install_handler>
f0120c8d:	83 c4 10             	add    $0x10,%esp
	//irq_install_handler(15, &disk_interrupt_handler);
	if (DISK_INT_BLK_METHOD == LCK_SLEEP)
	{
		init_channel(&DISKchannel, "DISK channel");
f0120c90:	83 ec 08             	sub    $0x8,%esp
f0120c93:	68 cc dc 12 f0       	push   $0xf012dccc
f0120c98:	68 00 24 55 f0       	push   $0xf0552400
f0120c9d:	e8 30 de fe ff       	call   f010ead2 <init_channel>
f0120ca2:	83 c4 10             	add    $0x10,%esp
		init_spinlock(&DISKlock, "DISK channel lock");
f0120ca5:	83 ec 08             	sub    $0x8,%esp
f0120ca8:	68 d9 dc 12 f0       	push   $0xf012dcd9
f0120cad:	68 40 4f 55 f0       	push   $0xf0554f40
f0120cb2:	e8 98 da fe ff       	call   f010e74f <init_spinlock>
f0120cb7:	83 c4 10             	add    $0x10,%esp
	}
	else if (DISK_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
	}
}
f0120cba:	90                   	nop
f0120cbb:	c9                   	leave  
f0120cbc:	c3                   	ret    

f0120cbd <ide_wait_ready>:
//	}
//	return 0;
//}

static int ide_wait_ready(bool check_error)
{
f0120cbd:	55                   	push   %ebp
f0120cbe:	89 e5                	mov    %esp,%ebp
f0120cc0:	83 ec 18             	sub    $0x18,%esp
	int r;

	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f0120cc3:	90                   	nop
f0120cc4:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0120ccb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0120cce:	89 c2                	mov    %eax,%edx
f0120cd0:	ec                   	in     (%dx),%al
f0120cd1:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f0120cd4:	8a 45 ef             	mov    -0x11(%ebp),%al
f0120cd7:	0f b6 c0             	movzbl %al,%eax
f0120cda:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0120cdd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120ce0:	25 c0 00 00 00       	and    $0xc0,%eax
f0120ce5:	83 f8 40             	cmp    $0x40,%eax
f0120ce8:	75 da                	jne    f0120cc4 <ide_wait_ready+0x7>
	/* do nothing */;


	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f0120cea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0120cee:	74 24                	je     f0120d14 <ide_wait_ready+0x57>
f0120cf0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0120cf3:	83 e0 21             	and    $0x21,%eax
f0120cf6:	85 c0                	test   %eax,%eax
f0120cf8:	74 1a                	je     f0120d14 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f0120cfa:	83 ec 0c             	sub    $0xc,%esp
f0120cfd:	ff 75 f4             	pushl  -0xc(%ebp)
f0120d00:	ff 75 f4             	pushl  -0xc(%ebp)
f0120d03:	68 ec dc 12 f0       	push   $0xf012dcec
f0120d08:	6a 5d                	push   $0x5d
f0120d0a:	68 0f dd 12 f0       	push   $0xf012dd0f
f0120d0f:	e8 06 f6 fd ff       	call   f010031a <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f0120d14:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120d19:	c9                   	leave  
f0120d1a:	c3                   	ret    

f0120d1b <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f0120d1b:	55                   	push   %ebp
f0120d1c:	89 e5                	mov    %esp,%ebp
f0120d1e:	57                   	push   %edi
f0120d1f:	53                   	push   %ebx
f0120d20:	83 ec 30             	sub    $0x30,%esp
	int r;

	assert(nsecs <= 256);
f0120d23:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120d2a:	76 16                	jbe    f0120d42 <ide_read+0x27>
f0120d2c:	68 1a dd 12 f0       	push   $0xf012dd1a
f0120d31:	68 27 dd 12 f0       	push   $0xf012dd27
f0120d36:	6a 68                	push   $0x68
f0120d38:	68 0f dd 12 f0       	push   $0xf012dd0f
f0120d3d:	e8 d8 f5 fd ff       	call   f010031a <_panic>

	//FUTURE NOTE: This BUSY-WAIT should be replaced by Interrupt to allow the OS to schedule another process till the device become ready [el7 :)]
	ide_wait_ready(0);
f0120d42:	83 ec 0c             	sub    $0xc,%esp
f0120d45:	6a 00                	push   $0x0
f0120d47:	e8 71 ff ff ff       	call   f0120cbd <ide_wait_ready>
f0120d4c:	83 c4 10             	add    $0x10,%esp

	outb(0x1F2, nsecs);
f0120d4f:	8b 45 10             	mov    0x10(%ebp),%eax
f0120d52:	0f b6 c0             	movzbl %al,%eax
f0120d55:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120d5c:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120d5f:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120d62:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120d65:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120d66:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d69:	0f b6 c0             	movzbl %al,%eax
f0120d6c:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120d73:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120d76:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120d79:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120d7c:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120d7d:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d80:	c1 e8 08             	shr    $0x8,%eax
f0120d83:	0f b6 c0             	movzbl %al,%eax
f0120d86:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120d8d:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120d90:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120d93:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120d96:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120d97:	8b 45 08             	mov    0x8(%ebp),%eax
f0120d9a:	c1 e8 10             	shr    $0x10,%eax
f0120d9d:	0f b6 c0             	movzbl %al,%eax
f0120da0:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120da7:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120daa:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120dad:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120db0:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120db1:	a1 b0 22 55 f0       	mov    0xf05522b0,%eax
f0120db6:	83 e0 01             	and    $0x1,%eax
f0120db9:	c1 e0 04             	shl    $0x4,%eax
f0120dbc:	88 c2                	mov    %al,%dl
f0120dbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0120dc1:	c1 e8 18             	shr    $0x18,%eax
f0120dc4:	83 e0 0f             	and    $0xf,%eax
f0120dc7:	09 d0                	or     %edx,%eax
f0120dc9:	83 c8 e0             	or     $0xffffffe0,%eax
f0120dcc:	0f b6 c0             	movzbl %al,%eax
f0120dcf:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120dd6:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120dd9:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120ddc:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120ddf:	ee                   	out    %al,(%dx)
f0120de0:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120de7:	c6 45 d7 20          	movb   $0x20,-0x29(%ebp)
f0120deb:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120dee:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120df1:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120df2:	eb 55                	jmp    f0120e49 <ide_read+0x12e>
		if ((r = ide_wait_ready(1)) < 0)
f0120df4:	83 ec 0c             	sub    $0xc,%esp
f0120df7:	6a 01                	push   $0x1
f0120df9:	e8 bf fe ff ff       	call   f0120cbd <ide_wait_ready>
f0120dfe:	83 c4 10             	add    $0x10,%esp
f0120e01:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120e04:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120e08:	79 05                	jns    f0120e0f <ide_read+0xf4>
			return r;
f0120e0a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120e0d:	eb 45                	jmp    f0120e54 <ide_read+0x139>
f0120e0f:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120e16:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120e19:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120e1c:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f0120e23:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120e26:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120e29:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120e2c:	89 cb                	mov    %ecx,%ebx
f0120e2e:	89 df                	mov    %ebx,%edi
f0120e30:	89 c1                	mov    %eax,%ecx
f0120e32:	fc                   	cld    
f0120e33:	f2 6d                	repnz insl (%dx),%es:(%edi)
f0120e35:	89 c8                	mov    %ecx,%eax
f0120e37:	89 fb                	mov    %edi,%ebx
f0120e39:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120e3c:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F4, (secno >> 8) & 0xFF);
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x20);	// CMD 0x20 means read sector

	for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f0120e3f:	ff 4d 10             	decl   0x10(%ebp)
f0120e42:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120e49:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120e4d:	75 a5                	jne    f0120df4 <ide_read+0xd9>
		if ((r = ide_wait_ready(1)) < 0)
			return r;
		insl(0x1F0, dst, SECTSIZE/4);
	}

	return 0;
f0120e4f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120e54:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120e57:	5b                   	pop    %ebx
f0120e58:	5f                   	pop    %edi
f0120e59:	5d                   	pop    %ebp
f0120e5a:	c3                   	ret    

f0120e5b <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f0120e5b:	55                   	push   %ebp
f0120e5c:	89 e5                	mov    %esp,%ebp
f0120e5e:	56                   	push   %esi
f0120e5f:	53                   	push   %ebx
f0120e60:	83 ec 30             	sub    $0x30,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f0120e63:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f0120e6a:	76 19                	jbe    f0120e85 <ide_write+0x2a>
f0120e6c:	68 1a dd 12 f0       	push   $0xf012dd1a
f0120e71:	68 27 dd 12 f0       	push   $0xf012dd27
f0120e76:	68 82 00 00 00       	push   $0x82
f0120e7b:	68 0f dd 12 f0       	push   $0xf012dd0f
f0120e80:	e8 95 f4 fd ff       	call   f010031a <_panic>

	//LOG_STATMENT(cprintf("2\n");)
	ide_wait_ready(0);
f0120e85:	83 ec 0c             	sub    $0xc,%esp
f0120e88:	6a 00                	push   $0x0
f0120e8a:	e8 2e fe ff ff       	call   f0120cbd <ide_wait_ready>
f0120e8f:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
	outb(0x1F2, nsecs);
f0120e92:	8b 45 10             	mov    0x10(%ebp),%eax
f0120e95:	0f b6 c0             	movzbl %al,%eax
f0120e98:	c7 45 f0 f2 01 00 00 	movl   $0x1f2,-0x10(%ebp)
f0120e9f:	88 45 d2             	mov    %al,-0x2e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0120ea2:	8a 45 d2             	mov    -0x2e(%ebp),%al
f0120ea5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0120ea8:	ee                   	out    %al,(%dx)
	outb(0x1F3, secno & 0xFF);
f0120ea9:	8b 45 08             	mov    0x8(%ebp),%eax
f0120eac:	0f b6 c0             	movzbl %al,%eax
f0120eaf:	c7 45 ec f3 01 00 00 	movl   $0x1f3,-0x14(%ebp)
f0120eb6:	88 45 d3             	mov    %al,-0x2d(%ebp)
f0120eb9:	8a 45 d3             	mov    -0x2d(%ebp),%al
f0120ebc:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0120ebf:	ee                   	out    %al,(%dx)
	outb(0x1F4, (secno >> 8) & 0xFF);
f0120ec0:	8b 45 08             	mov    0x8(%ebp),%eax
f0120ec3:	c1 e8 08             	shr    $0x8,%eax
f0120ec6:	0f b6 c0             	movzbl %al,%eax
f0120ec9:	c7 45 e8 f4 01 00 00 	movl   $0x1f4,-0x18(%ebp)
f0120ed0:	88 45 d4             	mov    %al,-0x2c(%ebp)
f0120ed3:	8a 45 d4             	mov    -0x2c(%ebp),%al
f0120ed6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0120ed9:	ee                   	out    %al,(%dx)
	outb(0x1F5, (secno >> 16) & 0xFF);
f0120eda:	8b 45 08             	mov    0x8(%ebp),%eax
f0120edd:	c1 e8 10             	shr    $0x10,%eax
f0120ee0:	0f b6 c0             	movzbl %al,%eax
f0120ee3:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%ebp)
f0120eea:	88 45 d5             	mov    %al,-0x2b(%ebp)
f0120eed:	8a 45 d5             	mov    -0x2b(%ebp),%al
f0120ef0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0120ef3:	ee                   	out    %al,(%dx)
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f0120ef4:	a1 b0 22 55 f0       	mov    0xf05522b0,%eax
f0120ef9:	83 e0 01             	and    $0x1,%eax
f0120efc:	c1 e0 04             	shl    $0x4,%eax
f0120eff:	88 c2                	mov    %al,%dl
f0120f01:	8b 45 08             	mov    0x8(%ebp),%eax
f0120f04:	c1 e8 18             	shr    $0x18,%eax
f0120f07:	83 e0 0f             	and    $0xf,%eax
f0120f0a:	09 d0                	or     %edx,%eax
f0120f0c:	83 c8 e0             	or     $0xffffffe0,%eax
f0120f0f:	0f b6 c0             	movzbl %al,%eax
f0120f12:	c7 45 e0 f6 01 00 00 	movl   $0x1f6,-0x20(%ebp)
f0120f19:	88 45 d6             	mov    %al,-0x2a(%ebp)
f0120f1c:	8a 45 d6             	mov    -0x2a(%ebp),%al
f0120f1f:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0120f22:	ee                   	out    %al,(%dx)
f0120f23:	c7 45 d8 f7 01 00 00 	movl   $0x1f7,-0x28(%ebp)
f0120f2a:	c6 45 d7 30          	movb   $0x30,-0x29(%ebp)
f0120f2e:	8a 45 d7             	mov    -0x29(%ebp),%al
f0120f31:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0120f34:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120f35:	eb 55                	jmp    f0120f8c <ide_write+0x131>
		if ((r = ide_wait_ready(1)) < 0)
f0120f37:	83 ec 0c             	sub    $0xc,%esp
f0120f3a:	6a 01                	push   $0x1
f0120f3c:	e8 7c fd ff ff       	call   f0120cbd <ide_wait_ready>
f0120f41:	83 c4 10             	add    $0x10,%esp
f0120f44:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0120f47:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0120f4b:	79 05                	jns    f0120f52 <ide_write+0xf7>
		{
			LOG_STATMENT(cprintf("FAILURE to write %d sectors to disk\n",nsecs););
			return r;
f0120f4d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0120f50:	eb 45                	jmp    f0120f97 <ide_write+0x13c>
f0120f52:	c7 45 f4 f0 01 00 00 	movl   $0x1f0,-0xc(%ebp)
f0120f59:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120f5c:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0120f5f:	c7 45 c8 80 00 00 00 	movl   $0x80,-0x38(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f0120f66:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0120f69:	8b 4d cc             	mov    -0x34(%ebp),%ecx
f0120f6c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0120f6f:	89 cb                	mov    %ecx,%ebx
f0120f71:	89 de                	mov    %ebx,%esi
f0120f73:	89 c1                	mov    %eax,%ecx
f0120f75:	fc                   	cld    
f0120f76:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f0120f78:	89 c8                	mov    %ecx,%eax
f0120f7a:	89 f3                	mov    %esi,%ebx
f0120f7c:	89 5d cc             	mov    %ebx,-0x34(%ebp)
f0120f7f:	89 45 c8             	mov    %eax,-0x38(%ebp)
	outb(0x1F5, (secno >> 16) & 0xFF);
	outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
	outb(0x1F7, 0x30);	// CMD 0x30 means write sector


	for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f0120f82:	ff 4d 10             	decl   0x10(%ebp)
f0120f85:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f0120f8c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0120f90:	75 a5                	jne    f0120f37 <ide_write+0xdc>
		}
	}
	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f0120f92:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0120f97:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0120f9a:	5b                   	pop    %ebx
f0120f9b:	5e                   	pop    %esi
f0120f9c:	5d                   	pop    %ebp
f0120f9d:	c3                   	ret    

f0120f9e <get_block_size>:

//=====================================================
// 1) GET BLOCK SIZE (including size of its meta data):
//=====================================================
__inline__ uint32 get_block_size(void* va)
{
f0120f9e:	55                   	push   %ebp
f0120f9f:	89 e5                	mov    %esp,%ebp
f0120fa1:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120fa4:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fa7:	83 e8 04             	sub    $0x4,%eax
f0120faa:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (*curBlkMetaData) & ~(0x1);
f0120fad:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120fb0:	8b 00                	mov    (%eax),%eax
f0120fb2:	83 e0 fe             	and    $0xfffffffe,%eax
}
f0120fb5:	c9                   	leave  
f0120fb6:	c3                   	ret    

f0120fb7 <is_free_block>:

//===========================
// 2) GET BLOCK STATUS:
//===========================
__inline__ int8 is_free_block(void* va)
{
f0120fb7:	55                   	push   %ebp
f0120fb8:	89 e5                	mov    %esp,%ebp
f0120fba:	83 ec 10             	sub    $0x10,%esp
	uint32 *curBlkMetaData = ((uint32 *)va - 1) ;
f0120fbd:	8b 45 08             	mov    0x8(%ebp),%eax
f0120fc0:	83 e8 04             	sub    $0x4,%eax
f0120fc3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return (~(*curBlkMetaData) & 0x1) ;
f0120fc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0120fc9:	8b 00                	mov    (%eax),%eax
f0120fcb:	83 e0 01             	and    $0x1,%eax
f0120fce:	85 c0                	test   %eax,%eax
f0120fd0:	0f 94 c0             	sete   %al
}
f0120fd3:	c9                   	leave  
f0120fd4:	c3                   	ret    

f0120fd5 <alloc_block>:
//===========================
// 3) ALLOCATE BLOCK:
//===========================

void *alloc_block(uint32 size, int ALLOC_STRATEGY)
{
f0120fd5:	55                   	push   %ebp
f0120fd6:	89 e5                	mov    %esp,%ebp
f0120fd8:	83 ec 18             	sub    $0x18,%esp
	void *va = NULL;
f0120fdb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (ALLOC_STRATEGY)
f0120fe2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0120fe5:	83 f8 02             	cmp    $0x2,%eax
f0120fe8:	74 2b                	je     f0121015 <alloc_block+0x40>
f0120fea:	83 f8 02             	cmp    $0x2,%eax
f0120fed:	7f 07                	jg     f0120ff6 <alloc_block+0x21>
f0120fef:	83 f8 01             	cmp    $0x1,%eax
f0120ff2:	74 0e                	je     f0121002 <alloc_block+0x2d>
f0120ff4:	eb 58                	jmp    f012104e <alloc_block+0x79>
f0120ff6:	83 f8 03             	cmp    $0x3,%eax
f0120ff9:	74 2d                	je     f0121028 <alloc_block+0x53>
f0120ffb:	83 f8 04             	cmp    $0x4,%eax
f0120ffe:	74 3b                	je     f012103b <alloc_block+0x66>
f0121000:	eb 4c                	jmp    f012104e <alloc_block+0x79>
	{
	case DA_FF:
		va = alloc_block_FF(size);
f0121002:	83 ec 0c             	sub    $0xc,%esp
f0121005:	ff 75 08             	pushl  0x8(%ebp)
f0121008:	e8 49 01 00 00       	call   f0121156 <alloc_block_FF>
f012100d:	83 c4 10             	add    $0x10,%esp
f0121010:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0121013:	eb 4a                	jmp    f012105f <alloc_block+0x8a>
	case DA_NF:
		va = alloc_block_NF(size);
f0121015:	83 ec 0c             	sub    $0xc,%esp
f0121018:	ff 75 08             	pushl  0x8(%ebp)
f012101b:	e8 4d 02 00 00       	call   f012126d <alloc_block_NF>
f0121020:	83 c4 10             	add    $0x10,%esp
f0121023:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0121026:	eb 37                	jmp    f012105f <alloc_block+0x8a>
	case DA_BF:
		va = alloc_block_BF(size);
f0121028:	83 ec 0c             	sub    $0xc,%esp
f012102b:	ff 75 08             	pushl  0x8(%ebp)
f012102e:	e8 c6 01 00 00       	call   f01211f9 <alloc_block_BF>
f0121033:	83 c4 10             	add    $0x10,%esp
f0121036:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f0121039:	eb 24                	jmp    f012105f <alloc_block+0x8a>
	case DA_WF:
		va = alloc_block_WF(size);
f012103b:	83 ec 0c             	sub    $0xc,%esp
f012103e:	ff 75 08             	pushl  0x8(%ebp)
f0121041:	e8 0a 02 00 00       	call   f0121250 <alloc_block_WF>
f0121046:	83 c4 10             	add    $0x10,%esp
f0121049:	89 45 f4             	mov    %eax,-0xc(%ebp)
		break;
f012104c:	eb 11                	jmp    f012105f <alloc_block+0x8a>
	default:
		cprintf("Invalid allocation strategy\n");
f012104e:	83 ec 0c             	sub    $0xc,%esp
f0121051:	68 3c dd 12 f0       	push   $0xf012dd3c
f0121056:	e8 11 ff fd ff       	call   f0100f6c <cprintf>
f012105b:	83 c4 10             	add    $0x10,%esp
		break;
f012105e:	90                   	nop
	}
	return va;
f012105f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0121062:	c9                   	leave  
f0121063:	c3                   	ret    

f0121064 <print_blocks_list>:
//===========================
// 4) PRINT BLOCKS LIST:
//===========================

void print_blocks_list(struct MemBlock_LIST list)
{
f0121064:	55                   	push   %ebp
f0121065:	89 e5                	mov    %esp,%ebp
f0121067:	53                   	push   %ebx
f0121068:	83 ec 14             	sub    $0x14,%esp
	cprintf("=========================================\n");
f012106b:	83 ec 0c             	sub    $0xc,%esp
f012106e:	68 5c dd 12 f0       	push   $0xf012dd5c
f0121073:	e8 f4 fe fd ff       	call   f0100f6c <cprintf>
f0121078:	83 c4 10             	add    $0x10,%esp
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
f012107b:	83 ec 0c             	sub    $0xc,%esp
f012107e:	68 87 dd 12 f0       	push   $0xf012dd87
f0121083:	e8 e4 fe fd ff       	call   f0100f6c <cprintf>
f0121088:	83 c4 10             	add    $0x10,%esp
	LIST_FOREACH(blk, &list)
f012108b:	8b 45 08             	mov    0x8(%ebp),%eax
f012108e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0121091:	eb 37                	jmp    f01210ca <print_blocks_list+0x66>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
f0121093:	83 ec 0c             	sub    $0xc,%esp
f0121096:	ff 75 f4             	pushl  -0xc(%ebp)
f0121099:	e8 19 ff ff ff       	call   f0120fb7 <is_free_block>
f012109e:	83 c4 10             	add    $0x10,%esp
f01210a1:	0f be d8             	movsbl %al,%ebx
f01210a4:	83 ec 0c             	sub    $0xc,%esp
f01210a7:	ff 75 f4             	pushl  -0xc(%ebp)
f01210aa:	e8 ef fe ff ff       	call   f0120f9e <get_block_size>
f01210af:	83 c4 10             	add    $0x10,%esp
f01210b2:	83 ec 04             	sub    $0x4,%esp
f01210b5:	53                   	push   %ebx
f01210b6:	50                   	push   %eax
f01210b7:	68 9f dd 12 f0       	push   $0xf012dd9f
f01210bc:	e8 ab fe fd ff       	call   f0100f6c <cprintf>
f01210c1:	83 c4 10             	add    $0x10,%esp
void print_blocks_list(struct MemBlock_LIST list)
{
	cprintf("=========================================\n");
	struct BlockElement* blk ;
	cprintf("\nDynAlloc Blocks List:\n");
	LIST_FOREACH(blk, &list)
f01210c4:	8b 45 10             	mov    0x10(%ebp),%eax
f01210c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01210ca:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01210ce:	74 07                	je     f01210d7 <print_blocks_list+0x73>
f01210d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01210d3:	8b 00                	mov    (%eax),%eax
f01210d5:	eb 05                	jmp    f01210dc <print_blocks_list+0x78>
f01210d7:	b8 00 00 00 00       	mov    $0x0,%eax
f01210dc:	89 45 10             	mov    %eax,0x10(%ebp)
f01210df:	8b 45 10             	mov    0x10(%ebp),%eax
f01210e2:	85 c0                	test   %eax,%eax
f01210e4:	75 ad                	jne    f0121093 <print_blocks_list+0x2f>
f01210e6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01210ea:	75 a7                	jne    f0121093 <print_blocks_list+0x2f>
	{
		cprintf("(size: %d, isFree: %d)\n", get_block_size(blk), is_free_block(blk)) ;
	}
	cprintf("=========================================\n");
f01210ec:	83 ec 0c             	sub    $0xc,%esp
f01210ef:	68 5c dd 12 f0       	push   $0xf012dd5c
f01210f4:	e8 73 fe fd ff       	call   f0100f6c <cprintf>
f01210f9:	83 c4 10             	add    $0x10,%esp

}
f01210fc:	90                   	nop
f01210fd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0121100:	c9                   	leave  
f0121101:	c3                   	ret    

f0121102 <initialize_dynamic_allocator>:
bool is_initialized = 0;
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
void initialize_dynamic_allocator(uint32 daStart, uint32 initSizeOfAllocatedSpace)
{
f0121102:	55                   	push   %ebp
f0121103:	89 e5                	mov    %esp,%ebp
f0121105:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
f0121108:	8b 45 0c             	mov    0xc(%ebp),%eax
f012110b:	83 e0 01             	and    $0x1,%eax
f012110e:	85 c0                	test   %eax,%eax
f0121110:	74 03                	je     f0121115 <initialize_dynamic_allocator+0x13>
f0121112:	ff 45 0c             	incl   0xc(%ebp)
		if (initSizeOfAllocatedSpace == 0)
f0121115:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0121119:	74 1e                	je     f0121139 <initialize_dynamic_allocator+0x37>
			return ;
		is_initialized = 1;
f012111b:	c7 05 b4 22 55 f0 01 	movl   $0x1,0xf05522b4
f0121122:	00 00 00 
	//==================================================================================
	//==================================================================================

	//TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("initialize_dynamic_allocator is not implemented yet");
f0121125:	83 ec 04             	sub    $0x4,%esp
f0121128:	68 b8 dd 12 f0       	push   $0xf012ddb8
f012112d:	6a 6a                	push   $0x6a
f012112f:	68 ec dd 12 f0       	push   $0xf012ddec
f0121134:	e8 e1 f1 fd ff       	call   f010031a <_panic>
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (initSizeOfAllocatedSpace % 2 != 0) initSizeOfAllocatedSpace++; //ensure it's multiple of 2
		if (initSizeOfAllocatedSpace == 0)
			return ;
f0121139:	90                   	nop
	//TODO: [PROJECT'24.MS1 - #04] [3] DYNAMIC ALLOCATOR - initialize_dynamic_allocator
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("initialize_dynamic_allocator is not implemented yet");
	//Your Code is Here...

}
f012113a:	c9                   	leave  
f012113b:	c3                   	ret    

f012113c <set_block_data>:
//==================================
// [2] SET BLOCK HEADER & FOOTER:
//==================================
void set_block_data(void* va, uint32 totalSize, bool isAllocated)
{
f012113c:	55                   	push   %ebp
f012113d:	89 e5                	mov    %esp,%ebp
f012113f:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #05] [3] DYNAMIC ALLOCATOR - set_block_data
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("set_block_data is not implemented yet");
f0121142:	83 ec 04             	sub    $0x4,%esp
f0121145:	68 04 de 12 f0       	push   $0xf012de04
f012114a:	6a 75                	push   $0x75
f012114c:	68 ec dd 12 f0       	push   $0xf012ddec
f0121151:	e8 c4 f1 fd ff       	call   f010031a <_panic>

f0121156 <alloc_block_FF>:

//=========================================
// [3] ALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *alloc_block_FF(uint32 size)
{
f0121156:	55                   	push   %ebp
f0121157:	89 e5                	mov    %esp,%ebp
f0121159:	83 ec 28             	sub    $0x28,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		if (size % 2 != 0) size++;	//ensure that the size is even (to use LSB as allocation flag)
f012115c:	8b 45 08             	mov    0x8(%ebp),%eax
f012115f:	83 e0 01             	and    $0x1,%eax
f0121162:	85 c0                	test   %eax,%eax
f0121164:	74 03                	je     f0121169 <alloc_block_FF+0x13>
f0121166:	ff 45 08             	incl   0x8(%ebp)
		if (size < DYN_ALLOC_MIN_BLOCK_SIZE)
f0121169:	83 7d 08 07          	cmpl   $0x7,0x8(%ebp)
f012116d:	77 07                	ja     f0121176 <alloc_block_FF+0x20>
			size = DYN_ALLOC_MIN_BLOCK_SIZE ;
f012116f:	c7 45 08 08 00 00 00 	movl   $0x8,0x8(%ebp)
		if (!is_initialized)
f0121176:	a1 b4 22 55 f0       	mov    0xf05522b4,%eax
f012117b:	85 c0                	test   %eax,%eax
f012117d:	75 63                	jne    f01211e2 <alloc_block_FF+0x8c>
		{
			uint32 required_size = size + 2*sizeof(int) /*header & footer*/ + 2*sizeof(int) /*da begin & end*/ ;
f012117f:	8b 45 08             	mov    0x8(%ebp),%eax
f0121182:	83 c0 10             	add    $0x10,%eax
f0121185:	89 45 f4             	mov    %eax,-0xc(%ebp)
			uint32 da_start = (uint32)sbrk(ROUNDUP(required_size, PAGE_SIZE)/PAGE_SIZE);
f0121188:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f012118f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0121192:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0121195:	01 d0                	add    %edx,%eax
f0121197:	48                   	dec    %eax
f0121198:	89 45 ec             	mov    %eax,-0x14(%ebp)
f012119b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f012119e:	ba 00 00 00 00       	mov    $0x0,%edx
f01211a3:	f7 75 f0             	divl   -0x10(%ebp)
f01211a6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01211a9:	29 d0                	sub    %edx,%eax
f01211ab:	c1 e8 0c             	shr    $0xc,%eax
f01211ae:	83 ec 0c             	sub    $0xc,%esp
f01211b1:	50                   	push   %eax
f01211b2:	e8 f6 75 fe ff       	call   f01087ad <sbrk>
f01211b7:	83 c4 10             	add    $0x10,%esp
f01211ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 da_break = (uint32)sbrk(0);
f01211bd:	83 ec 0c             	sub    $0xc,%esp
f01211c0:	6a 00                	push   $0x0
f01211c2:	e8 e6 75 fe ff       	call   f01087ad <sbrk>
f01211c7:	83 c4 10             	add    $0x10,%esp
f01211ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			initialize_dynamic_allocator(da_start, da_break - da_start);
f01211cd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01211d0:	2b 45 e8             	sub    -0x18(%ebp),%eax
f01211d3:	83 ec 08             	sub    $0x8,%esp
f01211d6:	50                   	push   %eax
f01211d7:	ff 75 e8             	pushl  -0x18(%ebp)
f01211da:	e8 23 ff ff ff       	call   f0121102 <initialize_dynamic_allocator>
f01211df:	83 c4 10             	add    $0x10,%esp
	//==================================================================================
	//==================================================================================

	//TODO: [PROJECT'24.MS1 - #06] [3] DYNAMIC ALLOCATOR - alloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("alloc_block_FF is not implemented yet");
f01211e2:	83 ec 04             	sub    $0x4,%esp
f01211e5:	68 2c de 12 f0       	push   $0xf012de2c
f01211ea:	68 93 00 00 00       	push   $0x93
f01211ef:	68 ec dd 12 f0       	push   $0xf012ddec
f01211f4:	e8 21 f1 fd ff       	call   f010031a <_panic>

f01211f9 <alloc_block_BF>:
}
//=========================================
// [4] ALLOCATE BLOCK BY BEST FIT:
//=========================================
void *alloc_block_BF(uint32 size)
{
f01211f9:	55                   	push   %ebp
f01211fa:	89 e5                	mov    %esp,%ebp
f01211fc:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - BONUS] [3] DYNAMIC ALLOCATOR - alloc_block_BF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("alloc_block_BF is not implemented yet");
f01211ff:	83 ec 04             	sub    $0x4,%esp
f0121202:	68 54 de 12 f0       	push   $0xf012de54
f0121207:	68 9e 00 00 00       	push   $0x9e
f012120c:	68 ec dd 12 f0       	push   $0xf012ddec
f0121211:	e8 04 f1 fd ff       	call   f010031a <_panic>

f0121216 <free_block>:

//===================================================
// [5] FREE BLOCK WITH COALESCING:
//===================================================
void free_block(void *va)
{
f0121216:	55                   	push   %ebp
f0121217:	89 e5                	mov    %esp,%ebp
f0121219:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #07] [3] DYNAMIC ALLOCATOR - free_block
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("free_block is not implemented yet");
f012121c:	83 ec 04             	sub    $0x4,%esp
f012121f:	68 7c de 12 f0       	push   $0xf012de7c
f0121224:	68 aa 00 00 00       	push   $0xaa
f0121229:	68 ec dd 12 f0       	push   $0xf012ddec
f012122e:	e8 e7 f0 fd ff       	call   f010031a <_panic>

f0121233 <realloc_block_FF>:

//=========================================
// [6] REALLOCATE BLOCK BY FIRST FIT:
//=========================================
void *realloc_block_FF(void* va, uint32 new_size)
{
f0121233:	55                   	push   %ebp
f0121234:	89 e5                	mov    %esp,%ebp
f0121236:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'24.MS1 - #08] [3] DYNAMIC ALLOCATOR - realloc_block_FF
	//COMMENT THE FOLLOWING LINE BEFORE START CODING
	panic("realloc_block_FF is not implemented yet");
f0121239:	83 ec 04             	sub    $0x4,%esp
f012123c:	68 a0 de 12 f0       	push   $0xf012dea0
f0121241:	68 b5 00 00 00       	push   $0xb5
f0121246:	68 ec dd 12 f0       	push   $0xf012ddec
f012124b:	e8 ca f0 fd ff       	call   f010031a <_panic>

f0121250 <alloc_block_WF>:
/*********************************************************************************************/
//=========================================
// [7] ALLOCATE BLOCK BY WORST FIT:
//=========================================
void *alloc_block_WF(uint32 size)
{
f0121250:	55                   	push   %ebp
f0121251:	89 e5                	mov    %esp,%ebp
f0121253:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_WF is not implemented yet");
f0121256:	83 ec 04             	sub    $0x4,%esp
f0121259:	68 c8 de 12 f0       	push   $0xf012dec8
f012125e:	68 c1 00 00 00       	push   $0xc1
f0121263:	68 ec dd 12 f0       	push   $0xf012ddec
f0121268:	e8 ad f0 fd ff       	call   f010031a <_panic>

f012126d <alloc_block_NF>:

//=========================================
// [8] ALLOCATE BLOCK BY NEXT FIT:
//=========================================
void *alloc_block_NF(uint32 size)
{
f012126d:	55                   	push   %ebp
f012126e:	89 e5                	mov    %esp,%ebp
f0121270:	83 ec 08             	sub    $0x8,%esp
	panic("alloc_block_NF is not implemented yet");
f0121273:	83 ec 04             	sub    $0x4,%esp
f0121276:	68 f0 de 12 f0       	push   $0xf012def0
f012127b:	68 ca 00 00 00       	push   $0xca
f0121280:	68 ec dd 12 f0       	push   $0xf012ddec
f0121285:	e8 90 f0 fd ff       	call   f010031a <_panic>
f012128a:	66 90                	xchg   %ax,%ax

f012128c <__moddi3>:
f012128c:	55                   	push   %ebp
f012128d:	57                   	push   %edi
f012128e:	56                   	push   %esi
f012128f:	53                   	push   %ebx
f0121290:	83 ec 2c             	sub    $0x2c,%esp
f0121293:	8b 74 24 40          	mov    0x40(%esp),%esi
f0121297:	8b 7c 24 44          	mov    0x44(%esp),%edi
f012129b:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f012129f:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f01212a3:	89 d8                	mov    %ebx,%eax
f01212a5:	85 ff                	test   %edi,%edi
f01212a7:	0f 88 d3 00 00 00    	js     f0121380 <__moddi3+0xf4>
f01212ad:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f01212b4:	00 
f01212b5:	85 c0                	test   %eax,%eax
f01212b7:	0f 88 ab 00 00 00    	js     f0121368 <__moddi3+0xdc>
f01212bd:	89 0c 24             	mov    %ecx,(%esp)
f01212c0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f01212c4:	89 74 24 10          	mov    %esi,0x10(%esp)
f01212c8:	89 fb                	mov    %edi,%ebx
f01212ca:	8b 14 24             	mov    (%esp),%edx
f01212cd:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f01212d1:	89 d0                	mov    %edx,%eax
f01212d3:	89 54 24 18          	mov    %edx,0x18(%esp)
f01212d7:	89 ca                	mov    %ecx,%edx
f01212d9:	8b 0c 24             	mov    (%esp),%ecx
f01212dc:	89 34 24             	mov    %esi,(%esp)
f01212df:	89 7c 24 14          	mov    %edi,0x14(%esp)
f01212e3:	85 d2                	test   %edx,%edx
f01212e5:	75 15                	jne    f01212fc <__moddi3+0x70>
f01212e7:	89 c7                	mov    %eax,%edi
f01212e9:	39 d8                	cmp    %ebx,%eax
f01212eb:	76 5b                	jbe    f0121348 <__moddi3+0xbc>
f01212ed:	89 f0                	mov    %esi,%eax
f01212ef:	89 da                	mov    %ebx,%edx
f01212f1:	f7 f7                	div    %edi
f01212f3:	89 d3                	mov    %edx,%ebx
f01212f5:	89 d8                	mov    %ebx,%eax
f01212f7:	31 d2                	xor    %edx,%edx
f01212f9:	eb 09                	jmp    f0121304 <__moddi3+0x78>
f01212fb:	90                   	nop
f01212fc:	39 fa                	cmp    %edi,%edx
f01212fe:	76 1c                	jbe    f012131c <__moddi3+0x90>
f0121300:	89 f0                	mov    %esi,%eax
f0121302:	89 fa                	mov    %edi,%edx
f0121304:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f0121308:	85 c9                	test   %ecx,%ecx
f012130a:	74 07                	je     f0121313 <__moddi3+0x87>
f012130c:	f7 d8                	neg    %eax
f012130e:	83 d2 00             	adc    $0x0,%edx
f0121311:	f7 da                	neg    %edx
f0121313:	83 c4 2c             	add    $0x2c,%esp
f0121316:	5b                   	pop    %ebx
f0121317:	5e                   	pop    %esi
f0121318:	5f                   	pop    %edi
f0121319:	5d                   	pop    %ebp
f012131a:	c3                   	ret    
f012131b:	90                   	nop
f012131c:	0f bd c2             	bsr    %edx,%eax
f012131f:	83 f0 1f             	xor    $0x1f,%eax
f0121322:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f0121326:	75 6c                	jne    f0121394 <__moddi3+0x108>
f0121328:	39 fa                	cmp    %edi,%edx
f012132a:	72 05                	jb     f0121331 <__moddi3+0xa5>
f012132c:	3b 0c 24             	cmp    (%esp),%ecx
f012132f:	77 0e                	ja     f012133f <__moddi3+0xb3>
f0121331:	8b 34 24             	mov    (%esp),%esi
f0121334:	29 ce                	sub    %ecx,%esi
f0121336:	19 d3                	sbb    %edx,%ebx
f0121338:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f012133c:	89 34 24             	mov    %esi,(%esp)
f012133f:	8b 04 24             	mov    (%esp),%eax
f0121342:	8b 54 24 14          	mov    0x14(%esp),%edx
f0121346:	eb bc                	jmp    f0121304 <__moddi3+0x78>
f0121348:	85 c9                	test   %ecx,%ecx
f012134a:	75 0b                	jne    f0121357 <__moddi3+0xcb>
f012134c:	b8 01 00 00 00       	mov    $0x1,%eax
f0121351:	31 d2                	xor    %edx,%edx
f0121353:	f7 f1                	div    %ecx
f0121355:	89 c1                	mov    %eax,%ecx
f0121357:	89 d8                	mov    %ebx,%eax
f0121359:	31 d2                	xor    %edx,%edx
f012135b:	f7 f1                	div    %ecx
f012135d:	8b 04 24             	mov    (%esp),%eax
f0121360:	f7 f1                	div    %ecx
f0121362:	89 d3                	mov    %edx,%ebx
f0121364:	eb 8f                	jmp    f01212f5 <__moddi3+0x69>
f0121366:	66 90                	xchg   %ax,%ax
f0121368:	89 c8                	mov    %ecx,%eax
f012136a:	89 da                	mov    %ebx,%edx
f012136c:	f7 d8                	neg    %eax
f012136e:	83 d2 00             	adc    $0x0,%edx
f0121371:	f7 da                	neg    %edx
f0121373:	89 04 24             	mov    %eax,(%esp)
f0121376:	89 54 24 04          	mov    %edx,0x4(%esp)
f012137a:	e9 45 ff ff ff       	jmp    f01212c4 <__moddi3+0x38>
f012137f:	90                   	nop
f0121380:	f7 de                	neg    %esi
f0121382:	83 d7 00             	adc    $0x0,%edi
f0121385:	f7 df                	neg    %edi
f0121387:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f012138e:	ff 
f012138f:	e9 21 ff ff ff       	jmp    f01212b5 <__moddi3+0x29>
f0121394:	b8 20 00 00 00       	mov    $0x20,%eax
f0121399:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f012139d:	29 f8                	sub    %edi,%eax
f012139f:	89 c6                	mov    %eax,%esi
f01213a1:	89 44 24 14          	mov    %eax,0x14(%esp)
f01213a5:	89 f9                	mov    %edi,%ecx
f01213a7:	d3 e2                	shl    %cl,%edx
f01213a9:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f01213ad:	89 e8                	mov    %ebp,%eax
f01213af:	89 f1                	mov    %esi,%ecx
f01213b1:	d3 e8                	shr    %cl,%eax
f01213b3:	09 d0                	or     %edx,%eax
f01213b5:	89 04 24             	mov    %eax,(%esp)
f01213b8:	89 ea                	mov    %ebp,%edx
f01213ba:	89 f9                	mov    %edi,%ecx
f01213bc:	d3 e2                	shl    %cl,%edx
f01213be:	89 d7                	mov    %edx,%edi
f01213c0:	89 da                	mov    %ebx,%edx
f01213c2:	d3 e2                	shl    %cl,%edx
f01213c4:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f01213c8:	d3 e5                	shl    %cl,%ebp
f01213ca:	8b 44 24 10          	mov    0x10(%esp),%eax
f01213ce:	89 f1                	mov    %esi,%ecx
f01213d0:	d3 e8                	shr    %cl,%eax
f01213d2:	09 d0                	or     %edx,%eax
f01213d4:	d3 eb                	shr    %cl,%ebx
f01213d6:	89 da                	mov    %ebx,%edx
f01213d8:	f7 34 24             	divl   (%esp)
f01213db:	89 d3                	mov    %edx,%ebx
f01213dd:	f7 e7                	mul    %edi
f01213df:	89 c6                	mov    %eax,%esi
f01213e1:	89 d1                	mov    %edx,%ecx
f01213e3:	39 d3                	cmp    %edx,%ebx
f01213e5:	72 29                	jb     f0121410 <__moddi3+0x184>
f01213e7:	74 33                	je     f012141c <__moddi3+0x190>
f01213e9:	89 e8                	mov    %ebp,%eax
f01213eb:	29 f0                	sub    %esi,%eax
f01213ed:	19 cb                	sbb    %ecx,%ebx
f01213ef:	89 de                	mov    %ebx,%esi
f01213f1:	8a 4c 24 14          	mov    0x14(%esp),%cl
f01213f5:	d3 e6                	shl    %cl,%esi
f01213f7:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f01213fb:	89 f9                	mov    %edi,%ecx
f01213fd:	d3 e8                	shr    %cl,%eax
f01213ff:	09 c6                	or     %eax,%esi
f0121401:	89 f0                	mov    %esi,%eax
f0121403:	89 f9                	mov    %edi,%ecx
f0121405:	d3 eb                	shr    %cl,%ebx
f0121407:	89 da                	mov    %ebx,%edx
f0121409:	e9 f6 fe ff ff       	jmp    f0121304 <__moddi3+0x78>
f012140e:	66 90                	xchg   %ax,%ax
f0121410:	29 f8                	sub    %edi,%eax
f0121412:	1b 14 24             	sbb    (%esp),%edx
f0121415:	89 d1                	mov    %edx,%ecx
f0121417:	89 c6                	mov    %eax,%esi
f0121419:	eb ce                	jmp    f01213e9 <__moddi3+0x15d>
f012141b:	90                   	nop
f012141c:	39 c5                	cmp    %eax,%ebp
f012141e:	72 f0                	jb     f0121410 <__moddi3+0x184>
f0121420:	89 d9                	mov    %ebx,%ecx
f0121422:	eb c5                	jmp    f01213e9 <__moddi3+0x15d>

f0121424 <__udivdi3>:
f0121424:	55                   	push   %ebp
f0121425:	57                   	push   %edi
f0121426:	56                   	push   %esi
f0121427:	53                   	push   %ebx
f0121428:	83 ec 1c             	sub    $0x1c,%esp
f012142b:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f012142f:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f0121433:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121437:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f012143b:	89 ca                	mov    %ecx,%edx
f012143d:	89 f8                	mov    %edi,%eax
f012143f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f0121443:	85 f6                	test   %esi,%esi
f0121445:	75 2d                	jne    f0121474 <__udivdi3+0x50>
f0121447:	39 cf                	cmp    %ecx,%edi
f0121449:	77 65                	ja     f01214b0 <__udivdi3+0x8c>
f012144b:	89 fd                	mov    %edi,%ebp
f012144d:	85 ff                	test   %edi,%edi
f012144f:	75 0b                	jne    f012145c <__udivdi3+0x38>
f0121451:	b8 01 00 00 00       	mov    $0x1,%eax
f0121456:	31 d2                	xor    %edx,%edx
f0121458:	f7 f7                	div    %edi
f012145a:	89 c5                	mov    %eax,%ebp
f012145c:	31 d2                	xor    %edx,%edx
f012145e:	89 c8                	mov    %ecx,%eax
f0121460:	f7 f5                	div    %ebp
f0121462:	89 c1                	mov    %eax,%ecx
f0121464:	89 d8                	mov    %ebx,%eax
f0121466:	f7 f5                	div    %ebp
f0121468:	89 cf                	mov    %ecx,%edi
f012146a:	89 fa                	mov    %edi,%edx
f012146c:	83 c4 1c             	add    $0x1c,%esp
f012146f:	5b                   	pop    %ebx
f0121470:	5e                   	pop    %esi
f0121471:	5f                   	pop    %edi
f0121472:	5d                   	pop    %ebp
f0121473:	c3                   	ret    
f0121474:	39 ce                	cmp    %ecx,%esi
f0121476:	77 28                	ja     f01214a0 <__udivdi3+0x7c>
f0121478:	0f bd fe             	bsr    %esi,%edi
f012147b:	83 f7 1f             	xor    $0x1f,%edi
f012147e:	75 40                	jne    f01214c0 <__udivdi3+0x9c>
f0121480:	39 ce                	cmp    %ecx,%esi
f0121482:	72 0a                	jb     f012148e <__udivdi3+0x6a>
f0121484:	3b 44 24 08          	cmp    0x8(%esp),%eax
f0121488:	0f 87 9e 00 00 00    	ja     f012152c <__udivdi3+0x108>
f012148e:	b8 01 00 00 00       	mov    $0x1,%eax
f0121493:	89 fa                	mov    %edi,%edx
f0121495:	83 c4 1c             	add    $0x1c,%esp
f0121498:	5b                   	pop    %ebx
f0121499:	5e                   	pop    %esi
f012149a:	5f                   	pop    %edi
f012149b:	5d                   	pop    %ebp
f012149c:	c3                   	ret    
f012149d:	8d 76 00             	lea    0x0(%esi),%esi
f01214a0:	31 ff                	xor    %edi,%edi
f01214a2:	31 c0                	xor    %eax,%eax
f01214a4:	89 fa                	mov    %edi,%edx
f01214a6:	83 c4 1c             	add    $0x1c,%esp
f01214a9:	5b                   	pop    %ebx
f01214aa:	5e                   	pop    %esi
f01214ab:	5f                   	pop    %edi
f01214ac:	5d                   	pop    %ebp
f01214ad:	c3                   	ret    
f01214ae:	66 90                	xchg   %ax,%ax
f01214b0:	89 d8                	mov    %ebx,%eax
f01214b2:	f7 f7                	div    %edi
f01214b4:	31 ff                	xor    %edi,%edi
f01214b6:	89 fa                	mov    %edi,%edx
f01214b8:	83 c4 1c             	add    $0x1c,%esp
f01214bb:	5b                   	pop    %ebx
f01214bc:	5e                   	pop    %esi
f01214bd:	5f                   	pop    %edi
f01214be:	5d                   	pop    %ebp
f01214bf:	c3                   	ret    
f01214c0:	bd 20 00 00 00       	mov    $0x20,%ebp
f01214c5:	89 eb                	mov    %ebp,%ebx
f01214c7:	29 fb                	sub    %edi,%ebx
f01214c9:	89 f9                	mov    %edi,%ecx
f01214cb:	d3 e6                	shl    %cl,%esi
f01214cd:	89 c5                	mov    %eax,%ebp
f01214cf:	88 d9                	mov    %bl,%cl
f01214d1:	d3 ed                	shr    %cl,%ebp
f01214d3:	89 e9                	mov    %ebp,%ecx
f01214d5:	09 f1                	or     %esi,%ecx
f01214d7:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f01214db:	89 f9                	mov    %edi,%ecx
f01214dd:	d3 e0                	shl    %cl,%eax
f01214df:	89 c5                	mov    %eax,%ebp
f01214e1:	89 d6                	mov    %edx,%esi
f01214e3:	88 d9                	mov    %bl,%cl
f01214e5:	d3 ee                	shr    %cl,%esi
f01214e7:	89 f9                	mov    %edi,%ecx
f01214e9:	d3 e2                	shl    %cl,%edx
f01214eb:	8b 44 24 08          	mov    0x8(%esp),%eax
f01214ef:	88 d9                	mov    %bl,%cl
f01214f1:	d3 e8                	shr    %cl,%eax
f01214f3:	09 c2                	or     %eax,%edx
f01214f5:	89 d0                	mov    %edx,%eax
f01214f7:	89 f2                	mov    %esi,%edx
f01214f9:	f7 74 24 0c          	divl   0xc(%esp)
f01214fd:	89 d6                	mov    %edx,%esi
f01214ff:	89 c3                	mov    %eax,%ebx
f0121501:	f7 e5                	mul    %ebp
f0121503:	39 d6                	cmp    %edx,%esi
f0121505:	72 19                	jb     f0121520 <__udivdi3+0xfc>
f0121507:	74 0b                	je     f0121514 <__udivdi3+0xf0>
f0121509:	89 d8                	mov    %ebx,%eax
f012150b:	31 ff                	xor    %edi,%edi
f012150d:	e9 58 ff ff ff       	jmp    f012146a <__udivdi3+0x46>
f0121512:	66 90                	xchg   %ax,%ax
f0121514:	8b 54 24 08          	mov    0x8(%esp),%edx
f0121518:	89 f9                	mov    %edi,%ecx
f012151a:	d3 e2                	shl    %cl,%edx
f012151c:	39 c2                	cmp    %eax,%edx
f012151e:	73 e9                	jae    f0121509 <__udivdi3+0xe5>
f0121520:	8d 43 ff             	lea    -0x1(%ebx),%eax
f0121523:	31 ff                	xor    %edi,%edi
f0121525:	e9 40 ff ff ff       	jmp    f012146a <__udivdi3+0x46>
f012152a:	66 90                	xchg   %ax,%ax
f012152c:	31 c0                	xor    %eax,%eax
f012152e:	e9 37 ff ff ff       	jmp    f012146a <__udivdi3+0x46>
f0121533:	90                   	nop

f0121534 <__umoddi3>:
f0121534:	55                   	push   %ebp
f0121535:	57                   	push   %edi
f0121536:	56                   	push   %esi
f0121537:	53                   	push   %ebx
f0121538:	83 ec 1c             	sub    $0x1c,%esp
f012153b:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f012153f:	8b 74 24 34          	mov    0x34(%esp),%esi
f0121543:	8b 7c 24 38          	mov    0x38(%esp),%edi
f0121547:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f012154b:	89 44 24 0c          	mov    %eax,0xc(%esp)
f012154f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f0121553:	89 f3                	mov    %esi,%ebx
f0121555:	89 fa                	mov    %edi,%edx
f0121557:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f012155b:	89 34 24             	mov    %esi,(%esp)
f012155e:	85 c0                	test   %eax,%eax
f0121560:	75 1a                	jne    f012157c <__umoddi3+0x48>
f0121562:	39 f7                	cmp    %esi,%edi
f0121564:	0f 86 a2 00 00 00    	jbe    f012160c <__umoddi3+0xd8>
f012156a:	89 c8                	mov    %ecx,%eax
f012156c:	89 f2                	mov    %esi,%edx
f012156e:	f7 f7                	div    %edi
f0121570:	89 d0                	mov    %edx,%eax
f0121572:	31 d2                	xor    %edx,%edx
f0121574:	83 c4 1c             	add    $0x1c,%esp
f0121577:	5b                   	pop    %ebx
f0121578:	5e                   	pop    %esi
f0121579:	5f                   	pop    %edi
f012157a:	5d                   	pop    %ebp
f012157b:	c3                   	ret    
f012157c:	39 f0                	cmp    %esi,%eax
f012157e:	0f 87 ac 00 00 00    	ja     f0121630 <__umoddi3+0xfc>
f0121584:	0f bd e8             	bsr    %eax,%ebp
f0121587:	83 f5 1f             	xor    $0x1f,%ebp
f012158a:	0f 84 ac 00 00 00    	je     f012163c <__umoddi3+0x108>
f0121590:	bf 20 00 00 00       	mov    $0x20,%edi
f0121595:	29 ef                	sub    %ebp,%edi
f0121597:	89 fe                	mov    %edi,%esi
f0121599:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f012159d:	89 e9                	mov    %ebp,%ecx
f012159f:	d3 e0                	shl    %cl,%eax
f01215a1:	89 d7                	mov    %edx,%edi
f01215a3:	89 f1                	mov    %esi,%ecx
f01215a5:	d3 ef                	shr    %cl,%edi
f01215a7:	09 c7                	or     %eax,%edi
f01215a9:	89 e9                	mov    %ebp,%ecx
f01215ab:	d3 e2                	shl    %cl,%edx
f01215ad:	89 14 24             	mov    %edx,(%esp)
f01215b0:	89 d8                	mov    %ebx,%eax
f01215b2:	d3 e0                	shl    %cl,%eax
f01215b4:	89 c2                	mov    %eax,%edx
f01215b6:	8b 44 24 08          	mov    0x8(%esp),%eax
f01215ba:	d3 e0                	shl    %cl,%eax
f01215bc:	89 44 24 04          	mov    %eax,0x4(%esp)
f01215c0:	8b 44 24 08          	mov    0x8(%esp),%eax
f01215c4:	89 f1                	mov    %esi,%ecx
f01215c6:	d3 e8                	shr    %cl,%eax
f01215c8:	09 d0                	or     %edx,%eax
f01215ca:	d3 eb                	shr    %cl,%ebx
f01215cc:	89 da                	mov    %ebx,%edx
f01215ce:	f7 f7                	div    %edi
f01215d0:	89 d3                	mov    %edx,%ebx
f01215d2:	f7 24 24             	mull   (%esp)
f01215d5:	89 c6                	mov    %eax,%esi
f01215d7:	89 d1                	mov    %edx,%ecx
f01215d9:	39 d3                	cmp    %edx,%ebx
f01215db:	0f 82 87 00 00 00    	jb     f0121668 <__umoddi3+0x134>
f01215e1:	0f 84 91 00 00 00    	je     f0121678 <__umoddi3+0x144>
f01215e7:	8b 54 24 04          	mov    0x4(%esp),%edx
f01215eb:	29 f2                	sub    %esi,%edx
f01215ed:	19 cb                	sbb    %ecx,%ebx
f01215ef:	89 d8                	mov    %ebx,%eax
f01215f1:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f01215f5:	d3 e0                	shl    %cl,%eax
f01215f7:	89 e9                	mov    %ebp,%ecx
f01215f9:	d3 ea                	shr    %cl,%edx
f01215fb:	09 d0                	or     %edx,%eax
f01215fd:	89 e9                	mov    %ebp,%ecx
f01215ff:	d3 eb                	shr    %cl,%ebx
f0121601:	89 da                	mov    %ebx,%edx
f0121603:	83 c4 1c             	add    $0x1c,%esp
f0121606:	5b                   	pop    %ebx
f0121607:	5e                   	pop    %esi
f0121608:	5f                   	pop    %edi
f0121609:	5d                   	pop    %ebp
f012160a:	c3                   	ret    
f012160b:	90                   	nop
f012160c:	89 fd                	mov    %edi,%ebp
f012160e:	85 ff                	test   %edi,%edi
f0121610:	75 0b                	jne    f012161d <__umoddi3+0xe9>
f0121612:	b8 01 00 00 00       	mov    $0x1,%eax
f0121617:	31 d2                	xor    %edx,%edx
f0121619:	f7 f7                	div    %edi
f012161b:	89 c5                	mov    %eax,%ebp
f012161d:	89 f0                	mov    %esi,%eax
f012161f:	31 d2                	xor    %edx,%edx
f0121621:	f7 f5                	div    %ebp
f0121623:	89 c8                	mov    %ecx,%eax
f0121625:	f7 f5                	div    %ebp
f0121627:	89 d0                	mov    %edx,%eax
f0121629:	e9 44 ff ff ff       	jmp    f0121572 <__umoddi3+0x3e>
f012162e:	66 90                	xchg   %ax,%ax
f0121630:	89 c8                	mov    %ecx,%eax
f0121632:	89 f2                	mov    %esi,%edx
f0121634:	83 c4 1c             	add    $0x1c,%esp
f0121637:	5b                   	pop    %ebx
f0121638:	5e                   	pop    %esi
f0121639:	5f                   	pop    %edi
f012163a:	5d                   	pop    %ebp
f012163b:	c3                   	ret    
f012163c:	3b 04 24             	cmp    (%esp),%eax
f012163f:	72 06                	jb     f0121647 <__umoddi3+0x113>
f0121641:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f0121645:	77 0f                	ja     f0121656 <__umoddi3+0x122>
f0121647:	89 f2                	mov    %esi,%edx
f0121649:	29 f9                	sub    %edi,%ecx
f012164b:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f012164f:	89 14 24             	mov    %edx,(%esp)
f0121652:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f0121656:	8b 44 24 04          	mov    0x4(%esp),%eax
f012165a:	8b 14 24             	mov    (%esp),%edx
f012165d:	83 c4 1c             	add    $0x1c,%esp
f0121660:	5b                   	pop    %ebx
f0121661:	5e                   	pop    %esi
f0121662:	5f                   	pop    %edi
f0121663:	5d                   	pop    %ebp
f0121664:	c3                   	ret    
f0121665:	8d 76 00             	lea    0x0(%esi),%esi
f0121668:	2b 04 24             	sub    (%esp),%eax
f012166b:	19 fa                	sbb    %edi,%edx
f012166d:	89 d1                	mov    %edx,%ecx
f012166f:	89 c6                	mov    %eax,%esi
f0121671:	e9 71 ff ff ff       	jmp    f01215e7 <__umoddi3+0xb3>
f0121676:	66 90                	xchg   %ax,%ax
f0121678:	39 44 24 04          	cmp    %eax,0x4(%esp)
f012167c:	72 ea                	jb     f0121668 <__umoddi3+0x134>
f012167e:	89 d9                	mov    %ebx,%ecx
f0121680:	e9 62 ff ff ff       	jmp    f01215e7 <__umoddi3+0xb3>
